#!/bin/bash
# Solution script for ClipBucket v5 unauthenticated flagging issue
# This script adds authentication check to the flag_object case handler
set -e

AJAX_FILE="/srv/http/clipbucket/upload/actions/ajax.php"

echo "[*] Applying fix to ${AJAX_FILE}..."

# Check if file exists
if [ ! -f "$AJAX_FILE" ]; then
    echo "[!] Error: ${AJAX_FILE} not found"
    exit 1
fi

# Check if already fixed (authentication check already present)
if grep -q "isUserConnected" "$AJAX_FILE" && grep -B5 "isUserConnected" "$AJAX_FILE" | grep -q "flag_object"; then
    echo "[*] Fix already applied (isUserConnected check found in flag_object context)"
    exit 0
fi

# Create backup
cp "$AJAX_FILE" "${AJAX_FILE}.bak"

# The fix: Add authentication check at the beginning of the flag_object case
# We need to find the vulnerable pattern and replace it with the fixed version

# Use PHP to do the replacement more reliably
php << 'PHPSCRIPT'
<?php
$file = '/srv/http/clipbucket/upload/actions/ajax.php';
$content = file_get_contents($file);

// Pattern to find the vulnerable flag_object case
// The vulnerable code starts with: case 'flag_object':
//     $type = strtolower($_POST['type']);
//     $id = $_POST['id'];
//     if (empty($_POST['flag_type'])) {

$vulnerable_pattern = "/case\s+'flag_object':\s*\n\s*\\\$type\s*=\s*strtolower\(\\\$_POST\['type'\]\);\s*\n\s*\\\$id\s*=\s*\\\$_POST\['id'\];\s*\n\s*if\s*\(\s*empty\(\\\$_POST\['flag_type'\]\)\s*\)/s";

$fixed_replacement = "case 'flag_object':
        \$type = strtolower(\$_POST['type']);
        \$id = \$_POST['id'];
        if (!User::getInstance()->isUserConnected()) {
            e(lang('please_login_to_flag'));
        } elseif (empty(\$_POST['flag_type']))";

if (preg_match($vulnerable_pattern, $content)) {
    $new_content = preg_replace($vulnerable_pattern, $fixed_replacement, $content);
    file_put_contents($file, $new_content);
    echo "[*] Fix applied successfully using pattern replacement\n";
    exit(0);
} else {
    echo "[!] Vulnerable pattern not found, trying alternative approach\n";
    exit(1);
}
?>
PHPSCRIPT

# If PHP replacement failed, try sed approach
if [ $? -ne 0 ]; then
    echo "[*] Trying sed-based fix..."

    # Restore from backup
    cp "${AJAX_FILE}.bak" "$AJAX_FILE"

    # Find line number of "case 'flag_object':"
    LINE_NUM=$(grep -n "case 'flag_object':" "$AJAX_FILE" | head -1 | cut -d: -f1)

    if [ -z "$LINE_NUM" ]; then
        echo "[!] Error: Could not find 'case flag_object' in the file"
        exit 1
    fi

    echo "[*] Found flag_object case at line $LINE_NUM"

    # Find the line with "if (empty($_POST['flag_type']))"
    IF_LINE_NUM=$(awk -v start="$LINE_NUM" 'NR > start && /if.*empty.*flag_type/ {print NR; exit}' "$AJAX_FILE")

    if [ -z "$IF_LINE_NUM" ]; then
        echo "[!] Error: Could not find 'if (empty(\$_POST[flag_type]))' after flag_object case"
        exit 1
    fi

    echo "[*] Found flag_type check at line $IF_LINE_NUM"

    # Get the indentation from the original if statement
    INDENT=$(sed -n "${IF_LINE_NUM}p" "$AJAX_FILE" | sed 's/\(^[[:space:]]*\).*/\1/')

    # Insert authentication check before the flag_type check
    # We'll replace the "if (empty($_POST['flag_type']))" with our auth check first
    sed -i "${IF_LINE_NUM}s/if (empty(\$_POST\['flag_type'\]))/if (!User::getInstance()->isUserConnected()) {\n${INDENT}    e(lang('please_login_to_flag'));\n${INDENT}} elseif (empty(\$_POST['flag_type']))/" "$AJAX_FILE"

    echo "[*] Fix applied using sed"
fi

# Verify the fix was applied
if grep -q "isUserConnected" "$AJAX_FILE"; then
    echo "[*] Verification: isUserConnected check found in file"
else
    echo "[!] Warning: Fix verification failed - isUserConnected not found"
    exit 1
fi

echo "[+] Fix applied successfully!"
echo "[*] The flag_object handler now requires authentication before processing flags"
