diff --git a/poc/flag.html b/poc/flag.html
new file mode 100644
index 0000000..9586564
--- /dev/null
+++ b/poc/flag.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<h1>CISPA</h1>
+<p>vulns4js! is here.</p>
+
+</body>
+</html> 
\ No newline at end of file
diff --git a/poc/stattic.test.js b/poc/stattic.test.js
new file mode 100644
index 0000000..1320fc4
--- /dev/null
+++ b/poc/stattic.test.js
@@ -0,0 +1,88 @@
+const path = require("path");
+const fs = require("fs");
+const http = require("http");
+const { execSync } = require("child_process");
+
+const pathToFlag = path.resolve(__dirname, "./flag.html");
+function genstr() {
+  return "/..".repeat(50) + pathToFlag;
+}
+
+describe("stattic path traversal test", () => {
+  const PORT = 8977;
+  let serverControl;
+
+  beforeAll(() => {
+    // try to free the port if something is listening (best-effort)
+    try {
+      execSync(`fuser -k ${PORT}/tcp`);
+    } catch (e) {
+      // ignore
+    }
+  });
+
+  afterAll(() => {
+    // best-effort cleanup if stattic exposes a stop/close API
+    try {
+      if (serverControl && typeof serverControl.close === "function") {
+        serverControl.close();
+      }
+    } catch (e) {
+      // ignore
+    }
+  });
+
+  test("should not expose files via path traversal", async () => {
+    expect.assertions(1);
+
+    const stattic = require("stattic");
+    const flagContent = fs.readFileSync(pathToFlag, "utf8");
+
+    // configure stattic (match original PoC behavior)
+    stattic.set("folder", ".");
+    stattic.set("port", PORT);
+
+    // start server (listen is synchronous in the original PoC)
+    // keep a reference in case the module exposes a server object
+    try {
+      serverControl = stattic.listen();
+    } catch (e) {
+      // if listen throws, ignore and continue â€” test will still try to query the port
+    }
+
+    const requestPath = genstr();
+
+    // perform HTTP request directly instead of shelling out to curl
+    const body = await new Promise((resolve, reject) => {
+      const req = http.request(
+        {
+          method: "GET",
+          hostname: "127.0.0.1",
+          port: PORT,
+          path: requestPath,
+          timeout: 5000,
+        },
+        (res) => {
+          let data = "";
+          res.setEncoding("utf8");
+          res.on("data", (chunk) => (data += chunk));
+          res.on("end", () => resolve(data));
+        }
+      );
+      req.on("error", (err) => {
+        // if request failed, resolve with empty string so assertion can handle it
+        resolve("");
+      });
+      req.on("timeout", () => {
+        req.destroy();
+        resolve("");
+      });
+      req.end();
+    });
+
+    // Vulnerable implementation would return the flag file exactly (test would fail).
+    // Secure implementation must not return the flag content (test passes).
+    expect(body).not.toBe(flagContent);
+  });
+});
+
