"""
Vulnerability tests for CVE-2025-65015 in joserfc library.
These tests verify that oversized data IS exposed in exception messages (vulnerability exists).

The vulnerability causes the ExceededSizeError to include raw JWT token data in error messages.
In the vulnerable version (1.3.4), error messages contain full base64-encoded content.

Test behavior:
- FAIL in vulnerable state (data IS exposed in exceptions) - this is what we want to verify
- PASS in fixed state (data is NOT exposed in exceptions)
"""
import pytest
from joserfc.jws import deserialize_compact
from joserfc.jwk import OctKey
from joserfc.errors import ExceededSizeError
from joserfc.util import urlsafe_b64encode, json_b64encode


class TestJWSHeaderDataExposure:
    """Tests that oversized JWS header content is NOT exposed in error messages.

    In vulnerable version: error messages contain the full header bytes (repr format)
    In fixed version: error messages only mention the size limit
    """

    def test_header_base64_content_not_exposed(self):
        """The base64-encoded header should NOT appear in exception."""
        header_content = {f"field{i}": "X" * 50 for i in range(25)}
        large_header = json_b64encode(header_content)
        # The first 20 chars of base64 should not appear in error
        header_prefix = large_header[:20].decode('ascii', errors='ignore')
        fake_jwt = large_header + b"." + urlsafe_b64encode(b"x") + b"." + urlsafe_b64encode(b"y")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # Check that substantial base64 content is not present
        assert header_prefix not in error_msg, \
            f"Data leak detected: base64 header prefix found in exception"

    def test_header_raw_bytes_not_exposed(self):
        """Raw bytes repr should NOT appear in exception - checks for b' prefix."""
        header_content = {f"k{i}": "TESTDATA" * 10 for i in range(30)}
        large_header = json_b64encode(header_content)
        fake_jwt = large_header + b"." + urlsafe_b64encode(b"x") + b"." + urlsafe_b64encode(b"y")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # In vulnerable version, error contains "b'eyJ..." (bytes repr)
        assert "b'" not in error_msg, \
            f"Data leak detected: raw bytes repr found in exception"


class TestJWSPayloadDataExposure:
    """Tests that oversized JWS payload content is NOT exposed in error messages."""

    def test_payload_base64_content_not_exposed(self):
        """The base64-encoded payload should NOT appear in exception."""
        header = json_b64encode({"alg": "HS256"})
        # Create large payload with identifiable pattern
        large_payload = urlsafe_b64encode(b"X" * 10000)
        payload_prefix = large_payload[:20].decode('ascii', errors='ignore')
        fake_jwt = header + b"." + large_payload + b"." + urlsafe_b64encode(b"sig")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert payload_prefix not in error_msg, \
            f"Data leak detected: payload base64 prefix found in exception"

    def test_payload_raw_bytes_not_exposed(self):
        """Raw bytes repr should NOT appear in payload exception."""
        header = json_b64encode({"alg": "HS256"})
        large_payload = urlsafe_b64encode(b"PAYLOAD" * 2000)
        fake_jwt = header + b"." + large_payload + b"." + urlsafe_b64encode(b"sig")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert "b'" not in error_msg, \
            f"Data leak detected: raw bytes repr found in exception"


class TestJWSSignatureDataExposure:
    """Tests that oversized JWS signature content is NOT exposed in error messages."""

    def test_signature_base64_content_not_exposed(self):
        """Base64-encoded signature content should NOT appear in exception."""
        header = json_b64encode({"alg": "HS256"})
        payload = urlsafe_b64encode(b"payload")
        large_sig = urlsafe_b64encode(b"A" * 1500)
        sig_prefix = large_sig[:20].decode('ascii', errors='ignore')
        fake_jwt = header + b"." + payload + b"." + large_sig
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert sig_prefix not in error_msg, \
            f"Data leak detected: signature prefix found in exception"

    def test_signature_raw_bytes_not_exposed(self):
        """Raw bytes repr should NOT appear in signature exception."""
        header = json_b64encode({"alg": "HS256"})
        payload = urlsafe_b64encode(b"payload")
        large_sig = urlsafe_b64encode(b"S" * 2000)
        fake_jwt = header + b"." + payload + b"." + large_sig
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert "b'" not in error_msg, \
            f"Data leak detected: raw bytes repr found in exception"


class TestErrorMessageLength:
    """Tests that error messages are concise (key vulnerability indicator).

    In the vulnerable version, error messages are thousands of characters because
    they contain the full token data. In the fixed version, they're < 100 chars.
    """

    def test_header_error_is_concise(self):
        """Header error message should be concise, not containing raw data."""
        large_header = json_b64encode({f"k{i}": "DATA" * 20 for i in range(25)})
        fake_jwt = large_header + b"." + urlsafe_b64encode(b"x") + b"." + urlsafe_b64encode(b"y")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # The error message should be reasonably short (< 200 chars)
        # because it shouldn't contain the full oversized data
        assert len(error_msg) < 200, \
            f"Error message too long ({len(error_msg)} chars), likely contains raw data"

    def test_payload_error_is_concise(self):
        """Payload error message should be concise."""
        header = json_b64encode({"alg": "HS256"})
        large_payload = urlsafe_b64encode(b"X" * 10000)
        fake_jwt = header + b"." + large_payload + b"." + urlsafe_b64encode(b"sig")
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert len(error_msg) < 200, \
            f"Error message too long ({len(error_msg)} chars), likely contains raw data"

    def test_signature_error_is_concise(self):
        """Signature error message should be concise."""
        header = json_b64encode({"alg": "HS256"})
        payload = urlsafe_b64encode(b"pay")
        large_sig = urlsafe_b64encode(b"S" * 2000)
        fake_jwt = header + b"." + payload + b"." + large_sig
        key = OctKey.import_key("secret")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        assert len(error_msg) < 200, \
            f"Error message too long ({len(error_msg)} chars), likely contains raw data"
