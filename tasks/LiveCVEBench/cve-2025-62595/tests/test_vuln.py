"""
Vulnerability tests for Koa.js open redirect bypass via protocol-relative URLs.

These tests verify that the vulnerability is fixed:
- FAIL in vulnerable state (redirect contains external URL)
- PASS in fixed state (redirect is blocked, falls back to safe default)

The vulnerability allows attackers to bypass same-origin validation by using
protocol-relative URLs (e.g., //evil.com) which are mistakenly treated as
safe relative paths by the vulnerable code.
"""
import pytest
import requests
import os

BASE_URL = os.environ.get('APP_URL', 'http://localhost:3000')


class TestProtocolRelativeURLBypass:
    """Test protocol-relative URL bypass vectors (//evil.com format)."""

    def test_double_slash_external_domain(self):
        """
        Protocol-relative URL //evil.com should NOT be returned as redirect location.
        Browsers interpret //evil.com as https://evil.com (or http:// based on context).
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        # The location should NOT contain the malicious domain
        assert '//evil.com' not in location
        assert 'evil.com' not in location
        # Should fall back to safe default
        assert location == '/'

    def test_double_slash_with_path(self):
        """
        Protocol-relative URL with path //evil.com/path should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com/attack/path'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert '//evil.com' not in location
        assert 'evil.com' not in location
        assert location == '/'

    def test_double_slash_with_query_string(self):
        """
        Protocol-relative URL with query string should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//malicious.site/page?stolen=data'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'malicious.site' not in location
        assert location == '/'

    def test_double_slash_with_port(self):
        """
        Protocol-relative URL with port should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com:8080/dangerous'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'evil.com' not in location
        assert location == '/'


class TestProtocolRelativeBypassVariations:
    """Test variations of the protocol-relative URL bypass."""

    def test_double_slash_attacker_domain_variation1(self):
        """
        Test with attacker.com domain.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//attacker.com/phishing'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'attacker.com' not in location
        assert location == '/'

    def test_double_slash_subdomain(self):
        """
        Protocol-relative URL with subdomain should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//sub.evil.com/path'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'evil.com' not in location
        assert location == '/'

    def test_double_slash_ipv4_address(self):
        """
        Protocol-relative URL with IP address should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//192.168.1.100/admin'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert '192.168.1.100' not in location
        assert location == '/'

    def test_double_slash_unicode_domain(self):
        """
        Protocol-relative URL with unicode/punycode domain should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//xn--80ak6aa92e.com/evil'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'xn--80ak6aa92e.com' not in location
        assert location == '/'


class TestConfusionAttackVectors:
    """Test URL confusion attack vectors related to protocol-relative URLs."""

    def test_backslash_variation(self):
        """
        Test URL with backslashes that might be normalized.
        Some browsers normalize \\ to //.
        """
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com\\path'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'evil.com' not in location


class TestEdgeCasesVulnerability:
    """Edge cases for the vulnerability."""

    def test_triple_slash(self):
        """Triple slash ///evil.com should be blocked."""
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '///evil.com/path'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        # Triple slash might be interpreted differently, but evil.com should not appear
        assert 'evil.com' not in location

    def test_double_slash_with_fragment(self):
        """Protocol-relative URL with fragment should be blocked."""
        response = requests.get(
            f"{BASE_URL}/redirect-back",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com/page#anchor'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'evil.com' not in location
        assert location == '/'

    def test_fallback_with_alt_parameter(self):
        """When blocked, should fallback to alt parameter if provided."""
        response = requests.get(
            f"{BASE_URL}/redirect-back-with-alt",
            headers={
                'Host': 'localhost:3000',
                'Referer': '//evil.com/attack'
            },
            allow_redirects=False
        )
        assert response.status_code == 302
        location = response.headers.get('Location', '')
        assert 'evil.com' not in location
        # Should fallback to the alt parameter (/home)
        assert location == '/home'
