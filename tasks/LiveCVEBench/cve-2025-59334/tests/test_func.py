"""
Functional tests for Linkr package extractor.
These tests verify that basic extraction functionality works correctly.
Should PASS in both vulnerable and fixed versions.
"""

import pytest
import os
import sys
import json
import hashlib
import shutil
import tempfile
import threading
import time
from http.server import HTTPServer, SimpleHTTPRequestHandler
from pathlib import Path

# Add the app directory to sys.path for imports
sys.path.insert(0, '/app')

from linkr_extractor import linkr_extractor
from sha256 import sha256_checksum
import inspect


def call_extractor(manifest_path, output_dir, checksum_override=False, integrity_check=False):
    """
    Helper to call linkr_extractor with appropriate parameters.
    The vulnerable version doesn't have integrity_check parameter,
    while the fixed version does.
    """
    sig = inspect.signature(linkr_extractor)
    if 'integrity_check' in sig.parameters:
        return linkr_extractor(str(manifest_path), str(output_dir),
                              checksum_override=checksum_override,
                              integrity_check=integrity_check)
    else:
        return linkr_extractor(str(manifest_path), str(output_dir),
                              checksum_override=checksum_override)


class MockHTTPHandler(SimpleHTTPRequestHandler):
    """Custom HTTP handler that serves files from a specific directory."""

    serve_directory = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=self.serve_directory, **kwargs)

    def log_message(self, format, *args):
        """Suppress logging."""
        pass


class ReuseAddrHTTPServer(HTTPServer):
    """HTTP server that allows address reuse."""
    allow_reuse_address = True


def start_mock_server(directory, port=8765):
    """Start a mock HTTP server serving files from a directory."""
    MockHTTPHandler.serve_directory = directory
    server = ReuseAddrHTTPServer(('127.0.0.1', port), MockHTTPHandler)
    thread = threading.Thread(target=server.serve_forever)
    thread.daemon = True
    thread.start()
    time.sleep(0.3)  # Give server time to start
    return server


class TestBasicExtraction:
    """Test basic extraction functionality."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        """Set up test environment with mock server."""
        self.tmp_path = tmp_path
        self.server_files_dir = tmp_path / "server_files"
        self.server_files_dir.mkdir()
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()

        # Create test files on "server"
        self.test_file1_content = b"This is test file 1 content"
        self.test_file1_path = self.server_files_dir / "file1.txt"
        self.test_file1_path.write_bytes(self.test_file1_content)

        self.test_file2_content = b"This is test file 2 with different content"
        self.test_file2_path = self.server_files_dir / "subdir" / "file2.txt"
        self.test_file2_path.parent.mkdir(parents=True, exist_ok=True)
        self.test_file2_path.write_bytes(self.test_file2_content)

        # Start mock server
        self.server_port = 8765
        self.server = start_mock_server(str(self.server_files_dir), self.server_port)
        self.base_url = f"http://127.0.0.1:{self.server_port}"

        yield

        # Cleanup - properly close server socket
        self.server.shutdown()
        self.server.server_close()
        time.sleep(0.1)  # Give OS time to release port

    def create_valid_manifest(self, manifest_path, files_info, package_name="test_package"):
        """Create a valid manifest file."""
        total_size = sum(f["SIZE"] for f in files_info)
        manifest = {
            "PACKAGE": package_name,
            "TOTAL_SIZE": total_size,
            "FILES": files_info
        }
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f, indent=4)
        return manifest_path

    def test_single_file_extraction(self):
        """Test extraction of a single file with valid checksum."""
        # Calculate checksum for test file
        file1_checksum = hashlib.sha256(self.test_file1_content).hexdigest()

        files_info = [{
            "URLS": [f"{self.base_url}/file1.txt"],
            "DESTINATION": "file1.txt",
            "SIZE": len(self.test_file1_content),
            "CHECKSUM": file1_checksum
        }]

        manifest_path = self.manifest_dir / "single.linkr"
        self.create_valid_manifest(manifest_path, files_info)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        # Verify file was extracted
        output_file = self.output_dir / "file1.txt"
        assert output_file.exists(), "Extracted file should exist"
        assert output_file.read_bytes() == self.test_file1_content, "Content should match"

    def test_multiple_files_extraction(self):
        """Test extraction of multiple files."""
        file1_checksum = hashlib.sha256(self.test_file1_content).hexdigest()
        file2_checksum = hashlib.sha256(self.test_file2_content).hexdigest()

        files_info = [
            {
                "URLS": [f"{self.base_url}/file1.txt"],
                "DESTINATION": "file1.txt",
                "SIZE": len(self.test_file1_content),
                "CHECKSUM": file1_checksum
            },
            {
                "URLS": [f"{self.base_url}/subdir/file2.txt"],
                "DESTINATION": "subdir/file2.txt",
                "SIZE": len(self.test_file2_content),
                "CHECKSUM": file2_checksum
            }
        ]

        manifest_path = self.manifest_dir / "multiple.linkr"
        self.create_valid_manifest(manifest_path, files_info, "multi_package")

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        # Verify all files extracted
        output_file1 = self.output_dir / "file1.txt"
        output_file2 = self.output_dir / "subdir" / "file2.txt"

        assert output_file1.exists(), "First file should exist"
        assert output_file2.exists(), "Second file should exist"
        assert output_file1.read_bytes() == self.test_file1_content
        assert output_file2.read_bytes() == self.test_file2_content

    def test_nested_directory_extraction(self):
        """Test extraction with nested directory structure."""
        # Create a deeply nested file
        deep_content = b"Deeply nested file content"
        deep_path = self.server_files_dir / "a" / "b" / "c" / "deep.txt"
        deep_path.parent.mkdir(parents=True, exist_ok=True)
        deep_path.write_bytes(deep_content)

        deep_checksum = hashlib.sha256(deep_content).hexdigest()

        files_info = [{
            "URLS": [f"{self.base_url}/a/b/c/deep.txt"],
            "DESTINATION": "a/b/c/deep.txt",
            "SIZE": len(deep_content),
            "CHECKSUM": deep_checksum
        }]

        manifest_path = self.manifest_dir / "nested.linkr"
        self.create_valid_manifest(manifest_path, files_info)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        # Verify
        output_file = self.output_dir / "a" / "b" / "c" / "deep.txt"
        assert output_file.exists(), "Deeply nested file should exist"
        assert output_file.read_bytes() == deep_content


class TestChecksumVerification:
    """Test checksum verification functionality."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        """Set up test environment."""
        self.tmp_path = tmp_path
        self.server_files_dir = tmp_path / "server_files"
        self.server_files_dir.mkdir()
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()

        # Create test file
        self.test_content = b"Test content for checksum verification"
        self.test_file_path = self.server_files_dir / "testfile.txt"
        self.test_file_path.write_bytes(self.test_content)

        # Start server
        self.server_port = 8766
        self.server = start_mock_server(str(self.server_files_dir), self.server_port)
        self.base_url = f"http://127.0.0.1:{self.server_port}"

        yield

        self.server.shutdown()
        self.server.server_close()
        time.sleep(0.1)

    def test_valid_checksum_succeeds(self):
        """Test that valid checksum allows file extraction."""
        correct_checksum = hashlib.sha256(self.test_content).hexdigest()

        manifest = {
            "PACKAGE": "checksum_test",
            "TOTAL_SIZE": len(self.test_content),
            "FILES": [{
                "URLS": [f"{self.base_url}/testfile.txt"],
                "DESTINATION": "testfile.txt",
                "SIZE": len(self.test_content),
                "CHECKSUM": correct_checksum
            }]
        }

        manifest_path = self.manifest_dir / "valid_checksum.linkr"
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        output_file = self.output_dir / "testfile.txt"
        assert output_file.exists(), "File with valid checksum should be extracted"

    def test_invalid_checksum_rejected_without_override(self):
        """Test that invalid checksum prevents file from being kept (without override)."""
        wrong_checksum = "0" * 64  # Invalid checksum

        manifest = {
            "PACKAGE": "bad_checksum_test",
            "TOTAL_SIZE": len(self.test_content),
            "FILES": [{
                "URLS": [f"{self.base_url}/testfile.txt"],
                "DESTINATION": "badfile.txt",
                "SIZE": len(self.test_content),
                "CHECKSUM": wrong_checksum
            }]
        }

        manifest_path = self.manifest_dir / "bad_checksum.linkr"
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        # File should NOT exist (deleted due to checksum mismatch)
        output_file = self.output_dir / "badfile.txt"
        assert not output_file.exists(), "File with bad checksum should be deleted"


class TestPackageMetadata:
    """Test package metadata handling."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        """Set up test environment."""
        self.tmp_path = tmp_path
        self.server_files_dir = tmp_path / "server_files"
        self.server_files_dir.mkdir()
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()

        # Create test file
        self.test_content = b"Simple test content"
        self.test_file = self.server_files_dir / "simple.txt"
        self.test_file.write_bytes(self.test_content)

        # Start server
        self.server_port = 8767
        self.server = start_mock_server(str(self.server_files_dir), self.server_port)
        self.base_url = f"http://127.0.0.1:{self.server_port}"

        yield

        self.server.shutdown()
        self.server.server_close()
        time.sleep(0.1)

    def test_package_with_custom_name(self):
        """Test extraction with custom package name."""
        checksum = hashlib.sha256(self.test_content).hexdigest()

        manifest = {
            "PACKAGE": "MyCustomPackage",
            "TOTAL_SIZE": len(self.test_content),
            "FILES": [{
                "URLS": [f"{self.base_url}/simple.txt"],
                "DESTINATION": "simple.txt",
                "SIZE": len(self.test_content),
                "CHECKSUM": checksum
            }]
        }

        manifest_path = self.manifest_dir / "custom.linkr"
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        output_file = self.output_dir / "simple.txt"
        assert output_file.exists()

    def test_empty_package_name_uses_default(self):
        """Test that missing package name defaults to UnknownPackage."""
        checksum = hashlib.sha256(self.test_content).hexdigest()

        manifest = {
            "TOTAL_SIZE": len(self.test_content),
            "FILES": [{
                "URLS": [f"{self.base_url}/simple.txt"],
                "DESTINATION": "simple.txt",
                "SIZE": len(self.test_content),
                "CHECKSUM": checksum
            }]
        }

        manifest_path = self.manifest_dir / "noname.linkr"
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f)

        # Extract (integrity_check=False for legacy manifests without LINKR_ADDRESS)
        call_extractor(manifest_path, self.output_dir, integrity_check=False)

        output_file = self.output_dir / "simple.txt"
        assert output_file.exists()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
