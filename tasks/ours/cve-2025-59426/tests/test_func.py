"""
Functional tests for the OIDC URL correction utility.

These tests verify that the correctOIDCUrl function works correctly
for legitimate proxy scenarios. They should PASS in both vulnerable
and fixed states.
"""

import subprocess
import json
import os
import pytest

# Path to the test runner
TEST_DIR = os.path.dirname(os.path.abspath(__file__))


def run_tsx_script(script: str, env_vars: dict = None) -> dict:
    """Run a TypeScript script using tsx and return the result."""
    # Wrap the script in an async IIFE to support top-level await
    wrapped_script = f"""
(async () => {{
{script}
}})().catch(e => {{ console.error(e); process.exit(1); }});
"""

    env = {**os.environ}
    if env_vars:
        env.update(env_vars)

    result = subprocess.run(
        ["npx", "tsx", "-e", wrapped_script],
        cwd="/app",
        capture_output=True,
        text=True,
        env=env
    )

    return result


class TestUrlCorrectionBasics:
    """Test basic URL correction functionality."""

    def test_localhost_url_corrected_to_request_host(self):
        """
        Test that localhost URLs are corrected to the request host.
        This is core functionality that should work in both states.
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHost: result.host,
    resultHostname: result.hostname,
    resultPath: result.pathname,
    protocol: result.protocol
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["resultHostname"] == "example.com", f"Expected hostname to be example.com, got {data['resultHostname']}"
        assert data["resultPath"] == "/auth/callback", f"Path should be preserved"

    def test_127_0_0_1_url_corrected(self):
        """Test that 127.0.0.1 URLs are also corrected."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://127.0.0.1:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["resultHostname"] == "example.com"

    def test_0_0_0_0_url_corrected(self):
        """Test that 0.0.0.0 URLs are also corrected."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://0.0.0.0:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["resultHostname"] == "example.com"


class TestProtocolHandling:
    """Test protocol/scheme handling."""

    def test_x_forwarded_proto_https_applied(self):
        """Test that X-Forwarded-Proto: https is applied correctly."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-proto') return 'https';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    protocol: result.protocol
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["protocol"] == "https:", f"Protocol should be https:, got {data['protocol']}"

    def test_x_forwarded_protocol_fallback(self):
        """Test that x-forwarded-protocol works as fallback."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-protocol') return 'https';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    protocol: result.protocol
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["protocol"] == "https:"


class TestPathAndQueryPreservation:
    """Test that paths and query parameters are preserved."""

    def test_query_parameters_preserved(self):
        """Test that query parameters are preserved during URL correction."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback?code=abc123&state=xyz789');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    search: result.search,
    pathname: result.pathname
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert "code=abc123" in data["search"], "Query param 'code' should be preserved"
        assert "state=xyz789" in data["search"], "Query param 'state' should be preserved"
        assert data["pathname"] == "/auth/callback"

    def test_hash_fragment_preserved(self):
        """Test that URL hash fragments are preserved."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback#access_token=test123');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    hash: result.hash
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["hash"] == "#access_token=test123"


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_null_host_returns_original_url(self):
        """Test that null host header returns the original URL unchanged."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => null
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    isOriginal: result.toString() === originalUrl.toString()
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["isOriginal"] == True, "Should return original URL when host is null"

    def test_string_null_host_returns_original(self):
        """Test that host header value 'null' returns original URL."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'null';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    isOriginal: result.toString() === originalUrl.toString()
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["isOriginal"] == True

    def test_matching_hostname_no_correction_needed(self):
        """Test that URL is not modified when hostname already matches."""
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('https://example.com/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    isSameObject: result === originalUrl,
    resultUrl: result.toString()
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())
        assert data["isSameObject"] == True, "Should return same URL object when no correction needed"


class TestLegitimateSubdomainsAllowed:
    """
    Test that legitimate subdomains are still allowed.
    These tests verify the URL correction works for legitimate hosts.
    """

    def test_legitimate_subdomain_allowed(self):
        """
        Test that legitimate subdomains of the configured domain are allowed.
        api.example.com should be allowed when APP_URL is example.com
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'api.example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    isSubdomain: result.hostname === 'api.example.com'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        # Subdomains should be allowed
        assert data["isSubdomain"] == True, \
            f"Legitimate subdomain 'api.example.com' should be allowed. Got: {data['resultHostname']}"

    def test_exact_domain_match_allowed(self):
        """
        Test that the exact configured domain is allowed.
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    isExactMatch: result.hostname === 'example.com'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["isExactMatch"] == True, \
            f"Exact domain match should be allowed. Got: {data['resultHostname']}"


class TestLocalhostDevelopmentEnvironment:
    """
    Test localhost handling in development environment.
    """

    def test_localhost_allowed_in_dev_environment(self):
        """
        Test that localhost is allowed when APP_URL is also localhost.
        This supports development scenarios.
        """
        script = """
process.env.APP_URL = 'http://localhost:3000';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'localhost:8080';
            return null;
        }
    }
};

const originalUrl = new URL('http://127.0.0.1:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHost: result.host,
    isLocalhost: result.hostname === 'localhost'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["isLocalhost"] == True, \
            f"Localhost should be allowed in dev environment. Got: {data['resultHost']}"
