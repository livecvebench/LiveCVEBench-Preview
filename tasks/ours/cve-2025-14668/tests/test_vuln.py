#!/usr/bin/env python3
"""
Vulnerability tests for the Online Examination System login endpoint.
These tests verify that SQL injection vulnerabilities are NOT present.

- Should FAIL when the application is VULNERABLE (before fix)
- Should PASS when the application is FIXED (after fix)

IMPORTANT: All payloads are carefully chosen to ALWAYS demonstrate vulnerability when
the application is vulnerable - either by:
1. Successfully bypassing authentication (returning "success")
2. Causing a PHP/SQL error (non-JSON response)
3. Causing a time delay (SLEEP injection)
"""

import pytest
import requests
import time

BASE_URL = "http://localhost"
LOGIN_ENDPOINT = f"{BASE_URL}/query/loginExe.php"


class TestSQLInjectionAuthBypass:
    """
    Test that authentication bypass via SQL injection is blocked.

    All payloads in this class use SQL comments (-- or #) to comment out
    the password check, ensuring they bypass authentication when vulnerable.
    """

    def test_auth_bypass_with_double_dash_space(self):
        """OR 1=1 with -- comment (space after) should not bypass authentication."""
        # This payload comments out password check: WHERE email='admin' OR 1=1-- ' AND password='x'
        payload = "admin' OR 1=1-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "anything"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_with_hash_comment(self):
        """OR 1=1 with # comment should not bypass authentication."""
        # MySQL # comment: WHERE email='admin' OR 1=1#' AND password='x'
        payload = "admin' OR 1=1#"
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "anything"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_existing_user_dash_comment(self):
        """Injection on real user with -- comment should not bypass."""
        # Uses existing email prefix to maximize match chance
        payload = "rogz.nunez2013@gmail.com'-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "wrongpassword"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_existing_user_hash_comment(self):
        """Injection on real user with # comment should not bypass."""
        payload = "rogz.nunez2013@gmail.com'#"
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "wrongpassword"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_jane_user(self):
        """Injection on jane user with comment should not bypass."""
        payload = "jane@gmail.com'-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "wrongpassword"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_or_true_literal(self):
        """OR TRUE with comment should not bypass authentication."""
        payload = "x' OR TRUE-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "anything"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"Payload '{payload}' caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"Auth bypass successful with payload '{payload}' - SQL injection vulnerability!"

    def test_auth_bypass_union_select_known_values(self):
        """UNION SELECT with known values should not bypass authentication."""
        # Attempts to inject a fake row that matches the session creation logic
        payload = "' UNION SELECT 1,'fake','fake','m','2020-01-01','1','test@test.com','test','active'-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "anything"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail(f"UNION injection caused application error (non-JSON response)")

        assert data.get("res") != "success", \
            f"UNION injection bypass successful - SQL injection vulnerability!"


class TestSQLInjectionTimeBased:
    """
    Test that time-based blind SQL injection is blocked.

    These tests measure response time - if the query is injectable,
    SLEEP() will execute and delay the response.
    """

    def test_sleep_injection_with_comment(self):
        """SLEEP with comment should not cause delay."""
        # Use valid user prefix so query finds row and SLEEP executes
        payload = "rogz.nunez2013@gmail.com' AND SLEEP(3)-- "
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, \
            f"SLEEP injection caused {elapsed:.1f}s delay - time-based SQL injection vulnerability!"

    def test_sleep_injection_with_hash(self):
        """SLEEP with # comment should not cause delay."""
        payload = "jane@gmail.com' AND SLEEP(3)#"
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, \
            f"SLEEP injection caused {elapsed:.1f}s delay - time-based SQL injection vulnerability!"

    def test_sleep_subquery_injection(self):
        """SLEEP in subquery should not cause delay."""
        payload = "glenn@gmail.com' AND (SELECT SLEEP(3))-- "
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, \
            f"SLEEP subquery caused {elapsed:.1f}s delay - time-based SQL injection vulnerability!"

    def test_if_sleep_injection(self):
        """IF(1=1, SLEEP(3), 0) should not cause delay."""
        payload = "maria@gmail.com' AND IF(1=1,SLEEP(3),0)-- "
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, \
            f"IF SLEEP injection caused {elapsed:.1f}s delay - time-based SQL injection vulnerability!"

    def test_benchmark_injection(self):
        """BENCHMARK function should not cause significant delay."""
        # BENCHMARK(50000000, MD5('x')) takes noticeable time if executed (~5s)
        payload = "dave@gmail.com' AND BENCHMARK(50000000,MD5('test'))-- "
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 3.0, \
            f"BENCHMARK injection caused {elapsed:.1f}s delay - SQL injection vulnerability!"


class TestSQLInjectionErrorBased:
    """
    Test that error-based SQL injection is blocked.

    These payloads are designed to cause SQL syntax errors when injected,
    which would crash PHP and return non-JSON response if vulnerable.
    """

    def test_unclosed_quote_injection(self):
        """Unclosed quote should be handled safely."""
        payload = "test'"
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Unclosed quote caused application error (non-JSON response) - SQL injection vulnerability!")

        assert data.get("res") == "invalid", \
            f"Unexpected response for unclosed quote: {data}"

    def test_multiple_quotes_injection(self):
        """Multiple quotes injection should be handled safely."""
        payload = "'''test'''"
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Multiple quotes caused application error (non-JSON response) - SQL injection vulnerability!")

    def test_backslash_quote_injection(self):
        """Backslash in SQL context should be handled safely."""
        # In MySQL, backslash can escape quotes in certain modes
        # Test with a payload using backslash to see if it causes issues
        payload = "rogz.nunez2013@gmail.com\\\\' OR 1=1-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Backslash-quote caused application error (non-JSON response) - SQL injection vulnerability!")

        # If vulnerable, the backslash may be used to escape and allow bypass
        assert data.get("res") != "success", \
            f"Backslash injection bypassed auth: {data}"

    def test_extractvalue_error_injection(self):
        """EXTRACTVALUE error-based injection should be handled safely."""
        # This causes an XPath error if executed
        payload = "admin' AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))-- "
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("EXTRACTVALUE injection caused application error - SQL injection vulnerability!")

        # Should not reveal version info in any field
        response_text = str(data)
        assert "MariaDB" not in response_text and "MySQL" not in response_text, \
            f"EXTRACTVALUE injection leaked database info: {data}"


class TestSQLInjectionStacked:
    """
    Test that stacked queries (multiple statements) are blocked.

    These use semicolons to inject additional statements.
    """

    def test_stacked_select_injection(self):
        """Stacked SELECT query should not execute."""
        payload = "admin'; SELECT SLEEP(3);-- "
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": payload, "pass": "test"},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # Check both: no delay AND no PHP error
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Stacked query caused application error (non-JSON response) - SQL injection vulnerability!")

        assert elapsed < 2.5, \
            f"Stacked SLEEP query executed ({elapsed:.1f}s delay) - SQL injection vulnerability!"


class TestSQLInjectionPasswordField:
    """
    Test SQL injection in the password field.

    The password field is also vulnerable to injection.
    """

    def test_password_field_auth_bypass_dash(self):
        """Password field injection with -- comment should not bypass."""
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": "rogz.nunez2013@gmail.com", "pass": "' OR '1'='1'-- "},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Password field injection caused application error - SQL injection vulnerability!")

        assert data.get("res") != "success", \
            "Password field injection bypassed authentication - SQL injection vulnerability!"

    def test_password_field_auth_bypass_hash(self):
        """Password field injection with # comment should not bypass."""
        response = requests.post(
            LOGIN_ENDPOINT,
            data={"username": "rogz.nunez2013@gmail.com", "pass": "wrongpass' OR '1'='1'#"},
            timeout=10
        )
        assert response.status_code == 200
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            pytest.fail("Password field injection caused application error - SQL injection vulnerability!")

        # Since password comes after AND, OR injection in password can work
        assert data.get("res") != "success", \
            "Password field OR injection bypassed authentication - SQL injection vulnerability!"

    def test_password_field_sleep_injection(self):
        """Password field SLEEP injection should not cause delay."""
        start_time = time.time()
        response = requests.post(
            LOGIN_ENDPOINT,
            # Use valid username so query reaches password comparison
            data={"username": "rogz.nunez2013@gmail.com", "pass": "' OR SLEEP(3)-- "},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, \
            f"Password SLEEP injection caused {elapsed:.1f}s delay - SQL injection vulnerability!"
