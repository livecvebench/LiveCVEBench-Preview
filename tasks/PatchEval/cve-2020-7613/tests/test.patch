diff --git a/poc/clamscan.test.js b/poc/clamscan.test.js
new file mode 100644
index 0000000..ee5fa92
--- /dev/null
+++ b/poc/clamscan.test.js
@@ -0,0 +1,61 @@
+const fs = require("fs");
+const PATH = "./clamscan";
+
+describe("clamscan command injection test", () => {
+  beforeEach(() => {
+    try {
+      if (fs.existsSync(PATH)) {
+        fs.unlinkSync(PATH);
+      }
+    } catch (e) {
+      // ignore cleanup errors
+    }
+  });
+
+  test("should not allow command injection via clamscan.path", async () => {
+    expect.assertions(2);
+    const ClamRoot = require("clamscan");
+
+    // precondition: file does not exist
+    expect(fs.existsSync(PATH)).toBe(false);
+
+    const attackCode = "touch clamscan";
+    const attackDir = attackCode + "&";
+
+    // ensure attackDir exists (mimic PoC setup)
+    try {
+      if (!fs.existsSync(attackDir)) {
+        fs.mkdirSync(attackDir, { recursive: true });
+      }
+    } catch (e) {
+      // ignore
+    }
+
+    const root = new ClamRoot();
+
+    try {
+      await root.init({ clamscan: { path: attackDir } });
+    } catch (e) {
+      // ignore errors from init
+    }
+
+    const existsAfter = fs.existsSync(PATH);
+
+    // Vulnerable implementation would create the file (test fails).
+    // Secure implementation should not create the file (test passes).
+    expect(existsAfter).toBe(false);
+
+    // cleanup
+    try {
+      if (fs.existsSync(PATH)) {
+        fs.unlinkSync(PATH);
+      }
+      if (fs.existsSync(attackDir)) {
+        fs.rmdirSync(attackDir, { recursive: true });
+      }
+    } catch (e) {
+      // ignore
+    }
+  });
+});
+
diff --git a/tests/clamscan.normal.test.js b/tests/clamscan.normal.test.js
new file mode 100644
index 0000000..ae2b17f
--- /dev/null
+++ b/tests/clamscan.normal.test.js
@@ -0,0 +1,57 @@
+/**
+ * @fileoverview Regression test for _is_clamav_binary function in NodeClam
+ */
+const fs = require('fs');
+const { promisify } = require('util');
+const { exec } = require('child_process');
+const { expect } = require('chai'); 
+const NodeClam = require('../index.js'); 
+
+const fs_access = promisify(fs.access);
+const cp_exec = promisify(exec);
+
+describe('_is_clamav_binary regression test (Mocha)', function () {
+  this.timeout(10000); // set timeout to 10 seconds
+
+  const validPath = '/usr/bin/clamscan';
+  const invalidPath = '/not/exist/clamscan';
+
+  let clam;
+
+  before(() => {
+    clam = new NodeClam();
+    clam.settings = {
+      clamscan: { path: validPath },
+      clamdscan: { path: validPath },
+      debug_mode: true,
+    };
+  });
+
+  it('should return true for valid clamscan binary', async () => {
+    // 1️⃣ make sure the validPath is accessible
+    try {
+      await fs_access(validPath, fs.constants.R_OK);
+      console.log(`[TEST] ${validPath} is accessible`);
+    } catch (err) {
+      throw new Error(`Cannot access ${validPath}: ${err.message}`);
+    }
+
+    // 2️⃣ call _is_clamav_binary()
+    const result = await clam._is_clamav_binary('clamscan');
+    console.log('[TEST] _is_clamav_binary("clamscan") =>', result);
+
+    expect(result).to.be.a('boolean');
+    expect(result).to.equal(true);
+  });
+
+  it('should return false for invalid clamscan binary', async () => {
+    clam.settings.clamscan.path = invalidPath;
+
+    const result = await clam._is_clamav_binary('clamscan');
+    console.log('[TEST] _is_clamav_binary(invalid path) =>', result);
+
+    expect(result).to.be.a('boolean');
+    expect(result).to.equal(false);
+  });
+});
+
