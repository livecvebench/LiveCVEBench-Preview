#!/usr/bin/env python3
"""
Vulnerability tests for ChanCMS collect/getArticle endpoint.
Tests the Remote Code Execution vulnerability via new Function() constructor.

These tests should:
- FAIL when the application is vulnerable (code execution works)
- PASS when the application is fixed (code execution is blocked)
"""

import pytest
import requests
import json
import time
import os
import re

# Application URL
BASE_URL = os.environ.get("APP_URL", "http://localhost:7001")

# Use local URL for scraping tests (avoiding external network dependency)
# The app's own endpoint can be used as a scrape target
LOCAL_SCRAPE_URL = f"{BASE_URL}/cms/site/runEnv"

# Test timeout settings
REQUEST_TIMEOUT = 30


def wait_for_app(max_wait=60):
    """Wait for the application to be ready."""
    start_time = time.time()
    while time.time() - start_time < max_wait:
        try:
            response = requests.get(f"{BASE_URL}/cms/site/runEnv", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


@pytest.fixture(scope="module", autouse=True)
def setup_app():
    """Ensure the application is running before tests."""
    if not wait_for_app():
        pytest.skip("Application is not available")


class TestCodeExecutionVulnerability:
    """
    Test that arbitrary code execution is NOT possible.
    These tests should PASS when fixed, FAIL when vulnerable.

    Key insight: In the vulnerable version, parseData is executed as JavaScript
    via new Function(). In the fixed version, parseData is parsed as JSON config.

    We detect vulnerability by checking if JavaScript expressions execute.
    """

    def test_basic_code_execution_blocked(self):
        """
        Test that basic JavaScript code execution is blocked.
        Vulnerable: parseData is executed as code via new Function()
        Fixed: parseData is parsed as JSON, code execution fails
        """
        # Payload that executes code and returns a specific marker string
        payload = "return 'CODE_EXECUTED_SUCCESSFULLY';"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        response_text = response.text

        # In vulnerable version, the string 'CODE_EXECUTED_SUCCESSFULLY' will appear
        # In fixed version, JSON.parse will fail or return an error
        assert "CODE_EXECUTED_SUCCESSFULLY" not in response_text, \
            "VULNERABLE: Code was executed - parseData should be treated as JSON config only"

    def test_arithmetic_code_execution_blocked(self):
        """
        Test that arithmetic JavaScript code is not executed.
        This proves arbitrary code execution works in vulnerable version.
        """
        # Simple arithmetic that produces a specific result (42)
        payload = "return 6 * 7;"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        # Check if the response contains the computed result in the article field
        # Vulnerable: {"article": 42} or "article":42
        # Fixed: error response or article contains scraped content
        try:
            data = response.json()
            article = data.get("data", {}).get("article")
            # If article is exactly 42, code was executed
            assert article != 42, \
                "VULNERABLE: Arithmetic code was executed (6*7=42 returned in article)"
        except (json.JSONDecodeError, AttributeError, TypeError):
            pass  # Non-JSON response or error is acceptable (indicates fix)

    def test_string_method_execution_blocked(self):
        """
        Test that string method execution is blocked.
        """
        payload = "return 'vulnerable'.toUpperCase();"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        response_text = response.text

        # If 'VULNERABLE' appears in uppercase in response, code was executed
        assert "VULNERABLE" not in response_text, \
            "VULNERABLE: String method was executed (.toUpperCase() worked)"

    def test_globalThis_process_version_blocked(self):
        """
        Test that accessing process.version via globalThis is blocked.
        This is a working RCE vector in Node.js ES modules.
        """
        payload = "const p = globalThis.process; return p.version;"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        response_text = response.text

        # If we see a Node.js version pattern (v22.x.x, v20.x.x, etc), code executed
        version_pattern = r'"article":\s*"v\d+\.\d+\.\d+"'
        assert not re.search(version_pattern, response_text), \
            "VULNERABLE: globalThis.process.version was leaked"

    def test_process_env_leak_blocked(self):
        """
        Test that process environment variables cannot be accessed.
        """
        payload = "const p = globalThis.process; return Object.keys(p.env).length;"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            article = data.get("data", {}).get("article")
            # If article is a number > 0, env vars were accessed
            if isinstance(article, int) and article > 0:
                pytest.fail(f"VULNERABLE: process.env was accessed, found {article} env vars")
        except (json.JSONDecodeError, AttributeError, TypeError):
            pass  # Error response is acceptable

    def test_date_constructor_blocked(self):
        """
        Test that Date constructor execution is blocked.
        Simple test to prove any JavaScript execution works.
        """
        # Get current year via Date - this definitively proves code runs
        payload = "return new Date().getFullYear();"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            article = data.get("data", {}).get("article")
            # If article is a year (2024, 2025, etc), code was executed
            current_year = time.localtime().tm_year
            if article in [current_year, current_year - 1, current_year + 1]:
                pytest.fail(f"VULNERABLE: Date code was executed, returned year {article}")
        except (json.JSONDecodeError, AttributeError, TypeError):
            pass  # Error response is acceptable


class TestJSONParsingEnforcement:
    """
    Test that parseData is executed as code (vulnerability).
    In the vulnerable version, parseData is passed to new Function().
    """

    def test_invalid_json_returns_error(self):
        """
        Test what happens when parseData contains code that references undefined variables.
        In the vulnerable version, this code runs but may error if data.toUpperCase fails.
        """
        # This code tries to call toUpperCase() on `data` which is HTML string
        # In vulnerable version: should execute and call data.toUpperCase()
        payload = "return data.toUpperCase();"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            # In vulnerable version: the code executes and transforms the data
            # In fixed version: JSON.parse fails, returns error code 201 or data field is a string

            # Handle the case where 'data' is a nested dict or a string (error message)
            data_field = data.get('data', {})
            if isinstance(data_field, dict):
                article = data_field.get('article', '')
                if isinstance(article, str) and len(article) > 10:
                    # If the article is all uppercase (except tags), code was executed
                    # The vulnerable version executes data.toUpperCase()
                    # This test PASSES if code did NOT execute, FAILS if it did
                    text_only = ''.join(c for c in article if c.isalpha())
                    if text_only and text_only.isupper():
                        pytest.fail("VULNERABLE: JavaScript code was executed (data.toUpperCase() worked)")
            # If data_field is a string (error message), the fix is working as expected

        except json.JSONDecodeError:
            pass  # Non-JSON error response is acceptable

    def test_json_string_executed_as_code(self):
        """
        Test that even valid JSON strings are executed as code.
        In vulnerable version: '{"a":1}' is valid JS and returns an object.
        """
        # This is valid JSON but also valid JS that creates an object
        payload = 'return {"test": "value"};'

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            article = data.get("data", {}).get("article")
            # If we got an object back with "test": "value", code was executed
            if isinstance(article, dict) and article.get("test") == "value":
                pytest.fail("VULNERABLE: JavaScript object literal was executed and returned")
        except (json.JSONDecodeError, AttributeError, TypeError):
            pass


class TestMultipleBypassAttempts:
    """
    Test various code execution techniques are all blocked.
    """

    @pytest.mark.parametrize("payload,description,expected_result", [
        # Basic code execution tests
        ("return 'EXEC_TEST_1';", "string return", "EXEC_TEST_1"),
        ("return 100 + 23;", "addition", 123),
        ("return Math.pow(2, 10);", "Math.pow", 1024),
        ("return Array(5).fill('x').join('');", "array manipulation", "xxxxx"),
        ("return JSON.stringify({a:1});", "JSON.stringify", '{"a":1}'),
    ])
    def test_code_execution_blocked(self, payload, description, expected_result):
        """
        Test that various JavaScript code execution attempts are blocked.
        """
        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            article = data.get("data", {}).get("article")

            # Check if the expected result appears (vulnerability)
            if article == expected_result:
                pytest.fail(f"VULNERABLE: {description} code was executed, returned: {article}")

            # Also check string representation in response
            if str(expected_result) in str(article):
                pytest.fail(f"VULNERABLE: {description} result found in response")

        except (json.JSONDecodeError, AttributeError, TypeError):
            pass  # Error response is acceptable


class TestProcessAccessPrevention:
    """
    Test that Node.js process object cannot be accessed.
    """

    def test_process_cwd_blocked(self):
        """
        Test that process.cwd() cannot be accessed via globalThis.
        """
        payload = "const p = globalThis.process; return p.cwd();"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        response_text = response.text

        # Check for common path patterns that would indicate cwd was returned
        path_patterns = ['/app', '/home', '/root', '/usr', '/var', 'C:\\\\']
        for pattern in path_patterns:
            if f'"article":"{pattern}' in response_text or f'"article": "{pattern}' in response_text:
                pytest.fail(f"VULNERABLE: process.cwd() was executed, found path pattern: {pattern}")

    def test_process_platform_blocked(self):
        """
        Test that process.platform cannot be accessed.
        """
        payload = "const p = globalThis.process; return p.platform;"

        response = requests.post(
            f"{BASE_URL}/cms/collect/getArticle",
            json={
                "taskUrl": LOCAL_SCRAPE_URL,
                "titleTag": "body",
                "articleTag": "body",
                "parseData": payload,
                "charset": "utf8"
            },
            timeout=REQUEST_TIMEOUT
        )

        try:
            data = response.json()
            article = data.get("data", {}).get("article")

            # Check for known platform values
            platforms = ['linux', 'darwin', 'win32', 'freebsd', 'openbsd', 'sunos', 'aix']
            if article in platforms:
                pytest.fail(f"VULNERABLE: process.platform was leaked: {article}")

        except (json.JSONDecodeError, AttributeError, TypeError):
            pass  # Error response is acceptable


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
