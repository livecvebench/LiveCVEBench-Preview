diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..13469b8
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,96 @@
+import sys
+import os
+from pathlib import Path
+import platform
+
+# Add project root to sys.path to allow importing gradio module
+# This script is located in projects/gradio/, where Gradio package is also present
+# Therefore, the current directory needs to be added to sys.path
+project_dir = os.path.dirname(os.path.abspath(__file__))
+sys.path.insert(0, project_dir)
+
+try:
+    from gradio.utils import is_allowed_file, is_in_or_equal
+except ImportError as e:
+    print(f"ERROR: Cannot import 'gradio' module. Please ensure this script is located in the 'projects/gradio/' directory.")
+    print(f"ImportError: {e}")
+    sys.exit(1)
+
+def run_test():
+    """
+    Run a custom verification test for CVE-2025-23042 patch.
+    This test directly calls is_allowed_file to check whether path-blocking logic
+    is case-insensitive. Output is concise and intended for automated parsing.
+    """
+    base_dir = Path("/tmp/gradio_test_app")
+    allowed_paths = [base_dir]
+    blocked_paths = [base_dir / "blocked_dir"]
+    created_paths = []
+
+    test_cases = [
+        {
+            "description": "Key test: access blocked directory with different case",
+            "path": base_dir / "BLOCKED_DIR" / "some_file.txt",
+            "expected_is_allowed": False,
+            "expected_reason": "in_blocklist",
+        },
+        {
+            "description": "Access blocked directory with exact case",
+            "path": base_dir / "blocked_dir" / "another_file.txt",
+            "expected_is_allowed": False,
+            "expected_reason": "in_blocklist",
+        },
+        {
+            "description": "Access safe path within allowed range",
+            "path": base_dir / "public" / "image.png",
+            "expected_is_allowed": True,
+            "expected_reason": "allowed",
+        },
+        {
+            "description": "Access path completely outside allowed range",
+            "path": Path("/etc/passwd"),
+            "expected_is_allowed": False,
+            "expected_reason": "not_created_or_allowed",
+        }
+    ]
+
+    failed_count = 0
+    passed_count = 0
+
+    for test in test_cases:
+        is_allowed, reason = is_allowed_file(
+            path=test["path"],
+            blocked_paths=blocked_paths,
+            allowed_paths=allowed_paths,
+            created_paths=created_paths
+        )
+        
+        success = (is_allowed == test['expected_is_allowed'] and 
+                   reason == test['expected_reason'])
+        
+        if success:
+            passed_count += 1
+        else:
+            failed_count += 1
+            print(f"\n- FAILED: {test['description']}")
+            print(f"  - Path:      {test['path']}")
+            print(f"  - Expected:  allow={test['expected_is_allowed']}, reason='{test['expected_reason']}'")
+            print(f"  - Actual:    allow={is_allowed}, reason='{reason}'")
+
+    print("\n----------------------------------------------------")
+    if failed_count > 0:
+        summary = f"{failed_count} failed, {passed_count} passed"
+        print(f"Result: FAILED ({summary})")
+        print("----------------------------------------------------")
+        sys.exit(1)
+    else:
+        summary = f"{passed_count} passed"
+        print(f"Result: PASSED ({summary})")
+        print("----------------------------------------------------")
+        sys.exit(0)
+
+if __name__ == "__main__":
+    if platform.system() == "Windows":
+        print("Warning: This test is designed for case-sensitive file systems (e.g., Linux). Results may be inaccurate on Windows.")
+    
+    run_test() 
\ No newline at end of file
