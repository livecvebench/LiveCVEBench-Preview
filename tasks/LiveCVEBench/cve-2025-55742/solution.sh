#!/bin/bash
set -e
cd /var/www/html

echo "=== Applying file upload validation fix ==="

# Step 0: Create admin user for tests if not exists
echo "Ensuring test admin user exists..."
php artisan tinker --execute="
\$admin = Webkul\User\Models\Admin::where('email', 'admin@example.com')->first();
if (!\$admin) {
    \$role = Webkul\User\Models\Role::first();
    \$locale = Webkul\Core\Models\Locale::first();
    Webkul\User\Models\Admin::create([
        'name' => 'Admin',
        'email' => 'admin@example.com',
        'password' => bcrypt('admin123'),
        'api_token' => Str::random(80),
        'status' => 1,
        'role_id' => \$role->id,
        'ui_locale_id' => \$locale->id,
        'timezone' => 'UTC',
    ]);
    echo 'Admin user created';
} else {
    echo 'Admin user already exists';
}
" 2>/dev/null || echo "Admin user setup skipped"

# Step 1: Create the new FileMimeExtensionMatch validation rule
echo "Creating FileMimeExtensionMatch.php..."
mkdir -p packages/Webkul/Core/src/Rules

cat > packages/Webkul/Core/src/Rules/FileMimeExtensionMatch.php << 'EOF'
<?php

namespace Webkul\Core\Rules;

use Closure;
use Illuminate\Contracts\Validation\ValidationRule;
use Illuminate\Http\File;
use Illuminate\Http\UploadedFile;
use Symfony\Component\Mime\MimeTypes;

class FileMimeExtensionMatch implements ValidationRule
{
    /**
     * Validate the file extension and mime type match.
     */
    public function validate(string $attribute, mixed $value, Closure $fail): void
    {
        if (! $this->isValidFileInstance($value)) {
            $fail('validation.file')->translate();

            return;
        }

        $extension = $value instanceof UploadedFile ? $value->getClientOriginalExtension() : $value->getExtension();

        $mimeType = $value->getMimeType();

        $mimeTypes = MimeTypes::getDefault()->getMimeTypes($extension);

        if (empty($mimeTypes)) {
            $fail(trans('core::validation.file-mime-extension-mismatch', ['extension' => $extension, 'mimeType' => $mimeType]));

            return;
        }

        if (! (in_array($mimeType, $mimeTypes) && $value->guessExtension() === $extension)) {
            $fail(trans('core::validation.file-mime-extension-mismatch', ['extension' => $extension, 'mimeType' => $mimeType]));

            return;
        }
    }

    /**
     * Check that the given value is a valid file instance.
     *
     * @param  mixed  $value
     * @return bool
     */
    public function isValidFileInstance($value)
    {
        return ($value instanceof UploadedFile && $value->isValid()) || $value instanceof File;
    }
}
EOF

# Step 2: Update UserForm.php with image validation
echo "Updating UserForm.php with image validation..."
cat > packages/Webkul/Admin/src/Http/Requests/UserForm.php << 'EOF'
<?php

namespace Webkul\Admin\Http\Requests;

use Illuminate\Contracts\Validation\Validator;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\ValidationException;
use Webkul\Core\Repositories\LocaleRepository;
use Webkul\Core\Rules\AlphaNumericSpace;
use Webkul\Core\Rules\FileMimeExtensionMatch;

class UserForm extends FormRequest
{
    /**
     * Create a new instance.
     *
     * @return void
     */
    public function __construct(
        protected LocaleRepository $localeRepository
    ) {}

    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'name'                  => ['required', new AlphaNumericSpace],
            'email'                 => 'required|email|unique:admins,email,'.$this->id,
            'password'              => 'nullable',
            'password_confirmation' => 'nullable|required_with:password|same:password',
            'status'                => 'sometimes',
            'ui_locale_id'          => 'required',
            'role_id'               => 'required',
            'timezone'              => 'required',
            'image.*'               => [
                'sometimes',
                'image',
                'mimes:jpeg,png,jpg,svg,gif',
                new FileMimeExtensionMatch,
            ],
        ];
    }

    /**
     * Handle a failed validation attempt.
     *
     * @return void
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    protected function failedValidation(Validator $validator)
    {
        $errors = $validator->errors()->toArray();

        if (! isset($errors['image.0'])) {
            parent::failedValidation($validator);

            return;
        }

        $errors['image'] = $errors['image.0'];

        unset($errors['image.0']);

        throw ValidationException::withMessages($errors)
            ->errorBag($this->errorBag)
            ->redirectTo($this->getRedirectUrl());
    }
}
EOF

# Step 3: Add the validation message by recreating the file
echo "Adding validation message..."

VALIDATION_FILE="packages/Webkul/Core/src/Resources/lang/en_US/validation.php"
mkdir -p "$(dirname "$VALIDATION_FILE")"

# Always create a clean validation.php file to avoid sed issues
cat > "$VALIDATION_FILE" << 'EOF'
<?php

return [
    'address'                      => 'The :attribute can only accept alpha, numeric, spaces, comma and dashes.',
    'alpha-numeric-space'          => 'The :attribute can only accept alpha, numeric and spaces.',
    'code'                         => 'The :attribute must be valid and can only contain alphanumeric characters (letters and numbers).',
    'decimal'                      => 'The :attribute must be valid.',
    'phone-number'                 => 'The :attribute must be valid phone number.',
    'slug'                         => 'The :attribute must be valid slug.',
    'comma-separated-integer'      => 'The :attribute field must be numeric and may contain comma.',
    'type'                         => 'The :attribute must be valid type.',
    'validation-type'              => 'The :attribute must be valid type.',
    'field-option-not-found'       => 'The :attribute contains invalid option(s) :invalid_codes.',
    'boolean-string'               => 'The :attribute must be a boolean string represented as "true" or "false"',
    'not-supported'                => 'The :attribute does not support the following values (:unsupported).',
    'seperator-not-supported'      => 'Only , or ; or | is supported as a seperator.',
    'file-type'                    => 'The file must be of type csv,xls,xlsx',
    'file-mime-extension-mismatch' => 'The file extension and mime type do not match for field :attribute. The file extension is :extension and the mime type is :mimeType.',
    'file-not-exists'              => 'The selected file does not exist :value for the field :attribute.',
];
EOF

# Step 4: Configure OPcache to validate timestamps on every request
echo "Configuring OPcache to validate file changes..."
# Find the PHP ini directory and configure opcache
PHP_INI_DIR=$(php -r "echo PHP_CONFIG_FILE_SCAN_DIR;")
if [ -n "$PHP_INI_DIR" ] && [ -d "$PHP_INI_DIR" ]; then
    # Create an ini file to configure opcache to check for file changes
    cat > "$PHP_INI_DIR/99-opcache-dev.ini" << 'OPCACHEINI'
; Development settings to ensure file changes are picked up
opcache.validate_timestamps=1
opcache.revalidate_freq=0
OPCACHEINI
    echo "Created $PHP_INI_DIR/99-opcache-dev.ini to force OPcache revalidation"
fi

# Alternative: try to reset OPcache via artisan command or direct PHP
# This creates a temporary file that will reset opcache when loaded
cat > /tmp/reset_opcache.php << 'OPCACHE'
<?php
if (function_exists('opcache_reset')) {
    opcache_reset();
    echo "OPcache reset successfully\n";
} else {
    echo "OPcache not available\n";
}
OPCACHE

# Step 5: Clear Laravel caches
echo "Clearing Laravel caches..."
php artisan config:clear 2>/dev/null || true
php artisan cache:clear 2>/dev/null || true
php artisan route:clear 2>/dev/null || true
php artisan view:clear 2>/dev/null || true
php artisan optimize:clear 2>/dev/null || true

# Step 6: Touch all modified files to invalidate any file-based caching
echo "Touching modified files to invalidate cache..."
touch packages/Webkul/Core/src/Rules/FileMimeExtensionMatch.php
touch packages/Webkul/Admin/src/Http/Requests/UserForm.php

echo "=== Fix applied successfully ==="
echo "The application now validates that uploaded file extensions match their actual MIME types."
