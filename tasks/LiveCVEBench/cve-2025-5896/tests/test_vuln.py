"""
Vulnerability tests for css-to-react-native ReDoS issue.

These tests verify the regex performance vulnerability:
- FAIL in vulnerable state (slow processing due to catastrophic backtracking)
- PASS in fixed state (fast processing with optimized regex patterns)

The vulnerability exists in regex patterns that cause exponential backtracking
when processing long numeric sequences followed by partial unit suffixes.
"""

import subprocess
import time
import pytest


APP_DIR = '/app/packages/css-to-react-native'

# Performance thresholds
FAST_THRESHOLD_MS = 1000  # Fixed version should complete within 1 second
TIMEOUT_SECONDS = 5        # Maximum time to wait before declaring timeout (reduced to fit within framework timeout)


def run_node_script(script, timeout=5):
    """Execute a Node.js script and return output with timing."""
    start = time.time()
    try:
        result = subprocess.run(
            ['node', '-e', script],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=APP_DIR
        )
        duration = time.time() - start
        return result.stdout.strip(), result.stderr.strip(), result.returncode, duration
    except subprocess.TimeoutExpired:
        duration = time.time() - start
        return None, f"Timeout after {timeout}s", -1, duration


class TestPxRegexPerformance:
    """Tests for px regex pattern performance vulnerability."""

    def test_long_digits_followed_by_p(self):
        """
        Test that processing 100k digits followed by 'p' completes quickly.

        Vulnerable pattern: /(\d+)px/
        Attack input: '0' * 100000 + 'p'

        The vulnerable regex causes catastrophic backtracking because when
        '0000...000p' doesn't end with 'px', the engine backtracks through
        all possible positions.
        """
        script = """
        const transform = require('./dist/index').default;
        const bigValue = '0'.repeat(100000) + 'p';
        const cssString = `.foo { some-prop: "${bigValue}"; }`;
        const start = Date.now();
        try {
            transform(cssString, { scalable: false, parseMediaQueries: false });
            console.log('DURATION:' + (Date.now() - start));
        } catch (e) {
            console.log('ERROR:' + e.message);
        }
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        # If it timed out, the vulnerability is present
        if rc == -1:
            pytest.fail(f"Processing timed out after {TIMEOUT_SECONDS}s - vulnerability present")

        # Parse the duration from output
        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms, expected < {FAST_THRESHOLD_MS}ms. Vulnerability present."
        else:
            pytest.fail(f"Unexpected output: {stdout}, stderr: {stderr}")

    def test_long_digits_followed_by_px_incomplete(self):
        """
        Test variant with digits followed by just 'p' (incomplete 'px').
        Uses 50k digits to test medium-sized input.
        """
        script = """
        const transform = require('./dist/index').default;
        const bigValue = '0'.repeat(50000) + 'p';
        const cssString = `.test { width: "${bigValue}"; }`;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms. Vulnerability present."

    def test_varying_digit_patterns_px(self):
        """
        Test with different digit patterns that could trigger backtracking.
        """
        script = """
        const transform = require('./dist/index').default;
        // Mix of different digits to ensure pattern isn't optimized away
        const bigValue = '1234567890'.repeat(10000) + 'p';
        const cssString = `.test { margin: "${bigValue}"; }`;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms. Vulnerability present."


class TestRemRegexPerformance:
    """Tests for rem regex pattern performance vulnerability."""

    def test_long_digits_followed_by_r(self):
        """
        Test that processing 100k digits followed by 'r' completes quickly.

        Vulnerable pattern: /(\d*\.?\d+)rem/g
        Attack input: '0' * 100000 + 'r'

        The nested optionality in \d*\.?\d+ creates multiple ways to
        split the digit sequence, causing exponential backtracking.
        """
        script = """
        const transform = require('./dist/index').default;
        const bigValue = '0'.repeat(100000) + 'r';
        const cssString = `.foo { font-size: "${bigValue}"; }`;
        const start = Date.now();
        try {
            transform(cssString, { scalable: false });
            console.log('DURATION:' + (Date.now() - start));
        } catch (e) {
            console.log('ERROR:' + e.message);
        }
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out after {TIMEOUT_SECONDS}s - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms, expected < {FAST_THRESHOLD_MS}ms. Vulnerability present."

    def test_long_digits_followed_by_re(self):
        """
        Test with 're' suffix (incomplete 'rem').
        """
        script = """
        const transform = require('./dist/index').default;
        const bigValue = '0'.repeat(75000) + 're';
        const cssString = `.test { line-height: "${bigValue}"; }`;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms. Vulnerability present."

    def test_decimal_like_pattern_for_rem(self):
        """
        Test with a pattern that looks like it could have decimals.
        The pattern \d*\.?\d+ is particularly vulnerable with ambiguous input.
        """
        script = """
        const transform = require('./dist/index').default;
        // Pattern with dots interspersed could trigger additional backtracking
        const bigValue = '0'.repeat(50000) + '.r';
        const cssString = `.test { padding: "${bigValue}"; }`;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS, \
                f"Processing took {duration_ms}ms. Vulnerability present."


class TestCombinedAttacks:
    """Tests combining multiple attack vectors."""

    def test_multiple_malicious_properties(self):
        """
        Test CSS with multiple properties containing malicious values.
        """
        script = """
        const transform = require('./dist/index').default;
        const attack1 = '0'.repeat(30000) + 'p';
        const attack2 = '0'.repeat(30000) + 'r';
        const cssString = `
            .test {
                width: "${attack1}";
                font-size: "${attack2}";
            }
        `;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS * 2, \
                f"Processing took {duration_ms}ms. Vulnerability present."

    def test_multiple_malicious_classes(self):
        """
        Test CSS with multiple classes containing malicious values.
        """
        script = """
        const transform = require('./dist/index').default;
        const attack = '0'.repeat(25000) + 'p';
        const cssString = `
            .class1 { width: "${attack}"; }
            .class2 { height: "${attack}"; }
            .class3 { margin: "${attack}"; }
        `;
        const start = Date.now();
        transform(cssString, { scalable: false });
        console.log('DURATION:' + (Date.now() - start));
        """
        stdout, stderr, rc, wall_time = run_node_script(script, timeout=TIMEOUT_SECONDS)

        if rc == -1:
            pytest.fail(f"Processing timed out - vulnerability present")

        if stdout and stdout.startswith('DURATION:'):
            duration_ms = int(stdout.split(':')[1])
            assert duration_ms < FAST_THRESHOLD_MS * 3, \
                f"Processing took {duration_ms}ms. Vulnerability present."


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
