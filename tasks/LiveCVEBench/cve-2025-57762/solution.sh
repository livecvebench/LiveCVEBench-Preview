#!/bin/bash
# Solution script for WeGIA Stored XSS vulnerability
# Fixes input sanitization and output encoding in document type management
set -e

cd /app

FUNC_DIR="/app/html/funcionario"

# Check if the directory exists
if [ ! -d "$FUNC_DIR" ]; then
    echo "Error: Directory $FUNC_DIR not found"
    # Try alternative paths
    if [ -d "/var/www/WeGIA/html/funcionario" ]; then
        FUNC_DIR="/var/www/WeGIA/html/funcionario"
    elif [ -d "/var/www/html/html/funcionario" ]; then
        FUNC_DIR="/var/www/html/html/funcionario"
    else
        echo "Error: Cannot find funcionario directory"
        exit 1
    fi
fi

echo "Using directory: $FUNC_DIR"

# Fix 1: Replace dependente_docdependente.php with fixed version
# The fix includes:
# - Replace extract($_POST) with filter_input for safe input handling
# - Add FILTER_SANITIZE_SPECIAL_CHARS for the 'nome' parameter
# - Add input validation (reject empty names)
# - Add htmlspecialchars() on output in JSON response

DOCDEP_FILE="$FUNC_DIR/dependente_docdependente.php"

if [ -f "$DOCDEP_FILE" ]; then
    echo "Patching dependente_docdependente.php..."

    cat > "$DOCDEP_FILE" << 'ENDOFFILE'
<?php
//realizar as sugestões de alteração da issue #311
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}

if (!isset($_SESSION["usuario"])) {
    header("Location: ../../index.php");
    exit();
} else {
    session_regenerate_id();
}

// Verifica Permissão do Usuário
require_once '../permissao/permissao.php';
permissao($_SESSION['id_pessoa'], 11, 7);

require_once "../../dao/Conexao.php";
$pdo = Conexao::connect();

$idDoc = filter_var($_REQUEST["id_doc"] ?? '', FILTER_SANITIZE_NUMBER_INT);
$action = filter_var($_REQUEST["action"] ?? '', FILTER_SANITIZE_SPECIAL_CHARS);

$actions = ['download', 'excluir', 'adicionar'];

if (!$action || !in_array($action, $actions)) {
    http_response_code(400);
    echo json_encode(['erro' => 'A ação informada não é válida.']);
    exit();
}

define("TYPEOF_EXTENSION", [
    'jpg' => 'image/jpg',
    'png' => 'image/png',
    'jpeg' => 'image/jpeg',
    'pdf' => 'application/pdf',
    'docx' => 'application/docx',
    'doc' => 'application/doc',
    'odp' => 'application/odp',
]);

switch ($action) {
    case 'download':
        download($pdo, $idDoc);
        break;
    case 'excluir':
        excluir($pdo, $idDoc);
        break;
    case 'adicionar':
        adicionar($pdo);
}

function validarIdDoc($id): bool
{
    if (!$id || $id < 1)
        return false;
    return true;
}

function download(PDO $pdo, $idDoc)
{
    if (!validarIdDoc($idDoc)) {
        http_response_code(400);
        echo json_encode(['erro' => 'O id fornecido para o documento não é válido.']);
        exit();
    }

    $sql = "SELECT extensao_arquivo, nome_arquivo, UNCOMPRESS(arquivo) AS arquivo FROM funcionario_dependentes_docs WHERE id_doc=:idDoc";
    try {
        $stmt = $pdo->prepare($sql);

        $stmt->bindParam(':idDoc', $idDoc);

        $stmt->execute();

        $docdependente = $stmt->fetch(PDO::FETCH_ASSOC);
        header("Content-type: " . TYPEOF_EXTENSION[$docdependente["extensao_arquivo"]]);
        header("Content-Disposition: attachment; filename=" . $docdependente["nome_arquivo"]);
        ob_clean();
        flush();
        echo base64_decode($docdependente["arquivo"]);
    } catch (PDOException $e) {
        error_log("[ERRO] {$e->getMessage()} em {$e->getFile()} na linha {$e->getLine()}");
        http_response_code(500);
        echo json_encode(['erro' => 'Erro no servidor ao baixar uma documentação.']);
    }
}

function excluir(PDO $pdo, $idDoc)
{
    if (!validarIdDoc($idDoc)) {
        http_response_code(400);
        echo json_encode(['erro' => 'O id fornecido para o documento não é válido.']);
        exit();
    }

    $sql1 = "DELETE FROM funcionario_dependentes_docs WHERE id_doc=:idDoc";

    $sql2 = "SELECT doc.nome_docdependente AS descricao, ddoc.data, ddoc.id_doc FROM funcionario_dependentes_docs ddoc LEFT JOIN funcionario_docdependentes doc ON doc.id_docdependentes = ddoc.id_docdependentes WHERE ddoc.id_dependente=:idDependente";

    try {
        $stmt1 = $pdo->prepare($sql1);
        $stmt1->bindParam(':idDoc', $idDoc);
        $stmt1->execute();

        $id_dependente = filter_var($_REQUEST["id_dependente"] ?? '', FILTER_SANITIZE_NUMBER_INT);
        $stmt2 = $pdo->prepare($sql2);
        $stmt2->bindParam(':idDependente', $id_dependente);
        $stmt2->execute();

        $docdependente = $stmt2->fetchAll(PDO::FETCH_ASSOC);
        $docdependente = json_encode($docdependente);
        echo $docdependente;
    } catch (PDOException $e) {
        error_log("[ERRO] {$e->getMessage()} em {$e->getFile()} na linha {$e->getLine()}");
        http_response_code(500);
        echo json_encode(['erro' => 'Erro no servidor ao excluir uma documentação']);
    }
}

function adicionar(PDO $pdo)
{
    $nome = filter_input(INPUT_POST, 'nome', FILTER_SANITIZE_SPECIAL_CHARS);

    if (!$nome || strlen($nome) < 1) {
        http_response_code(400);
        echo json_encode(['erro' => 'O nome do documento fornecido é inválido.']);
        exit();
    }

    $sql = [
        "INSERT INTO funcionario_docdependentes (nome_docdependente) VALUES (:n);",
        "SELECT * FROM funcionario_docdependentes;"
    ];
    try {
        $prep = $pdo->prepare($sql[0]);
        $prep->bindValue(":n", $nome);
        $prep->execute();
        $query = $pdo->query($sql[1]);
        $docdependente = $query->fetchAll(PDO::FETCH_ASSOC);

        foreach ($docdependente as $key => $value) {
            $docdependente[$key]['nome_docdependente'] = htmlspecialchars($value['nome_docdependente']);
        }

        $docdependente = json_encode($docdependente);
        echo $docdependente;
    } catch (PDOException $e) {
        error_log("[ERRO] {$e->getMessage()} em {$e->getFile()} na linha {$e->getLine()}");
        http_response_code(500);
        echo json_encode(['erro' => 'Erro no servidor ao adicionar uma documentação.']);
    }
}
ENDOFFILE

    echo "Successfully patched dependente_docdependente.php"
else
    echo "Warning: $DOCDEP_FILE not found"
fi

# Fix 2: Patch profile_dependente.php - add htmlspecialchars() to output
# This is a single-line fix on line 602

PROFILE_FILE="$FUNC_DIR/profile_dependente.php"

if [ -f "$PROFILE_FILE" ]; then
    echo "Patching profile_dependente.php..."

    # Replace the vulnerable line that outputs nome_docdependente without encoding
    # Before: $item["nome_docdependente"]
    # After: htmlspecialchars($item["nome_docdependente"])

    sed -i 's/\$item\["nome_docdependente"\]/htmlspecialchars($item["nome_docdependente"])/g' "$PROFILE_FILE"

    echo "Successfully patched profile_dependente.php"
else
    echo "Warning: $PROFILE_FILE not found"
fi

# Restart PHP/Apache to apply changes (if running as a service)
# PHP-FPM or Apache may cache the scripts
if command -v apachectl &> /dev/null; then
    echo "Restarting Apache..."
    apachectl graceful 2>/dev/null || true
fi

if command -v service &> /dev/null; then
    service apache2 reload 2>/dev/null || true
    service php-fpm reload 2>/dev/null || true
    service php8.2-fpm reload 2>/dev/null || true
fi

# Kill any PHP processes to ensure fresh code is loaded
pkill -f "php" 2>/dev/null || true

echo ""
echo "Fix applied successfully!"
echo "Changes made:"
echo "1. dependente_docdependente.php: Added input sanitization with FILTER_SANITIZE_SPECIAL_CHARS"
echo "2. dependente_docdependente.php: Added validation to reject empty/invalid names"
echo "3. dependente_docdependente.php: Added htmlspecialchars() on JSON output"
echo "4. profile_dependente.php: Added htmlspecialchars() to prevent XSS in HTML output"
