#!/bin/bash
# Solution script for CVE-2025-48866
# Fixes the sanitiseArg DoS vulnerability in ModSecurity
#
# The vulnerability is in apache2/re_actions.c - the msre_action_sanitizeArg_execute()
# function adds arguments to the sanitization table without checking if they were
# already added by a previous rule, causing O(R*N) entries.
#
# The fix adds a check for arg->marked_for_sanitization before adding, and sets
# the flag after adding to prevent duplicates.

set -e

echo "[*] Applying fix for ModSecurity sanitiseArg DoS vulnerability..."

# Find ModSecurity source directory
# It could be in various locations depending on how Builder set it up
MODSEC_SRC=""
for dir in /app /app/ModSecurity /opt/modsecurity /usr/local/src/modsecurity /usr/local/src/ModSecurity; do
    if [ -f "$dir/apache2/re_actions.c" ]; then
        MODSEC_SRC="$dir"
        break
    fi
done

if [ -z "$MODSEC_SRC" ]; then
    echo "[-] ERROR: Could not find ModSecurity source directory"
    echo "[-] Searched for apache2/re_actions.c in common locations"
    exit 1
fi

echo "[+] Found ModSecurity source at: $MODSEC_SRC"

VULN_FILE="$MODSEC_SRC/apache2/re_actions.c"

# Verify the file exists
if [ ! -f "$VULN_FILE" ]; then
    echo "[-] ERROR: Could not find re_actions.c at $VULN_FILE"
    exit 1
fi

# Check if fix is already applied to the sanitizeArg function specifically (idempotency)
# Note: sanitizeMatched function already has this pattern (fixed for CVE-2025-47947 in v2.9.9)
# We need to check if the STANDALONE sanitizeArg function is still vulnerable
# The vulnerable pattern is: if (strcasecmp(sargname, arg->name) == 0) { followed directly by apr_table_addn
# We look for lines with strcasecmp that DON'T have marked_for_sanitization before them
VULNERABLE_PATTERN=$(grep -n "if (strcasecmp(sargname, arg->name) == 0) {" "$VULN_FILE" | head -1)
if echo "$VULNERABLE_PATTERN" | grep -q .; then
    echo "[*] Found vulnerable pattern at: $VULNERABLE_PATTERN"
    echo "[*] Applying source code fix..."

    # Backup the original file
    cp "$VULN_FILE" "$VULN_FILE.bak"

    # Fix 1: Add the marked_for_sanitization check before the strcasecmp
    # Original: if (strcasecmp(sargname, arg->name) == 0) {
    # Fixed:    if (arg->marked_for_sanitization == 0 && strcasecmp(sargname, arg->name) == 0) {
    # Note: Only fix the FIRST occurrence which is in msre_action_sanitizeArg_execute
    # The second occurrence (in sanitizeMatched) is already fixed
    sed -i '0,/if (strcasecmp(sargname, arg->name) == 0) {/s//if (arg->marked_for_sanitization == 0 \&\& strcasecmp(sargname, arg->name) == 0) {/' "$VULN_FILE"

    # Fix 2: Add the marking statement after apr_table_addn
    # This needs to only add to the sanitizeArg function, not the sanitizeMatched which already has it
    # We check if the marking line already exists and only add if it doesn't exist immediately after apr_table_addn
    # The safest approach is to use awk to only modify within the sanitizeArg function context

    # First, check if the line after apr_table_addn already has marking
    NEEDS_MARKING=$(awk '/msre_action_sanitizeArg_execute/,/^}$/{if(/apr_table_addn\(msr->arguments_to_sanitize/){getline; if(!/marked_for_sanitization = 1/) print "yes"}}' "$VULN_FILE")

    if [ -n "$NEEDS_MARKING" ]; then
        # Use sed to add the marking line only for the sanitizeArg function's apr_table_addn
        # We target the first occurrence of this specific apr_table_addn pattern
        sed -i '0,/apr_table_addn(msr->arguments_to_sanitize, arg->name, (void \*)arg);/s//apr_table_addn(msr->arguments_to_sanitize, arg->name, (void *)arg);\n            arg->marked_for_sanitization = 1;/' "$VULN_FILE"
        echo "[+] Added marking statement"
    else
        echo "[*] Marking statement already present or not needed"
    fi

    echo "[+] Source code fix applied"
else
    echo "[+] Fix already applied (no vulnerable pattern found), verifying..."
    # Verify the fix is actually in place
    if grep -q "arg->marked_for_sanitization == 0 && strcasecmp(sargname, arg->name)" "$VULN_FILE"; then
        echo "[+] Fix confirmed in place"
    else
        echo "[!] Warning: Could not verify fix status"
    fi
fi

# Rebuild ModSecurity
echo "[*] Rebuilding ModSecurity..."
cd "$MODSEC_SRC"

# Check if we need to run make clean
if [ -f "Makefile" ]; then
    echo "[*] Running make clean..."
    make clean 2>/dev/null || true
fi

# Configure if needed
if [ ! -f "Makefile" ] || ! grep -q "mod_security2" Makefile 2>/dev/null; then
    echo "[*] Running configure..."
    if [ -x "./autogen.sh" ]; then
        ./autogen.sh
    fi
    ./configure --with-apxs=/usr/bin/apxs 2>&1 | tail -5
fi

# Build
echo "[*] Building ModSecurity..."
make -j$(nproc) 2>&1 | tail -10

# Install
echo "[*] Installing ModSecurity..."
make install 2>&1 | tail -5

# Verify the module was built
if [ -f ".libs/mod_security2.so" ]; then
    echo "[+] Module built successfully"
    cp .libs/mod_security2.so /usr/lib/apache2/modules/ 2>/dev/null || \
    cp .libs/mod_security2.so /usr/lib64/httpd/modules/ 2>/dev/null || \
    cp .libs/mod_security2.so /usr/local/apache2/modules/ 2>/dev/null || \
    echo "[*] Module will be loaded from build directory"
fi

# Restart Apache to load the new module
echo "[*] Restarting Apache to load fixed module..."

# Try graceful reload which doesn't kill the container
if command -v apachectl &> /dev/null; then
    # graceful reload is preferred - it reloads the module without stopping
    apachectl graceful 2>/dev/null && echo "[+] Apache reloaded successfully" || {
        echo "[*] Graceful reload failed, trying restart..."
        # If running in a container, killing apache may kill the container
        # So we try to restart it properly
        apachectl restart 2>/dev/null || {
            echo "[!] Could not restart Apache automatically"
            echo "[!] Apache will need to be restarted to load the fixed module"
        }
    }
fi

# Give Apache time to reload
sleep 2

# Verify Apache is running
echo "[*] Verifying Apache is running..."
if pgrep -f "apache2" > /dev/null 2>&1 || pgrep -f "httpd" > /dev/null 2>&1; then
    echo "[+] Apache is running"
else
    echo "[!] Apache not detected - container may need restart to apply fix"
fi

echo ""
echo "[+] Fix applied successfully!"
echo "[+] The vulnerability has been patched by:"
echo "    1. Adding check: arg->marked_for_sanitization == 0"
echo "    2. Setting flag after add: arg->marked_for_sanitization = 1"
echo "    This prevents duplicate entries in the sanitization table."
