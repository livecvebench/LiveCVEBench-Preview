diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..5e202cb
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,133 @@
+import os
+import sys
+import unittest
+from unittest import mock
+
+# Disable the start method of threading.Thread to prevent background tasks from hanging the tests.
+# This must be done before any application code is imported.
+mock.patch('threading.Thread.start').start()
+
+# Add project directory to path to allow imports from cps
+project_root = os.path.dirname(os.path.abspath(__file__))
+sys.path.insert(0, project_root)
+# The project also depends on a vendor folder
+sys.path.insert(0, os.path.join(project_root, 'vendor'))
+
+
+class MockUser:
+    """A mock user class to simulate logged-in users with different permissions."""
+    def __init__(self, can_edit_shelfs):
+        self._can_edit_shelfs = can_edit_shelfs
+        self.is_authenticated = True
+        self.is_active = True
+        self.is_anonymous = False
+
+    def get_id(self):
+        """Required by flask-login."""
+        return '1'
+
+    def role_edit_shelfs(self):
+        """This method is checked by the patched code."""
+        return self._can_edit_shelfs
+
+
+# Mock the config object that is loaded from the database on startup
+mock_config = mock.MagicMock()
+mock_config.config_calibre_dir = '.'
+
+
+# Use decorators to mock functions that are called during app setup.
+# This avoids side effects like database connections or starting background threads.
+class TestShelfPatch(unittest.TestCase):
+    """Test case for the shelf creation patch."""
+
+    def setUp(self):
+        """Set up a test environment before each test."""
+
+        # Start all the patches that were previously class decorators
+        patchers = [
+            mock.patch('cps.dep_check.dependency_check', return_value=[]),
+            mock.patch('cps.updater.Updater'),
+            mock.patch('cps.server.WebServer'),
+            mock.patch('cps.db.CalibreDB.setup_db'),
+            mock.patch('cps.config_sql.load_configuration', return_value=mock_config),
+            mock.patch('cps.ub.init_db')
+        ]
+        for patcher in patchers:
+            patcher.start()
+            self.addCleanup(patcher.stop)
+
+        # Imports are done here, after mocks are active
+        from cps import create_app
+        from cps.shelf import shelf
+        from cps.web import web
+        
+        # Create the Flask app instance
+        self.app = create_app()
+
+        # Configure the app for testing
+        self.app.config.update({
+            "TESTING": True,
+            "SECRET_KEY": 'test-secret-key',
+            "WTF_CSRF_ENABLED": False,  # Disable CSRF for easier POST requests
+            "SERVER_NAME": "localhost.local" # Needed for url_for to work
+        })
+
+        # Register the necessary blueprints to make routes available
+        self.app.register_blueprint(shelf)
+        self.app.register_blueprint(web) # For the redirect target
+
+        # Set up a test client and application context
+        self.app_context = self.app.app_context()
+        self.app_context.push()
+        self.client = self.app.test_client()
+
+    def tearDown(self):
+        """Clean up the application context after each test."""
+        self.app_context.pop()
+
+    @mock.patch('cps.shelf.create_edit_shelf', return_value="Shelf Creation Page")
+    @mock.patch('flask_login.utils._get_user')
+    def test_create_shelf_with_permission(self, mock_get_user, mock_create_edit_shelf):
+        """
+        Tests that a user WITH permission can proceed to the shelf creation logic.
+        """
+        # Simulate a logged-in user who has the required permission
+        mock_get_user.return_value = MockUser(can_edit_shelfs=True)
+        
+        response = self.client.post('/shelf/create', follow_redirects=True)
+        
+        # Assert that the request was successful
+        self.assertEqual(response.status_code, 200)
+        # Assert that the function to render the creation page was called
+        mock_create_edit_shelf.assert_called_once()
+
+    @mock.patch('cps.shelf.create_edit_shelf')
+    @mock.patch('flask_login.utils._get_user')
+    def test_create_shelf_without_permission_verifies_patch(self, mock_get_user, mock_create_edit_shelf):
+        """
+        Tests that a user WITHOUT permission is blocked, verifying the patch.
+        """
+        # Simulate a logged-in user who LACKS the required permission
+        mock_get_user.return_value = MockUser(can_edit_shelfs=False)
+        
+        # Use the client in a 'with' block to access the session for flashed messages
+        with self.client as c:
+            response = c.post('/shelf/create', follow_redirects=False)
+
+            # Assert that the user was redirected
+            self.assertEqual(response.status_code, 302)
+            # Assert that the logic was blocked BEFORE calling the page rendering function
+            mock_create_edit_shelf.assert_not_called()
+
+            # Check the flashed error message from the session
+            with c.session_transaction() as sess:
+                flashes = sess.get('_flashes', [])
+                self.assertGreater(len(flashes), 0, "No message was flashed to the user.")
+                category, message = flashes[0]
+                self.assertEqual(category, "error")
+                self.assertIn("not allowed to create a public shelf", message)
+
+
+if __name__ == '__main__':
+    unittest.main(argv=['first-arg-is-ignored']) 
\ No newline at end of file
