#!/bin/bash
set -e

cd /app

echo "Applying fix for asteval format string sandbox escape..."

# Find the asteval installation directory
ASTEVAL_DIR=$(python -c "import asteval; import os; print(os.path.dirname(asteval.__file__))")
echo "Found asteval at: $ASTEVAL_DIR"

# Apply the fix using a Python script
python3 << 'PYEOF'
import os
import sys

# Get asteval directory
import asteval
asteval_dir = os.path.dirname(asteval.__file__)

print(f"Modifying asteval files in: {asteval_dir}")

# ============================================================================
# Step 1: Modify astutils.py
# ============================================================================
astutils_path = os.path.join(asteval_dir, 'astutils.py')
print(f"Reading {astutils_path}...")

with open(astutils_path, 'r') as f:
    content = f.read()

# Check if fix already applied
if 'def safe_getattr' in content:
    print("Fix already applied to astutils.py")
else:
    # Add imports at the top (after existing imports)
    import_addition = """
from string import Formatter
try:
    from _string import formatter_field_name_split
except ImportError:
    formatter_field_name_split = lambda x: x._formatter_field_name_split()
"""

    # Find a good place to add the import - after the last import statement
    lines = content.split('\n')
    last_import_line = 0
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith('import ') or stripped.startswith('from '):
            last_import_line = i

    # Insert imports after the last import line
    lines.insert(last_import_line + 1, import_addition)
    content = '\n'.join(lines)

    # Add 'mro' to UNSAFE_ATTRS if not present
    if "'mro'" not in content and '"mro"' not in content:
        # Try to find the UNSAFE_ATTRS definition and add 'mro' to it
        # The tuple typically ends with a specific entry we can append to
        if "'__subclasshook__'" in content:
            content = content.replace(
                "'__subclasshook__',",
                "'__subclasshook__', 'mro',"
            )
        elif '"__subclasshook__"' in content:
            content = content.replace(
                '"__subclasshook__",',
                '"__subclasshook__", "mro",'
            )

    # Add safe_getattr, SafeFormatter, and safe_format functions at the end
    function_addition = '''

def safe_getattr(obj, attr, raise_exc, node):
    """safe version of getattr that checks for unsafe attributes"""
    unsafe = (attr in UNSAFE_ATTRS or
              (attr.startswith('__') and attr.endswith('__')))
    if not unsafe:
        for dtype, attrlist in UNSAFE_ATTRS_DTYPES.items():
            unsafe = (isinstance(obj, dtype) or obj is dtype) and attr in attrlist
            if unsafe:
                break
    if unsafe:
        msg = f"no safe attribute '{attr}' for {repr(obj)}"
        raise_exc(node, exc=AttributeError, msg=msg)
    else:
        try:
            return getattr(obj, attr)
        except AttributeError:
            pass
    return None


class SafeFormatter(Formatter):
    """String formatter that uses safe_getattr for attribute access."""

    def __init__(self, raise_exc, node):
        self.raise_exc = raise_exc
        self.node = node
        super().__init__()

    def get_field(self, field_name, args, kwargs):
        first, rest = formatter_field_name_split(field_name)
        obj = self.get_value(first, args, kwargs)
        for is_attr, i in rest:
            if is_attr:
                obj = safe_getattr(obj, i, self.raise_exc, self.node)
            else:
                obj = obj[i]
        return obj, first


def safe_format(fmt, raise_exc, node, *args, **kwargs):
    """Safe string formatting using SafeFormatter."""
    formatter = SafeFormatter(raise_exc, node)
    return formatter.vformat(fmt, args, kwargs)
'''

    content += function_addition

    with open(astutils_path, 'w') as f:
        f.write(content)

    print(f"Modified {astutils_path}")

# ============================================================================
# Step 2: Modify asteval.py
# ============================================================================
asteval_path = os.path.join(asteval_dir, 'asteval.py')
print(f"Reading {asteval_path}...")

with open(asteval_path, 'r') as f:
    content = f.read()

modified = False

# Add safe_format to imports from astutils
if 'safe_format' not in content:
    # Find the import from .astutils line and add safe_format
    if 'from .astutils import' in content:
        content = content.replace(
            'from .astutils import',
            'from .astutils import safe_format,'
        )
        modified = True
    else:
        print("Warning: Could not find 'from .astutils import' statement")

# Fix the on_formattedvalue method
old_line = 'return fmt.format(__fstring__=val)'
new_line = 'return safe_format(fmt, self.raise_exception, node, __fstring__=val)'

if old_line in content:
    content = content.replace(old_line, new_line)
    modified = True
    print(f"Fixed on_formattedvalue method in {asteval_path}")
elif new_line in content:
    print("on_formattedvalue already fixed")
else:
    print("Warning: Could not find vulnerable line to fix in on_formattedvalue")

if modified:
    with open(asteval_path, 'w') as f:
        f.write(content)
    print(f"Modified {asteval_path}")

# ============================================================================
# Step 3: Clear Python cache to ensure changes take effect
# ============================================================================
import shutil
pycache_dir = os.path.join(asteval_dir, '__pycache__')
if os.path.exists(pycache_dir):
    shutil.rmtree(pycache_dir)
    print(f"Cleared Python cache: {pycache_dir}")

print("\nFix applied successfully!")
print("The format string sandbox escape vulnerability has been patched.")
PYEOF

echo "Solution applied successfully"
