#!/usr/bin/env python3
"""
Vulnerability tests for AIDE terminal escape sequence injection.

These tests verify that control characters in filenames are properly escaped.
- FAIL in vulnerable state (escape sequences interpreted by terminal)
- PASS in fixed state (escape sequences shown as octal notation)
"""

import os
import subprocess
import tempfile
import shutil
import pytest
import re


class TestEscapeSequenceInFilenames:
    """Test that escape sequences in filenames are properly escaped in output"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        """Create a temporary test directory for each test"""
        self.test_dir = tempfile.mkdtemp(prefix="aide_vuln_")
        self.db_file = os.path.join(self.test_dir, "aide.db")
        self.db_out_file = os.path.join(self.test_dir, "aide.db.new")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        os.makedirs(self.monitored_dir)
        yield
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def _create_config(self, extra_options=""):
        """Create a minimal AIDE config file"""
        config_path = os.path.join(self.test_dir, "aide.conf")
        config = f"""
database_in=file:{self.db_file}
database_out=file:{self.db_out_file}
root_prefix={self.monitored_dir}
{extra_options}
/ R
"""
        with open(config_path, "w") as f:
            f.write(config)
        return config_path

    def _run_aide_check_no_db(self, config_content):
        """Run AIDE check with empty database (all files shown as 'added')"""
        config_path = os.path.join(self.test_dir, "aide_nodb.conf")
        with open(config_path, "w") as f:
            f.write(config_content)

        result = subprocess.run(
            ["aide", "--config", config_path, "--check"],
            capture_output=True,
            timeout=60,
            env={**os.environ, "TERM": "dumb"}  # Disable terminal processing
        )
        # Combine stdout and stderr, handling potential bytes
        stdout = result.stdout if isinstance(result.stdout, str) else result.stdout.decode('utf-8', errors='replace')
        stderr = result.stderr if isinstance(result.stderr, str) else result.stderr.decode('utf-8', errors='replace')
        return stdout + stderr

    def _has_raw_escape_sequence(self, output, seq):
        """Check if raw escape sequence is present (not escaped)"""
        # Raw escape starts with 0x1b (ESC character)
        return seq in output

    def _has_escaped_sequence(self, output, octal_pattern):
        """Check if escape sequence is properly escaped as octal"""
        # Escaped version should show \\033 (literal backslash and digits)
        return octal_pattern in output

    def test_cursor_up_escape_sequence(self):
        """Test that \\033[1A (cursor up) is escaped, not interpreted"""
        # Create file with cursor-up escape sequence
        # \x1b is ESC (0x1b), [1A is the cursor up command
        malicious_name = f"cursor-up-test\x1b[1A"
        malicious_file = os.path.join(self.monitored_dir, malicious_name)

        # Also create a regular file
        regular_file = os.path.join(self.monitored_dir, "regular_file.txt")

        try:
            with open(malicious_file, "w") as f:
                f.write("malicious")
            with open(regular_file, "w") as f:
                f.write("regular")
        except OSError as e:
            pytest.skip(f"Cannot create file with escape sequence: {e}")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        # After fix: escape sequence should appear as \033 (octal)
        # The ESC character (0x1b = 033 octal) should be escaped
        assert "\\033" in output or "\\033" in repr(output), \
            f"Escape sequence \\033[1A should be escaped as \\033 in output. " \
            f"Raw output contains ESC: {chr(0x1b) in output}. Output: {repr(output)[:500]}"

    def test_cursor_down_escape_sequence(self):
        """Test that \\033[1B (cursor down) is escaped"""
        malicious_name = f"cursor-down-test\x1b[1B"
        malicious_file = os.path.join(self.monitored_dir, malicious_name)

        try:
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError as e:
            pytest.skip(f"Cannot create file with escape sequence: {e}")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        assert "\\033" in output or "\\033" in repr(output), \
            f"Escape sequence should be escaped. Output: {repr(output)[:500]}"

    def test_clear_line_escape_sequence(self):
        """Test that \\033[2K (clear entire line) is escaped"""
        malicious_name = f"clear-line-test\x1b[2K"
        malicious_file = os.path.join(self.monitored_dir, malicious_name)

        try:
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError as e:
            pytest.skip(f"Cannot create file with escape sequence: {e}")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        assert "\\033" in output or "\\033" in repr(output), \
            f"Clear line escape should be escaped. Output: {repr(output)[:500]}"

    def test_home_cursor_escape_sequence(self):
        """Test that \\033[H (cursor home) is escaped"""
        malicious_name = f"home-cursor-test\x1b[H"
        malicious_file = os.path.join(self.monitored_dir, malicious_name)

        try:
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError as e:
            pytest.skip(f"Cannot create file with escape sequence: {e}")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        assert "\\033" in output or "\\033" in repr(output), \
            f"Cursor home escape should be escaped. Output: {repr(output)[:500]}"

    def test_clear_screen_escape_sequence(self):
        """Test that \\033[2J (clear screen) is escaped"""
        malicious_name = f"clear-screen-test\x1b[2J"
        malicious_file = os.path.join(self.monitored_dir, malicious_name)

        try:
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError as e:
            pytest.skip(f"Cannot create file with escape sequence: {e}")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        assert "\\033" in output or "\\033" in repr(output), \
            f"Clear screen escape should be escaped. Output: {repr(output)[:500]}"


class TestEntryCountConsistency:
    """Test that entry counts match visible entries (no hidden entries)"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        self.test_dir = tempfile.mkdtemp(prefix="aide_count_")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        os.makedirs(self.monitored_dir)
        yield
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def _run_aide_check_no_db(self, config_content):
        config_path = os.path.join(self.test_dir, "aide.conf")
        with open(config_path, "w") as f:
            f.write(config_content)

        result = subprocess.run(
            ["aide", "--config", config_path, "--check"],
            capture_output=True,
            timeout=60,
            env={**os.environ, "TERM": "dumb"}
        )
        stdout = result.stdout if isinstance(result.stdout, str) else result.stdout.decode('utf-8', errors='replace')
        stderr = result.stderr if isinstance(result.stderr, str) else result.stderr.decode('utf-8', errors='replace')
        return stdout + stderr

    def test_multiple_escape_files_all_visible(self):
        """Test multiple files with different escape sequences are all visible"""
        escape_sequences = [
            ("\x1b[1A", "up"),
            ("\x1b[1B", "down"),
            ("\x1b[2K", "clear"),
        ]

        created_count = 0
        for seq, name in escape_sequences:
            try:
                filename = f"file-{name}{seq}"
                filepath = os.path.join(self.monitored_dir, filename)
                with open(filepath, "w") as f:
                    f.write(f"content-{name}")
                created_count += 1
            except OSError:
                continue

        if created_count == 0:
            pytest.skip("Could not create any files with escape sequences")

        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
/ R
"""
        output = self._run_aide_check_no_db(config)

        # All escape sequences should be escaped to \033
        escape_count = output.count("\\033")

        assert escape_count >= created_count, \
            f"Expected at least {created_count} escaped sequences, found {escape_count}. " \
            f"Output: {repr(output)[:1000]}"


class TestJSONReportEscaping:
    """Test that JSON report format properly escapes control characters"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        self.test_dir = tempfile.mkdtemp(prefix="aide_json_")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        self.report_file = os.path.join(self.test_dir, "report.json")
        os.makedirs(self.monitored_dir)
        yield
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_json_escapes_control_characters(self):
        """Test that JSON output escapes control characters properly"""
        # Create file with escape sequence
        try:
            malicious_name = f"json-test\x1b"
            malicious_file = os.path.join(self.monitored_dir, malicious_name)
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError:
            pytest.skip("Cannot create file with escape sequence")

        # Create config with JSON report
        # Note: report_format must come BEFORE report_url for the format to apply
        config_path = os.path.join(self.test_dir, "aide.conf")
        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
report_format=json
report_url=file:{self.report_file}
/ R
"""
        with open(config_path, "w") as f:
            f.write(config)

        subprocess.run(
            ["aide", "--config", config_path, "--check"],
            capture_output=True,
            timeout=60
        )

        # Check the JSON report file if it was created
        if os.path.exists(self.report_file):
            with open(self.report_file, "r") as f:
                json_content = f.read()

            # In fixed version, ESC should be escaped as \u001b in JSON
            # Raw ESC byte should not appear
            assert "\x1b" not in json_content, \
                f"Raw ESC character should not appear in JSON output"

            # Could also check for proper \u001b escaping
            if "json-test" in json_content:
                assert "\\u001b" in json_content.lower() or "\\u001B" in json_content, \
                    f"ESC should be escaped as \\u001b in JSON. Content: {json_content[:500]}"


class TestLogOutputEscaping:
    """Test that log output properly escapes control characters"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        self.test_dir = tempfile.mkdtemp(prefix="aide_log_")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        os.makedirs(self.monitored_dir)
        yield
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_verbose_log_escapes_filenames(self):
        """Test that verbose logging escapes control characters in filenames"""
        # Create file with escape sequence
        try:
            malicious_name = f"log-test\x1b[1A"
            malicious_file = os.path.join(self.monitored_dir, malicious_name)
            with open(malicious_file, "w") as f:
                f.write("test")
        except OSError:
            pytest.skip("Cannot create file with escape sequence")

        config_path = os.path.join(self.test_dir, "aide.conf")
        config = f"""
database_in=file:/dev/null
root_prefix={self.monitored_dir}
log_level=debug
/ R
"""
        with open(config_path, "w") as f:
            f.write(config)

        result = subprocess.run(
            ["aide", "--config", config_path, "--check"],
            capture_output=True,
            timeout=60,
            env={**os.environ, "TERM": "dumb"}
        )

        stderr = result.stderr if isinstance(result.stderr, str) else result.stderr.decode('utf-8', errors='replace')

        # If verbose output includes filenames, they should be escaped
        if "log-test" in stderr:
            assert "\\033" in stderr or "\x1b" not in stderr, \
                f"Log output should escape control characters. stderr: {repr(stderr)[:500]}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
