"""
Vulnerability tests for SQL Injection in stock management.
Tests the pid parameter in stockin and stockout functionality.

These tests should:
- FAIL when the vulnerability exists (injectable)
- PASS when the vulnerability is fixed (not injectable)
"""

import pytest
import requests
import time


BASE_URL = "http://localhost:80"
ADMIN_URL = f"{BASE_URL}/admin"
LOGIN_URL = f"{ADMIN_URL}/index.php"
STOCK_URL = f"{ADMIN_URL}/admin_running.php"

# Known valid product ID from the database
VALID_PRODUCT_ID = "68129"

# Time threshold for detecting SQL injection via SLEEP
# If vulnerable, SLEEP(2) should cause ~2 second delay
# If fixed, request should complete in < 1 second
TIME_THRESHOLD = 1.5
SLEEP_DURATION = 2


class TestSession:
    """Helper class to manage admin session"""
    _session = None

    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            cls._login()
        return cls._session

    @classmethod
    def _login(cls):
        """Login to admin panel"""
        login_data = {
            'username': 'admin',
            'password': 'admin',
            'login': ''
        }
        cls._session.post(LOGIN_URL, data=login_data, allow_redirects=True)


@pytest.fixture(scope="module")
def admin_session():
    """Fixture that provides an authenticated admin session"""
    return TestSession.get_session()


class TestSQLInjectionStockIn:
    """Test SQL injection vulnerability in stock-in functionality using time-based detection"""

    def test_time_based_sqli_stockin_basic(self, admin_session):
        """
        Test time-based SQL injection in stockin via pid parameter.
        If vulnerable, the SLEEP will cause a delay.
        After fix, should complete quickly without executing the SLEEP.
        """
        # Payload that causes delay if SQL injection works
        payload = f"{VALID_PRODUCT_ID}' AND SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        # If vulnerable, response will take >= SLEEP_DURATION seconds
        # If fixed, response will be quick
        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection detected! Request took {elapsed:.2f}s. "
            f"The pid parameter is vulnerable to SQL injection."
        )

    def test_time_based_sqli_stockin_or_condition(self, admin_session):
        """
        Test time-based SQL injection using OR condition.
        The OR 1=1 ensures the condition is true, then SLEEP executes.
        """
        payload = f"' OR 1=1 AND SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection (OR condition) detected! Request took {elapsed:.2f}s."
        )

    def test_time_based_sqli_stockin_if_condition(self, admin_session):
        """
        Test time-based SQL injection using IF condition.
        IF(1=1, SLEEP(N), 0) will execute SLEEP if injectable.
        """
        payload = f"{VALID_PRODUCT_ID}' AND IF(1=1,SLEEP({SLEEP_DURATION}),0)-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection (IF condition) detected! Request took {elapsed:.2f}s."
        )


class TestSQLInjectionStockOut:
    """Test SQL injection vulnerability in stock-out functionality using time-based detection"""

    def test_time_based_sqli_stockout_basic(self, admin_session):
        """
        Test time-based SQL injection in stockout via pid parameter.
        """
        payload = f"{VALID_PRODUCT_ID}' AND SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockout': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection detected in stockout! "
            f"Request took {elapsed:.2f}s."
        )

    def test_time_based_sqli_stockout_benchmark(self, admin_session):
        """
        Test time-based SQL injection using BENCHMARK function.
        BENCHMARK executes an expression multiple times, causing delay.
        """
        # BENCHMARK is another way to cause delay in MySQL
        payload = f"{VALID_PRODUCT_ID}' AND BENCHMARK(5000000,SHA1('test'))-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockout': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        # BENCHMARK with 5M iterations should take noticeable time
        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection (BENCHMARK) detected! "
            f"Request took {elapsed:.2f}s."
        )

    def test_time_based_sqli_stockout_subquery(self, admin_session):
        """
        Test time-based SQL injection using subquery with SLEEP.
        """
        payload = f"{VALID_PRODUCT_ID}' AND (SELECT SLEEP({SLEEP_DURATION}))-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockout': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"Time-based SQL injection (subquery) detected! "
            f"Request took {elapsed:.2f}s."
        )


class TestSQLInjectionPayloadVariants:
    """Test various SQL injection payload variations using time-based detection"""

    def test_sqli_comment_style_double_dash(self, admin_session):
        """Test SQL injection with -- comment style"""
        payload = f"{VALID_PRODUCT_ID}' AND SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"SQL injection (-- comment) detected! Time: {elapsed:.2f}s"
        )

    def test_sqli_comment_style_hash(self, admin_session):
        """Test SQL injection with # comment style"""
        payload = f"{VALID_PRODUCT_ID}' AND SLEEP({SLEEP_DURATION})#"
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"SQL injection (# comment) detected! Time: {elapsed:.2f}s"
        )

    def test_sqli_case_variation(self, admin_session):
        """Test SQL injection with case variations"""
        payload = f"{VALID_PRODUCT_ID}' aNd sLeEp({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"SQL injection (case variation) detected! Time: {elapsed:.2f}s"
        )

    def test_sqli_whitespace_variation(self, admin_session):
        """Test SQL injection with inline comments as whitespace"""
        payload = f"{VALID_PRODUCT_ID}'/**/AND/**/SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, (
            f"SQL injection (whitespace bypass) detected! Time: {elapsed:.2f}s"
        )


class TestSQLInjectionConfirmation:
    """Additional confirmation tests to ensure vulnerability detection is reliable"""

    def test_sqli_double_sleep(self, admin_session):
        """
        Test with two SLEEP calls to confirm injection.
        If vulnerable, should take ~4 seconds (2 x SLEEP_DURATION).
        """
        payload = f"{VALID_PRODUCT_ID}' AND SLEEP({SLEEP_DURATION}) AND SLEEP({SLEEP_DURATION})-- "
        data = {
            'pid': payload,
            'new_stck': '1',
            'stockin': ''
        }

        start_time = time.time()
        response = admin_session.post(STOCK_URL, data=data, timeout=30)
        elapsed = time.time() - start_time

        # With two SLEEP(2) calls, vulnerable code takes >= 4 seconds
        assert elapsed < TIME_THRESHOLD, (
            f"SQL injection (double SLEEP) detected! Request took {elapsed:.2f}s."
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
