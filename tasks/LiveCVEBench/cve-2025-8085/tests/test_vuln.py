"""
Vulnerability tests for Ditty WordPress Plugin SSRF.

These tests verify that unauthenticated SSRF is NOT possible.
- FAIL in vulnerable state (SSRF is exploitable)
- PASS in fixed state (SSRF is blocked)
"""

import pytest
import requests
import time
import threading
import socket
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

BASE_URL = "http://localhost"
CALLBACK_PORT = 9999


def wait_for_wordpress(timeout=60):
    """Wait for WordPress to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{BASE_URL}/", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


class SSRFCallbackHandler(BaseHTTPRequestHandler):
    """HTTP handler to capture SSRF callbacks."""

    received_requests = []

    def do_GET(self):
        """Handle GET requests (SSRF callbacks)."""
        SSRFCallbackHandler.received_requests.append({
            "method": "GET",
            "path": self.path,
            "headers": dict(self.headers)
        })
        self.send_response(200)
        self.send_header("Content-Type", "text/plain")
        self.end_headers()
        self.wfile.write(b"OK")

    def do_HEAD(self):
        """Handle HEAD requests."""
        SSRFCallbackHandler.received_requests.append({
            "method": "HEAD",
            "path": self.path,
            "headers": dict(self.headers)
        })
        self.send_response(200)
        self.end_headers()

    def log_message(self, format, *args):
        """Suppress logging."""
        pass


class SSRFCallbackServer:
    """Threaded HTTP server to receive SSRF callbacks."""

    def __init__(self, port=CALLBACK_PORT):
        self.port = port
        self.server = None
        self.thread = None
        SSRFCallbackHandler.received_requests = []

    def start(self):
        """Start the callback server."""
        # Find an available port if default is in use
        for attempt_port in range(self.port, self.port + 10):
            try:
                self.server = HTTPServer(("0.0.0.0", attempt_port), SSRFCallbackHandler)
                self.port = attempt_port
                break
            except OSError:
                continue

        if self.server is None:
            raise RuntimeError("Could not find available port for callback server")

        self.thread = threading.Thread(target=self.server.serve_forever)
        self.thread.daemon = True
        self.thread.start()
        time.sleep(0.5)  # Give server time to start

    def stop(self):
        """Stop the callback server."""
        if self.server:
            self.server.shutdown()
            self.server.server_close()

    def get_requests(self):
        """Get received requests."""
        return SSRFCallbackHandler.received_requests

    def clear_requests(self):
        """Clear received requests."""
        SSRFCallbackHandler.received_requests = []


def send_ssrf_payload(callback_url, probe_path="/ssrf-probe"):
    """Send SSRF payload to displayItems endpoint."""
    payload = {
        "apiData": {
            "layouts": [{
                "id": "ssrf_test",
                "html": f'{{image default_src="{callback_url}{probe_path}"}}',
                "css": ""
            }],
            "items": [{
                "item_id": "1",
                "item_type": "default",
                "item_value": {"content": "test"},
                "layout_value": {"default": "ssrf_test"}
            }]
        }
    }

    response = requests.post(
        f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
        headers={"Content-Type": "application/json"},
        json=payload,
        timeout=30
    )
    return response


class TestSSRFVulnerabilityFixed:
    """Test that SSRF vulnerability is fixed."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        assert wait_for_wordpress(), "WordPress failed to start"
        self.server = SSRFCallbackServer()
        self.server.start()
        yield
        self.server.stop()

    def test_displayitems_rejects_unauthenticated_requests(self):
        """
        Test that displayItems endpoint rejects unauthenticated requests.

        The fix adds nonce verification, so unauthenticated requests should
        receive a 403 response with 'no_nonce' error.
        """
        response = send_ssrf_payload(f"http://127.0.0.1:{self.server.port}")

        # After fix: should return 403 with nonce error
        assert response.status_code == 403, (
            f"Expected 403 Forbidden, got {response.status_code}. "
            "Unauthenticated requests should be rejected with nonce verification."
        )

        data = response.json()
        assert data.get("code") == "no_nonce", (
            f"Expected 'no_nonce' error code, got '{data.get('code')}'. "
            "Fix should add nonce verification."
        )

    def test_no_ssrf_callback_received(self):
        """
        Test that no SSRF callback is received when request is blocked.

        Even if the endpoint responds, ensure no outbound request was made.
        """
        self.server.clear_requests()

        # Send the SSRF payload
        response = send_ssrf_payload(f"http://127.0.0.1:{self.server.port}", "/ssrf-check-1")

        # Give time for any SSRF callback to arrive
        time.sleep(2)

        # Check that no callback was received
        requests_received = self.server.get_requests()
        ssrf_callbacks = [r for r in requests_received if "/ssrf-check-1" in r.get("path", "")]

        assert len(ssrf_callbacks) == 0, (
            f"SSRF vulnerability detected! Received {len(ssrf_callbacks)} callback(s). "
            "Server should not make outbound requests for unauthenticated users."
        )

    def test_phpitemmods_rejects_unauthenticated(self):
        """Test phpItemMods endpoint rejects unauthenticated requests."""
        payload = {
            "apiData": {
                "item": {"test": "data"},
                "hook": "test"
            }
        }

        response = requests.post(
            f"{BASE_URL}/wp-json/dittyeditor/v1/phpItemMods",
            headers={"Content-Type": "application/json"},
            json=payload,
            timeout=10
        )

        # After fix: should return 403 with nonce error
        assert response.status_code == 403, (
            f"Expected 403 Forbidden for phpItemMods, got {response.status_code}"
        )

        data = response.json()
        assert data.get("code") == "no_nonce", (
            f"Expected 'no_nonce' error for phpItemMods, got '{data.get('code')}'"
        )

    def test_dynamiclayouttags_rejects_unauthenticated(self):
        """Test dynamicLayoutTags endpoint rejects unauthenticated requests."""
        payload = {
            "apiData": {
                "itemType": "default",
                "itemValue": {"content": "test"}
            }
        }

        response = requests.post(
            f"{BASE_URL}/wp-json/dittyeditor/v1/dynamicLayoutTags",
            headers={"Content-Type": "application/json"},
            json=payload,
            timeout=10
        )

        # After fix: should return 403 with nonce error
        assert response.status_code == 403, (
            f"Expected 403 Forbidden for dynamicLayoutTags, got {response.status_code}"
        )

        data = response.json()
        assert data.get("code") == "no_nonce", (
            f"Expected 'no_nonce' error for dynamicLayoutTags, got '{data.get('code')}'"
        )


class TestMultipleSSRFVectors:
    """Test multiple SSRF attack vectors are blocked."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        assert wait_for_wordpress(), "WordPress failed to start"
        self.server = SSRFCallbackServer()
        self.server.start()
        yield
        self.server.stop()

    def test_ssrf_to_localhost_blocked(self):
        """Test SSRF to localhost is blocked."""
        self.server.clear_requests()

        response = send_ssrf_payload(f"http://localhost:{self.server.port}", "/localhost-probe")
        time.sleep(2)

        requests_received = self.server.get_requests()
        probes = [r for r in requests_received if "/localhost-probe" in r.get("path", "")]

        assert response.status_code == 403, "Should reject unauthenticated request"
        assert len(probes) == 0, "SSRF to localhost should be blocked"

    def test_ssrf_to_127001_blocked(self):
        """Test SSRF to 127.0.0.1 is blocked."""
        self.server.clear_requests()

        response = send_ssrf_payload(f"http://127.0.0.1:{self.server.port}", "/127-probe")
        time.sleep(2)

        requests_received = self.server.get_requests()
        probes = [r for r in requests_received if "/127-probe" in r.get("path", "")]

        assert response.status_code == 403, "Should reject unauthenticated request"
        assert len(probes) == 0, "SSRF to 127.0.0.1 should be blocked"

    def test_ssrf_with_different_layout_ids(self):
        """Test SSRF with various layout IDs."""
        self.server.clear_requests()

        for layout_id in ["test1", "ssrf", "layout_123", "x"]:
            payload = {
                "apiData": {
                    "layouts": [{
                        "id": layout_id,
                        "html": f'{{image default_src="http://127.0.0.1:{self.server.port}/layout-{layout_id}"}}',
                        "css": ""
                    }],
                    "items": [{
                        "item_id": "1",
                        "item_type": "default",
                        "item_value": {"content": "test"},
                        "layout_value": {"default": layout_id}
                    }]
                }
            }

            response = requests.post(
                f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
                headers={"Content-Type": "application/json"},
                json=payload,
                timeout=10
            )

            assert response.status_code == 403, f"Should reject request with layout_id={layout_id}"

        time.sleep(2)
        requests_received = self.server.get_requests()
        assert len(requests_received) == 0, "No SSRF callbacks should be received"

    def test_ssrf_cloud_metadata_blocked(self):
        """Test that cloud metadata URLs cannot be accessed."""
        # This tests the authentication check - even cloud metadata URLs should be blocked
        # because the request is unauthenticated

        cloud_urls = [
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://169.254.169.254/metadata/instance",
        ]

        for url in cloud_urls:
            payload = {
                "apiData": {
                    "layouts": [{
                        "id": "cloud_test",
                        "html": f'{{image default_src="{url}"}}',
                        "css": ""
                    }],
                    "items": [{
                        "item_id": "1",
                        "item_type": "default",
                        "item_value": {"content": "test"},
                        "layout_value": {"default": "cloud_test"}
                    }]
                }
            }

            response = requests.post(
                f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
                headers={"Content-Type": "application/json"},
                json=payload,
                timeout=10
            )

            assert response.status_code == 403, (
                f"Cloud metadata URL request should be blocked: {url}"
            )

    def test_ssrf_internal_port_scanning_blocked(self):
        """Test that internal port scanning is blocked."""
        internal_targets = [
            "http://127.0.0.1:22/",     # SSH
            "http://127.0.0.1:3306/",   # MySQL
            "http://127.0.0.1:6379/",   # Redis
            "http://127.0.0.1:27017/",  # MongoDB
        ]

        for url in internal_targets:
            payload = {
                "apiData": {
                    "layouts": [{
                        "id": "port_scan",
                        "html": f'{{image default_src="{url}"}}',
                        "css": ""
                    }],
                    "items": [{
                        "item_id": "1",
                        "item_type": "default",
                        "item_value": {"content": "test"},
                        "layout_value": {"default": "port_scan"}
                    }]
                }
            }

            response = requests.post(
                f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
                headers={"Content-Type": "application/json"},
                json=payload,
                timeout=10
            )

            assert response.status_code == 403, (
                f"Port scanning should be blocked: {url}"
            )


class TestNonceValidation:
    """Test nonce validation behavior."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        assert wait_for_wordpress(), "WordPress failed to start"

    def test_invalid_nonce_rejected(self):
        """
        Test that the fix properly validates nonces via custom check.

        Note: WordPress core always validates X-WP-Nonce header at API level.
        This test specifically verifies the PLUGIN's nonce verification works
        by checking that the plugin adds its own nonce check (returns no_nonce code).

        In vulnerable state: Plugin returns 200 (no nonce check in plugin code)
        In fixed state: Plugin returns 403 with 'no_nonce' code

        We test without any nonce header to trigger the plugin's custom nonce check.
        """
        payload = {
            "apiData": {
                "layouts": [{"id": "test", "html": "{content}", "css": ""}],
                "items": [{"item_id": "1", "item_type": "default", "item_value": {"content": "test"}, "layout_value": {"default": "test"}}]
            }
        }

        response = requests.post(
            f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
            headers={"Content-Type": "application/json"},
            json=payload,
            timeout=10
        )

        # In fixed state: should return 403 with 'no_nonce' error from plugin
        # In vulnerable state: should return 200 (or 404 if no items) - NOT 403 with no_nonce
        assert response.status_code == 403, (
            f"Expected 403 Forbidden from plugin nonce check, got {response.status_code}. "
            "Vulnerable plugin does not verify nonces."
        )
        data = response.json()
        # Must be 'no_nonce' from the plugin's custom check, not WordPress core error
        assert data.get("code") == "no_nonce", \
            f"Should return 'no_nonce' error from plugin fix, got '{data.get('code')}'"

    def test_missing_nonce_rejected(self):
        """Test that missing nonces are rejected."""
        payload = {
            "apiData": {
                "layouts": [{"id": "test", "html": "{content}", "css": ""}],
                "items": [{"item_id": "1", "item_type": "default", "item_value": {"content": "test"}, "layout_value": {"default": "test"}}]
            }
        }

        response = requests.post(
            f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
            headers={"Content-Type": "application/json"},
            json=payload,
            timeout=10
        )

        # Missing nonce should be rejected
        assert response.status_code == 403, "Missing nonce should be rejected"

    def test_empty_nonce_not_bypassed(self):
        """Test that sending empty nonce doesn't bypass authentication to allow SSRF.

        In vulnerable state: This test should FAIL because when no authentication
        is needed (the plugin's permission check returns true), sending an empty
        nonce shouldn't matter - the request should still succeed, but that means
        the vulnerability exists.

        In fixed state: This test should PASS because the fixed version requires
        proper nonce validation.

        NOTE: WordPress REST API rejects explicitly empty nonces at the core level,
        so this test actually passes in both states. The real vulnerability test
        is test_missing_nonce_rejected which tests requests without any nonce header.
        """
        payload = {
            "apiData": {
                "layouts": [{"id": "test", "html": "{content}", "css": ""}],
                "items": [{"item_id": "1", "item_type": "default", "item_value": {"content": "test"}, "layout_value": {"default": "test"}}]
            }
        }

        # Test with NO nonce header at all - this is the actual vulnerability test
        response = requests.post(
            f"{BASE_URL}/wp-json/dittyeditor/v1/displayItems",
            headers={"Content-Type": "application/json"},
            json=payload,
            timeout=10
        )

        # In fixed state, missing nonce should be rejected
        # In vulnerable state, this should return 200 (allowing the exploit)
        assert response.status_code == 403, "Missing nonce should be rejected in fixed state"


class TestAllVulnerableEndpoints:
    """Test all endpoints that use general_ditty_permissions_check."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        assert wait_for_wordpress(), "WordPress failed to start"
        self.server = SSRFCallbackServer()
        self.server.start()
        yield
        self.server.stop()

    def test_all_general_permission_endpoints_protected(self):
        """Test all endpoints using general_ditty_permissions_check are now protected."""
        endpoints = [
            ("displayItems", {"apiData": {"layouts": [{"id": "t", "html": "", "css": ""}], "items": [{"item_id": "1", "item_type": "default", "item_value": {}, "layout_value": {"default": "t"}}]}}),
            ("phpItemMods", {"apiData": {"item": {}, "hook": "test"}}),
            ("dynamicLayoutTags", {"apiData": {"itemType": "default", "itemValue": {}}}),
        ]

        for endpoint, payload in endpoints:
            response = requests.post(
                f"{BASE_URL}/wp-json/dittyeditor/v1/{endpoint}",
                headers={"Content-Type": "application/json"},
                json=payload,
                timeout=10
            )

            assert response.status_code == 403, (
                f"Endpoint {endpoint} should reject unauthenticated requests, "
                f"got status {response.status_code}"
            )

            data = response.json()
            assert data.get("code") == "no_nonce", (
                f"Endpoint {endpoint} should return no_nonce error, "
                f"got {data.get('code')}"
            )
