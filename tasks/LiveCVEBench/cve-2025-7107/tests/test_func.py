"""
Functionality tests for file parse API.

These tests verify that the file parsing API works correctly for legitimate use cases.
They should PASS in both vulnerable and fixed states.
"""

import requests
import pytest

BASE_URL = "http://localhost:3000"
TIMEOUT = 30


class TestAPIBasicFunctionality:
    """Test basic API functionality that should work in all states."""

    def test_api_endpoint_responds(self):
        """Test that the API endpoint is responding."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "test.txt"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        # Should get a valid JSON response (even if file not found)
        assert response.status_code in [200, 400, 404, 500], \
            f"Unexpected status code: {response.status_code}"
        data = response.json()
        assert isinstance(data, dict), "Response should be a JSON object"

    def test_missing_filepath_returns_error(self):
        """Test that missing filePath parameter returns appropriate error."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Should return an error about missing file path
        assert "error" in data or data.get("success") == False, \
            "Missing filePath should return error"

    def test_empty_filepath_returns_error(self):
        """Test that empty filePath returns appropriate error."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": ""},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Should return an error
        assert "error" in data or data.get("success") == False, \
            "Empty filePath should return error"

    def test_nonexistent_file_returns_error(self):
        """Test that requesting a non-existent file returns appropriate error."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/nonexistent_file_12345.txt"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Should return file not found error
        assert data.get("success") == False, \
            "Non-existent file should return success=false"
        assert "not found" in data.get("error", "").lower() or \
               "inaccessible" in data.get("error", "").lower() or \
               "access denied" in data.get("error", "").lower(), \
            f"Expected file not found or access error, got: {data.get('error')}"

    def test_response_format_structure(self):
        """Test that response has expected structure."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/test.txt"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Response should have either 'success' field or 'error' field
        assert "success" in data or "error" in data, \
            "Response should contain 'success' or 'error' field"

    def test_json_content_type_required(self):
        """Test that JSON content type is handled properly."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "test.txt"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        # Should be able to parse response as JSON
        try:
            data = response.json()
            assert isinstance(data, dict)
        except Exception as e:
            pytest.fail(f"Response should be valid JSON: {e}")


class TestArrayFilePathHandling:
    """Test array file path handling functionality."""

    def test_single_file_in_array(self):
        """Test single file path in array format."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": ["/api/files/serve/test.txt"]},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Should return results array format
        assert isinstance(data, dict), "Response should be a dictionary"
        # May have 'results' key for array input
        if "results" in data:
            assert isinstance(data["results"], list), "Results should be a list"

    def test_multiple_files_in_array(self):
        """Test multiple file paths in array format."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": [
                "/api/files/serve/file1.txt",
                "/api/files/serve/file2.txt"
            ]},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"


class TestLegitimateFilePaths:
    """Test legitimate file path handling."""

    def test_simple_filename(self):
        """Test simple filename without path traversal."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/document.pdf"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        # Should handle gracefully (file not found is OK, but no crash)
        assert isinstance(data, dict), "Response should be a dictionary"

    def test_filename_with_subdirectory(self):
        """Test filename with subdirectory (legitimate)."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/uploads/document.pdf"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"

    def test_filename_with_special_characters(self):
        """Test filename with special characters."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/my-file_v2.0.txt"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"

    def test_filename_with_spaces(self):
        """Test filename with spaces."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={"filePath": "/api/files/serve/my document.pdf"},
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"


class TestExternalURLHandling:
    """Test external URL handling (if applicable)."""

    def test_http_url_format(self):
        """Test that HTTP URLs are recognized differently from local paths."""
        # Note: This tests the routing logic, not actual HTTP fetch
        # The external fetch may fail without proxy, but API should still respond
        try:
            response = requests.post(
                f"{BASE_URL}/api/files/parse",
                json={"filePath": "http://example.com/test.txt"},
                headers={"Content-Type": "application/json"},
                timeout=60  # Longer timeout for external URL handling
            )
            data = response.json()
            # Should be handled (may fail to fetch but shouldn't crash)
            assert isinstance(data, dict), "Response should be a dictionary"
        except requests.exceptions.Timeout:
            # External URL fetch may timeout without proxy - this is acceptable
            pytest.skip("External URL fetch timed out (no proxy configured)")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"External URL test skipped due to network issue: {e}")

    def test_https_url_format(self):
        """Test that HTTPS URLs are recognized differently from local paths."""
        # The external fetch may fail without proxy, but API should still respond
        try:
            response = requests.post(
                f"{BASE_URL}/api/files/parse",
                json={"filePath": "https://example.com/test.pdf"},
                headers={"Content-Type": "application/json"},
                timeout=60  # Longer timeout for external URL handling
            )
            data = response.json()
            assert isinstance(data, dict), "Response should be a dictionary"
        except requests.exceptions.Timeout:
            # External URL fetch may timeout without proxy - this is acceptable
            pytest.skip("External URL fetch timed out (no proxy configured)")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"External URL test skipped due to network issue: {e}")


class TestFileTypeParameter:
    """Test fileType parameter handling."""

    def test_with_filetype_parameter(self):
        """Test request with fileType parameter."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={
                "filePath": "/api/files/serve/document.pdf",
                "fileType": "application/pdf"
            },
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"

    def test_with_text_filetype(self):
        """Test request with text fileType."""
        response = requests.post(
            f"{BASE_URL}/api/files/parse",
            json={
                "filePath": "/api/files/serve/data.csv",
                "fileType": "text/csv"
            },
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )
        data = response.json()
        assert isinstance(data, dict), "Response should be a dictionary"
