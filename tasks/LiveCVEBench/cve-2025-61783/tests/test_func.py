"""Functional tests for social-auth-app-django user creation.

These tests verify that the user creation and authentication functionality
works correctly in both vulnerable and fixed states.
"""
import os
import sys

# Ensure Django settings are configured
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')

import django
django.setup()

import pytest
from django.contrib.auth import get_user_model
from social_django.models import UserSocialAuth


class TestNormalUserCreation:
    """Test that normal user creation works correctly."""

    @pytest.fixture(autouse=True)
    def setup_db(self, django_db_setup, db):
        """Setup database for each test."""
        pass

    @pytest.mark.django_db
    def test_create_new_user_with_unique_email(self):
        """Creating a user with a unique email should succeed."""
        user = UserSocialAuth.create_user(
            username="testuser1",
            email="unique1@example.com"
        )
        assert user is not None
        assert user.email == "unique1@example.com"
        assert user.username == "testuser1"

    @pytest.mark.django_db
    def test_create_new_user_with_unique_username(self):
        """Creating a user with a unique username should succeed."""
        user = UserSocialAuth.create_user(
            username="anotheruser",
            email="another@example.com"
        )
        assert user is not None
        assert user.username == "anotheruser"

    @pytest.mark.django_db
    def test_create_multiple_users_different_emails(self):
        """Should be able to create multiple users with different emails."""
        user1 = UserSocialAuth.create_user(
            username="user1",
            email="user1@example.com"
        )
        user2 = UserSocialAuth.create_user(
            username="user2",
            email="user2@example.com"
        )

        assert user1.id != user2.id
        assert user1.email != user2.email
        assert user1.username != user2.username

    @pytest.mark.django_db
    def test_created_user_is_saved_to_database(self):
        """Created user should be persisted in the database."""
        user = UserSocialAuth.create_user(
            username="saveduser",
            email="saved@example.com"
        )

        User = get_user_model()
        retrieved = User.objects.get(email="saved@example.com")
        assert retrieved.id == user.id

    @pytest.mark.django_db
    def test_create_user_returns_user_instance(self):
        """create_user should return a proper User model instance."""
        User = get_user_model()
        user = UserSocialAuth.create_user(
            username="instancetest",
            email="instance@example.com"
        )
        assert isinstance(user, User)


class TestUserModelAccess:
    """Test that the UserSocialAuth model properly accesses user model."""

    @pytest.fixture(autouse=True)
    def setup_db(self, django_db_setup, db):
        """Setup database for each test."""
        pass

    @pytest.mark.django_db
    def test_user_model_returns_correct_model(self):
        """user_model() should return the configured user model."""
        User = get_user_model()
        assert UserSocialAuth.user_model() == User

    @pytest.mark.django_db
    def test_username_field_detection(self):
        """username_field() should detect the correct username field."""
        # Default Django uses 'username' as the USERNAME_FIELD
        field = UserSocialAuth.username_field()
        assert field == 'username'


class TestUserExists:
    """Test the user_exists functionality."""

    @pytest.fixture(autouse=True)
    def setup_db(self, django_db_setup, db):
        """Setup database for each test."""
        pass

    @pytest.mark.django_db
    def test_user_exists_returns_true_for_existing_user(self):
        """user_exists should return True when user exists."""
        User = get_user_model()
        User.objects.create_user(username="existing", email="exists@example.com")

        assert UserSocialAuth.user_exists(username="existing") is True

    @pytest.mark.django_db
    def test_user_exists_returns_false_for_nonexistent_user(self):
        """user_exists should return False when user doesn't exist."""
        assert UserSocialAuth.user_exists(username="nonexistent") is False


class TestGetUser:
    """Test the get_user functionality."""

    @pytest.fixture(autouse=True)
    def setup_db(self, django_db_setup, db):
        """Setup database for each test."""
        pass

    @pytest.mark.django_db
    def test_get_user_by_pk(self):
        """get_user should retrieve user by primary key."""
        User = get_user_model()
        created = User.objects.create_user(username="pktest", email="pk@example.com")

        retrieved = UserSocialAuth.get_user(pk=created.pk)
        assert retrieved.id == created.id

    @pytest.mark.django_db
    def test_get_user_returns_none_for_nonexistent(self):
        """get_user should return None for nonexistent user."""
        result = UserSocialAuth.get_user(pk=99999)
        assert result is None


class TestImportsAndExceptions:
    """Test that required imports and exceptions are available."""

    @pytest.mark.django_db
    def test_auth_already_associated_is_importable(self):
        """Verify AuthAlreadyAssociated can be imported from social_core."""
        from social_core.exceptions import AuthAlreadyAssociated
        assert AuthAlreadyAssociated is not None
