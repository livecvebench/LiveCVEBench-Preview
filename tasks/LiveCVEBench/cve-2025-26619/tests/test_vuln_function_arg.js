/**
 * Test helper for vulnerability tests.
 * Tests that scale properly rejects function arguments.
 *
 * In VULNERABLE version: scale returns function(value) - the function is called (tests FAIL)
 * In FIXED version: scale returns undefined - the function is not called (tests PASS)
 *
 * Each test checks that when a function is passed as the first argument to scale(),
 * the result should be undefined (not the result of calling the function).
 */

// Import the scale function from the built package
const { scale } = require('/app/packages/vega-functions/build/vega-functions.js');

// Mock context with no scales registered
const mockContext = {
    scales: {}
};

// Create a mock 'this' context
const mockThis = {
    context: mockContext
};

const testCase = process.argv[2];

// Test helper: check if function was NOT called (result should be undefined)
// In vulnerable version, scale(func, arg) calls func(arg) and returns the result
// In fixed version, scale(func, arg) returns undefined
function checkNotCalled(testFunc, description) {
    let wasCalled = false;
    let receivedArg = null;

    const trackedFunc = (arg) => {
        wasCalled = true;
        receivedArg = arg;
        return 'function was called!';
    };

    const result = scale.call(mockThis, trackedFunc, 'test_value');

    if (!wasCalled && result === undefined) {
        console.log(`PASS: undefined for ${description}`);
        return true;
    } else if (wasCalled) {
        console.log(`FAIL: expected undefined for ${description}, got ${typeof result} (function returned directly)`);
        return false;
    } else {
        console.log(`FAIL: expected undefined for ${description}, got ${result}`);
        return false;
    }
}

switch (testCase) {
    case 'anonymous_function':
        // Test anonymous function
        checkNotCalled(function() { return 'anonymous'; }, 'function');
        break;

    case 'arrow_function':
        // Test arrow function
        checkNotCalled(() => 'arrow', 'arrow function');
        break;

    case 'named_function':
        // Test named function
        function namedFunc() { return 'named'; }
        checkNotCalled(namedFunc, 'named function');
        break;

    case 'builtin_function':
        // Test built-in function (like setTimeout)
        // This is the actual attack vector
        // Note: We can't easily track if setTimeout was called, but we can check if it throws
        let builtinWasCalled = false;
        const mockSetTimeout = (arg) => {
            builtinWasCalled = true;
            return 'called!';
        };
        const builtinResult = scale.call(mockThis, mockSetTimeout, 'test');
        if (!builtinWasCalled && builtinResult === undefined) {
            console.log('PASS: undefined for builtin function');
        } else {
            console.log('FAIL: expected undefined for builtin function, got ' + typeof builtinResult + ' (function returned directly)');
        }
        break;

    case 'constructor_function':
        // Test constructor function
        function MyConstructor() { this.value = 'constructed'; }
        checkNotCalled(MyConstructor, 'constructor');
        break;

    case 'bound_function':
        // Test bound function
        const boundFunc = (function() { return this.value; }).bind({ value: 'bound' });
        checkNotCalled(boundFunc, 'bound function');
        break;

    case 'async_function':
        // Test async function
        const asyncFunc = async function() { return 'async'; };
        checkNotCalled(asyncFunc, 'async function');
        break;

    case 'generator_function':
        // Test generator function
        function* generatorFunc() { yield 'generated'; }
        checkNotCalled(generatorFunc, 'generator function');
        break;

    case 'class_method':
        // Test class method
        class TestClass {
            method() { return 'method'; }
        }
        const instance = new TestClass();
        checkNotCalled(instance.method, 'class method');
        break;

    default:
        console.log(`Unknown test case: ${testCase}`);
        process.exit(1);
}
