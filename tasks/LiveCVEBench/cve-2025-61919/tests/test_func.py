"""
Functional tests for Rack request parsing.
These tests verify that normal Rack functionality works correctly.
They should PASS in both vulnerable and fixed states.
"""

import subprocess
import sys


def run_ruby_test(ruby_code: str) -> tuple[bool, str]:
    """Run a Ruby test script and return (success, output)."""
    result = subprocess.run(
        ["ruby", "-e", ruby_code],
        capture_output=True,
        text=True,
        timeout=30,
        cwd="/app"
    )
    output = result.stdout + result.stderr
    return result.returncode == 0, output


class TestNormalPostParsing:
    """Test that normal POST form data is parsed correctly."""

    def test_simple_post_params(self):
        """Simple key=value pairs are parsed correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "foo=bar&baz=qux"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "Missing foo" unless params["foo"] == "bar"
raise "Missing baz" unless params["baz"] == "qux"
puts "PASS: Simple POST params parsed correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_url_encoded_values(self):
        """URL-encoded values are decoded correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

# hello%20world = "hello world" (URL encoded)
body = "message=hello%20world&special=%26%3D%3F"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "message decode failed" unless params["message"] == "hello world"
raise "special decode failed" unless params["special"] == "&=?"
puts "PASS: URL-encoded values decoded correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_nested_params(self):
        """Nested parameters (user[name]=value) are parsed correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "user[name]=alice&user[email]=alice@example.com"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "Missing user hash" unless params["user"].is_a?(Hash)
raise "Wrong name" unless params["user"]["name"] == "alice"
raise "Wrong email" unless params["user"]["email"] == "alice@example.com"
puts "PASS: Nested params parsed correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_array_params(self):
        """Array parameters (tags[]=value) are parsed correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "tags[]=ruby&tags[]=web&tags[]=rack"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "tags not array" unless params["tags"].is_a?(Array)
raise "wrong tags" unless params["tags"] == ["ruby", "web", "rack"]
puts "PASS: Array params parsed correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestEmptyAndEdgeCases:
    """Test edge cases in POST parsing."""

    def test_empty_post_body(self):
        """Empty POST body returns empty params hash."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new("")
}

request = Rack::Request.new(env)
params = request.POST

raise "Should be empty hash" unless params == {}
puts "PASS: Empty POST returns empty hash"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_safari_null_byte_cleanup(self):
        """Safari's trailing null byte is cleaned up."""
        # Use escape sequence that Ruby will interpret
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

# Safari sometimes appends \\0 to POST bodies
# Using double quotes so Ruby interprets the escape
body = "foo=bar\\0"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "foo not parsed" unless params["foo"] == "bar"
puts "PASS: Safari null byte handled correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_input_rewound_after_parsing(self):
        """rack.input is rewound after POST parsing."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "foo=bar"
input = StringIO.new(body)
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => input
}

request = Rack::Request.new(env)
params = request.POST

# After parsing, input should be rewound to start
raise "Input not rewound" unless input.pos == 0
puts "PASS: Input rewound after parsing"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestContentTypeHandling:
    """Test that Content-Type is properly respected."""

    def test_no_content_type_post(self):
        """POST without Content-Type is treated as form data."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "foo=bar"
env = {
  "REQUEST_METHOD" => "POST",
  # No CONTENT_TYPE
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "foo not parsed" unless params["foo"] == "bar"
puts "PASS: POST without Content-Type parsed as form data"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_json_content_type_not_parsed_as_form(self):
        """JSON Content-Type is not parsed as form data."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

body = "foo=bar"
env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/json",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

# JSON content type should not be parsed as form data
raise "Should be empty" unless params == {}
puts "PASS: JSON Content-Type not parsed as form data"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestGetParams:
    """Test GET (query string) parameter parsing."""

    def test_query_string_parsing(self):
        """Query string parameters are parsed correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

env = {
  "REQUEST_METHOD" => "GET",
  "QUERY_STRING" => "page=1&limit=10",
  "rack.input" => StringIO.new("")
}

request = Rack::Request.new(env)
params = request.GET

raise "Missing page" unless params["page"] == "1"
raise "Missing limit" unless params["limit"] == "10"
puts "PASS: Query string parsed correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_params_merges_get_and_post(self):
        """params merges GET and POST parameters."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

env = {
  "REQUEST_METHOD" => "POST",
  "QUERY_STRING" => "from_query=yes",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new("from_body=yes")
}

request = Rack::Request.new(env)
params = request.params

raise "Missing from_query" unless params["from_query"] == "yes"
raise "Missing from_body" unless params["from_body"] == "yes"
puts "PASS: GET and POST params merged correctly"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestValidSizeParsing:
    """Test that data within size limits is parsed correctly."""

    def test_data_within_limit_parsed(self):
        """Data within the 4MB limit is parsed successfully."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

# Create body under the 4MB limit (use 100KB for faster test)
data = "x" * 100_000
body = "data=#{data}"

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(body)
}

request = Rack::Request.new(env)
params = request.POST

raise "Data not parsed" unless params["data"] == data
puts "PASS: Data within limit parsed successfully"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_multiple_params_within_limit(self):
        """Multiple parameters totaling under the limit work correctly."""
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

# Create multiple params, totaling under 4MB
params_str = (1..100).map { |i| "param#{i}=#{'x' * 1000}" }.join("&")

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(params_str)
}

request = Rack::Request.new(env)
params = request.POST

raise "Wrong param count" unless params.size == 100
raise "Wrong value" unless params["param1"] == ("x" * 1000)
puts "PASS: Multiple params within limit parsed"
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output
