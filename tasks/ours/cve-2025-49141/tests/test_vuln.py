"""
Vulnerability tests for HAXcms PHP command injection in gitImportSite.

These tests verify the vulnerability status:
- FAIL when vulnerable (command injection possible)
- PASS when fixed (command injection prevented)

The vulnerability allows OS command injection through the gitImportSite
endpoint when a malicious URL containing shell metacharacters is submitted.
"""

import pytest
import requests
import subprocess
import time
import os
import uuid

# Configuration
BASE_URL = os.environ.get("BASE_URL", "http://localhost:80")
APP_PATH = "/var/www/html"
MARKER_DIR = "/tmp"


def wait_for_server(url, timeout=60):
    """Wait for the server to be available."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            resp = requests.get(url, timeout=5)
            if resp.status_code < 500:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


def clean_marker_file(marker_path):
    """Remove marker file if it exists."""
    try:
        os.remove(marker_path)
    except FileNotFoundError:
        pass


class TestCommandInjectionVulnerability:
    """Test for command injection vulnerability in gitImportSite."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        self.base_url = BASE_URL
        self.unique_id = str(uuid.uuid4())[:8]
        self.marker_file = f"{MARKER_DIR}/vuln_test_{self.unique_id}"
        clean_marker_file(self.marker_file)
        yield
        clean_marker_file(self.marker_file)

    def test_command_injection_prevented(self):
        """
        Test that command injection is prevented in gitImportSite.

        This test sends a malicious URL containing shell metacharacters
        to the gitImportSite endpoint. If vulnerable, the server will
        execute the injected command and create a marker file.

        PASS: Marker file is NOT created (injection prevented or endpoint removed)
        FAIL: Marker file IS created (injection succeeded - vulnerable)
        """
        assert wait_for_server(self.base_url), "Server did not start in time"

        # Clean up any existing marker file
        clean_marker_file(self.marker_file)

        # Craft malicious URL that passes validation but injects commands
        # - Must pass filter_var() FILTER_VALIDATE_URL check
        # - Must contain ".git" to pass strpos() check
        # - Injects touch command to create marker file
       # malicious_url = f"http://example.com/repo.git;touch{chr(36)}{{IFS}}{self.marker_file}#"
        malicious_url = f"http://example.com/repo.git;touch {self.marker_file}"
        payload = {
            "site": {
                "git": {
                    "url": malicious_url
                }
            }
        }

        # Try to exploit the endpoint
        try:
            response = requests.post(
                f"{self.base_url}/system/api?op=gitImportSite",
                json=payload,
                timeout=30
            )
        except requests.exceptions.RequestException as e:
            # Connection error might mean endpoint was removed (which is a fix)
            pass

        # Give the server time to execute the command (if vulnerable)
        time.sleep(2)

        # Check if the marker file was created
        marker_exists = os.path.exists(self.marker_file)

        assert not marker_exists, (
            f"VULNERABLE: Command injection succeeded! "
            f"Marker file '{self.marker_file}' was created. "
            f"The gitImportSite endpoint executed the injected shell command."
        )

    def test_gitimportsite_endpoint_status(self):
        """
        Test that gitImportSite either returns error or is removed.

        After the fix, the endpoint should either:
        1. Be completely removed (404)
        2. Return an error without processing malicious input
        3. Properly sanitize input before use
        """
        assert wait_for_server(self.base_url), "Server did not start in time"

        # Another marker file for this test
        marker_file_2 = f"{MARKER_DIR}/vuln_test2_{self.unique_id}"
        clean_marker_file(marker_file_2)

        # Alternative payload using different shell syntax
        #malicious_url = f"http://x.com/repo.git;echo{chr(36)}{{IFS}}pwned>{marker_file_2}#"
        malicious_url = f"http://x.com/repo.git;touch {marker_file_2}"
        payload = {
            "site": {
                "git": {
                    "url": malicious_url
                }
            }
        }

        try:
            response = requests.post(
                f"{self.base_url}/system/api?op=gitImportSite",
                json=payload,
                timeout=30
            )
        except requests.exceptions.RequestException:
            pass

        time.sleep(2)

        marker_exists = os.path.exists(marker_file_2)
        clean_marker_file(marker_file_2)

        assert not marker_exists, (
            f"VULNERABLE: Alternative command injection succeeded! "
            f"Marker file '{marker_file_2}' was created via echo redirection."
        )

    def test_shell_metacharacters_neutralized(self):
        """
        Test that shell metacharacters in URL are properly neutralized.

        This verifies that various shell metacharacters cannot escape
        the command context when passed to proc_open via the Git library.
        """
        assert wait_for_server(self.base_url), "Server did not start in time"

        # Test with backtick command substitution
        marker_file_3 = f"{MARKER_DIR}/vuln_test3_{self.unique_id}"
        clean_marker_file(marker_file_3)

        # Using backticks for command substitution
        #malicious_url = f"http://a.com/repo.git`touch {marker_file_3}`#"
        malicious_url = f"http://a.com/repo.git;touch {marker_file_3}"
        payload = {
            "site": {
                "git": {
                    "url": malicious_url
                }
            }
        }

        try:
            requests.post(
                f"{self.base_url}/system/api?op=gitImportSite",
                json=payload,
                timeout=30
            )
        except requests.exceptions.RequestException:
            pass

        time.sleep(2)

        marker_exists = os.path.exists(marker_file_3)
        clean_marker_file(marker_file_3)

        assert not marker_exists, (
            f"VULNERABLE: Backtick command substitution succeeded! "
            f"Marker file '{marker_file_3}' was created."
        )


class TestVulnerableFunctionRemoval:
    """Test that the vulnerable function has been properly handled."""

    def test_gitimportsite_function_removed_or_fixed(self):
        """
        Test that gitImportSite function is either removed or fixed.

        The fix should either:
        1. Remove the gitImportSite function entirely
        2. Add proper input sanitization with escapeshellarg()
        """
        operations_path = f"{APP_PATH}/system/backend/php/lib/Operations.php"

        # Check if the file exists
        if not os.path.exists(operations_path):
            pytest.skip("Operations.php not found")

        with open(operations_path, 'r') as f:
            content = f.read()

        # Check if function exists
        function_exists = "function gitImportSite" in content

        if function_exists:
            # If function exists, it should use escapeshellarg or similar
            # Check for dangerous pattern: direct interpolation without escaping
            has_dangerous_pattern = (
                'set_remote("origin", $repoUrl)' in content or
                "set_remote('origin', $repoUrl)" in content
            )

            has_proper_escaping = (
                "escapeshellarg($repoUrl)" in content or
                "escapeshellcmd($repoUrl)" in content
            )

            if has_dangerous_pattern and not has_proper_escaping:
                pytest.fail(
                    "VULNERABLE: gitImportSite function exists with unsafe "
                    "direct URL interpolation. URL should be escaped with "
                    "escapeshellarg() before being passed to set_remote()."
                )

        # Function removed or properly fixed - test passes


class TestSetRemoteVulnerability:
    """Test Git.php set_remote function for proper escaping."""

    def test_set_remote_uses_escaping(self):
        """
        Test that set_remote properly escapes its arguments.

        The set_remote function should use escapeshellarg() to prevent
        command injection when user-controlled URLs are passed to it.
        """
        git_path = f"{APP_PATH}/system/backend/php/lib/Git.php"
        operations_path = f"{APP_PATH}/system/backend/php/lib/Operations.php"

        # Skip if files don't exist
        if not os.path.exists(git_path):
            pytest.skip("Git.php not found")

        with open(git_path, 'r') as f:
            git_content = f.read()

        # Check if set_remote exists
        if "function set_remote" not in git_content:
            return  # Function might have been removed

        # Check Operations.php - if gitImportSite is removed, we're safe
        if os.path.exists(operations_path):
            with open(operations_path, 'r') as f:
                ops_content = f.read()

            if "function gitImportSite" not in ops_content:
                # Vulnerable function removed - safe
                return

        # If both exist, check for safe patterns in either file
        # Either set_remote should escape, or gitImportSite should escape before calling

        has_safe_set_remote = (
            "escapeshellarg($url)" in git_content or
            "escapeshellarg($destination)" in git_content
        )

        has_unsafe_set_remote = 'run("remote add $destination $url")' in git_content

        if has_unsafe_set_remote and not has_safe_set_remote:
            # set_remote is unsafe, but check if caller escapes
            if os.path.exists(operations_path):
                with open(operations_path, 'r') as f:
                    ops_content = f.read()

                if "function gitImportSite" in ops_content:
                    # Function exists - should have escaping
                    if "escapeshellarg" not in ops_content:
                        pytest.fail(
                            "VULNERABLE: set_remote() uses unsafe string interpolation "
                            "and gitImportSite doesn't escape the URL. "
                            "User input can inject shell commands via proc_open()."
                        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
