"""
Vulnerability tests for zuluPolkit PolicyKit authorization issue.

These tests verify the vulnerability status:
- FAIL in vulnerable state (auth_self is used, allowing unprivileged access)
- PASS in fixed state (auth_admin is used, requiring admin privileges)

The vulnerability is a privilege escalation issue where the PolicyKit policy
allows any local user to access zuluPolkit operations with just their own
password, instead of requiring administrator credentials.
"""

import os
import re
import subprocess
import xml.etree.ElementTree as ET

import pytest


# Paths in the container
ZULUPOLKIT_BINARY = "/usr/bin/zuluPolkit"
POLICY_FILE = "/usr/share/polkit-1/actions/org.zulucrypt.zulupolkit.policy"
SOURCE_DIR = "/app"
CMAKE_FILE = f"{SOURCE_DIR}/zuluPolkit/CMakeLists.txt"


class TestPolicyAuthorizationLevel:
    """
    Tests verifying the PolicyKit authorization level is correctly configured.

    The vulnerable configuration uses 'auth_self' which allows any user to
    authenticate with their own password. The secure configuration uses
    'auth_admin' which requires administrator credentials.
    """

    def test_allow_any_uses_auth_admin(self):
        """Verify allow_any setting requires admin authentication."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern
        vulnerable_pattern = r"<allow_any>\s*auth_self\s*</allow_any>"
        if re.search(vulnerable_pattern, content):
            pytest.fail(
                "VULNERABLE: allow_any uses auth_self instead of auth_admin. "
                "This allows unprivileged users to authenticate with their own password."
            )

        # Verify secure pattern exists
        secure_pattern = r"<allow_any>\s*auth_admin\s*</allow_any>"
        assert re.search(secure_pattern, content), \
            "Expected allow_any to use auth_admin for secure configuration"

    def test_allow_inactive_uses_auth_admin(self):
        """Verify allow_inactive setting requires admin authentication."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern
        vulnerable_pattern = r"<allow_inactive>\s*auth_self\s*</allow_inactive>"
        if re.search(vulnerable_pattern, content):
            pytest.fail(
                "VULNERABLE: allow_inactive uses auth_self instead of auth_admin. "
                "This allows unprivileged users from inactive sessions to authenticate."
            )

        # Verify secure pattern exists
        secure_pattern = r"<allow_inactive>\s*auth_admin\s*</allow_inactive>"
        assert re.search(secure_pattern, content), \
            "Expected allow_inactive to use auth_admin for secure configuration"

    def test_allow_active_uses_auth_admin(self):
        """Verify allow_active setting requires admin authentication."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern
        vulnerable_pattern = r"<allow_active>\s*auth_self\s*</allow_active>"
        if re.search(vulnerable_pattern, content):
            pytest.fail(
                "VULNERABLE: allow_active uses auth_self instead of auth_admin. "
                "This allows unprivileged users from active sessions to authenticate."
            )

        # Verify secure pattern exists
        secure_pattern = r"<allow_active>\s*auth_admin\s*</allow_active>"
        assert re.search(secure_pattern, content), \
            "Expected allow_active to use auth_admin for secure configuration"

    def test_no_auth_self_anywhere(self):
        """Verify auth_self is not used anywhere in the policy file."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        if "auth_self" in content:
            pytest.fail(
                "VULNERABLE: Policy file contains 'auth_self' authorization level. "
                "All authorization levels should use 'auth_admin' to require "
                "administrator credentials."
            )

    def test_all_auth_levels_are_admin(self):
        """Comprehensive check that all three auth levels use auth_admin."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Count occurrences of auth_admin
        auth_admin_count = len(re.findall(r"auth_admin", content))

        # Should have at least 3 auth_admin entries (allow_any, allow_inactive, allow_active)
        assert auth_admin_count >= 3, \
            f"Expected at least 3 auth_admin settings, found {auth_admin_count}. " \
            f"All authorization levels (allow_any, allow_inactive, allow_active) " \
            f"should require admin authentication."


class TestSourceCodeFix:
    """
    Tests verifying the source code has been fixed.

    The fix must be applied to the source CMakeLists.txt file, not just
    the installed policy file, to ensure the fix persists across rebuilds.
    """

    def test_source_allow_any_is_auth_admin(self):
        """Verify source code allow_any setting is auth_admin."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern in source
        if "<allow_any>auth_self</allow_any>" in content:
            pytest.fail(
                "VULNERABLE: Source CMakeLists.txt contains auth_self for allow_any. "
                "This setting must be changed to auth_admin."
            )

        # Verify secure pattern
        assert "<allow_any>auth_admin</allow_any>" in content, \
            "Source should contain '<allow_any>auth_admin</allow_any>'"

    def test_source_allow_inactive_is_auth_admin(self):
        """Verify source code allow_inactive setting is auth_admin."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern in source
        if "<allow_inactive>auth_self</allow_inactive>" in content:
            pytest.fail(
                "VULNERABLE: Source CMakeLists.txt contains auth_self for allow_inactive. "
                "This setting must be changed to auth_admin."
            )

        # Verify secure pattern
        assert "<allow_inactive>auth_admin</allow_inactive>" in content, \
            "Source should contain '<allow_inactive>auth_admin</allow_inactive>'"

    def test_source_allow_active_is_auth_admin(self):
        """Verify source code allow_active setting is auth_admin."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        # Check for vulnerable pattern in source
        if "<allow_active>auth_self</allow_active>" in content:
            pytest.fail(
                "VULNERABLE: Source CMakeLists.txt contains auth_self for allow_active. "
                "This setting must be changed to auth_admin."
            )

        # Verify secure pattern
        assert "<allow_active>auth_admin</allow_active>" in content, \
            "Source should contain '<allow_active>auth_admin</allow_active>'"

    def test_source_no_auth_self(self):
        """Verify source code doesn't contain auth_self anywhere."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        if "auth_self" in content:
            pytest.fail(
                "VULNERABLE: Source CMakeLists.txt still contains 'auth_self'. "
                "All instances should be changed to 'auth_admin'."
            )


class TestPolicyXMLStructure:
    """
    Tests verifying the policy file defaults section structure is correct.

    These tests parse the XML to ensure authorization levels are properly
    configured in the defaults section.
    """

    def test_defaults_children_have_auth_admin(self):
        """Verify defaults section children all use auth_admin."""
        tree = ET.parse(POLICY_FILE)
        root = tree.getroot()

        # Find defaults element
        defaults = None
        for elem in root.iter():
            tag = elem.tag.split('}')[-1] if '}' in elem.tag else elem.tag
            if tag == "defaults":
                defaults = elem
                break

        assert defaults is not None, "Policy file has no defaults section"

        # Check each authorization setting
        for child in defaults:
            tag = child.tag.split('}')[-1] if '}' in child.tag else child.tag
            if tag in ["allow_any", "allow_inactive", "allow_active"]:
                value = child.text.strip() if child.text else ""
                if value == "auth_self":
                    pytest.fail(
                        f"VULNERABLE: {tag} is set to 'auth_self'. "
                        f"Should be 'auth_admin'."
                    )
                assert value == "auth_admin", \
                    f"Expected {tag} to be 'auth_admin', got '{value}'"


class TestAuthorizationVariants:
    """
    Tests for various bypass attempts and edge cases.

    These tests ensure the fix is comprehensive and handles different
    formatting variations that might be used.
    """

    def test_no_auth_self_with_whitespace_variants(self):
        """Check for auth_self with various whitespace patterns."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Various patterns that could indicate vulnerable configuration
        patterns = [
            r">\s*auth_self\s*<",      # auth_self with any surrounding whitespace
            r"auth_self",               # Direct string match
        ]

        for pattern in patterns:
            if re.search(pattern, content):
                pytest.fail(
                    f"VULNERABLE: Policy file contains auth_self "
                    f"(matched pattern: {pattern})"
                )

    def test_no_auth_self_in_source_with_whitespace(self):
        """Check for auth_self in source with various whitespace patterns."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        patterns = [
            r">\s*auth_self\s*<",      # auth_self with any surrounding whitespace
            r"auth_self",               # Direct string match
        ]

        for pattern in patterns:
            if re.search(pattern, content):
                pytest.fail(
                    f"VULNERABLE: Source CMakeLists.txt contains auth_self "
                    f"(matched pattern: {pattern})"
                )

    def test_auth_admin_properly_formatted(self):
        """Verify auth_admin entries are properly formatted."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Check for properly formatted auth_admin entries
        expected_patterns = [
            r"<allow_any>\s*auth_admin\s*</allow_any>",
            r"<allow_inactive>\s*auth_admin\s*</allow_inactive>",
            r"<allow_active>\s*auth_admin\s*</allow_active>",
        ]

        for pattern in expected_patterns:
            assert re.search(pattern, content), \
                f"Missing properly formatted auth_admin entry for pattern: {pattern}"


class TestPolicyConsistency:
    """
    Tests verifying policy file and source are consistent after fix.
    """

    def test_source_and_policy_both_fixed(self):
        """Verify both source and installed policy are in fixed state."""
        # Check source
        with open(CMAKE_FILE, 'r') as f:
            source_content = f.read()

        source_has_auth_self = "auth_self" in source_content

        # Check installed policy
        with open(POLICY_FILE, 'r') as f:
            policy_content = f.read()

        policy_has_auth_self = "auth_self" in policy_content

        if source_has_auth_self and policy_has_auth_self:
            pytest.fail(
                "VULNERABLE: Both source and policy file contain auth_self. "
                "The vulnerability has not been fixed."
            )
        elif source_has_auth_self:
            pytest.fail(
                "PARTIALLY FIXED: Source still contains auth_self. "
                "The source must be fixed for the solution to persist."
            )
        elif policy_has_auth_self:
            pytest.fail(
                "PARTIALLY FIXED: Policy file still contains auth_self. "
                "The policy file should be regenerated from fixed source."
            )

    def test_auth_admin_count_matches(self):
        """Verify both source and policy have same number of auth_admin entries."""
        with open(CMAKE_FILE, 'r') as f:
            source_content = f.read()

        with open(POLICY_FILE, 'r') as f:
            policy_content = f.read()

        source_count = source_content.count("auth_admin")
        policy_count = policy_content.count("auth_admin")

        # Both should have at least 3 (for the three authorization levels)
        assert source_count >= 3, \
            f"Source has only {source_count} auth_admin entries, expected at least 3"
        assert policy_count >= 3, \
            f"Policy has only {policy_count} auth_admin entries, expected at least 3"
