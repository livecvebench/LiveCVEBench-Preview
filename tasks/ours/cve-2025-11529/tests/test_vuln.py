
"""
Vulnerability tests for ChurchCRM API authentication bypass.

These tests verify that the authentication bypass vulnerability is fixed.
- FAIL in vulnerable state (bypass works, vulnerability exploitable)
- PASS in fixed state (bypass blocked, vulnerability mitigated)

The vulnerability allows unauthenticated access to protected API endpoints
by appending certain query parameters that trick the path validation.
"""

import pytest
import requests
import time

BASE_URL = "http://localhost"
MAX_RETRIES = 30
RETRY_DELAY = 2


def wait_for_application():
    """Wait for the application to be ready."""
    for i in range(MAX_RETRIES):
        try:
            response = requests.get(f"{BASE_URL}/", timeout=5, allow_redirects=True)
            if response.status_code in [200, 302, 303]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(RETRY_DELAY)
    return False


@pytest.fixture(scope="module", autouse=True)
def setup_module():
    """Ensure application is ready before running tests."""
    assert wait_for_application(), "Application failed to start within timeout"


class TestAuthenticationBypassBlocked:
    """
    Test that authentication bypass attempts are blocked.

    The middleware should properly validate the request path and not be
    tricked by query parameters or other parts of the URL that contain
    strings matching public route patterns.
    """

    def test_bypass_with_api_public_in_query_param_value(self):
        """
        Bypass attempt using 'api/public' as a query parameter value should be blocked.

        Vulnerable behavior: Returns 200 with person data
        Fixed behavior: Returns 401 Unauthorized
        """
        response = requests.get(
            f"{BASE_URL}/api/persons/latest?bypass=api/public",
            timeout=10
        )
        assert response.status_code == 401, \
            f"Authentication bypass detected! Expected 401, got {response.status_code}. " \
            f"Query parameter bypass should be blocked."

    def test_bypass_with_api_public_in_query_param_name(self):
        """
        Bypass attempt using 'api/public' as a query parameter name should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/api/persons/latest?api/public=anything",
            timeout=10
        )
        assert response.status_code == 401, \
            f"Authentication bypass detected! Expected 401, got {response.status_code}. " \
            f"Query parameter name bypass should be blocked."

    def test_bypass_with_api_public_among_multiple_params(self):
        """
        Bypass attempt with 'api/public' hidden among multiple query parameters.
        """
        response = requests.get(
            f"{BASE_URL}/api/persons/latest?foo=bar&x=api/public&baz=qux",
            timeout=10
        )
        assert response.status_code == 401, \
            f"Authentication bypass detected! Expected 401, got {response.status_code}. " \
            f"Hidden query parameter bypass should be blocked."

    def test_bypass_returns_no_sensitive_data(self):
        """
        Bypass attempt should not return any person data.

        On vulnerable version, this returns JSON array with person details.
        On fixed version, this returns 401 with no sensitive data.
        """
        response = requests.get(
            f"{BASE_URL}/api/persons/latest?bypass=api/public",
            timeout=10
        )

        # First check: should be 401
        assert response.status_code == 401, \
            f"Authentication bypass detected! Expected 401, got {response.status_code}"

        # Second check: response should not contain person data
        response_text = response.text.lower()
        assert "firstname" not in response_text, \
            "Response contains person data - authentication bypass in effect"
        assert "lastname" not in response_text, \
            "Response contains person data - authentication bypass in effect"


class TestMultipleBypassPatterns:
    """Test various bypass patterns that should all be blocked."""

    @pytest.mark.parametrize("bypass_pattern", [
        "?a=api/public",
        "?api/public",
        "?api/public=1",
        "?x=1&api/public",
        "?x=api/public&y=z",
        "?path=api/public",
        "?route=api/public",
        "?url=api/public",
        "?redirect=api/public",
    ])
    def test_various_bypass_patterns_blocked(self, bypass_pattern):
        """
        Various bypass patterns using 'api/public' in query string should be blocked.
        """
        response = requests.get(
            f"{BASE_URL}/api/persons/latest{bypass_pattern}",
            timeout=10
        )
        assert response.status_code == 401, \
            f"Bypass pattern '{bypass_pattern}' was not blocked! " \
            f"Expected 401, got {response.status_code}"


class TestDifferentProtectedEndpoints:
    """Test bypass attempts on different protected endpoints."""

    @pytest.mark.parametrize("endpoint", [
        "/api/persons/latest",
        "/api/families/latest",
    ])
    def test_bypass_blocked_on_various_endpoints(self, endpoint):
        """
        Bypass attempt should be blocked on all protected endpoints.
        """
        response = requests.get(
            f"{BASE_URL}{endpoint}?bypass=api/public",
            timeout=10
        )
        # Should be 401 (unauthorized) or 404 (endpoint doesn't exist in minimal setup)
        # The key is it should NOT be 200 with data
        assert response.status_code in [401, 404], \
            f"Endpoint {endpoint} bypass not blocked! " \
            f"Expected 401 or 404, got {response.status_code}"
