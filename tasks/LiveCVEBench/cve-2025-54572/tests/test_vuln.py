#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-54572.

These tests verify that the resource exhaustion vulnerability is mitigated.
- FAIL in vulnerable state (large messages cause delays before rejection)
- PASS in fixed state (large messages are rejected immediately)

The vulnerability is that `base64_encoded?` regex check runs BEFORE the size
check, causing CPU-intensive operations on arbitrarily large inputs.
"""

import subprocess
import pytest
import time
import os

APP_DIR = "/app"

# Threshold for "fast" rejection - fixed code should reject in under 0.5 seconds
# Vulnerable code takes several seconds for large payloads
FAST_THRESHOLD_SECONDS = 0.5

# Payload sizes that reliably demonstrate the vulnerability
# With 50MB+ payloads, the vulnerable regex takes >1s even on fast hardware
LARGE_PAYLOAD_SIZE = 50 * 1024 * 1024   # 50MB
MEDIUM_PAYLOAD_SIZE = 30 * 1024 * 1024  # 30MB


def run_ruby_script(script_content: str, timeout: int = 60) -> tuple[str, str, int, float]:
    """Execute Ruby code and return stdout, stderr, return code, and elapsed time."""
    start_time = time.time()
    try:
        result = subprocess.run(
            ["ruby", "-I", f"{APP_DIR}/lib", "-e", script_content],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=APP_DIR
        )
        elapsed = time.time() - start_time
        return result.stdout, result.stderr, result.returncode, elapsed
    except subprocess.TimeoutExpired:
        elapsed = time.time() - start_time
        return "", "TIMEOUT", -1, elapsed


class TestResourceExhaustionMitigation:
    """
    Test that large messages are rejected quickly without resource exhaustion.

    The fix moves the size check BEFORE the expensive base64_encoded? regex,
    ensuring that oversized messages are rejected in O(1) time.
    """

    def test_large_payload_rejected_quickly_5mb(self):
        """
        50MB payload should be rejected almost instantly with the fix.

        Vulnerable: Takes 1-3 seconds due to regex on entire string
        Fixed: Takes < 0.1 seconds due to immediate size check
        """
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create a 50MB payload of valid Base64 characters
payload_size = {LARGE_PAYLOAD_SIZE}
large_payload = "A" * payload_size

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000  # Very small limit

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError => e
    # Expected - message should be rejected
  end
end

puts "ELAPSED:#{{time.real}}"
puts "PAYLOAD_SIZE:#{{payload_size}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        # Parse elapsed time from Ruby output
        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time. Output: {stdout}"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"5MB payload took {elapsed:.2f}s to reject (threshold: {FAST_THRESHOLD_SECONDS}s). "
            f"The size check should happen BEFORE expensive regex operations."
        )

    def test_large_payload_rejected_quickly_10mb(self):
        """
        30MB payload should be rejected almost instantly with the fix.

        Vulnerable: Takes 3-8 seconds due to regex on entire string
        Fixed: Takes < 0.1 seconds due to immediate size check
        """
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create a 30MB payload
payload_size = {MEDIUM_PAYLOAD_SIZE}
large_payload = "B" * payload_size

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 500

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError => e
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time. Output: {stdout}"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"10MB payload took {elapsed:.2f}s to reject (threshold: {FAST_THRESHOLD_SECONDS}s). "
            f"The vulnerability allows expensive regex to run before size validation."
        )

    def test_large_payload_with_mixed_base64_chars(self):
        """
        Test with varied Base64 characters to ensure regex complexity is avoided.

        Valid Base64 alphabet: A-Za-z0-9+/
        """
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create payload with mixed valid Base64 characters
# This creates a more complex pattern for the regex to match
chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
payload_size = {LARGE_PAYLOAD_SIZE}  # 50MB

# Build payload with repeating pattern
pattern = chars * (payload_size / chars.length + 1)
large_payload = pattern[0, payload_size]

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError => e
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time. Output: {stdout}"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"8MB mixed-char payload took {elapsed:.2f}s to reject. "
            f"Size validation must occur before pattern matching."
        )

    def test_payload_at_boundary(self):
        """
        Test large payload that exceeds a small size limit - should be rejected instantly with fix.

        The vulnerability manifests even when a large payload exceeds a small limit,
        because the base64 regex runs on the ENTIRE payload before the size check.
        """
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create a 30MB payload - even though limit is small, vulnerable code
# still runs expensive regex on entire string before checking size
payload_size = {MEDIUM_PAYLOAD_SIZE}
large_payload = "C" * payload_size

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000  # Small limit, but payload is huge

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError => e
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time. Output: {stdout}"
        # With fix, rejection should be instant regardless of payload size
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"Boundary payload took {elapsed:.2f}s - size check should reject immediately"
        )


class TestCodePathOrder:
    """
    Verify that the code executes size check before base64_encoded? check.
    This is a structural verification of the fix.
    """

    def test_size_check_before_base64_check(self):
        """
        Verify the order of operations in decode_raw_saml.

        The fix ensures that saml.bytesize check happens BEFORE base64_encoded?(saml).
        """
        script = '''
require 'onelogin/ruby-saml'

# Read the source file and check the order
source_path = "/app/lib/onelogin/ruby-saml/saml_message.rb"

# Try to find gem path first, fallback to /app if not available
begin
  spec = Gem::Specification.find_by_name("ruby-saml")
  gem_path = File.join(spec.gem_dir, "lib/onelogin/ruby-saml/saml_message.rb")
  source_path = gem_path if File.exist?(gem_path)
rescue Gem::MissingSpecError
  # Use default /app path
end

content = File.read(source_path)

# Find the decode_raw_saml method
method_match = content.match(/def decode_raw_saml.*?^(\s{6}end|\z)/m)

if method_match.nil?
  puts "FAILURE: Could not find decode_raw_saml method"
  exit 1
end

method_content = method_match[0]

# Find positions of key operations
size_check_pos = method_content.index("bytesize > settings.message_max_bytesize") || method_content.index("saml.bytesize >")
base64_check_pos = method_content.index("base64_encoded?(saml)")

if size_check_pos.nil?
  puts "FAILURE: Could not find size check in method"
  exit 1
end

if base64_check_pos.nil?
  puts "FAILURE: Could not find base64_encoded? check in method"
  exit 1
end

# The fix: size check should come BEFORE base64 check
if size_check_pos < base64_check_pos
  puts "SUCCESS: Size check occurs before base64_encoded? check"
  exit 0
else
  puts "FAILURE: base64_encoded? check occurs before size check"
  puts "This allows expensive regex to run on oversized messages"
  exit 1
end
'''
        stdout, stderr, returncode, _ = run_ruby_script(script)
        assert returncode == 0, f"Code order check failed: {stderr}\n{stdout}"
        assert "SUCCESS" in stdout, f"Size check should occur before base64 check. Output: {stdout}"

    def test_early_return_after_size_check(self):
        """
        Verify that settings initialization occurs before size check.

        The fixed code should have this order:
        1. Initialize settings
        2. Check size
        3. Check base64
        """
        script = '''
source_path = "/app/lib/onelogin/ruby-saml/saml_message.rb"
content = File.read(source_path)

# Extract decode_raw_saml method
method_match = content.match(/def decode_raw_saml\(saml, settings = nil\).*?^(\s{6}end)/m)

if method_match.nil?
  puts "FAILURE: Could not extract decode_raw_saml method"
  exit 1
end

method_body = method_match[0]
lines = method_body.split("\n")

# Check the structure of the first few lines after method definition
settings_init_found = false
size_check_found = false
base64_check_found = false

lines.each do |line|
  if line.include?("Settings.new") && !settings_init_found
    settings_init_found = true
    if base64_check_found
      puts "FAILURE: base64 check found before settings init"
      exit 1
    end
  end

  if line.include?("bytesize > settings.message_max_bytesize") && !size_check_found
    size_check_found = true
    if !settings_init_found
      puts "FAILURE: size check before settings init"
      exit 1
    end
    if base64_check_found
      puts "FAILURE: base64 check found before size check"
      exit 1
    end
  end

  if line.include?("base64_encoded?(saml)") && !base64_check_found
    base64_check_found = true
    if !size_check_found
      puts "FAILURE: base64 check found before size check - vulnerability exists"
      exit 1
    end
  end
end

if settings_init_found && size_check_found && base64_check_found
  puts "SUCCESS: Correct order: settings init -> size check -> base64 check"
  exit 0
else
  puts "FAILURE: Missing expected code elements"
  puts "settings_init: #{settings_init_found}, size_check: #{size_check_found}, base64_check: #{base64_check_found}"
  exit 1
end
'''
        stdout, stderr, returncode, _ = run_ruby_script(script)
        assert returncode == 0, f"Structure check failed: {stderr}\n{stdout}"
        assert "SUCCESS" in stdout


class TestMultiplePayloadPatterns:
    """
    Test various payload patterns to ensure the fix handles all cases.
    """

    def test_payload_with_valid_base64_padding(self):
        """Test large payload that looks like properly padded Base64."""
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create payload that matches Base64 format with proper padding
# 4 characters per group, with == padding at end
base_size = {LARGE_PAYLOAD_SIZE}  # 50MB
groups = base_size / 4
large_payload = ("ABCD" * groups) + "AA=="

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"Padded Base64 payload took {elapsed:.2f}s - size check should reject immediately"
        )

    def test_payload_with_whitespace(self):
        """Test large payload with embedded whitespace (newlines)."""
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create payload with newlines (as produced by standard Base64.encode64)
target_size = {MEDIUM_PAYLOAD_SIZE}  # 30MB target
base_chars = "ABCDEFGHIJ" * (target_size / 10)  # ~30MB without newlines
# Add newlines every 76 chars as per RFC
chunks = base_chars.scan(/.{{1,76}}/)
large_payload = chunks.join("\\n")

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
puts "PAYLOAD_SIZE:#{{large_payload.bytesize}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"Whitespace payload took {elapsed:.2f}s - bytesize check should be first"
        )

    def test_payload_with_plus_and_slash(self):
        """Test payload with + and / characters (valid Base64)."""
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Include + and / which are valid Base64 chars
# These could affect regex performance differently
pattern = "ABC+DEF/GHI+JKL/"
large_payload = pattern * ({LARGE_PAYLOAD_SIZE} / pattern.length)

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000

saml_msg = OneLogin::RubySaml::SamlMessage.new

time = Benchmark.measure do
  begin
    saml_msg.send(:decode_raw_saml, large_payload, settings)
  rescue OneLogin::RubySaml::ValidationError
    # Expected
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"Plus/slash payload took {elapsed:.2f}s to reject"
        )


class TestResponseClass:
    """
    Test that the fix works through the Response class interface,
    which is the typical entry point for SAML processing.
    """

    def test_response_rejects_large_payload_quickly(self):
        """
        Test through OneLogin::RubySaml::Response.new which is the common entry point.
        """
        script = f'''
require 'onelogin/ruby-saml'
require 'benchmark'

# Create large payload (50MB)
large_payload = "X" * {LARGE_PAYLOAD_SIZE}

settings = OneLogin::RubySaml::Settings.new
settings.message_max_bytesize = 1000

time = Benchmark.measure do
  begin
    # This is how applications typically use ruby-saml
    response = OneLogin::RubySaml::Response.new(large_payload, settings: settings)
  rescue OneLogin::RubySaml::ValidationError
    # Expected - oversized
  rescue => e
    # Other errors are OK too - we just care about timing
  end
end

puts "ELAPSED:#{{time.real}}"
'''
        stdout, stderr, returncode, _ = run_ruby_script(script, timeout=120)

        elapsed = None
        for line in stdout.split('\n'):
            if line.startswith('ELAPSED:'):
                elapsed = float(line.split(':')[1])
                break

        assert elapsed is not None, f"Could not parse elapsed time. Output: {stdout}, Stderr: {stderr}"
        assert elapsed < FAST_THRESHOLD_SECONDS, (
            f"Response.new took {elapsed:.2f}s for oversized payload. "
            f"The vulnerability allows regex to run before size check."
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
