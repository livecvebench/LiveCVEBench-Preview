"""
Functional tests for i-Educar application.
These tests verify that the application works correctly for authorized users.
Should PASS in both vulnerable and fixed states.
"""
import os
import pytest
import requests
from requests.exceptions import RequestException

BASE_URL = os.environ.get("APP_URL", "http://localhost")
ADMIN_USER = os.environ.get("ADMIN_USER", "admin")
ADMIN_PASSWORD = os.environ.get("ADMIN_PASSWORD", "123456789")


def wait_for_app(timeout=60):
    """Wait for the application to be ready."""
    import time
    start = time.time()
    while time.time() - start < timeout:
        try:
            # Use a fresh request to avoid session state issues
            resp = requests.get(f"{BASE_URL}/login", timeout=5)
            if resp.status_code == 200:
                return True
        except RequestException:
            pass
        time.sleep(2)
    return False


def create_admin_session():
    """Create a new session and login as admin."""
    from bs4 import BeautifulSoup

    session = requests.Session()

    # Get login page for CSRF
    resp = session.get(f"{BASE_URL}/login")
    if resp.status_code != 200:
        return None

    soup = BeautifulSoup(resp.text, 'html.parser')
    csrf_input = soup.find('input', {'name': '_token'})
    csrf_token = csrf_input['value'] if csrf_input else None

    login_data = {
        'login': ADMIN_USER,
        'password': ADMIN_PASSWORD,
    }
    if csrf_token:
        login_data['_token'] = csrf_token

    resp = session.post(
        f"{BASE_URL}/login",
        data=login_data,
        allow_redirects=True
    )

    # Check if login succeeded
    if '/login' not in resp.url:
        return session
    return None


class TestApplicationBasicFunctionality:
    """Test basic application functionality."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure app is ready before tests."""
        assert wait_for_app(), "Application failed to start"

    def test_login_page_loads(self):
        """Login page should be accessible."""
        resp = requests.get(f"{BASE_URL}/login", timeout=10)
        assert resp.status_code == 200
        assert 'login' in resp.text.lower() or 'senha' in resp.text.lower()

    def test_admin_can_login(self):
        """Admin should be able to login successfully."""
        session = create_admin_session()
        assert session is not None, "Login failed - could not create admin session"

    def test_unauthenticated_access_redirects_to_login(self):
        """Unauthenticated users should be redirected to login."""
        # Create fresh session (no auth)
        test_session = requests.Session()
        resp = test_session.get(f"{BASE_URL}/usuarios/tipos", allow_redirects=True)
        # Should redirect to login
        assert '/login' in resp.url or resp.status_code == 401


class TestAdminUserTypeManagement:
    """Test that admin users can manage user types (functional tests)."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup admin session."""
        assert wait_for_app(), "Application failed to start"
        self.session = create_admin_session()
        assert self.session is not None, "Admin login failed"

    def test_admin_can_view_user_types_list(self):
        """Admin should be able to view user types list."""
        resp = self.session.get(f"{BASE_URL}/usuarios/tipos", allow_redirects=True)
        # Should not redirect to login
        assert '/login' not in resp.url
        # Page should load (may be PHP legacy page)
        assert resp.status_code == 200

    def test_admin_can_access_new_user_type_form(self):
        """Admin should be able to access new user type form."""
        resp = self.session.get(f"{BASE_URL}/usuarios/tipos/novo", allow_redirects=True)
        assert '/login' not in resp.url
        assert resp.status_code == 200

    def test_admin_can_view_existing_user_type(self):
        """Admin should be able to view an existing user type."""
        # Try to access user type ID 1 (typically exists)
        resp = self.session.get(f"{BASE_URL}/usuarios/tipos/1", allow_redirects=True)
        # Should not redirect to login, may get 404 if ID doesn't exist
        assert '/login' not in resp.url
        assert resp.status_code in [200, 404]

    def test_admin_can_update_user_type(self):
        """Admin should be able to update a user type."""
        from bs4 import BeautifulSoup

        # First, get an existing user type
        resp = self.session.get(f"{BASE_URL}/usuarios/tipos/1", allow_redirects=True)

        if resp.status_code == 404:
            pytest.skip("User type ID 1 doesn't exist")

        # Extract CSRF token from meta tag (Vue.js pages) or hidden input
        soup = BeautifulSoup(resp.text, 'html.parser')
        csrf_input = soup.find('input', {'name': '_token'})
        if csrf_input and csrf_input.get('value'):
            csrf_token = csrf_input['value']
        else:
            meta_csrf = soup.find('meta', {'name': 'csrf-token'})
            csrf_token = meta_csrf['content'] if meta_csrf else None

        # Try to update with minimal data
        update_data = {
            '_method': 'put',
            'name': 'Administrador',
            'level': '1',
            'description': 'Admin user type',
        }
        if csrf_token:
            update_data['_token'] = csrf_token

        resp = self.session.post(
            f"{BASE_URL}/usuarios/tipos/1",
            data=update_data,
            allow_redirects=True
        )

        # Admin should be able to update (either success or redirect to index)
        # After fix, admin with proper permissions should still succeed
        assert '/login' not in resp.url


class TestApplicationHomeAccess:
    """Test home page and dashboard access."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup admin session."""
        assert wait_for_app(), "Application failed to start"
        self.session = create_admin_session()
        assert self.session is not None, "Admin login failed"

    def test_admin_can_access_main_menu(self):
        """Admin should be able to access a protected page after login."""
        # Access the usuarios/tipos page (which we know works from other tests)
        resp = self.session.get(f"{BASE_URL}/usuarios/tipos", allow_redirects=True)
        assert '/login' not in resp.url
        assert resp.status_code == 200
