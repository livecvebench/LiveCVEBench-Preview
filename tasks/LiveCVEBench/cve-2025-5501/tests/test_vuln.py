#!/usr/bin/env python3
"""
Vulnerability tests for Open5GS SMF NGAP handler - PathSwitchRequest processing.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerability (CVE-2025-5501) occurs when:
1. SMF receives PathSwitchRequest with same tunnel parameters (far_update=false)
2. SMF incorrectly returns HTTP 204 No Content without N2 signaling buffer
3. AMF crashes because it expects N2 data in all cases

The fix ensures N2 signaling is ALWAYS sent, using:
- ngap_build_path_switch_request_ack_transfer(sess) to build N2 buffer
- smf_sbi_send_sm_context_updated_data_n2smbuf() to send it with PATH_SWITCH_REQ_ACK type
"""

import subprocess
import os
import re
import time
import pytest


class TestVulnerableCodePattern:
    """
    Test that the vulnerable code pattern has been fixed.

    The vulnerability is in src/smf/ngap-handler.c in the else branch of
    ngap_handle_path_switch_request_transfer() function.

    VULNERABLE CODE (should NOT exist after fix):
        } else {
            /* ACTIVATED Is NOT Included in RESPONSE */
            ogs_assert(true == ogs_sbi_send_http_status_no_content(stream));
        }

    FIXED CODE (should exist after fix):
        } else {
            ogs_pkbuf_t *n2smbuf =
                ngap_build_path_switch_request_ack_transfer(sess);
            ogs_assert(n2smbuf);
            smf_sbi_send_sm_context_updated_data_n2smbuf(sess, stream,
                OpenAPI_n2_sm_info_type_PATH_SWITCH_REQ_ACK, n2smbuf);
        }
    """

    def test_no_http_204_in_path_switch_else_branch(self):
        """
        Verify HTTP 204 No Content is NOT used in the path switch else branch.

        The vulnerable code sends HTTP 204 without N2 buffer when far_update=false.
        This causes AMF to crash. The fix removes this vulnerable pattern.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body (find matching braces)
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The vulnerable pattern: sending HTTP 204 No Content in else branch after far_update check
        # This is the exact vulnerable code that should be removed
        vulnerable_pattern = r'ogs_sbi_send_http_status_no_content\s*\(\s*stream\s*\)'

        if re.search(vulnerable_pattern, func_body):
            pytest.fail(
                "VULNERABLE: Found ogs_sbi_send_http_status_no_content(stream) in "
                "ngap_handle_path_switch_request_transfer function.\n"
                "This causes AMF crash when far_update=false during PathSwitchRequest.\n"
                "Fix: Replace HTTP 204 response with proper N2 signaling using "
                "ngap_build_path_switch_request_ack_transfer() and "
                "smf_sbi_send_sm_context_updated_data_n2smbuf()"
            )

    def test_n2_buffer_built_in_else_branch(self):
        """
        Verify N2 buffer is built in the else branch using ngap_build_path_switch_request_ack_transfer.

        The fix calls ngap_build_path_switch_request_ack_transfer(sess) to create
        the N2 signaling buffer even when tunnel parameters haven't changed.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # Look for the else branch with far_update check
        # The fix should have ngap_build_path_switch_request_ack_transfer in the function
        # This is called in the else branch when far_update is false
        fix_pattern = r'ngap_build_path_switch_request_ack_transfer\s*\(\s*sess\s*\)'

        assert re.search(fix_pattern, func_body), (
            "VULNERABLE: ngap_build_path_switch_request_ack_transfer(sess) not found in "
            "ngap_handle_path_switch_request_transfer function.\n"
            "The fix must build N2 buffer in the else branch when far_update=false."
        )

    def test_n2_buffer_sent_with_path_switch_ack_type(self):
        """
        Verify N2 buffer is sent with PATH_SWITCH_REQ_ACK type.

        The fix uses smf_sbi_send_sm_context_updated_data_n2smbuf() with
        OpenAPI_n2_sm_info_type_PATH_SWITCH_REQ_ACK to properly notify AMF.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The fix should call smf_sbi_send_sm_context_updated_data_n2smbuf with PATH_SWITCH_REQ_ACK
        # We check for both the function call and the message type
        send_pattern = r'smf_sbi_send_sm_context_updated_data_n2smbuf'
        type_pattern = r'OpenAPI_n2_sm_info_type_PATH_SWITCH_REQ_ACK'

        assert re.search(send_pattern, func_body), (
            "VULNERABLE: smf_sbi_send_sm_context_updated_data_n2smbuf not found in "
            "ngap_handle_path_switch_request_transfer function.\n"
            "The fix must send the N2 buffer to AMF properly."
        )

        assert re.search(type_pattern, func_body), (
            "VULNERABLE: OpenAPI_n2_sm_info_type_PATH_SWITCH_REQ_ACK not found in "
            "ngap_handle_path_switch_request_transfer function.\n"
            "The N2 buffer must be sent with PATH_SWITCH_REQ_ACK message type."
        )


class TestElseBranchStructure:
    """
    Test the structural correctness of the else branch in path switch handler.
    """

    def test_else_branch_after_far_update_check(self):
        """
        Verify the else branch after far_update check has correct structure.

        The vulnerable code pattern:
            if (far_update) {
                // PFCP modification request - OK
            } else {
                // VULNERABLE: HTTP 204 without N2 buffer
            }

        The fixed code pattern:
            if (far_update) {
                // PFCP modification request - OK
            } else {
                // Build N2 buffer
                // Send with PATH_SWITCH_REQ_ACK type
            }
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # Look for the specific vulnerable code comment ONLY within this function
        # The vulnerable code has: "/* ACTIVATED Is NOT Included in RESPONSE */"
        vulnerable_comment = "ACTIVATED Is NOT Included in RESPONSE"

        if vulnerable_comment in func_body:
            pytest.fail(
                f"VULNERABLE: Found comment '{vulnerable_comment}' in "
                "ngap_handle_path_switch_request_transfer function which indicates "
                "the vulnerable code pattern is still present.\n"
                "This comment accompanies the HTTP 204 response that causes AMF crash."
            )

    def test_n2smbuf_variable_declared(self):
        """
        Verify n2smbuf variable is declared in the else branch.

        The fix declares: ogs_pkbuf_t *n2smbuf = ngap_build_path_switch_request_ack_transfer(sess);
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # Check for n2smbuf variable declaration with the builder function
        n2smbuf_pattern = r'ogs_pkbuf_t\s*\*\s*n2smbuf\s*=\s*ngap_build_path_switch_request_ack_transfer'

        assert re.search(n2smbuf_pattern, func_body), (
            "VULNERABLE: n2smbuf variable not properly declared with "
            "ngap_build_path_switch_request_ack_transfer in the else branch.\n"
            "Fix must declare: ogs_pkbuf_t *n2smbuf = ngap_build_path_switch_request_ack_transfer(sess);"
        )


class TestCompilationAfterFix:
    """
    Test that the fix pattern exists in the code.

    These tests check for the presence of the FIX - they should FAIL
    in a vulnerable environment (because the fix is not present) and
    PASS in a fixed environment.
    """

    def test_smf_compiles_with_fix(self):
        """
        Verify the fix pattern exists: ngap_build_path_switch_request_ack_transfer
        should be called in the else branch of ngap_handle_path_switch_request_transfer.

        This test FAILS in vulnerable code because the fix is not present.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The fix should have this call in the else branch
        fix_pattern = r'ngap_build_path_switch_request_ack_transfer\s*\(\s*sess\s*\)'

        assert re.search(fix_pattern, func_body), (
            "VULNERABLE: ngap_build_path_switch_request_ack_transfer(sess) not found in "
            "the else branch of ngap_handle_path_switch_request_transfer function.\n"
            "The fix must build N2 buffer in the else branch when far_update=false."
        )

    def test_full_build_succeeds(self):
        """
        Verify the fix pattern exists: smf_sbi_send_sm_context_updated_data_n2smbuf
        should be called with PATH_SWITCH_REQ_ACK type in the else branch.

        This test FAILS in vulnerable code because the fix is not present.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The fix should send N2 buffer with PATH_SWITCH_REQ_ACK type
        send_pattern = r'smf_sbi_send_sm_context_updated_data_n2smbuf'
        type_pattern = r'PATH_SWITCH_REQ_ACK'

        assert re.search(send_pattern, func_body) and re.search(type_pattern, func_body), (
            "VULNERABLE: smf_sbi_send_sm_context_updated_data_n2smbuf with PATH_SWITCH_REQ_ACK "
            "not found in ngap_handle_path_switch_request_transfer function.\n"
            "The fix must send N2 buffer with correct message type in the else branch."
        )


class TestMultipleScenarios:
    """
    Test multiple attack scenarios that could trigger the vulnerability.
    """

    def test_far_update_false_scenario_handled(self):
        """
        Verify far_update=false scenario is handled correctly.

        When memcmp shows no change in gnb_n3_ip and gnb_n3_teid is the same,
        far_update remains false. The fix must still send N2 signaling.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The far_update logic should still exist
        assert "far_update" in func_body, "far_update variable should exist"
        assert "gnb_n3_ip" in func_body, "gNB N3 IP comparison should exist"
        assert "gnb_n3_teid" in func_body, "gNB N3 TEID comparison should exist"

        # But the else branch should NOT have HTTP 204
        # Instead it should have the N2 buffer building

        # Find the specific pattern that shows the vulnerable code WITHIN this function
        # The vulnerable pattern is: else branch with ogs_sbi_send_http_status_no_content
        vulnerable_else_pattern = r'\}\s*else\s*\{[^}]*ogs_sbi_send_http_status_no_content'

        if re.search(vulnerable_else_pattern, func_body, re.DOTALL):
            pytest.fail(
                "VULNERABLE: The else branch after far_update check in "
                "ngap_handle_path_switch_request_transfer still contains "
                "ogs_sbi_send_http_status_no_content.\n"
                "This causes AMF crash on repeated PathSwitchRequest with same tunnel params."
            )

    def test_consecutive_same_tunnel_request_handled(self):
        """
        Verify consecutive PathSwitchRequest with same tunnel params is handled.

        Scenario: UE → gNodeB1 → gNodeB2 → gNodeB2 (same cell)
        The second switch to gNodeB2 keeps same tunnel params.
        """
        # This is implicitly tested by test_n2_buffer_built_in_else_branch
        # Here we add additional validation for the complete fix pattern
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # The complete fix pattern should include:
        # 1. ngap_build_path_switch_request_ack_transfer(sess)
        # 2. ogs_assert(n2smbuf)
        # 3. smf_sbi_send_sm_context_updated_data_n2smbuf with PATH_SWITCH_REQ_ACK

        required_patterns = [
            (r'ngap_build_path_switch_request_ack_transfer', "N2 buffer builder"),
            (r'smf_sbi_send_sm_context_updated_data_n2smbuf', "N2 buffer sender"),
            (r'PATH_SWITCH_REQ_ACK', "correct message type"),
        ]

        for pattern, desc in required_patterns:
            assert re.search(pattern, content), (
                f"VULNERABLE: Missing {desc} ({pattern}) in ngap-handler.c\n"
                "Complete fix requires all three components for proper N2 signaling."
            )

    def test_no_assertion_failure_pattern(self):
        """
        Verify n2smbuf is properly declared in the ngap_handle_path_switch_request_transfer function.

        The fix should declare n2smbuf in the else branch and assert it.
        This test FAILS in vulnerable code because n2smbuf is not declared
        in the vulnerable function's else branch.
        """
        ngap_handler = "/app/src/smf/ngap-handler.c"
        with open(ngap_handler, 'r') as f:
            content = f.read()

        # Find the ngap_handle_path_switch_request_transfer function
        func_pattern = r'int\s+ngap_handle_path_switch_request_transfer\s*\([^)]+\)\s*\{'
        func_match = re.search(func_pattern, content)
        assert func_match, "Function ngap_handle_path_switch_request_transfer not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start
        while brace_count > 0 and func_end < len(content):
            if content[func_end] == '{':
                brace_count += 1
            elif content[func_end] == '}':
                brace_count -= 1
            func_end += 1

        func_body = content[func_start:func_end]

        # The fix should have ogs_pkbuf_t *n2smbuf declaration in this function
        # followed by ogs_assert(n2smbuf)
        n2smbuf_decl_pattern = r'ogs_pkbuf_t\s*\*\s*n2smbuf\s*='
        n2smbuf_assert_pattern = r'ogs_assert\s*\(\s*n2smbuf\s*\)'

        assert re.search(n2smbuf_decl_pattern, func_body), (
            "VULNERABLE: ogs_pkbuf_t *n2smbuf declaration not found in "
            "ngap_handle_path_switch_request_transfer function.\n"
            "The fix must declare n2smbuf in the else branch."
        )

        assert re.search(n2smbuf_assert_pattern, func_body), (
            "VULNERABLE: ogs_assert(n2smbuf) not found in "
            "ngap_handle_path_switch_request_transfer function.\n"
            "The fix must validate the N2 buffer was built successfully."
        )
