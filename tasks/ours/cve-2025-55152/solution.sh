#!/bin/bash
# Solution script for Oak header parsing performance issue
# This fixes the inefficient regex patterns in request.ts

set -e
cd /app

echo "Applying fix to request.ts..."

# Backup original file
cp request.ts request.ts.backup 2>/dev/null || true

# Fix 1: Replace the vulnerable ips getter (lines 84-89)
# The original code uses: .split(/\s*,\s*/)
# which causes exponential backtracking with specially crafted input.
#
# The fix:
# - Bounds input to 4096 characters
# - Uses simple .split(",", 100) with entry limit
# - Trims whitespace with .map().filter()

# Fix 2: Replace the vulnerable x-forwarded-proto handling (lines 141-143)
# The original code uses: .split(/\s*,\s*/, 1)[0]
# which has the same regex issue, plus lacks protocol validation.
#
# The fix:
# - Uses simple .split(",", 1)[0].trim().toLowerCase()
# - Validates protocol is only "http" or "https"

# Create the fixed ips getter
IPS_GETTER_OLD='get ips(): string\[\] {
    return this.#proxy
      ? (this.#serverRequest.headers.get("x-forwarded-for") ??
        this.#getRemoteAddr()).split(/\\s\*,\\s\*/)
      : \[\];
  }'

IPS_GETTER_NEW='get ips(): string[] {
    return this.#proxy
      ? (() => {
        const raw = this.#serverRequest.headers.get("x-forwarded-for") ??
          this.#getRemoteAddr();
        const bounded = raw.length > 4096 ? raw.slice(0, 4096) : raw;
        return bounded
          .split(",", 100)
          .map((part) => part.trim())
          .filter((part) => part.length > 0);
      })()
      : [];
  }'

# Use Python to perform the replacements since sed struggles with multiline
python3 << 'PYTHON_EOF'
import re

with open('request.ts', 'r') as f:
    content = f.read()

# Fix 1: Replace ips getter
# Match the vulnerable pattern
old_ips_pattern = r'''get ips\(\): string\[\] \{
    return this\.#proxy
      \? \(this\.#serverRequest\.headers\.get\("x-forwarded-for"\) \?\?
        this\.#getRemoteAddr\(\)\)\.split\(/\\s\*,\\s\*/\)
      : \[\];
  \}'''

new_ips_getter = '''get ips(): string[] {
    return this.#proxy
      ? (() => {
        const raw = this.#serverRequest.headers.get("x-forwarded-for") ??
          this.#getRemoteAddr();
        const bounded = raw.length > 4096 ? raw.slice(0, 4096) : raw;
        return bounded
          .split(",", 100)
          .map((part) => part.trim())
          .filter((part) => part.length > 0);
      })()
      : [];
  }'''

content = re.sub(old_ips_pattern, new_ips_getter, content)

# Fix 2: Replace x-forwarded-proto handling
# Match the vulnerable pattern
old_proto_pattern = r'''if \(this\.#proxy\) \{
          proto = serverRequest
            \.headers\.get\("x-forwarded-proto"\)\?\.split\(/\\s\*,\\s\*/, 1\)\[0\] \?\?
            "http";'''

new_proto_handling = '''if (this.#proxy) {
          const xForwardedProto = serverRequest.headers.get(
            "x-forwarded-proto",
          );
          let maybeProto = xForwardedProto
            ? xForwardedProto.split(",", 1)[0].trim().toLowerCase()
            : undefined;
          if (maybeProto !== "http" && maybeProto !== "https") {
            maybeProto = undefined;
          }
          proto = maybeProto ?? "http";'''

content = re.sub(old_proto_pattern, new_proto_handling, content)

with open('request.ts', 'w') as f:
    f.write(content)

print("Replacements applied successfully")
PYTHON_EOF

# Verify the fix was applied
if grep -q 'split(",", 100)' request.ts && grep -q 'maybeProto !== "http"' request.ts; then
    echo "Fix verified: request.ts has been updated"
else
    echo "Fix verification failed"
    exit 1
fi

# Clear Deno's cache so it recompiles the modified TypeScript
echo "Clearing Deno cache..."
rm -rf /deno-dir/dep_analysis_cache_v2* 2>/dev/null || true
rm -rf /deno-dir/v8_code_cache_v2* 2>/dev/null || true
rm -rf /deno-dir/gen 2>/dev/null || true

# Recache the modules to pick up the fix
echo "Recaching modules..."
deno cache --reload mod.ts server.ts 2>/dev/null || true

# Kill the running server process to trigger restart
# The entrypoint will automatically restart the server
echo "Restarting server..."
# Find and kill the deno process - use /proc since pkill may not be available
for pid in $(ls /proc 2>/dev/null | grep -E '^[0-9]+$'); do
    if [ -f "/proc/$pid/cmdline" ]; then
        cmdline=$(cat "/proc/$pid/cmdline" 2>/dev/null | tr '\0' ' ')
        if echo "$cmdline" | grep -q "deno.*server.ts"; then
            echo "Killing deno process $pid"
            kill "$pid" 2>/dev/null || true
        fi
    fi
done

sleep 2

echo "Fix applied successfully!"
