"""
Vulnerability tests for FileBrowser Command Execution Scope Bypass.

These tests verify:
- FAIL in vulnerable state (command execution enabled, can access files outside scope)
- PASS in fixed state (command execution disabled by default)

The vulnerability allows users to execute commands that access files outside their
assigned scope by using absolute paths in command arguments.
"""

import pytest
import requests
import json
import time
import subprocess
import os

try:
    import websocket
except ImportError:
    websocket = None

# Configuration
BASE_URL = os.environ.get("FILEBROWSER_URL", "http://localhost:8080")
WS_URL = BASE_URL.replace("http://", "ws://").replace("https://", "wss://")
TEST_USER = "user1"
TEST_USER_PASS = "password123"
ADMIN_USER = "admin"
ADMIN_PASS = os.environ.get("ADMIN_PASSWORD", "admin")

# Test data locations (outside user1's scope)
OUTSIDE_SCOPE_FILE = "/srv/user2/private_file.txt"
DATABASE_SECRET_FILE = "/database/test_secret.txt"
USER_SCOPE = "/"  # Use root path for WebSocket - user scope is applied automatically


def get_auth_token(username=TEST_USER, password=TEST_USER_PASS):
    """Get JWT authentication token."""
    response = requests.post(
        f"{BASE_URL}/api/login",
        json={"username": username, "password": password},
        timeout=10
    )
    if response.status_code == 200:
        return response.text.strip('"')
    return None


def execute_command_via_websocket(token, command, path="/"):
    """Execute a command via WebSocket and return output."""
    if websocket is None:
        pytest.skip("websocket-client not installed")

    ws_path = f"{WS_URL}/api/command{path}"
    headers = [f"Cookie: auth={token}"]

    try:
        ws = websocket.create_connection(
            ws_path,
            header=headers,
            timeout=15
        )

        # Send command
        ws.send(command)

        # Collect output
        output_lines = []
        try:
            while True:
                result = ws.recv()
                if result:
                    output_lines.append(result)
        except websocket.WebSocketConnectionClosedException:
            pass
        except websocket.WebSocketTimeoutException:
            pass

        ws.close()
        return "\n".join(output_lines)
    except Exception as e:
        return f"ERROR: {str(e)}"


def check_command_execution_enabled(token):
    """Check if command execution is enabled on the server."""
    headers = {"X-Auth": token}

    # Try to access command endpoint
    # If it upgrades to WebSocket, commands are enabled
    # If it returns 403 or error, commands are disabled
    try:
        response = requests.get(
            f"{BASE_URL}/api/command/",
            headers=headers,
            timeout=5
        )
        # If we get here without WebSocket upgrade, feature might be disabled
        return response.status_code not in [403, 404, 501]
    except:
        return True  # Assume enabled if we can't determine


class TestVulnerabilityFixed:
    """
    Tests that verify the vulnerability is fixed.
    These tests should PASS after the fix is applied.
    """

    def test_command_execution_disabled_by_default(self):
        """
        Test that command execution is disabled by default after fix.

        After the fix, the --disable-exec flag defaults to true,
        meaning command execution should be disabled unless explicitly enabled.
        """
        token = get_auth_token()
        if token is None:
            token = get_auth_token(ADMIN_USER, ADMIN_PASS)

        if token is None:
            pytest.skip("Could not authenticate")

        # Try to access command execution endpoint
        # After fix, this should fail or be disabled
        headers = {"X-Auth": token}

        if websocket is None:
            pytest.skip("websocket-client not installed")

        ws_path = f"{WS_URL}/api/command{USER_SCOPE}"

        try:
            ws = websocket.create_connection(
                ws_path,
                header=[f"Cookie: auth={token}"],
                timeout=10
            )

            # If connection succeeded, try to send command
            # Use an allowed command (ls) to check if exec is actually enabled
            ws.send("ls /")

            try:
                result = ws.recv()
                ws.close()

                # If we got here and received output, command execution is enabled
                # After fix, this should not happen by default
                # The test passes if command execution is blocked
                if "command execution is disabled" in result.lower() or "not allowed" in result.lower():
                    return  # Pass - commands are disabled

                # If the command returned file listing (bin, etc, usr, etc), exec is enabled
                if any(x in result for x in ["bin", "etc", "usr", "srv"]):
                    pytest.fail(
                        "Command execution should be disabled by default after fix. "
                        f"Received directory listing: {result}"
                    )

                # If we got actual command output, the vulnerability still exists
                pytest.fail(
                    "Command execution should be disabled by default after fix. "
                    f"Received output: {result}"
                )
            except websocket.WebSocketConnectionClosedException:
                # Connection closed - likely commands disabled
                pass
            except websocket.WebSocketTimeoutException:
                # Timeout - commands might be disabled
                pass

        except websocket.WebSocketException as e:
            # WebSocket connection failed - commands likely disabled
            pass
        except Exception as e:
            # Other error - commands might be disabled
            if "403" in str(e) or "forbidden" in str(e).lower():
                pass  # Commands disabled - test passes
            else:
                # For other errors, we need to check if it's because commands are disabled
                pass

    def test_cannot_read_files_outside_scope_cat(self):
        """
        Test that cat command cannot read files outside user scope.
        After fix: command execution disabled, this should fail.
        """
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Attempt to read file outside scope using cat
        output = execute_command_via_websocket(
            token,
            f"cat {OUTSIDE_SCOPE_FILE}",
            USER_SCOPE
        )

        # After fix, command execution should be disabled
        # So either error or the secret content should NOT appear
        assert "SECRET_DATA_USER2_PRIVATE" not in output, \
            f"Should not be able to read files outside scope. Got: {output}"

    def test_cannot_read_database_files(self):
        """
        Test that cat command cannot read database files.
        After fix: command execution disabled, should fail.
        """
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Attempt to read database directory file
        output = execute_command_via_websocket(
            token,
            f"cat {DATABASE_SECRET_FILE}",
            USER_SCOPE
        )

        # After fix, this should fail
        assert "DATABASE_SECRET_CONTENT" not in output, \
            f"Should not be able to read database files. Got: {output}"

    def test_cannot_grep_entire_filesystem(self):
        """
        Test that grep cannot search files outside user scope.
        After fix: command execution disabled, should fail.
        """
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Attempt to grep across filesystem
        output = execute_command_via_websocket(
            token,
            'grep -r "SECRET" /srv/',
            USER_SCOPE
        )

        # After fix, this should fail
        assert "SECRET_DATA_USER2_PRIVATE" not in output, \
            f"Should not be able to grep outside scope. Got: {output}"

    def test_cannot_list_other_user_directories(self):
        """
        Test that ls cannot list directories outside user scope.
        After fix: command execution disabled, should fail.
        """
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Attempt to list another user's directory
        output = execute_command_via_websocket(
            token,
            "ls -la /srv/user2/",
            USER_SCOPE
        )

        # After fix, this should fail
        assert "private_file.txt" not in output, \
            f"Should not be able to list other user directories. Got: {output}"

    def test_cannot_read_etc_passwd(self):
        """
        Test that commands cannot read sensitive system files.
        After fix: command execution disabled, should fail.
        """
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Attempt to read /etc/passwd
        output = execute_command_via_websocket(
            token,
            "cat /etc/passwd",
            USER_SCOPE
        )

        # After fix, this should fail
        assert "root:" not in output, \
            f"Should not be able to read system files. Got: {output}"


class TestMultipleAttackVectors:
    """
    Test various attack vectors and bypass techniques.
    These tests demonstrate the vulnerability exists by showing
    that command execution can access files outside scope.
    All should FAIL in vulnerable state (because attacks succeed).
    """

    def test_path_traversal_via_absolute_path(self):
        """Test that absolute paths bypass scope restriction."""
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Direct absolute path access - the core vulnerability
        output = execute_command_via_websocket(
            token,
            f"cat {OUTSIDE_SCOPE_FILE}",
            USER_SCOPE
        )

        # In vulnerable state: this succeeds, so test FAILS
        # In fixed state: command execution disabled, so test PASSES
        assert "SECRET_DATA_USER2_PRIVATE" not in output, \
            f"Absolute path access should be blocked. Got: {output}"

    def test_relative_traversal_outside_scope(self):
        """Test path traversal with relative paths from working directory."""
        token = get_auth_token()
        if token is None:
            pytest.skip("Could not authenticate")

        # Try relative path traversal from user's scope (/srv/user1)
        # ../user2 should reach /srv/user2
        output = execute_command_via_websocket(
            token,
            "cat ../user2/private_file.txt",
            USER_SCOPE
        )

        # In vulnerable state: relative paths also work to access files
        assert "SECRET_DATA_USER2_PRIVATE" not in output, \
            f"Relative path traversal should be blocked. Got: {output}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
