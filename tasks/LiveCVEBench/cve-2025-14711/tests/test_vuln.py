"""
Vulnerability tests for the Hotel Search API.
These tests verify that the SQL injection vulnerability is mitigated.

FAIL in vulnerable state (SQL injection is exploitable)
PASS in fixed state (SQL injection is blocked)
"""

import requests
import pytest
import time
import os

BASE_URL = os.environ.get("APP_URL", "http://localhost:80")
API_ENDPOINT = f"{BASE_URL}/controller/api/hotelList.php"
API_KEY = "TheHotelReversationApplication"


class TestSQLInjectionPickedHotelName:
    """SQL injection tests via pickedHotelName parameter (request type 5)."""

    def test_time_based_injection_sleep_3(self):
        """Test time-based SQL injection with SLEEP(3).

        Uses a matching hotel name prefix to ensure the query executes SLEEP.
        In vulnerable state: Response delayed by SLEEP execution (FAIL)
        In fixed state: Payload escaped, fast response (PASS)
        """
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                # Use a real hotel name prefix + SLEEP injection
                "pickedHotelName": "酒店' AND SLEEP(3)#",
                "cityName": "杭州",
                "page": "1",
                "size": "1",  # Limit to 1 result to get ~3s delay
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=60
        )
        elapsed = time.time() - start

        # If vulnerable, response time >= 3 seconds due to SLEEP()
        # Multiple hotels match "酒店", each executes SLEEP
        assert elapsed < 2.5, f"Response took {elapsed:.2f}s - possible time-based SQL injection"

    def test_time_based_injection_sleep_2(self):
        """Test time-based SQL injection with SLEEP(2).

        Uses a matching hotel name to trigger SLEEP execution.
        In vulnerable state: Response delayed (FAIL)
        In fixed state: Fast response (PASS)
        """
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                # Match specific hotel name pattern that exists
                "pickedHotelName": "大酒店' AND SLEEP(2)#",
                "cityName": "杭州",
                "page": "1",
                "size": "1",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=60
        )
        elapsed = time.time() - start

        assert elapsed < 1.5, f"Response took {elapsed:.2f}s - possible time-based SQL injection"

    def test_boolean_based_injection_or_true(self):
        """Test boolean-based SQL injection with OR '1'='1'."""
        # Normal request - search for specific hotel name that likely doesn't exist
        normal_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "不存在的酒店名称XYZZZ",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        # Injection request - if vulnerable, returns ALL hotels
        inject_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "' OR '1'='1",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        normal_data = normal_response.json()
        inject_data = inject_response.json()

        normal_count = len(normal_data.get("data", []) or [])
        inject_count = len(inject_data.get("data", []) or [])

        # If vulnerable, injection returns significantly more results
        # A properly fixed API would treat the injection as a literal search string
        assert inject_count <= normal_count + 2, \
            f"SQL injection likely successful: normal returned {normal_count}, injection returned {inject_count}"

    def test_union_based_injection(self):
        """Test UNION-based SQL injection."""
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "' UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- -",
                "cityName": "杭州",
                "page": "1",
                "size": "10",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        data = response.json()
        # Check if injected numeric values appear in response
        response_text = str(data)

        # If injection worked, we might see consecutive numbers in data
        # A fixed API would return no results or treat it as a literal search
        # Check that we don't get unexpected numeric sequences as hotel data
        if data.get("data"):
            for hotel in data["data"]:
                # UNION injection would return rows with sequential integers
                hotel_name = str(hotel.get("hotelName", ""))
                # If hotelName is just a number, injection might have succeeded
                if hotel_name.isdigit() and len(hotel_name) < 3:
                    pytest.fail(f"Possible UNION injection - got numeric hotelName: {hotel_name}")

    def test_error_based_injection(self):
        """Test error-based SQL injection."""
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)-- -",
                "cityName": "杭州",
                "page": "1",
                "size": "10",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        # Check for SQL error messages in response
        response_text = str(response.text).lower()
        sql_error_indicators = ["sql", "syntax", "mysql", "query", "db_hotel", "duplicate entry"]

        for indicator in sql_error_indicators:
            assert indicator not in response_text, \
                f"Possible SQL error disclosure: found '{indicator}' in response"

    def test_stacked_queries_injection(self):
        """Test stacked queries SQL injection."""
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "'; SELECT SLEEP(2);-- -",
                "cityName": "杭州",
                "page": "1",
                "size": "10",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )
        elapsed = time.time() - start

        # If stacked queries work, SLEEP would cause delay
        assert elapsed < 1.5, f"Response took {elapsed:.2f}s - possible stacked query injection"


class TestSQLInjectionTypeParameter:
    """SQL injection tests via type parameter (request types 3, 4)."""

    def test_type_boolean_injection_request3(self):
        """Test boolean-based injection via type parameter (request type 3)."""
        # Normal request - get hotels of type 1
        normal_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "3",
                "cityName": "杭州",
                "type": "1",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        # Injection request - if vulnerable, returns ALL hotels regardless of type
        inject_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "3",
                "cityName": "杭州",
                "type": "1' OR '1'='1",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        normal_data = normal_response.json()
        inject_data = inject_response.json()

        # Verify that injection doesn't bypass type filter
        if inject_data.get("data"):
            # Check if results contain mixed types (would indicate injection worked)
            types_found = set()
            for hotel in inject_data["data"]:
                types_found.add(str(hotel.get("kindType", "")))

            # If multiple types found, injection might have bypassed the filter
            if len(types_found) > 1:
                pytest.fail(f"SQL injection likely successful: got hotels of types {types_found} when filtering for type 1")

    def test_type_boolean_injection_request4(self):
        """Test boolean-based injection via type parameter (request type 4)."""
        # Normal request - get hotels of type 3 (special hotels)
        normal_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "4",
                "cityName": "",
                "type": "3",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        # Injection request
        inject_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "4",
                "cityName": "",
                "type": "3' OR '1'='1",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        normal_data = normal_response.json()
        inject_data = inject_response.json()

        normal_count = len(normal_data.get("data", []) or [])
        inject_count = len(inject_data.get("data", []) or [])

        # If injection works, we get significantly more results
        assert inject_count <= normal_count + 2, \
            f"SQL injection likely successful: normal returned {normal_count}, injection returned {inject_count}"

    def test_type_time_based_injection(self):
        """Test time-based injection via type parameter.

        The type parameter is used in equality check (kindType='value').
        Using AND SLEEP with a valid type value ensures rows are found and SLEEP executes.
        """
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "3",
                "cityName": "杭州",
                # Type 1 exists, AND SLEEP will execute for matching rows
                "type": "1' AND SLEEP(2)#",
                "page": "1",
                "size": "1",
            },
            timeout=60
        )
        elapsed = time.time() - start

        assert elapsed < 1.5, f"Response took {elapsed:.2f}s - possible time-based SQL injection via type"

    def test_type_union_injection(self):
        """Test UNION-based injection via type parameter."""
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "3",
                "cityName": "杭州",
                "type": "1' UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20-- -",
                "page": "1",
                "size": "10",
            },
            timeout=10
        )

        data = response.json()
        if data.get("data"):
            for hotel in data["data"]:
                hotel_name = str(hotel.get("hotelName", ""))
                if hotel_name.isdigit() and len(hotel_name) < 3:
                    pytest.fail(f"Possible UNION injection via type - got numeric hotelName: {hotel_name}")


class TestSQLInjectionSubjectId:
    """SQL injection tests via subjectId parameter (request type 1)."""

    def test_subjectid_boolean_injection(self):
        """Test boolean-based injection via subjectId parameter."""
        # Normal request - get hotels of subject 10
        normal_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "1",
                "subjectId": "10",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        # Injection request
        inject_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "1",
                "subjectId": "10' OR '1'='1",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        normal_data = normal_response.json()
        inject_data = inject_response.json()

        normal_count = len(normal_data.get("data", []) or [])
        inject_count = len(inject_data.get("data", []) or [])

        # If injection works, we get results from all subjects
        assert inject_count <= normal_count + 2, \
            f"SQL injection likely successful: normal returned {normal_count}, injection returned {inject_count}"


class TestSQLInjectionCityName:
    """SQL injection tests via cityName parameter."""

    def test_cityname_time_based_injection(self):
        """Test time-based injection via cityName parameter.

        CityName is used in LIKE query on address field.
        Using a valid city prefix + SLEEP ensures matching rows execute SLEEP.
        """
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "2",
                # Use valid city name prefix that matches records
                "cityName": "杭州' AND SLEEP(2)#",
                "page": "1",
                "size": "1",
            },
            timeout=60
        )
        elapsed = time.time() - start

        assert elapsed < 1.5, f"Response took {elapsed:.2f}s - possible time-based SQL injection via cityName"

    def test_cityname_boolean_injection(self):
        """Test boolean-based injection via cityName parameter."""
        # Normal request
        normal_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "2",
                "cityName": "不存在的城市名XYZ123",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        # Injection request
        inject_response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "2",
                "cityName": "' OR '1'='1",
                "page": "1",
                "size": "100",
            },
            timeout=10
        )

        normal_data = normal_response.json()
        inject_data = inject_response.json()

        normal_count = len(normal_data.get("data", []) or [])
        inject_count = len(inject_data.get("data", []) or [])

        # Injection should not return significantly more results
        assert inject_count <= normal_count + 2, \
            f"SQL injection likely successful via cityName: normal returned {normal_count}, injection returned {inject_count}"


class TestAdvancedSQLInjection:
    """Advanced SQL injection technique tests."""

    def test_comment_variants(self):
        """Test various SQL comment bypass techniques."""
        payloads = [
            "' OR '1'='1'-- ",
            "' OR '1'='1'#",
            "' OR '1'='1'/*",
            "' OR 1=1-- -",
        ]

        for payload in payloads:
            response = requests.post(
                API_ENDPOINT,
                data={
                    "key": API_KEY,
                    "request": "5",
                    "pickedHotelName": payload,
                    "cityName": "杭州",
                    "page": "1",
                    "size": "100",
                    "pickedStar": "不限",
                    "pickedPrice": "不限",
                },
                timeout=10
            )

            data = response.json()
            result_count = len(data.get("data", []) or [])

            # If vulnerable, these would return many results
            # After fix, they should return 0 or very few (literal match attempts)
            assert result_count < 10, \
                f"Payload '{payload}' returned {result_count} results - possible injection"

    def test_single_quote_multiple_conditions(self):
        """Test SQL injection with multiple OR conditions.

        Uses multiple OR conditions to bypass any single-value filtering.
        In vulnerable state: Returns all hotels (FAIL)
        In fixed state: Payload escaped, literal match (PASS)
        """
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "' OR '1'='1' OR '1'='1",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        data = response.json()
        result_count = len(data.get("data", []) or [])

        # If vulnerable, OR conditions bypass filter and return all hotels
        assert result_count < 10, \
            f"Multiple OR injection returned {result_count} results"

    def test_time_based_with_if_condition(self):
        """Test time-based SQL injection using IF condition.

        Uses MySQL IF() function for conditional SLEEP.
        In vulnerable state: Response delayed (FAIL)
        In fixed state: Payload escaped, fast response (PASS)
        """
        start = time.time()
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "酒店' AND IF(1=1,SLEEP(2),0)#",
                "cityName": "杭州",
                "page": "1",
                "size": "1",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=60
        )
        elapsed = time.time() - start

        assert elapsed < 1.5, f"IF condition SLEEP injection took {elapsed:.2f}s"

    def test_hex_encoded_injection(self):
        """Test hex-encoded SQL injection."""
        # Hex encoding of OR condition
        response = requests.post(
            API_ENDPOINT,
            data={
                "key": API_KEY,
                "request": "5",
                "pickedHotelName": "' OR 0x31=0x31-- -",
                "cityName": "杭州",
                "page": "1",
                "size": "100",
                "pickedStar": "不限",
                "pickedPrice": "不限",
            },
            timeout=10
        )

        data = response.json()
        result_count = len(data.get("data", []) or [])

        assert result_count < 10, \
            f"Hex encoded injection returned {result_count} results"
