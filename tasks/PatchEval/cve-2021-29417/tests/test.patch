diff --git a/internal/pkg/gitjacker/retriever_test.go b/internal/pkg/gitjacker/retriever_test.go
new file mode 100644
index 0000000..d3ed35c
--- /dev/null
+++ b/internal/pkg/gitjacker/retriever_test.go
@@ -0,0 +1,144 @@
+package gitjacker
+
+import (
+	"fmt"
+	"io/ioutil"
+	"net/http"
+	"net/url"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"testing"
+)
+
+type vulnerableServer struct {
+	dir    string
+	server *http.Server
+}
+
+func newVulnerableServer() (*vulnerableServer, error) {
+
+	dir, err := ioutil.TempDir(os.TempDir(), "gjtest_server")
+	if err != nil {
+		return nil, err
+	}
+
+	cmd := exec.Command("git", "init")
+	cmd.Dir = dir
+	if err := cmd.Run(); err != nil {
+		return nil, err
+	}
+
+	f, err := os.OpenFile(filepath.Join(dir, ".git", "config"), os.O_APPEND|os.O_WRONLY, os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	defer func() { _ = f.Close() }()
+
+	if _, err := f.WriteString(`
+[user]
+	email = test@test.com
+	name = test
+`); err != nil {
+		return nil, err
+	}
+
+	fs := http.FileServer(http.Dir(dir))
+
+	return &vulnerableServer{
+		dir: dir,
+		server: &http.Server{
+			Addr:    "127.0.0.1:9999",
+			Handler: fs,
+		},
+	}, nil
+}
+
+func (v *vulnerableServer) Listen() error {
+	return v.server.ListenAndServe()
+}
+
+func (v *vulnerableServer) Addr() string {
+	return v.server.Addr
+}
+
+func (v *vulnerableServer) Close() error {
+	if err := os.RemoveAll(v.dir); err != nil {
+		return err
+	}
+	return v.server.Close()
+}
+
+func (v *vulnerableServer) writeFile(path, content string) error {
+	return ioutil.WriteFile(filepath.Join(v.dir, path), []byte(content), 0644)
+}
+
+func (v *vulnerableServer) commit(msg string) error {
+	cmd := exec.Command("git", "add", ".")
+	cmd.Dir = v.dir
+	if err := cmd.Run(); err != nil {
+		return err
+	}
+
+	commitCmd := exec.Command("git", "commit", "-a", "-m", msg)
+	commitCmd.Dir = v.dir
+	return commitCmd.Run()
+}
+
+func TestDownloadFile_PathTraversal(t *testing.T) {
+	// Start a mock server with a .git directory
+	server, err := newVulnerableServer()
+	if err != nil {
+		t.Fatal(err)
+	}
+	go func() { _ = server.Listen() }()
+	defer func() { _ = server.Close() }()
+
+	// Prepare test environment: make sure the server can serve a file that the malicious path will try to access
+	// URL "../pwned.txt" resolves to "pwned.txt" at the server root.
+	if err := server.writeFile("pwned.txt", "content for pwned.txt"); err != nil {
+		t.Fatal(err)
+	}
+	// Optional: commit file to make server state more realistic; not required for this test
+	// if err := server.commit("add pwned.txt for traversal test"); err != nil {
+	// 	t.Fatal(err)
+	// }
+
+	target, err := url.Parse(fmt.Sprintf("http://%s", server.Addr()))
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	// Output directory
+	outputDir, err := ioutil.TempDir(os.TempDir(), "gjtest_out_pathtraversal")
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer func() { _ = os.RemoveAll(outputDir) }()
+
+	// Create retriever instance (assumes New initializes fields like r.downloaded, r.http)
+	r := New(target, outputDir)
+
+	// Use malicious path attempting to escape the .git directory
+	maliciousPath := "../pwned.txt"
+
+	// Call the function under test
+	// Focus is on side effects, not return value
+	_ = r.downloadFile(maliciousPath)
+
+	// Check if file was incorrectly written outside .git directory
+	pwnedFileOutsideGit := filepath.Join(outputDir, "pwned.txt")
+	if _, statErr := os.Stat(pwnedFileOutsideGit); statErr == nil {
+		// If the file exists at outputDir/pwned.txt, it indicates a path traversal vulnerability
+		t.Fatalf("Path traversal vulnerability detected: File was written outside the .git directory at %s", pwnedFileOutsideGit)
+	}
+
+	// For fixed code, pwnedFileOutsideGit should not exist
+	// Optional: verify file is correctly written inside outputDir/.git
+	// fixedPathInsideGit := filepath.Join(outputDir, ".git", "pwned.txt") // expected path after fix
+	// if _, statErr := os.Stat(fixedPathInsideGit); os.IsNotExist(statErr) {
+	//    // For fixed code, if the file doesn't exist here, it may indicate another part of the download logic failed
+	//    // or path sanitization behaves differently
+	// 	  t.Logf("Note: Fixed code did not create file at expected location %s, or downloadFile returned an error earlier.", fixedPathInsideGit)
+	// }
+}
