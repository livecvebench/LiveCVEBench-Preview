diff --git a/poc/flag.html b/poc/flag.html
new file mode 100644
index 0000000..9586564
--- /dev/null
+++ b/poc/flag.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<h1>CISPA</h1>
+<p>vulns4js! is here.</p>
+
+</body>
+</html> 
\ No newline at end of file
diff --git a/poc/mcstatic.test.js b/poc/mcstatic.test.js
new file mode 100644
index 0000000..e15a922
--- /dev/null
+++ b/poc/mcstatic.test.js
@@ -0,0 +1,99 @@
+// tests/mcstatic.path-traversal.test.js
+const { exec, spawn, execSync } = require('child_process');
+const fs = require('fs');
+const path = require('path');
+const http = require('http');
+
+const pathToFlag = path.resolve(__dirname, './flag.html');
+
+function genstr() {
+  return '/..'.repeat(50) + pathToFlag;
+}
+
+afterAll(() => {
+  // best-effort cleanup of any process listening on 8080
+  try {
+    execSync('fuser -k 8080/tcp');
+  } catch (e) {
+    // ignore
+  }
+});
+
+test('Path traversal should NOT leak file contents (fix should make this pass)', (done) => {
+  expect.assertions(1);
+
+  // prepare a known flag file
+  const flagContent =
+    '<!DOCTYPE html>\n<html>\n<body>\n\n<h1>CISPA</h1>\n<p>vulns4js! is here.</p>\n\n</body>\n</html>';
+  fs.writeFileSync(pathToFlag, flagContent, 'utf8');
+
+  // start mcstatic server as a child process
+  // adjust the command if the actual executable path is different
+  const serverProcess = exec('node ./bin/mcstatic', { cwd: process.cwd() });
+
+  let serverStarted = false;
+  const startupTimer = setTimeout(() => {
+    // proceed after wait (server should be listening by now)
+    serverStarted = true;
+
+    const options = {
+      hostname: '127.0.0.1',
+      port: 8080,
+      path: genstr(),
+      method: 'GET',
+    };
+
+    const req = http.request(options, (res) => {
+      let body = '';
+      res.setEncoding('utf8');
+      res.on('data', (chunk) => (body += chunk));
+      res.on('end', () => {
+        // cleanup
+        try {
+          serverProcess.kill();
+        } catch (e) {}
+        try {
+          if (fs.existsSync(pathToFlag)) fs.unlinkSync(pathToFlag);
+        } catch (e) {}
+
+        // EXPECTATION:
+        // - If the server is vulnerable (before fix) it will return the flag content and this will FAIL.
+        // - After the fix (no path traversal) the server will not return the flag content and this will PASS.
+        expect(body).not.toBe(flagContent);
+
+        done();
+      });
+    });
+
+    req.on('error', (err) => {
+      // cleanup and propagate the error so the test fails (server did not respond)
+      try {
+        serverProcess.kill();
+      } catch (e) {}
+      try {
+        if (fs.existsSync(pathToFlag)) fs.unlinkSync(pathToFlag);
+      } catch (e) {}
+      done(err);
+    });
+
+    req.end();
+  }, 2000); // wait 2 seconds for server to start
+
+  // guard: if the server exits early, fail fast
+  serverProcess.on('exit', (code, signal) => {
+    if (!serverStarted) {
+      clearTimeout(startupTimer);
+      try {
+        if (fs.existsSync(pathToFlag)) fs.unlinkSync(pathToFlag);
+      } catch (e) {}
+      done(new Error(`server exited prematurely (code=${code}, signal=${signal})`));
+    }
+  });
+
+  // capture and log server stderr for debugging if needed
+  serverProcess.stderr && serverProcess.stderr.on('data', (d) => {
+    // keep logs out of tests by default; uncomment to debug
+    // console.error(d.toString());
+  });
+});
+
