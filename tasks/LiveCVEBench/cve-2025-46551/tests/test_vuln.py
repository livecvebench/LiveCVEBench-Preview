#!/usr/bin/env python3
"""
Vulnerability tests for JRuby SSL/TLS hostname verification bypass (CVE-2025-46551).

These tests verify that the vulnerability EXISTS in the vulnerable state.

Expected behavior:
- FAIL in vulnerable state: The vulnerability is exploitable, so security checks fail
- PASS in fixed state: The vulnerability is mitigated, security checks pass

The tests check that hostname verification is working correctly.
In the vulnerable state, hostname verification is DISABLED (verify_hostname is nil),
so connections to mismatched hostnames succeed when they should fail.
"""

import subprocess
import pytest


class TestHostnameVerificationEnabled:
    """Tests that check if hostname verification is enabled (should FAIL when vulnerable)."""

    def test_verify_hostname_is_true(self):
        """
        Test that verify_hostname is set to true in DEFAULT_PARAMS.

        PASS: verify_hostname is true (fixed)
        FAIL: verify_hostname is nil (vulnerable)
        """
        script = '''
require 'openssl'
val = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:verify_hostname]
if val == true
  puts "PATCHED: verify_hostname is true"
  exit 0
elsif val.nil?
  puts "VULNERABLE: verify_hostname is nil (disabled)"
  exit 1
else
  puts "UNKNOWN: verify_hostname is #{val.inspect}"
  exit 2
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"Hostname verification disabled (vulnerable): {result.stdout}\n{result.stderr}"

    def test_ssl_context_set_params_enables_hostname_verification(self):
        """
        Test SSLContext with set_params properly enables hostname verification.

        PASS: set_params enables verify_hostname (fixed)
        FAIL: set_params leaves verify_hostname disabled (vulnerable)
        """
        script = '''
require 'openssl'

ctx = OpenSSL::SSL::SSLContext.new
ctx.set_params

if ctx.verify_hostname == true
  puts "PATCHED: SSLContext.verify_hostname is true after set_params"
  exit 0
else
  puts "VULNERABLE: SSLContext.verify_hostname is #{ctx.verify_hostname.inspect} after set_params"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"SSLContext vulnerable: {result.stdout}\n{result.stderr}"


class TestHostnameMismatchRejected:
    """Tests that verify hostname verification is enabled by checking DEFAULT_PARAMS.

    Note: Network-based tests to external hosts like bad.substitutealert.com are
    unreliable because network errors cause false passes. Instead, we focus on
    checking the configuration directly, which is the root cause of the vulnerability.
    """

    def test_verify_hostname_in_default_params(self):
        """
        Test that verify_hostname is set to true in DEFAULT_PARAMS.

        The vulnerability exists because verify_hostname was nil (disabled) in DEFAULT_PARAMS.
        This is the direct check for whether the vulnerability is present.

        PASS: verify_hostname is true (fixed)
        FAIL: verify_hostname is nil/false (vulnerable)
        """
        script = '''
require 'openssl'
val = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:verify_hostname]
puts "DEFAULT_PARAMS[:verify_hostname] = #{val.inspect}"
if val == true
  puts "PATCHED: verify_hostname is enabled by default"
  exit 0
else
  puts "VULNERABLE: verify_hostname is #{val.inspect} (should be true)"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"Hostname verification disabled (vulnerable): {result.stdout}\n{result.stderr}"

    def test_ssl_context_verify_hostname_after_set_params(self):
        """
        Test that SSLContext.verify_hostname is true after calling set_params.

        When set_params is called, it applies DEFAULT_PARAMS to the context.
        If verify_hostname is nil in DEFAULT_PARAMS, it will be nil in the context.

        PASS: verify_hostname is true after set_params (fixed)
        FAIL: verify_hostname is nil/false after set_params (vulnerable)
        """
        script = '''
require 'openssl'

ctx = OpenSSL::SSL::SSLContext.new
ctx.set_params

val = ctx.verify_hostname
puts "After set_params, ctx.verify_hostname = #{val.inspect}"
if val == true
  puts "PATCHED: SSLContext has hostname verification enabled"
  exit 0
else
  puts "VULNERABLE: SSLContext.verify_hostname is #{val.inspect}"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"SSLContext verify_hostname not enabled (vulnerable): {result.stdout}\n{result.stderr}"

    def test_net_http_would_verify_hostname(self):
        """
        Test that Net::HTTP would perform hostname verification based on defaults.

        This checks the underlying mechanism that Net::HTTP uses. When verify_hostname
        is true in DEFAULT_PARAMS, Net::HTTP will verify hostnames automatically.

        PASS: Default configuration includes hostname verification (fixed)
        FAIL: Default configuration does not include hostname verification (vulnerable)
        """
        script = '''
require 'openssl'

# Check both the raw DEFAULT_PARAMS value and what an SSLContext gets
default_val = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:verify_hostname]
ctx = OpenSSL::SSL::SSLContext.new
ctx.set_params
ctx_val = ctx.verify_hostname

puts "DEFAULT_PARAMS[:verify_hostname] = #{default_val.inspect}"
puts "SSLContext.verify_hostname after set_params = #{ctx_val.inspect}"

if default_val == true && ctx_val == true
  puts "PATCHED: Net::HTTP would verify hostnames automatically"
  exit 0
else
  puts "VULNERABLE: Net::HTTP would NOT verify hostnames"
  puts "This allows man-in-the-middle attacks with valid certificates for other domains"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"Net::HTTP hostname verification disabled (vulnerable): {result.stdout}\n{result.stderr}"


class TestVulnerableVersion:
    """Tests to verify the fix has been applied."""

    def test_jruby_openssl_fix_applied(self):
        """
        Verify that the hostname verification fix has been applied.

        This test checks if verify_hostname is set to true in DEFAULT_PARAMS,
        which indicates the fix has been applied (either through patching 0.15.3
        or by upgrading to 0.15.4+).

        This test FAILS in vulnerable state (verify_hostname is nil)
        This test PASSES in fixed state (verify_hostname is true)
        """
        script = '''
require 'openssl'
version = JOpenSSL::VERSION
verify_hostname = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:verify_hostname]
puts "JOpenSSL VERSION: #{version}"
puts "verify_hostname: #{verify_hostname.inspect}"

# The fix sets verify_hostname to true
# This works whether we patched 0.15.3 in-place or upgraded to 0.15.4+
if verify_hostname == true
  puts "PATCHED: Hostname verification is enabled by default"
  exit 0
else
  puts "VULNERABLE: Hostname verification is disabled (#{verify_hostname.inspect})"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        print(f"JOpenSSL fix check: {result.stdout.strip()}")
        assert result.returncode == 0, f"Fix not applied: {result.stdout}\n{result.stderr}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
