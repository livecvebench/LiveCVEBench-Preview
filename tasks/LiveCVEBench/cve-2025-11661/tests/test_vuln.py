#!/usr/bin/env python3
"""
Vulnerability tests for School Management System.

These tests verify that unauthenticated access to data-modifying endpoints
is properly blocked.

- FAIL when vulnerable (unauthenticated access allowed)
- PASS when fixed (unauthenticated access blocked with 401)
"""

import pytest
import requests
import time
import os
import random
import string

BASE_URL = os.environ.get("APP_URL", "http://localhost")


def wait_for_app():
    """Wait for the application to be ready."""
    max_retries = 15
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/", timeout=10)
            if response.status_code in [200, 302]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


@pytest.fixture(scope="module", autouse=True)
def ensure_app_ready():
    """Ensure the application is ready before running tests."""
    assert wait_for_app(), "Application not ready"


class TestUnauthenticatedEditSubject:
    """Test that editSubject.php requires authentication."""

    def test_unauthenticated_edit_basic(self):
        """Basic test: unauthenticated POST to editSubject.php should be blocked."""
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "UNAUTHORIZED_EDIT",
                "subject_id": "12c6672ac911a253"
            },
            timeout=10
        )

        # After fix: should return 401 Unauthorized
        # Before fix: returns 200 with "success" or "Unable to edit"
        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated access allowed! Status: {response.status_code}, Response: {response.text}"

    def test_unauthenticated_edit_with_different_content_type(self):
        """Test with different content type header."""
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "HACKED_SUBJECT",
                "subject_id": "12c6672ac9c45d68"
            },
            headers={"Content-Type": "application/x-www-form-urlencoded"},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated access allowed with explicit content-type! Response: {response.text}"

    def test_unauthenticated_edit_with_multipart(self):
        """Test with multipart form data."""
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            files={
                "subject": (None, "MULTIPART_ATTACK"),
                "subject_id": (None, "12c6672aca78c3c7")
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated multipart access allowed! Response: {response.text}"

    def test_unauthenticated_edit_with_empty_cookie(self):
        """Test with empty session cookie."""
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "EMPTY_COOKIE_ATTACK",
                "subject_id": "12c6672ac911a253"
            },
            cookies={"PHPSESSID": ""},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Access allowed with empty session cookie! Response: {response.text}"

    def test_unauthenticated_edit_with_invalid_session(self):
        """Test with forged/invalid session ID."""
        fake_session_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=26))

        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "FORGED_SESSION_ATTACK",
                "subject_id": "12c6672ac911a253"
            },
            cookies={"PHPSESSID": fake_session_id},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Access allowed with forged session! Response: {response.text}"


class TestUnauthenticatedAddSubject:
    """Test that addSubject.php requires authentication."""

    def test_unauthenticated_add_basic_json(self):
        """Test unauthenticated JSON POST to addSubject.php."""
        unique_subject = f"UNAUTH_ADD_{random.randint(10000, 99999)}"

        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": unique_subject,
                "class": "99"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated add allowed! Response: {response.text}"

    def test_unauthenticated_add_existing_subject(self):
        """Test adding a subject that already exists."""
        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": "Hindi",
                "class": "12c"
            },
            timeout=10
        )

        # Should be blocked before checking if subject exists
        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated access allowed even for existing subject! Response: {response.text}"

    def test_unauthenticated_add_with_special_characters(self):
        """Test with special characters in subject name."""
        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": "Test<script>alert(1)</script>",
                "class": "10"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated add with special chars allowed! Response: {response.text}"

    def test_unauthenticated_add_with_invalid_session(self):
        """Test with forged session cookie."""
        fake_session_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=26))

        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": "FORGED_SESSION_ADD",
                "class": "10"
            },
            cookies={"PHPSESSID": fake_session_id},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Add allowed with forged session! Response: {response.text}"


class TestUnauthenticatedDeleteOperations:
    """Test that delete endpoints require authentication."""

    def test_unauthenticated_delete_notice(self):
        """Test unauthenticated access to deleteNotice.php."""
        response = requests.post(
            f"{BASE_URL}/assets/deleteNotice.php",
            data={"noticeId": "99999"},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated delete notice allowed! Status: {response.status_code}, Response: {response.text}"

    def test_unauthenticated_delete_subject(self):
        """Test unauthenticated access to deleteSubject.php."""
        response = requests.post(
            f"{BASE_URL}/assets/deleteSubject.php",
            data={"subject_id": "nonexistent_id"},
            timeout=10
        )

        # Should be blocked regardless of whether endpoint exists
        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated delete subject allowed! Response: {response.text}"


class TestUnauthenticatedStudentOperations:
    """Test that student management endpoints require authentication."""

    def test_unauthenticated_add_student(self):
        """Test unauthenticated access to addStudent.php."""
        response = requests.post(
            f"{BASE_URL}/assets/addStudent.php",
            data={
                "fname": "Hacker",
                "lname": "Test",
                "email": "hacker@test.com",
                "class": "10",
                "section": "A"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated add student allowed! Response: {response.text}"

    def test_unauthenticated_edit_student(self):
        """Test unauthenticated access to editStudent.php."""
        response = requests.post(
            f"{BASE_URL}/assets/editStudent.php",
            data={
                "id": "S1718791292",
                "fname": "Modified",
                "lname": "Student"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated edit student allowed! Response: {response.text}"

    def test_unauthenticated_remove_student(self):
        """Test unauthenticated access to removeStudent.php."""
        response = requests.post(
            f"{BASE_URL}/assets/removeStudent.php",
            data={"id": "nonexistent_id"},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated remove student allowed! Response: {response.text}"


class TestUnauthenticatedTeacherOperations:
    """Test that teacher management endpoints require authentication."""

    def test_unauthenticated_add_teacher(self):
        """Test unauthenticated access to addTeacher.php."""
        response = requests.post(
            f"{BASE_URL}/assets/addTeacher.php",
            data={
                "fname": "Fake",
                "lname": "Teacher",
                "email": "fake@teacher.com",
                "subject": "Hacking"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated add teacher allowed! Response: {response.text}"

    def test_unauthenticated_edit_teacher(self):
        """Test unauthenticated access to editTeacher.php."""
        response = requests.post(
            f"{BASE_URL}/assets/editTeacher.php",
            data={
                "id": "T1718791191",
                "fname": "Modified",
                "lname": "Teacher"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated edit teacher allowed! Response: {response.text}"

    def test_unauthenticated_remove_teacher(self):
        """Test unauthenticated access to removeTeacher.php."""
        response = requests.post(
            f"{BASE_URL}/assets/removeTeacher.php",
            data={"id": "nonexistent_id"},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text or response.status_code == 404, \
            f"Unauthenticated remove teacher allowed! Response: {response.text}"


class TestSessionBypass:
    """Test various session bypass techniques."""

    def test_expired_session_cookie(self):
        """Test with an expired session cookie format."""
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "EXPIRED_SESSION",
                "subject_id": "12c6672ac911a253"
            },
            cookies={"PHPSESSID": "expired_session_12345"},
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Access allowed with expired session cookie! Response: {response.text}"

    def test_tampered_session_cookie(self):
        """Test with a tampered session cookie."""
        # Try various common session manipulation techniques
        for session_value in ["admin", "1", "true", "authenticated=1", "../../../etc/passwd"]:
            response = requests.post(
                f"{BASE_URL}/assets/editSubject.php",
                data={
                    "subject": "TAMPERED_SESSION",
                    "subject_id": "12c6672ac911a253"
                },
                cookies={"PHPSESSID": session_value},
                timeout=10
            )

            assert response.status_code == 401 or "Unauthorized" in response.text, \
                f"Access allowed with tampered session '{session_value}'! Response: {response.text}"

    def test_multiple_requests_without_auth(self):
        """Test that multiple sequential requests are all blocked."""
        for i in range(3):
            response = requests.post(
                f"{BASE_URL}/assets/editSubject.php",
                data={
                    "subject": f"MULTI_REQUEST_{i}",
                    "subject_id": "12c6672ac911a253"
                },
                timeout=10
            )

            assert response.status_code == 401 or "Unauthorized" in response.text, \
                f"Request {i+1} allowed without auth! Response: {response.text}"


class TestDataIntegrity:
    """Test that unauthenticated requests don't modify data."""

    def test_database_not_modified_by_unauthenticated_edit(self):
        """Verify that failed auth attempts don't modify the database."""
        # This test verifies the fix is working correctly
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "SHOULD_NOT_APPEAR_IN_DB",
                "subject_id": "12c6672ac911a253"
            },
            timeout=10
        )

        # If we get 401, the request was blocked before reaching the database
        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated edit may have modified data! Response: {response.text}"

    def test_database_not_modified_by_unauthenticated_add(self):
        """Verify that failed auth attempts don't add to the database."""
        unique_subject = f"SHOULD_NOT_EXIST_{random.randint(10000, 99999)}"

        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": unique_subject,
                "class": "99"
            },
            timeout=10
        )

        assert response.status_code == 401 or "Unauthorized" in response.text, \
            f"Unauthenticated add may have modified data! Response: {response.text}"
