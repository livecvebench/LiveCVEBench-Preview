"""
Vulnerability tests for interactive-git-checkout package.
Tests verify that command injection via branch names is NOT possible.

These tests should:
- FAIL in vulnerable state (command injection works)
- PASS in fixed state (command injection is prevented)
"""

import subprocess
import os
import pytest
import time
import random

# Path to node modules in the container
NODE_PATH = '/app/node_modules'
MARKER_BASE = '/tmp/igc-test-marker'


def run_node_script(script, timeout=30):
    """Helper to run Node.js scripts with proper NODE_PATH"""
    env = os.environ.copy()
    env['NODE_PATH'] = NODE_PATH
    result = subprocess.run(
        ['node', '-e', script],
        capture_output=True,
        text=True,
        timeout=timeout,
        env=env,
        cwd='/app'
    )
    return result


def cleanup_markers(pattern):
    """Remove any marker files matching pattern"""
    import glob
    for f in glob.glob(pattern):
        try:
            os.unlink(f)
        except:
            pass


class TestCheckoutCommandInjection:
    """Test command injection in checkout.js"""

    def test_semicolon_injection_checkout(self):
        """Test that semicolon command chaining is not possible in checkout"""
        marker = f"{MARKER_BASE}-checkout-semicolon-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test ; echo PWNED > {marker} ; #"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Semicolon command injection successful in checkout.js"

    def test_pipe_injection_checkout(self):
        """Test that pipe command chaining is not possible in checkout"""
        marker = f"{MARKER_BASE}-checkout-pipe-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test | echo PWNED > {marker}"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Pipe command injection successful in checkout.js"

    def test_and_operator_injection_checkout(self):
        """Test that && command chaining is not possible in checkout"""
        marker = f"{MARKER_BASE}-checkout-and-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Use 'master' which always exists, so && will execute the second command
        payload = f"master && echo PWNED > {marker}"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: && operator injection successful in checkout.js"

    def test_backtick_injection_checkout(self):
        """Test that backtick command substitution is not possible in checkout"""
        marker = f"{MARKER_BASE}-checkout-backtick-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"`echo PWNED > {marker}`"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Backtick command substitution successful in checkout.js"

    def test_dollar_paren_injection_checkout(self):
        """Test that $() command substitution is not possible in checkout"""
        marker = f"{MARKER_BASE}-checkout-dollarparen-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Using escaped quotes within the Node script
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('$(echo PWNED > {marker})');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: $() command substitution successful in checkout.js"


class TestCheckoutToNewCommandInjection:
    """Test command injection in checkoutToNew.js"""

    def test_semicolon_injection_checkout_to_new(self):
        """Test that semicolon command chaining is not possible in checkoutToNew"""
        marker = f"{MARKER_BASE}-new-semicolon-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test ; echo PWNED > {marker} ; #"
        script = f"""
const checkoutToNew = require('interactive-git-checkout/src/checkoutToNew');

(async () => {{
    try {{
        await checkoutToNew('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Semicolon command injection successful in checkoutToNew.js"

    def test_pipe_injection_checkout_to_new(self):
        """Test that pipe command chaining is not possible in checkoutToNew"""
        marker = f"{MARKER_BASE}-new-pipe-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test | echo PWNED > {marker}"
        script = f"""
const checkoutToNew = require('interactive-git-checkout/src/checkoutToNew');

(async () => {{
    try {{
        await checkoutToNew('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Pipe command injection successful in checkoutToNew.js"

    def test_and_operator_injection_checkout_to_new(self):
        """Test that && command chaining is not possible in checkoutToNew"""
        marker = f"{MARKER_BASE}-new-and-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Use a unique branch name to ensure git checkout -b succeeds
        unique_branch = f"testbranch{random.randint(10000, 99999)}"
        payload = f"{unique_branch} && echo PWNED > {marker}"
        script = f"""
const checkoutToNew = require('interactive-git-checkout/src/checkoutToNew');

(async () => {{
    try {{
        await checkoutToNew('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: && operator injection successful in checkoutToNew.js"

    def test_backtick_injection_checkout_to_new(self):
        """Test that backtick command substitution is not possible in checkoutToNew"""
        marker = f"{MARKER_BASE}-new-backtick-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"`echo PWNED > {marker}`"
        script = f"""
const checkoutToNew = require('interactive-git-checkout/src/checkoutToNew');

(async () => {{
    try {{
        await checkoutToNew('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Backtick command substitution successful in checkoutToNew.js"

    def test_dollar_paren_injection_checkout_to_new(self):
        """Test that $() command substitution is not possible in checkoutToNew"""
        marker = f"{MARKER_BASE}-new-dollarparen-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        script = f"""
const checkoutToNew = require('interactive-git-checkout/src/checkoutToNew');

(async () => {{
    try {{
        await checkoutToNew('$(echo PWNED > {marker})');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: $() command substitution successful in checkoutToNew.js"


class TestComplexInjectionPayloads:
    """Test more complex injection payloads"""

    def test_newline_injection_checkout(self):
        """Test that newline-based command injection is not possible"""
        marker = f"{MARKER_BASE}-newline-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Newline in the middle of the payload
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('test\\necho PWNED > {marker}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Newline command injection successful"

    def test_or_operator_injection(self):
        """Test that || operator command chaining is not possible"""
        marker = f"{MARKER_BASE}-or-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Use a guaranteed non-existent branch name so checkout fails and || executes
        nonexistent_branch = f"nonexistent{random.randint(10000, 99999)}"
        payload = f"{nonexistent_branch} || echo PWNED > {marker}"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: || operator injection successful"

    def test_complex_payload_with_multiple_operators(self):
        """Test complex payload with multiple shell operators"""
        marker = f"{MARKER_BASE}-complex-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"main; echo TEST > {marker}; echo done #"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Complex payload injection successful"

    def test_env_variable_expansion(self):
        """Test that environment variable expansion is not possible"""
        marker = f"{MARKER_BASE}-env-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        # Set an env var and try to expand it
        os.environ['MARKER_PATH'] = marker

        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('test; echo PWNED > $MARKER_PATH; #');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        env = os.environ.copy()
        env['NODE_PATH'] = NODE_PATH
        env['MARKER_PATH'] = marker

        subprocess.run(
            ['node', '-e', script],
            capture_output=True,
            text=True,
            timeout=30,
            env=env,
            cwd='/app'
        )
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Environment variable expansion injection successful"


class TestDataExfiltrationAttempts:
    """Test that data exfiltration via command injection is not possible"""

    def test_file_read_injection(self):
        """Test that reading sensitive files via injection is not possible"""
        marker = f"{MARKER_BASE}-exfil-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test; cat /etc/passwd > {marker}; #"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        if is_vulnerable:
            # Check if it actually contains passwd content
            try:
                with open(marker) as f:
                    content = f.read()
                    is_vulnerable = 'root:' in content
            except:
                pass

        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: File read injection successful"

    def test_command_output_capture(self):
        """Test that capturing command output via injection is not possible"""
        marker = f"{MARKER_BASE}-capture-{random.randint(10000, 99999)}.txt"
        cleanup_markers(f"{MARKER_BASE}*")

        payload = f"test; id > {marker}; #"
        script = f"""
const checkout = require('interactive-git-checkout/src/checkout');

(async () => {{
    try {{
        await checkout('{payload}');
    }} catch (e) {{
        // Expected to fail
    }}
}})();
"""
        run_node_script(script)
        time.sleep(0.5)

        is_vulnerable = os.path.exists(marker)
        if is_vulnerable:
            try:
                with open(marker) as f:
                    content = f.read()
                    is_vulnerable = 'uid=' in content
            except:
                pass

        cleanup_markers(f"{MARKER_BASE}*")

        assert not is_vulnerable, "VULNERABLE: Command output capture injection successful"
