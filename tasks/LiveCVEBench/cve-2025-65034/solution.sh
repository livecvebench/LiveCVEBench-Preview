#!/bin/bash
set -e
cd /app

echo "Applying authorization fix for poll management operations..."

# The application runs from pre-compiled JavaScript files in .next/standalone
# We need to patch the compiled chunk file, not the TypeScript source files
CHUNK_FILE="apps/web/.next/standalone/apps/web/.next/server/chunks/8211.js"

if [ ! -f "$CHUNK_FILE" ]; then
    echo "ERROR: Chunk file not found at $CHUNK_FILE"
    echo "Searching for chunk file..."
    CHUNK_FILE=$(find apps/web/.next -name "*.js" -exec grep -l "poll_reopen" {} \; 2>/dev/null | head -1)
    if [ -z "$CHUNK_FILE" ]; then
        echo "ERROR: Could not find chunk file containing poll_reopen"
        exit 1
    fi
    echo "Found chunk file at: $CHUNK_FILE"
fi

echo "Patching compiled JavaScript chunk: $CHUNK_FILE"

# Create backup
cp "$CHUNK_FILE" "${CHUNK_FILE}.backup"

# The authorization check code to inject (minified to match the compiled format)
# This checks if the poll belongs to the user or the user is a member of the poll's space
# Pattern: let authPoll=await e.z.poll.findFirst({where:{id:a.pollId,OR:[{userId:b.user.id},{space:{members:{some:{userId:b.user.id}}}}]},select:{id:!0}});if(!authPoll)throw new i.gt({code:"FORBIDDEN",message:"..."});

# For reopen mutation:
# Original: reopen:u.z$.input(m.object({pollId:m.string()})).mutation(async({input:a,ctx:b})=>{await e.z.$transaction
# We need to inject auth check after the opening brace of the mutation callback

echo "Patching reopen mutation..."
# The reopen mutation pattern - inject authorization check
perl -i -pe 's/(reopen:u\.z\$\.input\(m\.object\(\{pollId:m\.string\(\)\}\)\)\.mutation\(async\(\{input:a,ctx:b\}\)=>\{)(await e\.z\.\$transaction)/\1let authPoll=await e.z.poll.findFirst({where:{id:a.pollId,OR:[{userId:b.user.id},{space:{members:{some:{userId:b.user.id}}}}]},select:{id:!0}});if(!authPoll)throw new i.gt({code:"FORBIDDEN",message:"You are not allowed to reopen this poll"});\2/' "$CHUNK_FILE"

echo "Patching pause mutation..."
# The pause mutation pattern - inject authorization check
# Original: pause:u.mi.input(m.object({pollId:m.string()})).use(u.ZV).mutation(async({input:a,ctx:b})=>{await e.z.poll.update
perl -i -pe 's/(pause:u\.mi\.input\(m\.object\(\{pollId:m\.string\(\)\}\)\)\.use\(u\.ZV\)\.mutation\(async\(\{input:a,ctx:b\}\)=>\{)(await e\.z\.poll\.update)/\1let authPoll=await e.z.poll.findFirst({where:{id:a.pollId,OR:[{userId:b.user.id},{space:{members:{some:{userId:b.user.id}}}}]},select:{id:!0}});if(!authPoll)throw new i.gt({code:"FORBIDDEN",message:"You are not allowed to pause this poll"});\2/' "$CHUNK_FILE"

echo "Patching resume mutation..."
# The resume mutation pattern - inject authorization check
# Original: resume:u.mi.input(m.object({pollId:m.string()})).use(u.ZV).mutation(async({input:a,ctx:b})=>{await e.z.poll.update
perl -i -pe 's/(resume:u\.mi\.input\(m\.object\(\{pollId:m\.string\(\)\}\)\)\.use\(u\.ZV\)\.mutation\(async\(\{input:a,ctx:b\}\)=>\{)(await e\.z\.poll\.update)/\1let authPoll=await e.z.poll.findFirst({where:{id:a.pollId,OR:[{userId:b.user.id},{space:{members:{some:{userId:b.user.id}}}}]},select:{id:!0}});if(!authPoll)throw new i.gt({code:"FORBIDDEN",message:"You are not allowed to resume this poll"});\2/' "$CHUNK_FILE"

echo "Patching watch mutation..."
# The watch mutation pattern - inject authorization check
# Original: watch:u.z$.input(m.object({pollId:m.string()})).mutation(async({input:a,ctx:b})=>{await e.z.watcher.create
perl -i -pe 's/(watch:u\.z\$\.input\(m\.object\(\{pollId:m\.string\(\)\}\)\)\.mutation\(async\(\{input:a,ctx:b\}\)=>\{)(await e\.z\.watcher\.create)/\1let authPoll=await e.z.poll.findFirst({where:{id:a.pollId,OR:[{userId:b.user.id},{space:{members:{some:{userId:b.user.id}}}}]},select:{id:!0}});if(!authPoll)throw new i.gt({code:"FORBIDDEN",message:"You are not allowed to watch this poll"});\2/' "$CHUNK_FILE"

# Verify patches were applied
echo "Verifying patches..."
if grep -q "You are not allowed to reopen this poll" "$CHUNK_FILE"; then
    echo "  - reopen patch applied successfully"
else
    echo "  - WARNING: reopen patch may not have been applied"
fi

if grep -q "You are not allowed to pause this poll" "$CHUNK_FILE"; then
    echo "  - pause patch applied successfully"
else
    echo "  - WARNING: pause patch may not have been applied"
fi

if grep -q "You are not allowed to resume this poll" "$CHUNK_FILE"; then
    echo "  - resume patch applied successfully"
else
    echo "  - WARNING: resume patch may not have been applied"
fi

if grep -q "You are not allowed to watch this poll" "$CHUNK_FILE"; then
    echo "  - watch patch applied successfully"
else
    echo "  - WARNING: watch patch may not have been applied"
fi

# Restart the application to apply changes
echo "Restarting the application to apply changes..."

# Kill the existing Next.js server process
# The process appears as either "next-server" or "node server.js" depending on timing
pkill -9 "next-server" 2>/dev/null || pkill -9 -f "server.js" 2>/dev/null || true
sleep 3

# Wait for entrypoint to restart the server
# The entrypoint.sh runs in a while loop, so killing node will cause it to restart
echo "Waiting for server to restart with patched code..."
for i in $(seq 1 30); do
    if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null | grep -q "200"; then
        echo "Server is ready!"
        break
    fi
    echo "  Waiting... ($i/30)"
    sleep 2
done

echo "Fix applied successfully!"
echo "The application is now running with the patched code."
