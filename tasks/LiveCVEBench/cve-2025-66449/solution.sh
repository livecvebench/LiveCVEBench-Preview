#!/bin/bash
# Solution script for ConvertX path traversal vulnerability
# This script fixes the upload handler to sanitize filenames
set -e

cd /app

echo "Applying path traversal fix to upload handler..."

# Write the fixed upload.tsx file directly - this is more reliable than sed
cat > src/pages/upload.tsx << 'EOF'
import { Elysia, t } from "elysia";
import db from "../db/db";
import { WEBROOT } from "../helpers/env";
import { uploadsDir } from "../index";
import { userService } from "./user";
import sanitize from "sanitize-filename";

export const upload = new Elysia().use(userService).post(
  "/upload",
  async ({ body, redirect, user, cookie: { jobId } }) => {
    if (!jobId?.value) {
      return redirect(`${WEBROOT}/`, 302);
    }

    const existingJob = await db
      .query("SELECT * FROM jobs WHERE id = ? AND user_id = ?")
      .get(jobId.value, user.id);

    if (!existingJob) {
      return redirect(`${WEBROOT}/`, 302);
    }

    const userUploadsDir = `${uploadsDir}${user.id}/${jobId.value}/`;

    if (body?.file) {
      if (Array.isArray(body.file)) {
        for (const file of body.file) {
          const santizedFileName = sanitize(file.name);
          await Bun.write(`${userUploadsDir}${santizedFileName}`, file);
        }
      } else {
        const santizedFileName = sanitize(body.file["name"]);
        await Bun.write(`${userUploadsDir}${santizedFileName}`, body.file);
      }
    }

    return {
      message: "Files uploaded successfully.",
    };
  },
  { body: t.Object({ file: t.Files() }), auth: true },
);
EOF

echo "Fix applied to src/pages/upload.tsx"

# Verify the fix was applied
if grep -q 'import sanitize from "sanitize-filename"' src/pages/upload.tsx && \
   grep -q 'sanitize(file.name)' src/pages/upload.tsx && \
   grep -q 'sanitize(body.file\["name"\])' src/pages/upload.tsx; then
    echo "Fix verified successfully!"
else
    echo "ERROR: Fix not applied correctly"
    exit 1
fi

# Kill the existing bun process to force reload
# The entrypoint script will auto-restart bun
echo "Restarting application to apply changes..."

# Find bun process PID from /proc and kill it using bash builtin
for pid in /proc/[0-9]*; do
    pidnum="${pid##*/}"
    if [ -f "$pid/cmdline" ]; then
        cmdline=$(cat "$pid/cmdline" 2>/dev/null | tr '\0' ' ')
        if [[ "$cmdline" == *"bun"*"index"* ]] && [ "$pidnum" != "$$" ]; then
            echo "Killing bun process $pidnum"
            kill -9 "$pidnum" 2>/dev/null || true
        fi
    fi
done

# Wait for bun to restart - entrypoint has 2 second delay before restart
echo "Waiting for application to restart..."
sleep 5

# Verify bun is running again by checking /proc
bun_running=false
for i in {1..15}; do
    for pid in /proc/[0-9]*; do
        if [ -f "$pid/cmdline" ]; then
            cmdline=$(cat "$pid/cmdline" 2>/dev/null | tr '\0' ' ')
            if [[ "$cmdline" == *"bun"*"index"* ]]; then
                echo "Application restarted successfully (PID: ${pid##*/})"
                bun_running=true
                break 2
            fi
        fi
    done
    echo "Waiting for application to restart... ($i/15)"
    sleep 1
done

if [ "$bun_running" = false ]; then
    echo "Warning: Bun process may not have restarted yet, waiting additional time..."
    sleep 3
fi

echo "Solution applied successfully!"
