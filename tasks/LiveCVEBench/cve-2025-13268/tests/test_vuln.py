"""
Vulnerability tests for CVE-2025-13268 - JDBC URL Injection in dataCompare.

These tests verify that dangerous JDBC URL parameters are blocked.
- FAIL in vulnerable state (dangerous parameters are processed)
- PASS in fixed state (dangerous parameters are rejected)
"""

import pytest
import requests
import time

BASE_URL = "http://localhost"
LOGIN_URL = f"{BASE_URL}/login"
TEST_CONN_URL = f"{BASE_URL}/system/dbconfig/testConnection"

# Default credentials
USERNAME = "admin"
PASSWORD = "admin123"


class TestSession:
    """Shared session for authenticated requests"""
    _session = None
    _cookies = None

    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            cls._cookies = cls._login()
        return cls._session, cls._cookies

    @classmethod
    def _login(cls):
        """Login and get session cookies"""
        session = cls._session

        # First get the login page
        login_page = session.get(f"{BASE_URL}/login", timeout=10)

        # Attempt login
        login_data = {
            "username": USERNAME,
            "password": PASSWORD,
            "rememberMe": "false"
        }

        response = session.post(
            LOGIN_URL,
            data=login_data,
            allow_redirects=True,
            timeout=10
        )

        return session.cookies


@pytest.fixture(scope="module")
def auth_session():
    """Provide authenticated session for tests"""
    session, cookies = TestSession.get_session()
    return session


def is_dangerous_param_blocked(response):
    """
    Check if the response indicates the dangerous parameter was blocked.
    Returns True if blocked (safe), False if not blocked (vulnerable).
    """
    result = response.json()
    msg = result.get("msg", "").lower()

    # Check for common rejection messages
    blocked_indicators = [
        "非法",           # Chinese for "illegal"
        "illegal",
        "不允许",         # Chinese for "not allowed"
        "forbidden",
        "blocked",
        "rejected",
        "invalid parameter",
        "dangerous",
        "禁止",           # Chinese for "prohibited"
        "安全",           # Chinese for "security"
    ]

    for indicator in blocked_indicators:
        if indicator in msg:
            return True

    # If the code indicates error and message mentions the parameter type
    if result.get("code") != 0:
        # Check if error is specifically about parameter validation
        param_keywords = [
            "allowloadlocalinfile",
            "autodeserialize",
            "allowurlinlocalinfile",
            "queryinterceptors",
            "statementinterceptors",
            "jdbc"
        ]
        for keyword in param_keywords:
            if keyword in msg:
                return True

    return False


class TestAllowLoadLocalInfile:
    """Test blocking of allowLoadLocalInfile parameter - enables arbitrary file read"""

    def test_allowloadlocalinfile_lowercase(self, auth_session):
        """Test that allowLoadLocalInfile=true is blocked (lowercase)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_file_read_1",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowloadlocalinfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowLoadLocalInfile should be blocked. Response: {response.json()}"

    def test_allowloadlocalinfile_mixed_case(self, auth_session):
        """Test that allowLoadLocalInfile=true is blocked (mixed case)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_file_read_2",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowLoadLocalInfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowLoadLocalInfile should be blocked (mixed case). Response: {response.json()}"

    def test_allowloadlocalinfile_uppercase(self, auth_session):
        """Test that ALLOWLOADLOCALINFILE=true is blocked (uppercase)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_file_read_3",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?ALLOWLOADLOCALINFILE=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"ALLOWLOADLOCALINFILE should be blocked (uppercase). Response: {response.json()}"

    def test_allowloadlocalinfile_with_other_params(self, auth_session):
        """Test that allowLoadLocalInfile is blocked even with other safe params"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_file_read_4",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?useSSL=false&allowLoadLocalInfile=true&serverTimezone=UTC",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowLoadLocalInfile should be blocked when mixed with safe params. Response: {response.json()}"


class TestAutoDeserialize:
    """Test blocking of autoDeserialize parameter - enables RCE via deserialization"""

    def test_autodeserialize_lowercase(self, auth_session):
        """Test that autoDeserialize=true is blocked (lowercase)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_deserialize_1",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?autodeserialize=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"autoDeserialize should be blocked. Response: {response.json()}"

    def test_autodeserialize_mixed_case(self, auth_session):
        """Test that autoDeserialize=true is blocked (mixed case)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_deserialize_2",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?autoDeserialize=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"autoDeserialize should be blocked (mixed case). Response: {response.json()}"

    def test_autodeserialize_uppercase(self, auth_session):
        """Test that AUTODESERIALIZE=true is blocked (uppercase)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_deserialize_3",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?AUTODESERIALIZE=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"AUTODESERIALIZE should be blocked (uppercase). Response: {response.json()}"


class TestAllowUrlInLocalInfile:
    """Test blocking of allowUrlInLocalInfile parameter - enables SSRF"""

    def test_allowurlinlocalinfile_lowercase(self, auth_session):
        """Test that allowUrlInLocalInfile=true is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_ssrf_1",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowurlinlocalinfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowUrlInLocalInfile should be blocked. Response: {response.json()}"

    def test_allowurlinlocalinfile_mixed_case(self, auth_session):
        """Test that allowUrlInLocalInfile=true is blocked (mixed case)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_ssrf_2",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowUrlInLocalInfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowUrlInLocalInfile should be blocked (mixed case). Response: {response.json()}"


class TestQueryInterceptors:
    """Test blocking of queryInterceptors parameter - enables code injection"""

    def test_queryinterceptors_lowercase(self, auth_session):
        """Test that queryInterceptors is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_interceptor_1",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?queryinterceptors=com.example.Evil",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"queryInterceptors should be blocked. Response: {response.json()}"

    def test_queryinterceptors_mixed_case(self, auth_session):
        """Test that queryInterceptors is blocked (mixed case)"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_interceptor_2",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"queryInterceptors should be blocked (mixed case). Response: {response.json()}"


class TestStatementInterceptors:
    """Test blocking of statementInterceptors parameter"""

    def test_statementinterceptors(self, auth_session):
        """Test that statementInterceptors is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_stmt_interceptor",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?statementInterceptors=com.example.Evil",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"statementInterceptors should be blocked. Response: {response.json()}"


class TestDetectCustomCollations:
    """Test blocking of detectCustomCollations parameter"""

    def test_detectcustomcollations(self, auth_session):
        """Test that detectCustomCollations is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_collations",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?detectCustomCollations=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"detectCustomCollations should be blocked. Response: {response.json()}"


class TestAllowLoadLocalInfileInPath:
    """Test blocking of allowLoadLocalInfileInPath parameter"""

    def test_allowloadlocalinfileinpath(self, auth_session):
        """Test that allowLoadLocalInfileInPath is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_inpath",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowLoadLocalInfileInPath=/etc/",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowLoadLocalInfileInPath should be blocked. Response: {response.json()}"


class TestMultipleDangerousParams:
    """Test blocking when multiple dangerous parameters are present"""

    def test_multiple_dangerous_params(self, auth_session):
        """Test that multiple dangerous parameters are all blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_multiple",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowLoadLocalInfile=true&autoDeserialize=true&allowUrlInLocalInfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"Multiple dangerous params should be blocked. Response: {response.json()}"

    def test_dangerous_params_with_safe_params(self, auth_session):
        """Test dangerous params mixed with many safe params"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_mixed",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=UTC&autoDeserialize=true&connectTimeout=5000",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"Dangerous param should be blocked even with safe params. Response: {response.json()}"


class TestAllowPublicKeyRetrieval:
    """Test blocking of allowPublicKeyRetrieval parameter"""

    def test_allowpublickeyretrieval(self, auth_session):
        """Test that allowPublicKeyRetrieval is blocked"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_pubkey",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?allowPublicKeyRetrieval=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"allowPublicKeyRetrieval should be blocked. Response: {response.json()}"


class TestBypassAttempts:
    """Test various bypass attempts"""

    def test_param_in_different_position(self, auth_session):
        """Test dangerous param at end of URL"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_position_1",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?useSSL=false&serverTimezone=UTC&allowLoadLocalInfile=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"Param at end of URL should still be blocked. Response: {response.json()}"

    def test_param_at_start(self, auth_session):
        """Test dangerous param at start of query string"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_position_2",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?autoDeserialize=true&useSSL=false",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"Param at start of URL should be blocked. Response: {response.json()}"

    def test_random_case_variation(self, auth_session):
        """Test with random case variation"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_case_var",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?aUtOdEsErIaLiZe=true",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        assert is_dangerous_param_blocked(response), \
            f"Random case param should be blocked. Response: {response.json()}"
