"""
Functionality tests for the WebSocket server.
These tests verify the server works correctly for normal operations.
Should PASS in both vulnerable and fixed states.
"""

import socket
import time
import base64
import hashlib
import struct
import subprocess
import pytest


HOST = "localhost"
PORT = 8000
BASE_URL = f"ws://{HOST}:{PORT}"


def websocket_handshake(sock):
    """
    Perform WebSocket handshake with the server.
    Returns True if handshake successful, False otherwise.
    """
    key = base64.b64encode(b"thisis16byteskey").decode()
    request = (
        f"GET /websocket HTTP/1.1\r\n"
        f"Host: {HOST}:{PORT}\r\n"
        f"Upgrade: websocket\r\n"
        f"Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {key}\r\n"
        f"Sec-WebSocket-Version: 13\r\n"
        f"\r\n"
    )
    sock.send(request.encode())
    response = sock.recv(1024)
    return b"101" in response and b"Switching Protocols" in response


def create_websocket_frame(payload, opcode=0x1, fin=True, mask=True):
    """
    Create a WebSocket frame with the given payload.

    Args:
        payload: bytes - The payload data
        opcode: int - Frame opcode (0x1 for text, 0x2 for binary, 0x9 for ping, etc.)
        fin: bool - FIN bit (True = final frame)
        mask: bool - Whether to mask the frame (required for client->server)

    Returns:
        bytes - The complete WebSocket frame
    """
    frame = bytearray()

    # First byte: FIN + opcode
    first_byte = (0x80 if fin else 0x00) | opcode
    frame.append(first_byte)

    # Second byte: MASK + payload length
    payload_len = len(payload)
    mask_bit = 0x80 if mask else 0x00

    if payload_len < 126:
        frame.append(mask_bit | payload_len)
    elif payload_len < 65536:
        frame.append(mask_bit | 126)
        frame.extend(struct.pack(">H", payload_len))
    else:
        frame.append(mask_bit | 127)
        frame.extend(struct.pack(">Q", payload_len))

    # Add mask key and masked payload if masking
    if mask:
        mask_key = bytes([0x12, 0x34, 0x56, 0x78])
        frame.extend(mask_key)
        masked_payload = bytes(p ^ mask_key[i % 4] for i, p in enumerate(payload))
        frame.extend(masked_payload)
    else:
        frame.extend(payload)

    return bytes(frame)


def read_websocket_frame(sock, timeout=5):
    """
    Read and parse a WebSocket frame from the socket.

    Returns:
        dict with keys: opcode, fin, payload
    """
    sock.settimeout(timeout)
    try:
        # Read first two bytes
        data = sock.recv(2)
        if len(data) < 2:
            return None

        first_byte = data[0]
        second_byte = data[1]

        fin = bool(first_byte & 0x80)
        opcode = first_byte & 0x0F
        masked = bool(second_byte & 0x80)
        payload_len = second_byte & 0x7F

        # Extended payload length
        if payload_len == 126:
            ext_len = sock.recv(2)
            payload_len = struct.unpack(">H", ext_len)[0]
        elif payload_len == 127:
            ext_len = sock.recv(8)
            payload_len = struct.unpack(">Q", ext_len)[0]

        # Mask key (server->client frames should not be masked per RFC)
        if masked:
            mask_key = sock.recv(4)

        # Payload
        payload = b""
        while len(payload) < payload_len:
            chunk = sock.recv(payload_len - len(payload))
            if not chunk:
                break
            payload += chunk

        # Unmask if needed
        if masked:
            payload = bytes(p ^ mask_key[i % 4] for i, p in enumerate(payload))

        return {"opcode": opcode, "fin": fin, "payload": payload}
    except socket.timeout:
        return None


def wait_for_server(host=HOST, port=PORT, timeout=10):
    """Wait for the server to be ready."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            sock.connect((host, port))
            sock.close()
            return True
        except (socket.error, ConnectionRefusedError):
            time.sleep(0.5)
    return False


class TestWebSocketFunctionality:
    """Test normal WebSocket functionality."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before each test."""
        assert wait_for_server(), "Server is not running"

    def test_websocket_handshake(self):
        """Test that WebSocket handshake works correctly."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"
        finally:
            sock.close()

    def test_text_message_echo(self):
        """Test sending and receiving a text message."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send text message
            message = b"Hello, WebSocket!"
            frame = create_websocket_frame(message, opcode=0x1)  # TEXT
            sock.send(frame)

            # Receive echo
            response = read_websocket_frame(sock)
            assert response is not None, "No response received"
            assert response["opcode"] == 0x1, "Expected TEXT frame"
            assert response["payload"] == message, f"Expected {message!r}, got {response['payload']!r}"
        finally:
            sock.close()

    def test_binary_message_echo(self):
        """Test sending and receiving a binary message."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send binary message
            message = bytes([0x00, 0x01, 0x02, 0xFF, 0xFE, 0xFD])
            frame = create_websocket_frame(message, opcode=0x2)  # BINARY
            sock.send(frame)

            # Note: The server might echo as text (depending on implementation)
            # Just verify we get a response without crash
            response = read_websocket_frame(sock)
            assert response is not None, "No response received for binary message"
        finally:
            sock.close()

    def test_multiple_messages(self):
        """Test sending multiple messages in sequence."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            messages = [b"First", b"Second", b"Third", b"Fourth"]

            for msg in messages:
                frame = create_websocket_frame(msg, opcode=0x1)
                sock.send(frame)
                response = read_websocket_frame(sock)
                assert response is not None, f"No response for message: {msg}"
                assert response["payload"] == msg, f"Echo mismatch for {msg}"
        finally:
            sock.close()

    def test_ping_pong(self):
        """Test that server responds to PING with PONG."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send PING
            ping_data = b"ping"
            frame = create_websocket_frame(ping_data, opcode=0x9)  # PING
            sock.send(frame)

            # Expect PONG
            response = read_websocket_frame(sock)
            assert response is not None, "No PONG response"
            assert response["opcode"] == 0xA, "Expected PONG frame (opcode 0xA)"
            assert response["payload"] == ping_data, "PONG payload should match PING"
        finally:
            sock.close()

    def test_empty_message(self):
        """Test sending an empty text message."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send empty text message
            frame = create_websocket_frame(b"", opcode=0x1)
            sock.send(frame)

            # Server should handle it gracefully (may or may not echo empty)
            # Just verify connection is still alive
            time.sleep(0.5)

            # Send another message to verify server is still running
            test_msg = b"still alive"
            frame = create_websocket_frame(test_msg, opcode=0x1)
            sock.send(frame)
            response = read_websocket_frame(sock)
            # The first response might be empty echo, second is our test
            if response and response["payload"] == b"":
                response = read_websocket_frame(sock)
            assert response is not None, "Server not responding after empty message"
        finally:
            sock.close()

    def test_large_message(self):
        """Test sending a moderately large message."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send message larger than 125 bytes (uses 16-bit length)
            message = b"X" * 1000
            frame = create_websocket_frame(message, opcode=0x1)
            sock.send(frame)

            response = read_websocket_frame(sock)
            assert response is not None, "No response for large message"
            assert response["payload"] == message, "Large message echo mismatch"
        finally:
            sock.close()

    def test_concurrent_connections(self):
        """Test multiple concurrent WebSocket connections."""
        sockets = []
        try:
            # Create multiple connections
            for i in range(3):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((HOST, PORT))
                assert websocket_handshake(sock), f"Handshake failed for connection {i}"
                sockets.append(sock)

            # Send message on each connection
            for i, sock in enumerate(sockets):
                msg = f"Connection {i}".encode()
                frame = create_websocket_frame(msg, opcode=0x1)
                sock.send(frame)

            # Verify responses
            for i, sock in enumerate(sockets):
                expected = f"Connection {i}".encode()
                response = read_websocket_frame(sock)
                assert response is not None, f"No response for connection {i}"
                assert response["payload"] == expected
        finally:
            for sock in sockets:
                sock.close()

    def test_http_rest_endpoint(self):
        """Test that HTTP REST endpoint still works alongside WebSocket."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            request = (
                f"GET /rest HTTP/1.1\r\n"
                f"Host: {HOST}:{PORT}\r\n"
                f"\r\n"
            )
            sock.send(request.encode())
            response = sock.recv(1024).decode()
            assert "200" in response, "REST endpoint should return 200"
            assert "123" in response, "REST endpoint should return JSON with result"
        finally:
            sock.close()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
