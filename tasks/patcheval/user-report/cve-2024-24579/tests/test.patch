diff --git a/pkg/file/tarutil_test.go b/pkg/file/tarutil_test.go
new file mode 100644
index 0000000..8400c65
--- /dev/null
+++ b/pkg/file/tarutil_test.go
@@ -0,0 +1,504 @@
+//go:build !windows
+// +build !windows
+
+package file
+
+import (
+	"archive/tar"
+	"bytes"
+	"crypto/sha256"
+	"fmt"
+	"io"
+	"os"
+	"os/exec"
+	"path"
+	"path/filepath"
+	"sort"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+	"github.com/scylladb/go-set/strset"
+	"github.com/spf13/afero"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+)
+
+const (
+	fixturesPath = "test-fixtures"
+)
+
+var (
+	fixturesGeneratorsPath = path.Join(fixturesPath, "generators")
+	tarCachePath           = path.Join(fixturesPath, "tar-cache")
+)
+
+func TestReaderFromTar_GoCase(t *testing.T) {
+	tarReader := getTarFixture(t, "fixture-1")
+
+	fileReader, err := ReaderFromTar(tarReader, "path/branch/two/file-2.txt")
+	if err != nil {
+		t.Fatal("could not get file reader from tar:", err)
+	}
+
+	contents, err := io.ReadAll(fileReader)
+	if err != nil {
+		t.Fatal("could not read from file reader:", err)
+	}
+
+	if string(contents) != "second file\n" {
+		t.Errorf("unexpected contents: '%s'", string(contents))
+	}
+}
+
+func TestReaderFromTar_MissingFile(t *testing.T) {
+	tarReader := getTarFixture(t, "fixture-1")
+
+	_, err := ReaderFromTar(tarReader, "nOn-ExIsTaNt-paTh")
+	if err == nil {
+		t.Error("expected an error but did not find one")
+	}
+}
+
+func TestMetadataFromTar(t *testing.T) {
+	tests := []struct {
+		name     string
+		fixture  string
+		expected Metadata
+	}{
+		{
+			name:    "path/branch/two/file-2.txt",
+			fixture: "fixture-1",
+			expected: Metadata{
+				Path:            "/path/branch/two/file-2.txt",
+				LinkDestination: "",
+				UserID:          1337,
+				GroupID:         5432,
+				Type:            TypeRegular,
+				MIMEType:        "application/octet-stream",
+				FileInfo: ManualInfo{
+					NameValue:    "file-2.txt",
+					SizeValue:    12,
+					ModeValue:    0x1ed,
+					ModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),
+				},
+			},
+		},
+		{
+			name:    "path/branch/two/",
+			fixture: "fixture-1",
+			expected: Metadata{
+				Path:            "/path/branch/two",
+				LinkDestination: "",
+				UserID:          1337,
+				GroupID:         5432,
+				Type:            TypeDirectory,
+				MIMEType:        "",
+				FileInfo: ManualInfo{
+					NameValue:    "two",
+					SizeValue:    0,
+					ModeValue:    0x800001ed,
+					ModTimeValue: time.Date(2019, time.September, 16, 0, 0, 0, 0, time.UTC),
+				},
+			},
+		},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			f := getTarFixture(t, test.fixture)
+			metadata, err := MetadataFromTar(f, test.name)
+			assert.NoError(t, err)
+			assertMetadataEqual(t, test.expected, metadata)
+		})
+	}
+}
+
+func getTarFixture(t testing.TB, name string) *os.File {
+	generatorScriptName := name + ".sh"
+	generatorScriptPath := path.Join(fixturesGeneratorsPath, generatorScriptName)
+	if !fileExists(t, generatorScriptPath) {
+		t.Fatalf("no tar generator script for fixture '%s'", generatorScriptPath)
+	}
+
+	version := fixtureVersion(t, generatorScriptPath)
+	tarName := name + ":" + version + ".tar"
+	tarFixturePath := path.Join(tarCachePath, tarName)
+
+	if !fileExists(t, tarFixturePath) {
+		t.Logf("Creating tar fixture: %s", tarFixturePath)
+
+		fullPath, err := filepath.Abs(tarFixturePath)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		cmd := exec.Command("./"+generatorScriptName, fullPath)
+		cmd.Env = os.Environ()
+		cmd.Dir = fixturesGeneratorsPath
+		cmd.Stdout = os.Stdout
+		cmd.Stderr = os.Stderr
+		cmd.Stdin = os.Stdin
+
+		err = cmd.Run()
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	file, err := os.Open(tarFixturePath)
+	if err != nil {
+		t.Fatalf("could not open tar fixture '%s'", tarFixturePath)
+	}
+
+	t.Cleanup(func() {
+		file.Close()
+	})
+
+	return file
+}
+
+func fixtureVersion(t testing.TB, path string) string {
+	t.Helper()
+	f, err := os.Open(path)
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer func() {
+		err := f.Close()
+		if err != nil {
+			t.Fatal(err)
+		}
+	}()
+
+	h := sha256.New()
+	if _, err := io.Copy(h, f); err != nil {
+		t.Fatal(err)
+	}
+
+	return fmt.Sprintf("%x", h.Sum(nil))
+}
+
+func fileExists(t testing.TB, filename string) bool {
+	t.Helper()
+	info, err := os.Stat(filename)
+	if os.IsNotExist(err) {
+		return false
+	} else if err != nil {
+		t.Fatal(err)
+	}
+	return !info.IsDir()
+}
+
+func Test_tarVisitor_visit(t *testing.T) {
+	assertNoFilesInRoot := func(t testing.TB, fs afero.Fs) {
+		t.Helper()
+
+		allowableFiles := strset.New("tmp")
+
+		// list all files in root
+		files, err := afero.ReadDir(fs, "/")
+		require.NoError(t, err)
+
+		for _, f := range files {
+			assert.True(t, allowableFiles.Has(f.Name()), "unexpected file in root: %s", f.Name())
+		}
+	}
+
+	assertPaths := func(expectedFiles []string, expectedDirs []string) func(t testing.TB, fs afero.Fs) {
+		return func(t testing.TB, fs afero.Fs) {
+			t.Helper()
+
+			sort.Strings(expectedFiles)
+			haveFiles := strset.New()
+			haveDirs := strset.New()
+			err := afero.Walk(fs, "/", func(path string, info os.FileInfo, err error) error {
+				require.NoError(t, err)
+				if info.IsDir() {
+					haveDirs.Add(path)
+				} else {
+					haveFiles.Add(path)
+				}
+				return nil
+			})
+
+			haveFilesList := haveFiles.List()
+			sort.Strings(haveFilesList)
+
+			haveDirsList := haveDirs.List()
+			sort.Strings(haveDirsList)
+
+			require.NoError(t, err)
+
+			if d := cmp.Diff(expectedFiles, haveFilesList); d != "" {
+				t.Errorf("unexpected files (-want +got):\n%s", d)
+			}
+
+			if d := cmp.Diff(expectedDirs, haveDirsList); d != "" {
+				t.Errorf("unexpected dirs (-want +got):\n%s", d)
+			}
+
+		}
+	}
+
+	tests := []struct {
+		name     string
+		entry    TarFileEntry
+		wantErr  require.ErrorAssertionFunc
+		assertFs []func(t testing.TB, fs afero.Fs)
+	}{
+		{
+			name: "regular file is written",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeReg,
+					Name:     "file.txt",
+					Linkname: "",
+					Size:     2,
+				},
+				Reader: strings.NewReader("hi"),
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{"/tmp/file.txt"},
+					[]string{"/", "/tmp"},
+				),
+			},
+		},
+		{
+			name: "regular file with possible path traversal errors out",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeReg,
+					Name:     "../file.txt",
+					Linkname: "",
+					Size:     2,
+				},
+				Reader: strings.NewReader("hi"),
+			},
+			wantErr: require.Error,
+		},
+		{
+			name: "directory is created",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeDir,
+					Name:     "dir",
+					Linkname: "",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/", "/tmp", "/tmp/dir"},
+				),
+			},
+		},
+		{
+			name: "symlink is ignored",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeSymlink,
+					Name:     "symlink",
+					Linkname: "./../to-location",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/"},
+				),
+			},
+		},
+		{
+			name: "hardlink is ignored",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeLink,
+					Name:     "link",
+					Linkname: "./../to-location",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/"},
+				),
+			},
+		},
+		{
+			name: "device is ignored",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeChar,
+					Name:     "device",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/"},
+				),
+			},
+		},
+		{
+			name: "block device is ignored",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeBlock,
+					Name:     "device",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/"},
+				),
+			},
+		},
+		{
+			name: "pipe is ignored",
+			entry: TarFileEntry{
+				Sequence: 0,
+				Header: tar.Header{
+					Typeflag: tar.TypeFifo,
+					Name:     "pipe",
+				},
+			},
+			assertFs: []func(t testing.TB, fs afero.Fs){
+				assertPaths(
+					[]string{},
+					[]string{"/"},
+				),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if tt.wantErr == nil {
+				tt.wantErr = require.NoError
+			}
+			v := tarVisitor{
+				fs:          afero.NewMemMapFs(),
+				destination: "/tmp",
+			}
+			err := v.visit(tt.entry)
+			tt.wantErr(t, err)
+			if err != nil {
+				return
+			}
+			for _, fn := range tt.assertFs {
+				fn(t, v.fs)
+			}
+
+			// even if the test has no other assertions, check that the root is empty
+			assertNoFilesInRoot(t, v.fs)
+		})
+	}
+}
+func TestUntarToDirectory(t *testing.T) {
+	tests := []struct {
+		name    string
+		header  tar.Header
+		content string
+		wantErr bool
+		// verify after extraction whether certain files or directories exist
+		check func(t *testing.T, tempDir string)
+	}{
+		{
+			name: "regular file is written",
+			header: tar.Header{
+				Typeflag: tar.TypeReg,
+				Name:     "file.txt",
+				Linkname: "",
+				Size:     2,
+				Mode:     0644,
+			},
+			content: "hi",
+			check: func(t *testing.T, tempDir string) {
+				// check if the corresponding file is created
+				fullPath := filepath.Join(tempDir, "file.txt")
+				info, err := os.Stat(fullPath)
+				require.NoError(t, err)
+				require.False(t, info.IsDir(), "expected a regular file, got a directory")
+			},
+		},
+		{
+			name: "directory is created",
+			header: tar.Header{
+				Typeflag: tar.TypeDir,
+				Name:     "dir",
+				Mode:     0755,
+			},
+			check: func(t *testing.T, tempDir string) {
+				fullPath := filepath.Join(tempDir, "dir")
+				info, err := os.Stat(fullPath)
+				require.NoError(t, err)
+				require.True(t, info.IsDir(), "expected a directory, got a file")
+			},
+		},
+		{
+			name: "symlink is ignored",
+			header: tar.Header{
+				Typeflag: tar.TypeSymlink,
+				Name:     "link",
+				Linkname: "./target",
+			},
+			// symlink is not created, expected no error
+			check: func(t *testing.T, tempDir string) {
+				_, err := os.Stat(filepath.Join(tempDir, "link"))
+				require.Error(t, err, "symlink should not exist")
+			},
+		},
+		{
+			name: "file with path traversal errors out",
+			header: tar.Header{
+				Typeflag: tar.TypeReg,
+				Name:     "../file.txt",
+				Mode:     0644,
+				Size:     2,
+			},
+			content: "hi",
+			wantErr: true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// 1. create a temporary directory, extraction will write here
+			tempDir, err := os.MkdirTemp("", "untar-test-*")
+			require.NoError(t, err)
+			defer os.RemoveAll(tempDir)
+
+			// 2. construct an in-memory tar stream
+			var buf bytes.Buffer
+			tw := tar.NewWriter(&buf)
+			// write a single entry
+			require.NoError(t, tw.WriteHeader(&tt.header))
+			if tt.content != "" {
+				_, _ = io.Copy(tw, strings.NewReader(tt.content))
+			}
+			require.NoError(t, tw.Close())
+
+			// 3. call UntarToDirectory
+			err = UntarToDirectory(&buf, tempDir)
+			if tt.wantErr {
+				require.Error(t, err)
+				return
+			}
+			require.NoError(t, err)
+
+			// 4. verify the result
+			if tt.check != nil {
+				tt.check(t, tempDir)
+			}
+		})
+	}
+}
