"""
Functionality tests for mruby Array#fill operations.
These tests should PASS in both vulnerable and fixed states.
"""

import subprocess
import pytest
import os


MRUBY_BIN = "/app/bin/mruby"


def run_mruby_code(code: str, timeout: int = 10) -> subprocess.CompletedProcess:
    """Execute mruby code and return the result."""
    # Write code to a temp file
    test_file = "/tmp/test_func.rb"
    with open(test_file, "w") as f:
        f.write(code)

    result = subprocess.run(
        [MRUBY_BIN, test_file],
        capture_output=True,
        timeout=timeout
    )
    return result


class TestArrayFillBasic:
    """Test basic Array#fill functionality works correctly."""

    def test_fill_with_value(self):
        """Test Array#fill with a single value fills the entire array."""
        code = '''
a = [1, 2, 3, 4, 5]
a.fill(0)
raise "Expected [0,0,0,0,0] but got #{a.inspect}" unless a == [0, 0, 0, 0, 0]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_with_start_and_length(self):
        """Test Array#fill with start index and length."""
        code = '''
b = [1, 2, 3, 4, 5]
b.fill("x", 2, 2)
raise "Expected [1,2,'x','x',5] but got #{b.inspect}" unless b == [1, 2, "x", "x", 5]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_with_range(self):
        """Test Array#fill with a range."""
        code = '''
c = [1, 2, 3, 4, 5]
c.fill("y", 1..3)
raise "Expected [1,'y','y','y',5] but got #{c.inspect}" unless c == [1, "y", "y", "y", 5]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_with_block(self):
        """Test Array#fill with a block."""
        code = '''
d = [1, 2, 3]
d.fill { |i| i * 2 }
raise "Expected [0,2,4] but got #{d.inspect}" unless d == [0, 2, 4]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_empty_array(self):
        """Test Array#fill on an empty array."""
        code = '''
e = []
e.fill(1)
raise "Expected [] but got #{e.inspect}" unless e == []
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_extends_array(self):
        """Test Array#fill can extend an array."""
        code = '''
f = [1, 2, 3]
f.fill("z", 1, 5)
raise "Expected [1,'z','z','z','z','z'] but got #{f.inspect}" unless f == [1, "z", "z", "z", "z", "z"]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout


class TestArrayFillEdgeCases:
    """Test edge cases for Array#fill."""

    def test_fill_with_string(self):
        """Test Array#fill with string value."""
        code = '''
g = [1, 2, 3, 4]
g.fill("test", 1, 2)
raise "Expected [1,'test','test',4] but got #{g.inspect}" unless g == [1, "test", "test", 4]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_start_at_zero(self):
        """Test Array#fill starting at index 0."""
        code = '''
h = [1, 2, 3, 4, 5]
h.fill("a", 0, 3)
raise "Expected ['a','a','a',4,5] but got #{h.inspect}" unless h == ["a", "a", "a", 4, 5]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout

    def test_fill_length_zero(self):
        """Test Array#fill with length 0 does nothing."""
        code = '''
i = [1, 2, 3]
i.fill("b", 1, 0)
raise "Expected [1,2,3] but got #{i.inspect}" unless i == [1, 2, 3]
puts "OK"
'''
        result = run_mruby_code(code)
        assert result.returncode == 0, f"Failed: {result.stderr.decode()}"
        assert b"OK" in result.stdout


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
