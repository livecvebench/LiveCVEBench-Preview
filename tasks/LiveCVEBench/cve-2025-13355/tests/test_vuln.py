#!/usr/bin/env python3
"""
Vulnerability tests for URL Shortify plugin.
These tests verify that the reflected XSS vulnerability is properly mitigated.

FAIL in vulnerable state (XSS payload is reflected)
PASS in fixed state (XSS payload is not reflected or is properly escaped)
"""

import pytest
import requests
import re
import html

BASE_URL = "http://localhost"
ADMIN_USER = "admin"
ADMIN_PASS = "admin"


class WordPressSession:
    """Helper class to handle WordPress admin authentication."""

    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.session = requests.Session()
        self.logged_in = False

    def login(self, username=ADMIN_USER, password=ADMIN_PASS):
        """Login to WordPress admin."""
        login_url = f"{self.base_url}/wp-login.php"

        # Get the login page to retrieve any necessary cookies
        self.session.get(login_url)

        # Perform login
        login_data = {
            "log": username,
            "pwd": password,
            "wp-submit": "Log In",
            "redirect_to": f"{self.base_url}/wp-admin/",
            "testcookie": "1"
        }

        response = self.session.post(login_url, data=login_data, allow_redirects=True)

        # Check if login was successful
        if "wordpress_logged_in" in str(self.session.cookies) or "/wp-admin/" in response.url:
            self.logged_in = True
            return True

        return False

    def get(self, url, **kwargs):
        """Perform authenticated GET request."""
        if not self.logged_in:
            self.login()
        return self.session.get(url, **kwargs)


def is_payload_reflected_unescaped(response_text, payload):
    """Check if the XSS payload is reflected in the page without escaping."""
    # Check for exact payload in response (unescaped)
    if payload in response_text:
        return True

    # Check for common XSS patterns that would indicate successful injection
    dangerous_patterns = [
        '<script>',
        'onerror=',
        'onload=',
        'onclick=',
        'javascript:',
        '"><script>',
        "' onclick=",
        '" onclick=',
    ]

    for pattern in dangerous_patterns:
        if pattern in response_text.lower():
            # Verify it's not just escaped HTML entities
            escaped_pattern = html.escape(pattern)
            if pattern in response_text and escaped_pattern not in response_text:
                return True

    return False


def check_injection_in_attribute(response_text, marker):
    """
    Check if our marker breaks out of an HTML attribute.
    If we send marker=" and it appears as value="..." this is vulnerable.
    """
    # Look for our marker appearing after a closing quote in attribute context
    # Pattern: value="...[marker]..." where marker contains " that breaks the attribute
    pattern = rf'value="[^"]*{re.escape(marker)}'
    if re.search(pattern, response_text):
        return True

    # Check if the response contains unescaped quotes from our payload
    if f'value="{marker}"' in response_text:
        return True

    return False


class TestXSSVulnerabilityLinks:
    """Test XSS vulnerability in links management."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        self.wp = WordPressSession()
        self.wp.login()

    def test_basic_script_tag_injection_cpt_id(self):
        """Test basic <script> tag injection in cpt_id parameter."""
        payload = 'test"><script>alert("XSS")</script>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # The payload should NOT appear unescaped in the response
        # In vulnerable state: value="test"><script>alert("XSS")</script>"/> (breaks out of attribute)
        # In fixed state: payload is not reflected at all (POST-only) or is escaped

        # Check for the exact unescaped payload
        unescaped_present = '<script>alert("XSS")</script>' in response.text
        assert not unescaped_present, "XSS payload was reflected without escaping - vulnerable to script injection"

    def test_attribute_breakout_injection(self):
        """Test attribute breakout with quote character."""
        marker = 'xss_test_marker_12345'
        payload = f'"><img src=x onerror=alert("{marker}")>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # Check if onerror handler is present unescaped
        assert 'onerror=alert' not in response.text, "Event handler XSS payload was reflected - vulnerable"

    def test_svg_onload_injection(self):
        """Test SVG onload event injection."""
        payload = '"><svg onload=alert(1)>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # SVG onload should not be present
        assert '<svg onload=' not in response.text.lower(), "SVG onload XSS payload was reflected - vulnerable"

    def test_url_encoded_payload(self):
        """Test URL-encoded XSS payload."""
        # URL-encoded: "><script>alert('XSS')</script>
        payload = '"><script>alert(/XSS/)</script>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # The script tag should not appear unescaped
        assert '<script>alert(/XSS/)</script>' not in response.text, "Encoded XSS payload was reflected - vulnerable"

    def test_html_entities_payload(self):
        """Test with HTML entity bypass attempts."""
        payload = 'test"><body onpageshow=alert(1)>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        assert 'onpageshow=' not in response.text.lower(), "Body onpageshow XSS payload was reflected - vulnerable"

    def test_input_autofocus_onfocus(self):
        """Test input autofocus onfocus injection."""
        payload = 'x" autofocus onfocus="alert(1)'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # Check that onfocus is not added as an attribute
        assert 'onfocus="alert(1)' not in response.text, "Autofocus onfocus XSS payload was reflected - vulnerable"

    def test_double_quote_breakout(self):
        """Test double quote attribute breakout."""
        marker = 'XSSMARKER123'
        payload = f'"{marker}test'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # If the quote is unescaped and in attribute context, look for our marker outside quotes
        # Vulnerable pattern: value=""XSSMARKER123test"/>
        # The marker after a double quote followed by another character suggests breakout
        vulnerable_pattern = f'value=""{marker}'
        assert vulnerable_pattern not in response.text, "Quote breakout detected - vulnerable"


class TestXSSVulnerabilityBypassAttempts:
    """Test various XSS bypass techniques."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        self.wp = WordPressSession()
        self.wp.login()

    def test_case_variation_script(self):
        """Test case variations of script tag."""
        payload = '"><ScRiPt>alert(1)</sCrIpT>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # Check case-insensitively
        assert '<script>' not in response.text.lower() or \
               '&lt;script&gt;' in response.text.lower() or \
               'alert(1)' not in response.text, \
            "Case variation XSS payload was reflected - vulnerable"

    def test_null_byte_injection(self):
        """Test null byte injection attempt."""
        payload = '"><script%00>alert(1)</script>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        assert '<script' not in response.text.lower() or 'alert(1)' not in response.text, \
            "Null byte XSS payload was reflected - vulnerable"

    def test_javascript_protocol_handler(self):
        """Test javascript: protocol handler injection."""
        payload = '"><a href="javascript:alert(1)">click</a>'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # javascript: protocol should not appear in an href
        assert 'href="javascript:alert(1)"' not in response.text, \
            "JavaScript protocol XSS payload was reflected - vulnerable"

    def test_data_uri_injection(self):
        """Test data: URI injection attempt."""
        payload = '"><object data="data:text/html,<script>alert(1)</script>">'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        assert '<object data="data:text/html' not in response.text, \
            "Data URI XSS payload was reflected - vulnerable"

    def test_html5_formaction_injection(self):
        """Test HTML5 formaction injection."""
        payload = '" formaction="javascript:alert(1)" onclick="submit'

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        assert 'formaction="javascript:' not in response.text, \
            "Formaction XSS payload was reflected - vulnerable"


class TestGETParameterNotAccepted:
    """
    Test that form_data is not accepted from GET parameters after fix.
    In the fixed version, form_data should only be read from POST.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        self.wp = WordPressSession()
        self.wp.login()

    def test_get_form_data_not_reflected_links(self):
        """Test that GET form_data is not reflected in links page."""
        unique_marker = "UNIQUETESTMARKER_12345"
        payload = unique_marker

        params = {
            "page": "us_links",
            "action": "new",
            "form_data[cpt_id]": payload,
            "submitted": "submitted"
        }

        response = self.wp.get(f"{BASE_URL}/wp-admin/admin.php", params=params)
        assert response.status_code == 200

        # After fix, the unique marker from GET should NOT appear in cpt_id value
        # Look for the specific pattern in the hidden input
        cpt_input_pattern = r'name="form_data\[cpt_id\]"[^>]*value="([^"]*)"'
        match = re.search(cpt_input_pattern, response.text)

        if match:
            value = match.group(1)
            # In fixed version, GET parameters should not populate form_data
            assert unique_marker not in value, \
                f"GET parameter was reflected in form field value: {value}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
