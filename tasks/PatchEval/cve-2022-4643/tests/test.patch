diff --git a/pdf_ocr_test.go b/pdf_ocr_test.go
new file mode 100644
index 0000000..b62876c
--- /dev/null
+++ b/pdf_ocr_test.go
@@ -0,0 +1,222 @@
+//go:build ocr
+// +build ocr
+
+package docconv
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+	"time"
+)
+
+
+func TestPDFHasImage_CannotExecuteCode(t *testing.T) {
+	// Try to inject code by passing a bad file path.
+	// If the code was successful it will create a file called foo in the working directory
+	badFilePath := "$(id >> foo).pdf"
+	if got, want := PDFHasImage(badFilePath), false; got != want {
+		t.Errorf("got %v, want %v", got, want)
+	}
+
+	if got, want := fileExists("foo"), false; got != want {
+		t.Errorf("got bad file exists, want not file to exist")
+	}
+}
+
+func fileExists(filename string) bool {
+	info, err := os.Stat(filename)
+	if os.IsNotExist(err) {
+		return false
+	}
+	return !info.IsDir()
+}
+
+
+func writeFakePdffonts(binDir, markerPath string) error {
+	script := `#!/bin/sh
+# write all args (space separated) to marker for inspection
+printf "%s " "$@" > "` + markerPath + `"
+echo "" >> "` + markerPath + `"
+
+# also record the current process command line (to see how shell invoked this script)
+# this helps when arg capture via "$@" is unreliable in some environments
+if command -v ps >/dev/null 2>&1; then
+  ps -o args= $$ >> "` + markerPath + `"
+fi
+
+# the last arg is assumed to be the filename/path
+last="${!#}"
+
+if [ -f "$last" ]; then
+  # simulate header lines then font names (matching how real pdffonts might behave)
+  echo "header line 1"
+  echo "header line 2"
+  echo "header line 3"
+  echo "Arial  something"
+  echo "Arial  something"
+  echo "Times  something"
+  exit 0
+else
+  echo "Error: file not found: $last" 1>&2
+  exit 2
+fi
+`
+	scriptPath := filepath.Join(binDir, "pdffonts")
+	if err := ioutil.WriteFile(scriptPath, []byte(script), 0700); err != nil {
+		return err
+	}
+	return nil
+}
+
+
+func TestPDFHasImage_PassesFullPath(t *testing.T) {
+	tmpRoot, err := ioutil.TempDir("", "pdfhasimage-test-")
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer os.RemoveAll(tmpRoot)
+
+	binDir := filepath.Join(tmpRoot, "bin")
+	if err := os.Mkdir(binDir, 0755); err != nil {
+		t.Fatal(err)
+	}
+
+	marker := filepath.Join(tmpRoot, "pdffonts_arg.txt")
+	if err := writeFakePdffonts(binDir, marker); err != nil {
+		t.Fatal(err)
+	}
+
+	// prepend our fake bin to PATH
+	origPath := os.Getenv("PATH")
+	defer os.Setenv("PATH", origPath)
+	os.Setenv("PATH", binDir+string(os.PathListSeparator)+origPath)
+
+	// create a fake PDF in a subdir (not cwd)
+	pdfDir := filepath.Join(tmpRoot, "pdfs")
+	if err := os.Mkdir(pdfDir, 0755); err != nil {
+		t.Fatal(err)
+	}
+	pdfPath := filepath.Join(pdfDir, "input file.pdf") // include a space to exercise quoting
+	if err := ioutil.WriteFile(pdfPath, []byte("%PDF-1.4 fake"), 0644); err != nil {
+		t.Fatal(err)
+	}
+
+	// change working dir so basename-only would fail
+	oldWd, err := os.Getwd()
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer os.Chdir(oldWd)
+	if err := os.Chdir(tmpRoot); err != nil {
+		t.Fatal(err)
+	}
+
+	// invoke function under test (we ignore its boolean return; we will inspect marker)
+	_ = PDFHasImage(pdfPath)
+
+	// wait for marker to be written
+	var content string
+	deadline := time.Now().Add(2 * time.Second)
+	for time.Now().Before(deadline) {
+		b, err := ioutil.ReadFile(marker)
+		if err == nil && len(b) > 0 {
+			content = string(b)
+			break
+		}
+		time.Sleep(10 * time.Millisecond)
+	}
+	if content == "" {
+		t.Fatalf("pdffonts invocation marker %s not written; cannot inspect invocation", marker)
+	}
+
+	// Normalize lines and tokens
+	content = strings.TrimSpace(content)
+	lines := strings.Split(content, "\n")
+	// first line is the printf of "$@" (space-separated), subsequent lines may include ps output
+	argLine := strings.TrimSpace(lines[0])
+
+	// try to find the pdfPath anywhere in argLine or in any ps line.
+	found := false
+	if strings.Contains(argLine, pdfPath) {
+		found = true
+	} else {
+		// check all lines (ps output might contain the full command)
+		for _, ln := range lines {
+			if strings.Contains(ln, pdfPath) {
+				found = true
+				break
+			}
+		}
+	}
+
+	if !found {
+		// As a weaker fallback, accept if the basename appears (some implementations may pass basename)
+		base := filepath.Base(pdfPath)
+		if strings.Contains(argLine, base) {
+			// still consider this a fail (basename-only is wrong for non-cwd), but provide detailed message
+			t.Fatalf("pdffonts was invoked with basename-only argument (marker: %q). Expected the full path (or absolute path) like %q", content, pdfPath)
+		}
+
+		// no occurrence of path or basename -> fail
+		t.Fatalf("pdffonts invocation did not contain expected path. marker contents:\n%s", content)
+	}
+
+	// If we reached here, either pdfPath was found (good) or above would have failed.
+}
+
+
+func TestPDFHasImage_NoCommandInjectionSideEffects(t *testing.T) {
+	tmpRoot, err := ioutil.TempDir("", "pdfhasimage-inject-")
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer os.RemoveAll(tmpRoot)
+
+	binDir := filepath.Join(tmpRoot, "bin")
+	if err := os.Mkdir(binDir, 0755); err != nil {
+		t.Fatal(err)
+	}
+
+	// This pdffonts simply writes its arg to marker and prints minimal valid output if file exists.
+	marker := filepath.Join(tmpRoot, "pdffonts_arg2.txt")
+	if err := writeFakePdffonts(binDir, marker); err != nil {
+		t.Fatal(err)
+	}
+
+	origPath := os.Getenv("PATH")
+	defer os.Setenv("PATH", origPath)
+	os.Setenv("PATH", binDir+string(os.PathListSeparator)+origPath)
+
+	// Create normal PDF file in a directory
+	pdfDir := filepath.Join(tmpRoot, "pdfs")
+	if err := os.Mkdir(pdfDir, 0755); err != nil {
+		t.Fatal(err)
+	}
+	pdfPath := filepath.Join(pdfDir, "safe.pdf")
+	if err := ioutil.WriteFile(pdfPath, []byte("%PDF-1.4 fake"), 0644); err != nil {
+		t.Fatal(err)
+	}
+
+	// sentinel that would be created by an injected command; ensure it does NOT exist before
+	sentinel := filepath.Join(tmpRoot, "INJECTION_RAN")
+	_ = os.Remove(sentinel)
+
+	// Construct a malicious-looking path that attempts to inject a second command
+	// For example: "/tmp/safe.pdf; touch /tmp/INJECTION_RAN"
+	// If code passes this string unescaped into `bash -c`, the touch would run and create sentinel.
+	maliciousPath := pdfPath + "; touch " + sentinel
+
+	// Call the function under test with malicious path
+	_ = PDFHasImage(maliciousPath)
+
+	// Give a short moment for any injected command to run (if vulnerability present)
+	time.Sleep(100 * time.Millisecond)
+
+	if _, err := os.Stat(sentinel); err == nil {
+		t.Fatalf("Sentinel file %s was created â€” possible command injection occurred when calling pdffonts", sentinel)
+	}
+}
+
