#!/usr/bin/env python3
"""
Functional Tests for ImageSharp GIF Decoder

These tests verify that normal GIF processing functionality works correctly.
They should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import tempfile
import struct
import pytest

# Path to the application in container
APP_DIR = "/app/test"
TEST_DIR = "/tests"


def create_valid_gif_with_comment(comment: bytes = b"test comment") -> bytes:
    """Create a valid GIF with a properly terminated comment block."""
    gif_data = bytearray()

    # GIF Header - GIF89a
    gif_data.extend(b'GIF89a')

    # Logical Screen Descriptor (7 bytes)
    gif_data.extend(struct.pack('<H', 1))  # Width: 1 pixel
    gif_data.extend(struct.pack('<H', 1))  # Height: 1 pixel
    gif_data.append(0x80)  # Packed byte: has global color table, 2 colors
    gif_data.append(0x00)  # Background Color Index
    gif_data.append(0x00)  # Pixel Aspect Ratio

    # Global Color Table (2 colors = 6 bytes)
    gif_data.extend(b'\x00\x00\x00')  # Color 0: black
    gif_data.extend(b'\xFF\xFF\xFF')  # Color 1: white

    # Comment Extension Block (properly terminated)
    gif_data.append(0x21)  # Extension Introducer
    gif_data.append(0xFE)  # Comment Label

    # Split comment into sub-blocks of max 255 bytes
    remaining = comment
    while remaining:
        chunk = remaining[:255]
        remaining = remaining[255:]
        gif_data.append(len(chunk))
        gif_data.extend(chunk)

    gif_data.append(0x00)  # Block Terminator - REQUIRED

    # Image Descriptor
    gif_data.append(0x2C)  # Image Separator
    gif_data.extend(struct.pack('<H', 0))  # Left Position
    gif_data.extend(struct.pack('<H', 0))  # Top Position
    gif_data.extend(struct.pack('<H', 1))  # Width
    gif_data.extend(struct.pack('<H', 1))  # Height
    gif_data.append(0x00)  # Packed byte

    # Image Data
    gif_data.append(0x02)  # LZW Minimum Code Size
    gif_data.append(0x02)  # Block Size
    gif_data.extend(b'\x4C\x01')  # Compressed data for 1 white pixel
    gif_data.append(0x00)  # Block Terminator

    # GIF Trailer
    gif_data.append(0x3B)

    return bytes(gif_data)


def create_minimal_valid_gif() -> bytes:
    """Create a minimal valid GIF without comment blocks."""
    gif_data = bytearray()

    # GIF Header
    gif_data.extend(b'GIF89a')

    # Logical Screen Descriptor
    gif_data.extend(struct.pack('<H', 1))  # Width
    gif_data.extend(struct.pack('<H', 1))  # Height
    gif_data.append(0x80)  # Has global color table
    gif_data.append(0x00)  # Background color
    gif_data.append(0x00)  # Aspect ratio

    # Global Color Table
    gif_data.extend(b'\x00\x00\x00\xFF\xFF\xFF')

    # Image Descriptor
    gif_data.append(0x2C)
    gif_data.extend(struct.pack('<H', 0))
    gif_data.extend(struct.pack('<H', 0))
    gif_data.extend(struct.pack('<H', 1))
    gif_data.extend(struct.pack('<H', 1))
    gif_data.append(0x00)

    # Image Data
    gif_data.append(0x02)
    gif_data.append(0x02)
    gif_data.extend(b'\x4C\x01')
    gif_data.append(0x00)

    # Trailer
    gif_data.append(0x3B)

    return bytes(gif_data)


def run_dotnet_test(gif_path: str, timeout: int = 30) -> subprocess.CompletedProcess:
    """Run the dotnet application with the given GIF file."""
    result = subprocess.run(
        ["dotnet", "/app/test/publish/ImageTestFromSource.dll", gif_path],
        capture_output=True,
        text=True,
        timeout=timeout,
        cwd=APP_DIR
    )
    return result


class TestValidGifProcessing:
    """Tests for valid GIF file processing."""

    def test_minimal_valid_gif_loads(self):
        """Test that a minimal valid GIF can be loaded."""
        gif_data = create_minimal_valid_gif()

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(gif_data)
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            # Should succeed without timeout
            assert result.returncode == 0, f"Failed to load valid GIF: {result.stderr}"
            assert "success" in result.stdout.lower() or "processed" in result.stdout.lower()
        finally:
            os.unlink(temp_path)

    def test_valid_gif_with_short_comment(self):
        """Test GIF with a short properly-terminated comment."""
        gif_data = create_valid_gif_with_comment(b"Hello World")

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(gif_data)
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0, f"Failed to load GIF with comment: {result.stderr}"
        finally:
            os.unlink(temp_path)

    def test_valid_gif_with_long_comment(self):
        """Test GIF with a long comment spanning multiple sub-blocks."""
        # Create a comment longer than 255 bytes (requires multiple sub-blocks)
        long_comment = b"X" * 300
        gif_data = create_valid_gif_with_comment(long_comment)

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(gif_data)
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0, f"Failed to load GIF with long comment: {result.stderr}"
        finally:
            os.unlink(temp_path)

    def test_valid_gif_with_unicode_comment(self):
        """Test GIF with UTF-8 encoded comment."""
        unicode_comment = "Hello ‰∏ñÁïå üåç".encode('utf-8')
        gif_data = create_valid_gif_with_comment(unicode_comment)

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(gif_data)
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0, f"Failed to load GIF with unicode comment: {result.stderr}"
        finally:
            os.unlink(temp_path)


class TestGifIdentification:
    """Tests for Image.Identify functionality."""

    def test_identify_returns_dimensions(self):
        """Test that Image.Identify returns correct dimensions."""
        gif_data = create_minimal_valid_gif()

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(gif_data)
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0
            # Output should contain dimensions
            assert "1x1" in result.stdout or ("width" in result.stdout.lower() and "1" in result.stdout)
        finally:
            os.unlink(temp_path)


class TestEmptyAndEdgeCases:
    """Tests for edge cases in GIF processing."""

    def test_valid_gif_with_empty_comment(self):
        """Test GIF with empty comment block (just terminator)."""
        gif_data = bytearray()
        gif_data.extend(b'GIF89a')
        gif_data.extend(struct.pack('<H', 1))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.append(0x80)
        gif_data.append(0x00)
        gif_data.append(0x00)
        gif_data.extend(b'\x00\x00\x00\xFF\xFF\xFF')

        # Empty comment block (just introducer, label, and terminator)
        gif_data.append(0x21)  # Extension Introducer
        gif_data.append(0xFE)  # Comment Label
        gif_data.append(0x00)  # Block Terminator immediately

        # Image data
        gif_data.append(0x2C)
        gif_data.extend(struct.pack('<H', 0))
        gif_data.extend(struct.pack('<H', 0))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.append(0x00)
        gif_data.append(0x02)
        gif_data.append(0x02)
        gif_data.extend(b'\x4C\x01')
        gif_data.append(0x00)
        gif_data.append(0x3B)

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(bytes(gif_data))
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0, f"Failed to load GIF with empty comment: {result.stderr}"
        finally:
            os.unlink(temp_path)

    def test_valid_gif_with_multiple_comments(self):
        """Test GIF with multiple comment blocks."""
        gif_data = bytearray()
        gif_data.extend(b'GIF89a')
        gif_data.extend(struct.pack('<H', 1))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.append(0x80)
        gif_data.append(0x00)
        gif_data.append(0x00)
        gif_data.extend(b'\x00\x00\x00\xFF\xFF\xFF')

        # First comment block
        gif_data.append(0x21)
        gif_data.append(0xFE)
        gif_data.append(0x05)
        gif_data.extend(b'First')
        gif_data.append(0x00)

        # Second comment block
        gif_data.append(0x21)
        gif_data.append(0xFE)
        gif_data.append(0x06)
        gif_data.extend(b'Second')
        gif_data.append(0x00)

        # Image data
        gif_data.append(0x2C)
        gif_data.extend(struct.pack('<H', 0))
        gif_data.extend(struct.pack('<H', 0))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.extend(struct.pack('<H', 1))
        gif_data.append(0x00)
        gif_data.append(0x02)
        gif_data.append(0x02)
        gif_data.extend(b'\x4C\x01')
        gif_data.append(0x00)
        gif_data.append(0x3B)

        with tempfile.NamedTemporaryFile(suffix='.gif', delete=False) as f:
            f.write(bytes(gif_data))
            temp_path = f.name

        try:
            result = run_dotnet_test(temp_path)
            assert result.returncode == 0, f"Failed to load GIF with multiple comments: {result.stderr}"
        finally:
            os.unlink(temp_path)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
