"""
Functional tests for the MCP database server query tools.
These tests verify that the application works correctly for legitimate use cases.
Should PASS in both vulnerable and fixed states.
"""

import subprocess
import json
import os
import tempfile
import pytest

# Path to the compiled application
APP_DIR = "/app"
DIST_DIR = os.path.join(APP_DIR, "dist", "src")


class TestQueryValidation:
    """Test basic query validation in the readQuery function."""

    def test_valid_select_query_accepted(self):
        """A simple SELECT query should be accepted."""
        result = run_query_test("SELECT 1 AS test_value")
        assert result["success"] is True, f"Simple SELECT should succeed: {result}"

    def test_select_with_where_clause(self):
        """SELECT with WHERE clause should work."""
        result = run_query_test("SELECT * FROM users WHERE id = 1")
        # This may fail if table doesn't exist, but validation should pass
        assert result.get("validation_passed", True), "SELECT with WHERE should pass validation"

    def test_select_with_join(self):
        """SELECT with JOIN should work."""
        result = run_query_test("SELECT u.id FROM users u LEFT JOIN products p ON u.id = p.id")
        assert result.get("validation_passed", True), "SELECT with JOIN should pass validation"

    def test_select_with_limit(self):
        """SELECT with LIMIT should work."""
        result = run_query_test("SELECT * FROM users LIMIT 10")
        assert result.get("validation_passed", True), "SELECT with LIMIT should pass validation"

    def test_select_with_order_by(self):
        """SELECT with ORDER BY should work."""
        result = run_query_test("SELECT * FROM users ORDER BY id DESC")
        assert result.get("validation_passed", True), "SELECT with ORDER BY should pass validation"

    def test_select_with_group_by(self):
        """SELECT with GROUP BY should work."""
        result = run_query_test("SELECT COUNT(*) FROM users GROUP BY username")
        assert result.get("validation_passed", True), "SELECT with GROUP BY should pass validation"

    def test_select_case_insensitive(self):
        """SELECT keyword should be case-insensitive."""
        result = run_query_test("select 1")
        assert result.get("validation_passed", True), "Lowercase 'select' should pass"

        result = run_query_test("SELECT 1")
        assert result.get("validation_passed", True), "Uppercase 'SELECT' should pass"

        result = run_query_test("SeLeCt 1")
        assert result.get("validation_passed", True), "Mixed case 'SeLeCt' should pass"

    def test_select_with_leading_whitespace(self):
        """SELECT with leading whitespace should work."""
        result = run_query_test("   SELECT 1")
        assert result.get("validation_passed", True), "SELECT with leading spaces should pass"

        result = run_query_test("\t\nSELECT 1")
        assert result.get("validation_passed", True), "SELECT with tabs/newlines should pass"


class TestNonSelectRejection:
    """Test that non-SELECT queries are properly rejected."""

    def test_insert_rejected(self):
        """INSERT queries should be rejected by read_query."""
        result = run_query_test("INSERT INTO users VALUES (99, 'test', 'test@test.com')")
        assert result["validation_passed"] is False, f"INSERT should be rejected: {result}"
        assert "Only SELECT" in result.get("error", ""), "Should mention only SELECT allowed"

    def test_update_rejected(self):
        """UPDATE queries should be rejected by read_query."""
        result = run_query_test("UPDATE users SET username = 'new' WHERE id = 1")
        assert result["validation_passed"] is False, f"UPDATE should be rejected: {result}"

    def test_delete_rejected(self):
        """DELETE queries should be rejected by read_query."""
        result = run_query_test("DELETE FROM users WHERE id = 1")
        assert result["validation_passed"] is False, f"DELETE should be rejected: {result}"

    def test_drop_rejected(self):
        """DROP queries should be rejected by read_query."""
        result = run_query_test("DROP TABLE users")
        assert result["validation_passed"] is False, f"DROP should be rejected: {result}"

    def test_create_rejected(self):
        """CREATE queries should be rejected by read_query."""
        result = run_query_test("CREATE TABLE new_table (id INT)")
        assert result["validation_passed"] is False, f"CREATE should be rejected: {result}"

    def test_truncate_rejected(self):
        """TRUNCATE queries should be rejected by read_query."""
        result = run_query_test("TRUNCATE TABLE users")
        assert result["validation_passed"] is False, f"TRUNCATE should be rejected: {result}"

    def test_alter_rejected(self):
        """ALTER queries should be rejected by read_query."""
        result = run_query_test("ALTER TABLE users ADD COLUMN new_col INT")
        assert result["validation_passed"] is False, f"ALTER should be rejected: {result}"


class TestSubqueriesAndCTEs:
    """Test that complex SELECT queries with subqueries work."""

    def test_subquery_in_select(self):
        """Subquery in SELECT list should work."""
        result = run_query_test("SELECT (SELECT COUNT(*) FROM users) AS cnt")
        assert result.get("validation_passed", True), "Subquery in SELECT should pass"

    def test_subquery_in_from(self):
        """Subquery in FROM clause should work."""
        result = run_query_test("SELECT * FROM (SELECT 1 AS x) AS subq")
        assert result.get("validation_passed", True), "Subquery in FROM should pass"

    def test_subquery_in_where(self):
        """Subquery in WHERE clause should work."""
        result = run_query_test("SELECT * FROM users WHERE id IN (SELECT id FROM products)")
        assert result.get("validation_passed", True), "Subquery in WHERE should pass"

    def test_cte_query(self):
        """Common Table Expression (CTE) should work."""
        result = run_query_test("WITH cte AS (SELECT 1 AS x) SELECT * FROM cte")
        # Note: CTE doesn't start with SELECT but should still be allowed as read-only
        # Depending on implementation, this may or may not pass
        # The test validates current behavior
        pass  # Skip assertion - implementation may vary


def run_query_test(query: str) -> dict:
    """
    Run a query through the readQuery validation and return results.
    This function creates a test harness that initializes the database
    and then tests the query.
    """
    # Escape the query for JavaScript
    escaped_query = json.dumps(query)

    test_script = f'''
import {{ initDatabase }} from "{DIST_DIR}/db/index.js";
import {{ readQuery }} from "{DIST_DIR}/tools/queryTools.js";

async function test() {{
    try {{
        // Initialize database connection first
        await initDatabase({{
            host: "postgres",
            database: "testdb",
            user: "testuser",
            password: "testpass",
            port: 5432
        }}, "postgresql");

        const result = await readQuery({escaped_query});
        console.log(JSON.stringify({{
            success: true,
            validation_passed: true,
            result: result
        }}));
    }} catch (error) {{
        // Check if it's a validation error vs database error
        const msg = error.message || "";
        const isValidationError = msg.includes("Only SELECT") ||
                                  msg.includes("Multiple SQL") ||
                                  msg.includes("not allowed");
        console.log(JSON.stringify({{
            success: false,
            validation_passed: !isValidationError,
            error: msg
        }}));
    }}
    process.exit(0);
}}

test();
'''

    with tempfile.NamedTemporaryFile(mode='w', suffix='.mjs', delete=False) as f:
        f.write(test_script)
        temp_path = f.name

    try:
        result = subprocess.run(
            ['node', temp_path],
            cwd=APP_DIR,
            capture_output=True,
            text=True,
            timeout=15
        )

        # Try to parse JSON output (may have logging before it)
        output = result.stdout.strip()
        lines = output.split('\n')
        for line in reversed(lines):
            line = line.strip()
            if line.startswith('{'):
                try:
                    return json.loads(line)
                except json.JSONDecodeError:
                    pass

        return {
            "success": False,
            "validation_passed": True,  # Assume validation passed if no clear error
            "error": result.stderr or "Unknown error",
            "stdout": result.stdout
        }
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "validation_passed": True,
            "error": "Query timed out"
        }
    except Exception as e:
        return {
            "success": False,
            "validation_passed": True,
            "error": str(e)
        }
    finally:
        os.unlink(temp_path)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
