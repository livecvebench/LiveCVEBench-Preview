"""
Vulnerability tests for DjVuLibre MMR decoder out-of-bounds access (CVE-2025-53367).

These tests verify that the vulnerability EXISTS in the vulnerable environment.
- FAIL in vulnerable state (the application crashes on malformed data - vulnerability exists)
- PASS in fixed state (application handles malformed data gracefully - vulnerability is fixed)

Test design:
- Each test asserts that the application handles malformed data WITHOUT CRASHING
- In the vulnerable version (3.5.28), the application CRASHES, so these assertions FAIL
- In the fixed version (3.5.29+), proper bounds checking throws exceptions, so tests PASS
"""

import subprocess
import os
import signal
import pytest


POC_FILE = '/tests/fuzzer-poc.djvu'


def run_ddjvu(extra_args=None, timeout=30):
    """
    Run ddjvu with the PoC file and return the result.
    Returns tuple of (return_code, crashed, signal_num, stderr)
    """
    if extra_args is None:
        extra_args = []

    cmd = ['ddjvu'] + extra_args + [POC_FILE, '/dev/null']

    result = subprocess.run(
        cmd,
        capture_output=True,
        timeout=timeout
    )

    crashed = result.returncode < 0
    sig_num = -result.returncode if crashed else None
    stderr = result.stderr.decode('utf-8', errors='replace')

    return result.returncode, crashed, sig_num, stderr


class TestMMRBufferOverflow:
    """
    Core vulnerability tests - verify the buffer overflow in MMRDecoder::scanruns().

    The vulnerability occurs when xr/pr pointers are incremented beyond allocated
    buffers without bounds checking. In vulnerable version, this causes crashes.
    """

    def test_no_crash_on_malformed_mmr_data(self):
        """
        Test that malformed MMR data doesn't cause a crash.

        Vulnerable: CRASHES with SIGABRT/SIGSEGV (FAILS this test)
        Fixed: Throws exception with "Bad MMR data" error (PASSES)
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu()

        # This assertion FAILS in vulnerable state (crash occurs)
        # and PASSES in fixed state (graceful error)
        assert not crashed, \
            f"Process crashed with signal {sig_num} - vulnerability exists!"

    def test_no_crash_with_pbm_output(self):
        """
        Test that PBM format output doesn't trigger a crash.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=pbm'])

        assert not crashed, \
            f"Crashed with signal {sig_num} on PBM format - vulnerability exists!"

    def test_no_crash_with_pgm_output(self):
        """
        Test that PGM format output doesn't trigger a crash.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=pgm'])

        assert not crashed, \
            f"Crashed with signal {sig_num} on PGM format - vulnerability exists!"

    def test_no_crash_with_ppm_output(self):
        """
        Test that PPM format output doesn't trigger a crash.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=ppm'])

        assert not crashed, \
            f"Crashed with signal {sig_num} on PPM format - vulnerability exists!"

    def test_no_crash_with_tiff_output(self):
        """
        Test that TIFF format output doesn't trigger a crash.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=tiff'])

        assert not crashed, \
            f"Crashed with signal {sig_num} on TIFF format - vulnerability exists!"


class TestMultipleAttempts:
    """
    Test that multiple decoding attempts are all stable (no crashes).
    """

    def test_repeated_decoding_stable(self):
        """
        Test 5 consecutive decode attempts don't cause crashes.

        Vulnerable: At least some attempts crash (FAILS)
        Fixed: All attempts return graceful error (PASSES)
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        for i in range(5):
            returncode, crashed, sig_num, stderr = run_ddjvu()

            assert not crashed, \
                f"Attempt {i+1}/5 crashed with signal {sig_num} - vulnerability exists!"


class TestGracefulErrorHandling:
    """
    Test that the fixed version provides graceful error handling.
    These tests verify the fix behavior, not just crash absence.
    """

    def test_graceful_rejection_with_error_message(self):
        """
        Test that malformed data is rejected with proper error message.

        Vulnerable: CRASHES (no proper error message - FAILS)
        Fixed: Returns non-zero with "Bad MMR data" error (PASSES)
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu()

        # First, must not crash
        assert not crashed, \
            f"Crashed with signal {sig_num} instead of graceful rejection!"

        # Then, should have proper error handling
        assert returncode != 0, \
            "Should reject malformed file with non-zero exit code"

        # Error message should mention the issue
        stderr_lower = stderr.lower()
        has_proper_error = any(kw in stderr_lower for kw in ['bad', 'mmr', 'invalid', 'error'])
        assert has_proper_error, \
            f"Expected descriptive error message, got: {stderr[:200]}"

    def test_quick_termination(self):
        """
        Test that decoder terminates quickly, not hanging on malformed data.

        Vulnerable: May crash (which is fast but wrong) - FAILS if crash
        Fixed: Exits quickly with error - PASSES
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        import time
        start = time.time()

        returncode, crashed, sig_num, stderr = run_ddjvu(timeout=10)
        elapsed = time.time() - start

        # Must not crash
        assert not crashed, \
            f"Crashed with signal {sig_num} - vulnerability exists!"

        # Should complete quickly
        assert elapsed < 5, \
            f"Took {elapsed:.1f}s - possible issue with error handling"


class TestBufferBoundaryConditions:
    """
    Tests specifically targeting the xr/pr pointer overflow conditions.
    """

    def test_xr_pointer_bounds(self):
        """
        Test xr pointer (lineruns buffer) doesn't overflow.

        The vulnerability writes beyond lineruns+width+2 when xr++ happens
        without bounds checking in horizontal/vertical mode processing.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=pbm'])

        assert not crashed, \
            f"xr pointer overflow caused crash (signal {sig_num}) - vulnerability exists!"

    def test_pr_pointer_bounds(self):
        """
        Test pr pointer (prevruns buffer) doesn't overflow.

        The vulnerability reads beyond prevruns+width+2 when pr++ happens
        without bounds checking in the reference line processing.
        """
        if not os.path.exists(POC_FILE):
            pytest.skip(f"PoC file not found at {POC_FILE}")

        # PGM format exercises slightly different code path
        returncode, crashed, sig_num, stderr = run_ddjvu(['-format=pgm'])

        assert not crashed, \
            f"pr pointer overflow caused crash (signal {sig_num}) - vulnerability exists!"
