cat <<'EOF' > /workspace/fix.patch
diff --git a/x/claims/keeper/ibc_callbacks.go b/x/claims/keeper/ibc_callbacks.go
index 5a27b235..d974b29a 100644
--- a/x/claims/keeper/ibc_callbacks.go
+++ b/x/claims/keeper/ibc_callbacks.go
@@ -9,6 +9,7 @@ import (
 	channeltypes "github.com/cosmos/ibc-go/v3/modules/core/04-channel/types"
 	"github.com/cosmos/ibc-go/v3/modules/core/exported"
 
+	evmos "github.com/tharsis/evmos/v2/types"
 	"github.com/tharsis/evmos/v2/x/claims/types"
 )
 
@@ -21,7 +22,7 @@ func (k Keeper) OnRecvPacket(
 ) exported.Acknowledgement {
 	params := k.GetParams(ctx)
 
-	// short circuit in case claim is not active (no-op)
+	// short (no-op) circuit by returning original ACK in case the claim is not active
 	if !params.IsClaimsActive(ctx.BlockTime()) {
 		return ack
 	}
@@ -60,6 +61,38 @@ func (k Keeper) OnRecvPacket(
 	}
 
 	senderClaimsRecord, senderRecordFound := k.GetClaimsRecord(ctx, sender)
+
+	// NOTE: we know that the connected chains from the authorized IBC channels
+	// don't support ethereum keys (i.e `ethsecp256k1`). Thus, so we return an error,
+	// unless the destination channel from a connection to a chain that is EVM-compatible
+	// or supports ethereum keys (eg: Cronos, Injective).
+	if sender.Equals(recipient) && !params.IsEVMChannel(packet.DestinationChannel) {
+		switch {
+		// case 1: secp256k1 key from sender/recipient has no claimed actions -> error ACK to prevent funds from getting stuck
+		case senderRecordFound && !senderClaimsRecord.HasClaimedAny():
+			return channeltypes.NewErrorAcknowledgement(
+				sdkerrors.Wrapf(
+					evmos.ErrKeyTypeNotSupported, "receiver address %s is not a valid ethereum address", data.Receiver,
+				).Error(),
+			)
+		default:
+			// case 2: sender/recipient has funds stuck -> error acknowledgement to prevent more transferred tokens from
+			// getting stuck while we implement IBC withdrawals
+			return channeltypes.NewErrorAcknowledgement(
+				sdkerrors.Wrapf(
+					evmos.ErrKeyTypeNotSupported,
+					"reverted transfer to unsupported address %s to prevent more funds from getting stuck",
+					data.Receiver,
+				).Error(),
+			)
+		}
+	}
+
+	// return original ACK in case the destination channel is not authorized
+	if !params.IsAuthorizedChannel(packet.DestinationChannel) {
+		return ack
+	}
+
 	recipientClaimsRecord, recipientRecordFound := k.GetClaimsRecord(ctx, recipient)
 
 	// handle the 4 cases for the recipient and sender claim records
diff --git a/x/claims/types/claim_record.go b/x/claims/types/claim_record.go
index 1ee604c524..6fa1c91f02 100644
--- a/x/claims/types/claim_record.go
+++ b/x/claims/types/claim_record.go
@@ -57,6 +57,17 @@ func (cr ClaimsRecord) HasClaimedAction(action Action) bool {
 	}
 }
 
+// HasClaimedAny returns true if the user has claimed at least one reward from the
+// available actions
+func (cr ClaimsRecord) HasClaimedAny() bool {
+	for _, completed := range cr.ActionsCompleted {
+		if completed {
+			return true
+		}
+	}
+	return false
+}
+
 // HasClaimedAll returns true if the user has claimed all the rewards from the
 // available actions
 func (cr ClaimsRecord) HasClaimedAll() bool {
diff --git a/types/errors.go b/types/errors.go
new file mode 100644
index 0000000000..8ca79877cb
--- /dev/null
+++ b/types/errors.go
@@ -0,0 +1,18 @@
+package types
+
+import (
+	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
+)
+
+// RootCodespace is the codespace for all errors defined in this package
+const RootCodespace = "evmos"
+
+// root error codes for Evmos
+const (
+	codeKeyTypeNotSupported = iota + 2
+)
+
+// errors
+var (
+	ErrKeyTypeNotSupported = sdkerrors.Register(RootCodespace, codeKeyTypeNotSupported, "key type 'secp256k1' not supported")
+)


EOF

cd /workspace/evmos
git apply --whitespace=nowarn  /workspace/fix.patch