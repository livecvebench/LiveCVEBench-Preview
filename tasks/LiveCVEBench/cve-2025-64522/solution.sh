#!/bin/bash
set -e

# Ensure Go is in PATH (golang Docker image puts it in /usr/local/go/bin)
export PATH=$PATH:/usr/local/go/bin

echo "Applying webhook URL validation fix..."

# Step 1: Create the validator.go file with URL validation logic
cat > /app/pkg/webhook/validator.go << 'EOF'
package webhook

import (
	"errors"
	"fmt"
	"net"
	"net/url"
	"slices"
	"strings"
)

var (
	// ErrInvalidScheme is returned when the webhook URL scheme is not http or https.
	ErrInvalidScheme = errors.New("webhook URL must use http or https scheme")
	// ErrPrivateIP is returned when the webhook URL resolves to a private IP address.
	ErrPrivateIP = errors.New("webhook URL cannot resolve to private or internal IP addresses")
	// ErrInvalidURL is returned when the webhook URL is invalid.
	ErrInvalidURL = errors.New("invalid webhook URL")
)

// ValidateWebhookURL validates that a webhook URL is safe to use.
// It checks:
// - URL is properly formatted
// - Scheme is http or https
// - Hostname does not resolve to private/internal IP addresses
// - Hostname is not localhost or similar.
func ValidateWebhookURL(rawURL string) error {
	if rawURL == "" {
		return ErrInvalidURL
	}

	// Parse the URL
	u, err := url.Parse(rawURL)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrInvalidURL, err)
	}

	// Check scheme
	if u.Scheme != "http" && u.Scheme != "https" {
		return ErrInvalidScheme
	}

	// Extract hostname (without port)
	hostname := u.Hostname()
	if hostname == "" {
		return fmt.Errorf("%w: missing hostname", ErrInvalidURL)
	}

	// Check for localhost variations
	if isLocalhost(hostname) {
		return ErrPrivateIP
	}

	// If it's an IP address, validate it directly
	if ip := net.ParseIP(hostname); ip != nil {
		if isPrivateOrInternalIP(ip) {
			return ErrPrivateIP
		}
		return nil
	}

	// Resolve hostname to IP addresses
	ips, err := net.LookupIP(hostname)
	if err != nil {
		return fmt.Errorf("%w: cannot resolve hostname: %v", ErrInvalidURL, err)
	}

	// Check all resolved IPs
	if slices.ContainsFunc(ips, isPrivateOrInternalIP) {
		return ErrPrivateIP
	}

	return nil
}

// isLocalhost checks if the hostname is localhost or similar.
func isLocalhost(hostname string) bool {
	hostname = strings.ToLower(hostname)
	return hostname == "localhost" ||
		hostname == "localhost.localdomain" ||
		strings.HasSuffix(hostname, ".localhost")
}

// isPrivateOrInternalIP checks if an IP address is private, internal, or reserved.
func isPrivateOrInternalIP(ip net.IP) bool {
	// Loopback addresses (127.0.0.0/8, ::1)
	if ip.IsLoopback() {
		return true
	}

	// Link-local addresses (169.254.0.0/16, fe80::/10)
	// This blocks AWS/GCP/Azure metadata services
	if ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() {
		return true
	}

	// Private addresses (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7)
	if ip.IsPrivate() {
		return true
	}

	// Unspecified addresses (0.0.0.0, ::)
	if ip.IsUnspecified() {
		return true
	}

	// Multicast addresses
	if ip.IsMulticast() {
		return true
	}

	// Additional checks for IPv4
	if ip4 := ip.To4(); ip4 != nil {
		// 0.0.0.0/8 (current network)
		if ip4[0] == 0 {
			return true
		}
		// 100.64.0.0/10 (Shared Address Space)
		if ip4[0] == 100 && ip4[1] >= 64 && ip4[1] <= 127 {
			return true
		}
		// 192.0.0.0/24 (IETF Protocol Assignments)
		if ip4[0] == 192 && ip4[1] == 0 && ip4[2] == 0 {
			return true
		}
		// 192.0.2.0/24 (TEST-NET-1)
		if ip4[0] == 192 && ip4[1] == 0 && ip4[2] == 2 {
			return true
		}
		// 198.18.0.0/15 (benchmarking)
		if ip4[0] == 198 && (ip4[1] == 18 || ip4[1] == 19) {
			return true
		}
		// 198.51.100.0/24 (TEST-NET-2)
		if ip4[0] == 198 && ip4[1] == 51 && ip4[2] == 100 {
			return true
		}
		// 203.0.113.0/24 (TEST-NET-3)
		if ip4[0] == 203 && ip4[1] == 0 && ip4[2] == 113 {
			return true
		}
		// 224.0.0.0/4 (Multicast - already handled by IsMulticast)
		// 240.0.0.0/4 (Reserved for future use)
		if ip4[0] >= 240 {
			return true
		}
		// 255.255.255.255/32 (Broadcast)
		if ip4[0] == 255 && ip4[1] == 255 && ip4[2] == 255 && ip4[3] == 255 {
			return true
		}
	}

	return false
}

// ValidateIPBeforeDial validates an IP address before establishing a connection.
// This is used to prevent DNS rebinding attacks.
func ValidateIPBeforeDial(ip net.IP) error {
	if isPrivateOrInternalIP(ip) {
		return ErrPrivateIP
	}
	return nil
}
EOF

echo "Created validator.go"

# Step 2: Patch pkg/backend/webhooks.go to add URL validation in CreateWebhook
# Add validation after url = utils.Sanitize(url) line
if grep -q "ValidateWebhookURL" /app/pkg/backend/webhooks.go; then
    echo "CreateWebhook validation already applied"
else
    # Patch CreateWebhook function
    sed -i '/url = utils.Sanitize(url)/a\\n\t// Validate webhook URL to prevent SSRF attacks\n\tif err := webhook.ValidateWebhookURL(url); err != nil {\n\t\treturn err //nolint:wrapcheck\n\t}' /app/pkg/backend/webhooks.go
    echo "Patched CreateWebhook in webhooks.go"
fi

# Step 3: Patch UpdateWebhook function in pkg/backend/webhooks.go
# Add validation after datastore := store.FromContext(ctx)
if grep -q "ValidateWebhookURL" /app/pkg/backend/webhooks.go | grep -q "UpdateWebhook" 2>/dev/null; then
    echo "UpdateWebhook validation may already be applied"
fi

# We need to insert after the datastore line in UpdateWebhook
# This is trickier because sed doesn't easily handle function-scoped changes
# Use a more targeted approach with a marker

# First, let's check if the file needs patching for UpdateWebhook
if ! grep -A5 "func (b \*Backend) UpdateWebhook" /app/pkg/backend/webhooks.go | grep -q "ValidateWebhookURL"; then
    # Create a temporary Python script to do the patch properly
    python3 << 'PYTHON_SCRIPT'
import re

with open('/app/pkg/backend/webhooks.go', 'r') as f:
    content = f.read()

# Pattern to find the UpdateWebhook function and add validation after datastore line
pattern = r'(func \(b \*Backend\) UpdateWebhook\([^)]+\) error \{\s*\n\s*dbx := db\.FromContext\(ctx\)\s*\n\s*datastore := store\.FromContext\(ctx\))'

replacement = r'''\1

	// Validate webhook URL to prevent SSRF attacks
	if err := webhook.ValidateWebhookURL(url); err != nil {
		return err
	}'''

new_content = re.sub(pattern, replacement, content)

with open('/app/pkg/backend/webhooks.go', 'w') as f:
    f.write(new_content)

print("Patched UpdateWebhook in webhooks.go")
PYTHON_SCRIPT
fi

# Step 4: Patch pkg/webhook/webhook.go to add secure HTTP client
if grep -q "secureHTTPClient" /app/pkg/webhook/webhook.go; then
    echo "Secure HTTP client already added"
else
    # Add net and time imports if not present
    if ! grep -q '"net"' /app/pkg/webhook/webhook.go; then
        sed -i 's/"io"/"io"\n\t"net"/' /app/pkg/webhook/webhook.go
    fi
    if ! grep -q '"time"' /app/pkg/webhook/webhook.go; then
        sed -i 's/"net\/http"/"net\/http"\n\t"time"/' /app/pkg/webhook/webhook.go
    fi

    # Add the secure HTTP client after the Delivery struct
    python3 << 'PYTHON_SCRIPT'
import re

with open('/app/pkg/webhook/webhook.go', 'r') as f:
    content = f.read()

# Find the Delivery struct and add secureHTTPClient after it
secure_client_code = '''

// secureHTTPClient creates an HTTP client with SSRF protection.
var secureHTTPClient = &http.Client{
	Timeout: 30 * time.Second,
	Transport: &http.Transport{
		DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
			host, _, err := net.SplitHostPort(addr)
			if err != nil {
				return nil, err
			}

			ip := net.ParseIP(host)
			if ip != nil {
				if err := ValidateIPBeforeDial(ip); err != nil {
					return nil, fmt.Errorf("blocked connection to private IP: %w", err)
				}
			}

			dialer := &net.Dialer{
				Timeout:   10 * time.Second,
				KeepAlive: 30 * time.Second,
			}
			return dialer.DialContext(ctx, network, addr)
		},
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	},
	CheckRedirect: func(*http.Request, []*http.Request) error {
		return http.ErrUseLastResponse
	},
}
'''

# Insert after the Delivery struct
pattern = r'(type Delivery struct \{[^}]+\})'
replacement = r'\1' + secure_client_code

new_content = re.sub(pattern, replacement, content)

# Now replace http.DefaultClient.Do with secureHTTPClient.Do
new_content = new_content.replace('http.DefaultClient.Do(req)', 'secureHTTPClient.Do(req)')

with open('/app/pkg/webhook/webhook.go', 'w') as f:
    f.write(new_content)

print("Added secureHTTPClient and patched do() function")
PYTHON_SCRIPT
fi

echo "All patches applied"

# Step 5: Rebuild the application
echo "Rebuilding soft-serve..."
cd /app

# Run go mod tidy to ensure dependencies are correct
go mod tidy 2>/dev/null || true

# Build the application
go build -o /usr/local/bin/soft ./cmd/soft

echo "Rebuild complete"

# Step 6: Restart the service
# Kill the running soft-serve process so the entrypoint can restart it
echo "Restarting soft-serve..."
pkill -f "soft serve" || true
pkill -f "/usr/local/bin/soft" || true

# Give it time to shut down
sleep 3

echo "Fix applied successfully!"
echo "The service will be restarted by the container entrypoint."
