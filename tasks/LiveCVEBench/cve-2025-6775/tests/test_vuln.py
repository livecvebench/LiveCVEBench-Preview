#!/usr/bin/env python3
"""
Vulnerability tests for OpenVPN CMS Flask application.
These tests verify that command injection is NOT possible.
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""

import os
import pytest
import requests
import subprocess
import time
import uuid

BASE_URL = os.environ.get("APP_URL", "http://localhost:5000")
DEFAULT_USERNAME = "super"
DEFAULT_PASSWORD = "openvpn@123456"


def get_auth_token():
    """Get authentication token."""
    login_url = f"{BASE_URL}/cms/user/login"
    params = {"username": DEFAULT_USERNAME, "password": DEFAULT_PASSWORD}

    response = requests.post(login_url, params=params, timeout=10)
    if response.status_code != 200:
        pytest.fail(f"Authentication failed: {response.text}")
    return response.json()["access_token"]


def send_malicious_payload(token, username_payload):
    """Send a potentially malicious username to the openvpn endpoint."""
    openvpn_url = f"{BASE_URL}/v1/openvpn"
    headers = {"Authorization": f"Bearer {token}"}
    payload = {
        "username": username_payload,
        "nickname": "test",
        "summary": "test"
    }

    return requests.post(openvpn_url, headers=headers, json=payload, timeout=10)


def file_exists_in_container(filepath):
    """Check if a file exists (works both locally and in container)."""
    return os.path.exists(filepath)


def clean_marker_file(filepath):
    """Remove marker file if it exists."""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception:
        pass


class TestCommandInjectionSemicolon:
    """Test semicolon-based command injection payloads.

    Note: The vulnerable app has a 20-character username limit, so payloads must be short.
    We use /tmp/vXXX format (16 chars for ';touch /tmp/vXXX') to stay under the limit.
    """

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        # Cleanup marker files
        for f in self.marker_files:
            clean_marker_file(f)

    def test_semicolon_touch_command(self):
        """Test semicolon injection to create a file."""
        # Short path to fit within 20-char username limit: ';touch /tmp/vXXX' = 16 chars
        marker_file = f"/tmp/a{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f";touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)  # Give time for command execution

        # If file exists, vulnerability is present - test should FAIL
        assert not file_exists_in_container(marker_file), \
            f"Command injection successful! File {marker_file} was created. " \
            "The application executed the injected 'touch' command."

    def test_semicolon_with_leading_text(self):
        """Test semicolon injection with leading username text."""
        # 'a;touch /tmp/bXXX' = 17 chars
        marker_file = f"/tmp/b{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"a;touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Command injection with leading text successful! File {marker_file} was created."

    def test_multiple_semicolon_commands(self):
        """Test multiple commands chained with semicolons."""
        # ';touch /tmp/cXXX' = 16 chars (skip id;ls to fit limit)
        marker_file = f"/tmp/c{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        # Simplified to fit 20-char limit
        payload = f";touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Multiple semicolon command injection successful! File {marker_file} was created."


class TestCommandInjectionPipe:
    """Test pipe-based command injection payloads."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_pipe_command_injection(self):
        """Test pipe injection to execute command."""
        # '|touch /tmp/dXXX' = 16 chars
        marker_file = f"/tmp/d{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"|touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Pipe command injection successful! File {marker_file} was created."

    def test_double_pipe_or_injection(self):
        """Test OR operator with failing command to trigger second part.

        Note: The || operator only executes the second command if the first FAILS.
        We use 'x;0||touch' where '0' is not a valid command (fails), triggering ||.
        """
        # 'x;0||touch /tmp/eXX' = 19 chars (2-char hex suffix)
        marker_file = f"/tmp/e{uuid.uuid4().hex[:2]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        # x;0 terminates first cmd with ; then 0 fails (not a command), triggering ||touch
        payload = f"x;0||touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"OR operator injection successful! File {marker_file} was created."


class TestCommandInjectionSubstitution:
    """Test command substitution injection payloads."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_dollar_parentheses_substitution(self):
        """Test $() command substitution."""
        # '$(touch /tmp/fXXX)' = 18 chars
        marker_file = f"/tmp/f{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"$(touch {marker_file})"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Command substitution $() successful! File {marker_file} was created."

    def test_backtick_substitution(self):
        """Test backtick command substitution."""
        # '`touch /tmp/gXXX`' = 17 chars
        marker_file = f"/tmp/g{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"`touch {marker_file}`"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Backtick command substitution successful! File {marker_file} was created."

    def test_nested_command_substitution(self):
        """Test nested command substitution."""
        # 'x$(touch /tmp/hXXX)' = 19 chars
        marker_file = f"/tmp/h{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"x$(touch {marker_file})"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Nested command substitution successful! File {marker_file} was created."


class TestCommandInjectionAmpersand:
    """Test ampersand-based command injection payloads."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_ampersand_background_command(self):
        """Test single ampersand background execution."""
        # 'x&touch /tmp/iXXX' = 17 chars
        marker_file = f"/tmp/i{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"x&touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Ampersand background injection successful! File {marker_file} was created."

    def test_double_ampersand_and_injection(self):
        """Test AND operator injection (&&)."""
        # 'x&&touch /tmp/jXXX' = 18 chars
        marker_file = f"/tmp/j{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"x&&touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"AND operator injection (&&) successful! File {marker_file} was created."


class TestCommandInjectionNewline:
    """Test newline-based command injection payloads."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_newline_injection(self):
        """Test newline character injection."""
        # 'x\ntouch /tmp/kXXX' = 17 chars
        marker_file = f"/tmp/k{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"x\ntouch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Newline injection successful! File {marker_file} was created."

    def test_carriage_return_injection(self):
        """Test carriage return + newline injection."""
        # 'x\r\ntouch /tmp/lXXX' = 18 chars
        marker_file = f"/tmp/l{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f"x\r\ntouch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"CRLF injection successful! File {marker_file} was created."


class TestCommandInjectionWriteContent:
    """Test command injection by writing content to files."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_echo_redirect(self):
        """Test echo with redirect to write file content."""
        # ';echo x>/tmp/mXXX' = 17 chars
        marker_file = f"/tmp/m{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f";echo x>{marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Echo redirect injection successful! File {marker_file} was created."

    def test_append_redirect(self):
        """Test append redirect."""
        # ';echo x>>/tmp/nXXX' = 18 chars
        marker_file = f"/tmp/n{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f";echo x>>{marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Append redirect injection successful! File {marker_file} was created."


class TestCommandInjectionPathTraversal:
    """Test command injection with path traversal attempts."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_path_traversal_with_injection(self):
        """Test path traversal combined with command injection."""
        # ';touch /tmp/oXXX' = 16 chars (skip ../ to fit limit)
        marker_file = f"/tmp/o{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        # Simplified to fit 20-char limit
        payload = f";touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Path traversal with injection successful! File {marker_file} was created."


class TestCommandInjectionEdgeCases:
    """Test edge cases and bypass attempts."""

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self):
        """Setup and teardown for each test."""
        self.marker_files = []
        yield
        for f in self.marker_files:
            clean_marker_file(f)

    def test_whitespace_bypass(self):
        """Test using $IFS (Internal Field Separator) bypass."""
        # ';touch$IFS/tmp/pXXX' = 19 chars
        marker_file = f"/tmp/p{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        # $IFS can be used to bypass space filtering
        payload = f";touch$IFS{marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"IFS bypass injection successful! File {marker_file} was created."

    def test_tab_separator(self):
        """Test using tab as command separator."""
        # ';\ttouch\t/tmp/qXXX' = 18 chars
        marker_file = f"/tmp/q{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f";\ttouch\t{marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Tab separator injection successful! File {marker_file} was created."

    def test_short_payload(self):
        """Test minimal payload within length limits."""
        # ';touch /tmp/rXXX' = 16 chars
        marker_file = f"/tmp/r{uuid.uuid4().hex[:3]}"
        self.marker_files.append(marker_file)
        clean_marker_file(marker_file)

        token = get_auth_token()
        payload = f";touch {marker_file}"

        send_malicious_payload(token, payload)
        time.sleep(1)

        assert not file_exists_in_container(marker_file), \
            f"Short payload injection successful! File {marker_file} was created."
