"""
Functional tests for URL validation in BentoML.
These tests verify the application works correctly after fixes are applied.
Tests should PASS in both vulnerable and fixed states (core functionality works).
"""

import pytest
import requests
import time
import subprocess
import sys

BASE_URL = "http://localhost:3000"


def wait_for_service(url, timeout=60):
    """Wait for the BentoML service to be ready."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            resp = requests.get(f"{url}/readyz", timeout=5)
            if resp.status_code == 200:
                return True
        except requests.exceptions.ConnectionError:
            pass
        time.sleep(2)
    return False


@pytest.fixture(scope="module", autouse=True)
def service_ready():
    """Ensure the service is ready before running tests."""
    assert wait_for_service(BASE_URL), "BentoML service did not start in time"


class TestServiceBasicFunctionality:
    """Test that the service endpoints are accessible and responding."""

    def test_service_healthcheck(self):
        """Verify service health endpoint is responding."""
        response = requests.get(f"{BASE_URL}/readyz", timeout=10)
        assert response.status_code == 200

    def test_service_livez(self):
        """Verify service livez endpoint is responding."""
        response = requests.get(f"{BASE_URL}/livez", timeout=10)
        assert response.status_code == 200

    def test_endpoint_exists(self):
        """Verify the process_file endpoint exists."""
        # Sending an empty request should get a response (even if error)
        response = requests.post(f"{BASE_URL}/process_file", timeout=10)
        # We just need to verify the endpoint exists, not that it succeeds
        assert response.status_code in [200, 400, 422, 500]


class TestPublicURLsAllowed:
    """Test that public URLs are still allowed after fix."""

    def test_public_https_url_not_blocked(self):
        """
        Verify that public HTTPS URLs are not blocked by URL validation.
        The request may fail for other reasons (network, content), but should
        not fail due to URL security validation.
        """
        # Using a known reliable public URL
        public_url = "https://www.google.com/robots.txt"

        # Test via multipart form
        response = requests.post(
            f"{BASE_URL}/process_file",
            files={'file': (None, public_url)},
            timeout=30
        )

        # The response should NOT contain "URL not allowed" error
        response_text = response.text.lower()
        assert "url not allowed" not in response_text, \
            f"Public URL was incorrectly blocked: {response.text}"

    def test_public_http_url_format_accepted(self):
        """
        Verify that HTTP URLs with proper format are accepted.
        Note: The actual fetch may fail, but URL validation should pass.
        """
        # Using example.com which is a valid public domain
        public_url = "http://example.com/"

        response = requests.post(
            f"{BASE_URL}/process_file",
            files={'file': (None, public_url)},
            timeout=30
        )

        response_text = response.text.lower()
        assert "url not allowed" not in response_text, \
            f"Public URL was incorrectly blocked: {response.text}"


class TestRequestMethods:
    """Test both multipart and JSON request methods work."""

    def test_multipart_form_request(self):
        """Verify multipart form requests are handled."""
        # Send actual file content
        response = requests.post(
            f"{BASE_URL}/process_file",
            files={'file': ('test.txt', b'test content', 'text/plain')},
            timeout=10
        )
        # Service should respond (may error on content, but endpoint works)
        assert response.status_code in [200, 400, 422, 500]

    def test_json_request_format(self):
        """Verify JSON requests are handled."""
        response = requests.post(
            f"{BASE_URL}/process_file",
            headers={"Content-Type": "application/json"},
            json={"file": "test"},
            timeout=10
        )
        # Service should respond
        assert response.status_code in [200, 400, 422, 500]


class TestErrorHandling:
    """Test that the service handles errors gracefully."""

    def test_invalid_url_format(self):
        """Verify invalid URL formats are handled gracefully."""
        invalid_url = "not-a-valid-url"

        response = requests.post(
            f"{BASE_URL}/process_file",
            files={'file': (None, invalid_url)},
            timeout=10
        )

        # Should return an error response, not crash
        assert response.status_code in [200, 400, 422, 500]

    def test_empty_request(self):
        """Verify empty requests are handled gracefully."""
        response = requests.post(
            f"{BASE_URL}/process_file",
            timeout=10
        )

        # Should return an error response, not crash
        assert response.status_code in [200, 400, 422, 500]

    def test_malformed_url(self):
        """Verify malformed URLs don't crash the service."""
        malformed_urls = [
            "://missing-scheme",
            "http://",
            "http:///no-host",
            "ftp://unsupported-scheme.com",
        ]

        for url in malformed_urls:
            response = requests.post(
                f"{BASE_URL}/process_file",
                files={'file': (None, url)},
                timeout=10
            )
            # Should handle gracefully
            assert response.status_code in [200, 400, 422, 500], \
                f"Service crashed on malformed URL: {url}"
