#!/usr/bin/env python3
"""
Functionality tests for WeGIA debug_info.php
These tests verify the application works correctly for normal operations.
Should PASS in both vulnerable and fixed states.
"""

import pytest
import requests
import os
import time

BASE_URL = os.environ.get("APP_URL", "http://127.0.0.1")
ENDPOINT = f"{BASE_URL}/html/configuracao/debug_info.php"

# Request timeout in seconds
TIMEOUT = 10


class TestApplicationBasicFunctionality:
    """Test basic application functionality"""

    def test_endpoint_is_accessible(self):
        """Test that the debug_info.php endpoint is accessible"""
        try:
            response = requests.get(ENDPOINT, timeout=TIMEOUT, allow_redirects=False)
            # The endpoint may redirect to login or return content
            # Both are acceptable responses indicating the server is running
            assert response.status_code in [200, 302, 303], \
                f"Endpoint not accessible, got status {response.status_code}"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")

    def test_post_request_is_handled(self):
        """Test that POST requests are handled without server errors"""
        payload = {
            'branch': 'master',
            'action': 'switch'
        }
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)
            # We accept various status codes, but not 5xx server errors
            assert response.status_code < 500, \
                f"Server error when handling POST: {response.status_code}"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")


class TestValidBranchNames:
    """Test that valid branch names are accepted"""

    @pytest.mark.parametrize("branch_name", [
        "master",
        "main",
        "develop",
        "feature-123",
        "feature_test",
        "feature/new-feature",
        "release-1.0.0",
        "hotfix/urgent-fix",
        "v1.2.3",
        "branch.with.dots",
    ])
    def test_valid_branch_names_accepted(self, branch_name):
        """Test that valid Git branch names are not rejected with 400 error"""
        payload = {
            'branch': branch_name,
            'action': 'switch'
        }
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)
            # Valid branch names should not return 400 Bad Request
            # They may fail for other reasons (e.g., branch doesn't exist) but not input validation
            # After fix, validation allows these patterns
            # Note: 400 is only expected for invalid patterns like special characters
            assert response.status_code != 400 or "Branch" not in response.text, \
                f"Valid branch name '{branch_name}' was rejected"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")

    def test_update_action_handled(self):
        """Test that update action is handled"""
        payload = {
            'branch': 'master',
            'action': 'update'
        }
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)
            # Should redirect or handle the update action
            assert response.status_code < 500, \
                f"Server error when handling update action: {response.status_code}"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")


class TestResponseTime:
    """Test that responses return within acceptable time limits"""

    def test_simple_request_responds_quickly(self):
        """Test that a simple valid request responds within reasonable time"""
        payload = {
            'branch': 'master',
            'action': 'switch'
        }
        start_time = time.time()
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=10, allow_redirects=False)
            elapsed = time.time() - start_time
            # Normal requests should complete within 5 seconds
            assert elapsed < 5, \
                f"Request took {elapsed:.2f}s, expected < 5s"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - this may indicate a problem")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
