#!/bin/bash
#
# Solution script for fixing the off-by-one loop bug and error handling
# in tiffmedian's quant_fsdither() and get_histogram() functions.
#
set -e

FILE="/app/libtiff/tools/tiffmedian.c"

echo "Applying fixes to $FILE..."

# Verify file exists
if [ ! -f "$FILE" ]; then
    echo "Error: $FILE not found"
    exit 1
fi

# Check if already fixed
if grep -q 'for (i = 0; i < imagelength; ++i)' "$FILE" 2>/dev/null; then
    if grep -q 'fprintf(stderr, "Error reading scanline' "$FILE" 2>/dev/null; then
        echo "File appears to already be fixed, skipping..."
    fi
fi

# Fix 1: Change the loop initialization and boundary in quant_fsdither()
# Original: for (i = 1; i <= imagelength; ++i)
# Fixed:    for (i = 0; i < imagelength; ++i)
#
# This fixes the off-by-one error that skips the first line
sed -i 's/for (i = 1; i <= imagelength; ++i)/for (i = 0; i < imagelength; ++i)/g' "$FILE"

# Fix 2: Change TIFFWriteScanline from i-1 to i
# Original: if (TIFFWriteScanline(out, outline, i - 1, 0) < 0)
# Fixed:    if (TIFFWriteScanline(out, outline, i, 0) < 0)
#
# This corrects the scanline index to match the new loop indexing
sed -i 's/if (TIFFWriteScanline(out, outline, i - 1, 0) < 0)/if (TIFFWriteScanline(out, outline, i, 0) < 0)/g' "$FILE"

# Fix 3: Change silent break to proper error handling in get_histogram()
# Original:
#     if (TIFFReadScanline(in, inputline, i, 0) <= 0)
#         break;
# Fixed:
#     if (TIFFReadScanline(in, inputline, i, 0) <= 0)
#     {
#         fprintf(stderr, "Error reading scanline\n");
#         exit(EXIT_FAILURE);
#     }
#
# This ensures read errors are properly reported instead of silently ignored

# Use a more robust approach with a temp file
TEMP_FILE=$(mktemp)
awk '
/if \(TIFFReadScanline\(in, inputline, i, 0\) <= 0\)/ {
    print $0
    getline
    if ($0 ~ /break;/) {
        print "        {"
        print "            fprintf(stderr, \"Error reading scanline\\n\");"
        print "            exit(EXIT_FAILURE);"
        print "        }"
    } else {
        print $0
    }
    next
}
{ print }
' "$FILE" > "$TEMP_FILE"

# Only replace if the transformation succeeded
if [ -s "$TEMP_FILE" ]; then
    cp "$TEMP_FILE" "$FILE"
fi
rm -f "$TEMP_FILE"

# Fix 4: Remove erroneous _TIFFfree(cell) in map_colortable()
# The cell pointer points to memory that's still referenced in ColorCells array
# and will be accessed later by quant_fsdither(). Freeing it here causes use-after-free.
# The cells will be properly freed when ColorCells is freed.
sed -i '/^[[:space:]]*_TIFFfree(cell);$/d' "$FILE"

echo "Fixes applied successfully."

# Rebuild both builds (non-ASan for functional tests, ASan for vulnerability tests)
echo "Rebuilding libtiff..."

# Rebuild non-ASan build
cd /app/mybuild
make -j$(nproc) 2>&1 | tail -20

# Rebuild ASan build
cd /app/mybuild_asan
make -j$(nproc) 2>&1 | tail -20

echo "Build complete."
echo "Fix summary:"
echo "  1. Loop now iterates from 0 to imagelength-1 (was 1 to imagelength)"
echo "  2. TIFFWriteScanline uses correct index i (was i-1)"
echo "  3. Read errors in get_histogram() now exit with error message"
echo "  4. Removed erroneous _TIFFfree(cell) in map_colortable() that caused use-after-free"
