"""
Vulnerability tests for Solid.js SSR HTML encoding issue.
These tests verify that HTML special characters are properly escaped.

- FAIL in vulnerable state (HTML tags appear unescaped in output)
- PASS in fixed state (HTML tags are properly escaped)

NOTE: These tests check the user content area specifically, not the whole page,
because Solid.js adds legitimate hydration scripts to the page that should NOT
be flagged as XSS vulnerabilities.
"""

import requests
import time
import pytest
import re
import os

BASE_URL = os.environ.get("APP_URL", "http://localhost:3000")


def wait_for_server(url, timeout=30):
    """Wait for server to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(1)
    return False


def extract_user_content(html):
    """
    Extract the user content area from the SSR response.
    The user content is rendered inside: User Input: <!--$-->CONTENT<!--/-->
    or similar patterns based on Solid's SSR output.
    """
    # Try to find content between User Input markers
    # Pattern matches: User Input: followed by content until end of div or comment
    match = re.search(r'User Input:\s*(?:<!--\$-->)?(.*?)(?:<!--/-->|</div>)', html, re.DOTALL)
    if match:
        return match.group(1)

    # Fallback: try to get content between Solid SSR comments
    match = re.search(r'<!--\$-->(.*?)<!--/-->', html, re.DOTALL)
    if match:
        return match.group(1)

    # Last resort: return the body content excluding script tags
    body_match = re.search(r'<body[^>]*>(.*?)</body>', html, re.DOTALL | re.IGNORECASE)
    if body_match:
        body = body_match.group(1)
        # Remove Solid's hydration scripts (they start with self.$R or _$HY)
        body = re.sub(r'<script>self\.\$R.*?</script>', '', body, flags=re.DOTALL)
        body = re.sub(r'<script>_\$HY.*?</script>', '', body, flags=re.DOTALL)
        return body

    return html


def check_xss_in_content(content, payload_tag):
    """
    Check if a specific HTML tag from the payload appears unescaped in the content.
    Returns True if the tag is UNESCAPED (vulnerable), False if escaped (safe).
    """
    # Check for raw unescaped tag (vulnerability)
    if re.search(rf'<{payload_tag}[^&]', content, re.IGNORECASE):
        return True
    # Also check for exact tag match
    if f'<{payload_tag}>' in content.lower():
        return True
    return False


class TestBasicHTMLTagEscaping:
    """Test that basic HTML tags are properly escaped in user content."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_script_tag_escaped(self):
        """Test that <script> tags from user input are escaped."""
        payload = "<script>alert(1)</script>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The user content should NOT contain raw <script> tag
        # It should be escaped to &lt;script&gt;
        assert "<script>" not in user_content, \
            f"Unescaped <script> tag found in user content area: {user_content}"

    def test_svg_tag_escaped(self):
        """Test that <svg> tags are escaped."""
        payload = "<svg/onload=alert(1)>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Raw <svg tag should NOT appear in user content
        assert not check_xss_in_content(user_content, 'svg'), \
            f"Unescaped <svg> tag found in user content: {user_content}"

    def test_img_tag_escaped(self):
        """Test that <img> tags are escaped."""
        payload = "<img src=x onerror=alert(1)>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Raw <img tag should NOT appear in user content
        assert not check_xss_in_content(user_content, 'img'), \
            f"Unescaped <img> tag found in user content: {user_content}"

    def test_div_tag_escaped(self):
        """Test that injected <div> tags with styles are escaped."""
        payload = "<div style='color:red'>malicious</div>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The key is that the < character must be escaped to prevent HTML injection
        # If < is escaped to &lt; then the whole tag is safe
        assert not re.search(r'<div[^&]', user_content, re.IGNORECASE), \
            f"Unescaped <div> tag found in user content: {user_content}"


class TestEventHandlerEscaping:
    """Test that event handler injection attempts are escaped."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_onload_event_escaped(self):
        """Test that onload event handlers are escaped."""
        payload = "<body onload=alert(1)>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Should not contain raw onload attribute from injected payload
        assert not re.search(r'<body[^>]*onload', user_content, re.IGNORECASE), \
            f"Unescaped onload event found in user content: {user_content}"

    def test_onerror_event_escaped(self):
        """Test that onerror event handlers are escaped."""
        payload = "<img src=x onerror=alert('xss')>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Raw img with onerror should NOT appear
        assert not re.search(r'<img[^>]*onerror', user_content, re.IGNORECASE), \
            f"Unescaped onerror event found in user content: {user_content}"

    def test_onclick_event_escaped(self):
        """Test that onclick event handlers are escaped."""
        payload = "<a href='#' onclick=alert(1)>click</a>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Raw anchor with onclick should NOT appear
        assert not re.search(r'<a[^>]*onclick', user_content, re.IGNORECASE), \
            f"Unescaped onclick event found in user content: {user_content}"

    def test_onmouseover_event_escaped(self):
        """Test that onmouseover event handlers are escaped."""
        payload = "<div onmouseover=alert(1)>hover</div>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The key is that the < character must be escaped to prevent HTML injection
        # If < is escaped to &lt; then the whole tag including event handler is safe
        assert not re.search(r'<div[^&]', user_content, re.IGNORECASE), \
            f"Unescaped <div> tag with onmouseover found in user content: {user_content}"


class TestEncodedPayloads:
    """Test various encoding bypass attempts."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_mixed_case_script_escaped(self):
        """Test that mixed-case script tags are escaped."""
        payload = "<ScRiPt>alert(1)</sCrIpT>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert not re.search(r'<script', user_content, re.IGNORECASE), \
            f"Unescaped mixed-case script tag found in user content: {user_content}"

    def test_self_closing_script_escaped(self):
        """Test that self-closing script variants are escaped."""
        payload = "<script/src=data:,alert(1)>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert not re.search(r'<script', user_content, re.IGNORECASE), \
            f"Unescaped self-closing script found in user content: {user_content}"

    def test_iframe_escaped(self):
        """Test that iframe tags are escaped."""
        payload = "<iframe src='javascript:alert(1)'>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert not re.search(r'<iframe', user_content, re.IGNORECASE), \
            f"Unescaped iframe tag found in user content: {user_content}"

    def test_object_tag_escaped(self):
        """Test that object tags are escaped."""
        payload = "<object data='javascript:alert(1)'>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert not re.search(r'<object[^>]*data\s*=', user_content, re.IGNORECASE), \
            f"Unescaped object tag found in user content: {user_content}"


class TestProperEscaping:
    """Test that content is properly escaped with HTML entities."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_less_than_escaped(self):
        """Test that < is escaped to &lt; in the response."""
        payload = "<test>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The raw tag should not appear, and escaped version should
        assert "&lt;" in user_content or "<test>" not in user_content, \
            f"Less-than character not properly escaped in user content: {user_content}"

    def test_ampersand_escaped(self):
        """Test that & is escaped to &amp; when needed."""
        payload = "test&<script>alert(1)</script>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The content contains both & and <script> tag
        # The < should be escaped to prevent XSS
        assert "<script>" not in user_content, \
            f"Script tag after ampersand not escaped: {user_content}"

    def test_html_entities_preserved_after_escaping(self):
        """Test that HTML content alongside entities is properly escaped."""
        # This payload has both HTML entities AND a real script tag
        payload = "&lt;safe&gt;<script>alert('xss')</script>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The real script tag should be escaped to prevent XSS
        assert "<script>" not in user_content, \
            f"Script tag not escaped in content with HTML entities: {user_content}"


class TestComplexPayloads:
    """Test more complex injection payloads."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_nested_tags_escaped(self):
        """Test that nested malicious tags are escaped."""
        payload = "<div><script>alert(1)</script></div>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert "<script>" not in user_content, \
            f"Nested script tag not escaped in user content: {user_content}"

    def test_multiple_tags_escaped(self):
        """Test that multiple tags are all escaped."""
        payload = "<script>a</script><img src=x onerror=b><svg onload=c>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert "<script>" not in user_content, f"Script tag not escaped: {user_content}"
        assert not check_xss_in_content(user_content, 'img'), f"Img tag not escaped: {user_content}"
        assert not check_xss_in_content(user_content, 'svg'), f"Svg tag not escaped: {user_content}"

    def test_javascript_protocol_escaped(self):
        """Test that javascript: protocol is handled."""
        payload = "<a href='javascript:alert(1)'>click</a>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The raw anchor tag should be escaped
        assert not re.search(r"<a[^>]*href\s*=\s*['\"]?javascript:", user_content, re.IGNORECASE), \
            f"javascript: protocol in href not properly handled: {user_content}"

    def test_data_protocol_escaped(self):
        """Test that data: protocol is handled."""
        payload = "<a href='data:text/html,<script>alert(1)</script>'>click</a>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The raw anchor tag should be escaped
        assert not re.search(r"<a[^>]*href\s*=\s*['\"]?data:", user_content, re.IGNORECASE), \
            f"data: protocol in href not properly handled: {user_content}"


class TestEdgeCases:
    """Test edge cases in HTML escaping."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(BASE_URL), f"Server at {BASE_URL} not available"

    def test_broken_tag_escaped(self):
        """Test that broken/incomplete tags are handled."""
        payload = "<script"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # Even incomplete tags should be escaped to prevent HTML context issues
        # The < character should be escaped to &lt;
        assert "&lt;" in user_content or "<script" not in user_content, \
            f"Broken tag not escaped in user content: {user_content}"

    def test_tag_with_newlines_escaped(self):
        """Test that tags with newlines are escaped."""
        payload = "<script\n>alert(1)</script\n>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        assert not re.search(r'<script\s*>', user_content, re.IGNORECASE), \
            f"Script tag with newlines not escaped in user content: {user_content}"

    def test_null_byte_handling(self):
        """Test handling of null bytes in payload."""
        payload = "<scr\x00ipt>alert(1)</script>"
        response = requests.get(f"{BASE_URL}/?text={requests.utils.quote(payload)}")

        user_content = extract_user_content(response.text)

        # The < characters should be escaped regardless of null bytes
        # Check that raw HTML tags are not present
        assert "</script>" not in user_content, \
            f"Closing script tag not escaped: {user_content}"
