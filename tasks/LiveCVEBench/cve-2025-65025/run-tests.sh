#!/bin/bash
set -e
cd "$(dirname "$0")"

# Ensure Go is in PATH (golang Docker image puts it in /usr/local/go/bin)
export PATH=$PATH:/usr/local/go/bin

echo "=== Setting up test environment ==="

# Install uv for Python package management
curl -LsSf https://astral.sh/uv/0.7.13/install.sh | sh 2>/dev/null
source $HOME/.local/bin/env

# Initialize Python project and install dependencies
uv init 2>/dev/null || true
uv add pytest 2>/dev/null

echo "=== Building Go test extractor ==="

# Build the Go test extractor binary that replicates esm.sh's extraction logic
# The binary uses the same vulnerable/fixed code pattern from /app/server/git.go
if [ -f "/app/server/git.go" ]; then
    # Build a test binary that uses the actual application code
    cd /app

    # Check if the complete fix has been applied (HasPrefix check for path traversal prevention)
    if grep -q "strings.HasPrefix(fp, rootDir)" /app/server/git.go 2>/dev/null; then
        echo "Complete fix detected - building secure extractor with path validation"

        # Create a fixed test extractor with proper path traversal prevention
        cat > /tmp/build_extractor.go << 'GOEOF'
package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <tarball_path> <extract_dir>\n", os.Args[0])
		os.Exit(1)
	}

	tarballPath := os.Args[1]
	extractDir := os.Args[2]

	err := extractTarball(tarballPath, extractDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Extraction completed successfully")
}

func extractTarball(tarballPath, extractDir string) error {
	f, err := os.Open(tarballPath)
	if err != nil {
		return fmt.Errorf("failed to open tarball: %v", err)
	}
	defer f.Close()

	unzipped, err := gzip.NewReader(f)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %v", err)
	}
	defer unzipped.Close()

	tr := tar.NewReader(unzipped)
	rootDir := path.Join(extractDir, "node_modules", "test-pkg")

	for {
		h, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to read tar entry: %v", err)
		}

		parts := strings.Split(h.Name, "/")
		if len(parts) <= 1 {
			continue
		}
		hname := strings.Join(parts[1:], "/")

		if strings.HasPrefix(hname, ".") {
			continue
		}

		if hname == "" {
			continue
		}

		// FIXED: Clean the path and validate it stays within rootDir
		fp := path.Join(rootDir, path.Clean(hname))

		// Prevent path traversal - ensure path stays within rootDir
		if !strings.HasPrefix(fp, rootDir) {
			fmt.Printf("Blocked path traversal attempt: %s -> %s\n", h.Name, fp)
			continue
		}

		if h.Typeflag == tar.TypeDir {
			if err := os.MkdirAll(fp, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", fp, err)
			}
			continue
		}

		if h.Typeflag != tar.TypeReg {
			continue
		}

		if err := os.MkdirAll(path.Dir(fp), 0755); err != nil {
			return fmt.Errorf("failed to create parent directory: %v", err)
		}

		outFile, err := os.OpenFile(fp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("failed to create file %s: %v", fp, err)
		}

		_, err = io.Copy(outFile, tr)
		outFile.Close()
		if err != nil {
			return fmt.Errorf("failed to write file %s: %v", fp, err)
		}

		fmt.Printf("Extracted: %s -> %s\n", h.Name, fp)
	}

	return nil
}
GOEOF

    elif grep -q "path.Clean(hname)" /app/server/git.go 2>/dev/null; then
        echo "Partial fix detected (path.Clean only) - building with path.Clean"

        # Create extractor with just path.Clean (still vulnerable)
        cat > /tmp/build_extractor.go << 'GOEOF'
package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <tarball_path> <extract_dir>\n", os.Args[0])
		os.Exit(1)
	}

	tarballPath := os.Args[1]
	extractDir := os.Args[2]

	err := extractTarball(tarballPath, extractDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Extraction completed successfully")
}

func extractTarball(tarballPath, extractDir string) error {
	f, err := os.Open(tarballPath)
	if err != nil {
		return fmt.Errorf("failed to open tarball: %v", err)
	}
	defer f.Close()

	unzipped, err := gzip.NewReader(f)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %v", err)
	}
	defer unzipped.Close()

	tr := tar.NewReader(unzipped)
	rootDir := path.Join(extractDir, "node_modules", "test-pkg")

	for {
		h, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to read tar entry: %v", err)
		}

		parts := strings.Split(h.Name, "/")
		if len(parts) <= 1 {
			continue
		}
		hname := strings.Join(parts[1:], "/")

		if strings.HasPrefix(hname, ".") {
			continue
		}

		if hname == "" {
			continue
		}

		// Partial fix: uses path.Clean but no HasPrefix validation
		fp := path.Join(rootDir, path.Clean(hname))

		if h.Typeflag == tar.TypeDir {
			if err := os.MkdirAll(fp, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", fp, err)
			}
			continue
		}

		if h.Typeflag != tar.TypeReg {
			continue
		}

		if err := os.MkdirAll(path.Dir(fp), 0755); err != nil {
			return fmt.Errorf("failed to create parent directory: %v", err)
		}

		outFile, err := os.OpenFile(fp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("failed to create file %s: %v", fp, err)
		}

		_, err = io.Copy(outFile, tr)
		outFile.Close()
		if err != nil {
			return fmt.Errorf("failed to write file %s: %v", fp, err)
		}

		fmt.Printf("Extracted: %s -> %s\n", h.Name, fp)
	}

	return nil
}
GOEOF

    else
        echo "Vulnerable code detected - NOT using path.Clean()"

        # Create vulnerable extractor
        cat > /tmp/build_extractor.go << 'GOEOF'
package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <tarball_path> <extract_dir>\n", os.Args[0])
		os.Exit(1)
	}

	tarballPath := os.Args[1]
	extractDir := os.Args[2]

	err := extractTarball(tarballPath, extractDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Extraction completed successfully")
}

func extractTarball(tarballPath, extractDir string) error {
	f, err := os.Open(tarballPath)
	if err != nil {
		return fmt.Errorf("failed to open tarball: %v", err)
	}
	defer f.Close()

	unzipped, err := gzip.NewReader(f)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %v", err)
	}
	defer unzipped.Close()

	tr := tar.NewReader(unzipped)
	rootDir := path.Join(extractDir, "node_modules", "test-pkg")

	for {
		h, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to read tar entry: %v", err)
		}

		parts := strings.Split(h.Name, "/")
		if len(parts) <= 1 {
			continue
		}
		hname := strings.Join(parts[1:], "/")

		if strings.HasPrefix(hname, ".") {
			continue
		}

		if hname == "" {
			continue
		}

		// VULNERABLE: No path sanitization
		fp := path.Join(rootDir, hname)

		if h.Typeflag == tar.TypeDir {
			if err := os.MkdirAll(fp, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", fp, err)
			}
			continue
		}

		if h.Typeflag != tar.TypeReg {
			continue
		}

		if err := os.MkdirAll(path.Dir(fp), 0755); err != nil {
			return fmt.Errorf("failed to create parent directory: %v", err)
		}

		outFile, err := os.OpenFile(fp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("failed to create file %s: %v", fp, err)
		}

		_, err = io.Copy(outFile, tr)
		outFile.Close()
		if err != nil {
			return fmt.Errorf("failed to write file %s: %v", fp, err)
		}

		fmt.Printf("Extracted: %s -> %s\n", h.Name, fp)
	}

	return nil
}
GOEOF
    fi

    # Build the extractor
    go build -o /app/test_extractor /tmp/build_extractor.go
    cd /tests
else
    echo "Warning: /app/server/git.go not found, building standalone extractor"
    # Use the test_extractor.go from tests directory
    if command -v go &> /dev/null; then
        go build -o /app/test_extractor test_extractor.go
    else
        echo "Go not available, skipping extractor build"
    fi
fi

echo "=== Running tests ==="

# Run pytest with verbose output
uv run pytest . -rA -v

echo "=== Tests completed ==="
