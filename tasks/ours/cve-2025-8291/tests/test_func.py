#!/usr/bin/env python3
"""
Functional tests for zipfile module.

These tests verify that the zipfile module works correctly for valid
ZIP and ZIP64 archives. Should PASS in both vulnerable and fixed states.
"""

import io
import os
import struct
import tempfile
import zipfile
import zlib

import pytest


class TestBasicZipOperations:
    """Test basic ZIP file operations."""

    def test_create_and_read_simple_zip(self):
        """Test creating and reading a simple ZIP file."""
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('hello.txt', 'Hello, World!')
            zf.writestr('test.txt', 'Test content')

        buffer.seek(0)
        with zipfile.ZipFile(buffer, 'r') as zf:
            files = zf.namelist()
            assert 'hello.txt' in files
            assert 'test.txt' in files
            assert zf.read('hello.txt') == b'Hello, World!'
            assert zf.read('test.txt') == b'Test content'

    def test_create_and_read_with_subdirectories(self):
        """Test ZIP with subdirectories."""
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('dir1/file1.txt', 'File 1')
            zf.writestr('dir1/subdir/file2.txt', 'File 2')
            zf.writestr('dir2/file3.txt', 'File 3')

        buffer.seek(0)
        with zipfile.ZipFile(buffer, 'r') as zf:
            files = zf.namelist()
            assert 'dir1/file1.txt' in files
            assert 'dir1/subdir/file2.txt' in files
            assert 'dir2/file3.txt' in files

    def test_zip_with_compression(self):
        """Test ZIP file with compression."""
        buffer = io.BytesIO()
        # Create compressible content
        content = b'A' * 10000

        with zipfile.ZipFile(buffer, 'w', compression=zipfile.ZIP_DEFLATED) as zf:
            zf.writestr('compressed.txt', content)

        buffer.seek(0)
        with zipfile.ZipFile(buffer, 'r') as zf:
            assert zf.read('compressed.txt') == content
            info = zf.getinfo('compressed.txt')
            # Compressed size should be less than original
            assert info.compress_size < len(content)

    def test_is_zipfile_valid(self):
        """Test is_zipfile returns True for valid ZIP files."""
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('test.txt', 'Test')

        buffer.seek(0)
        assert zipfile.is_zipfile(buffer) is True

    def test_is_zipfile_invalid(self):
        """Test is_zipfile returns False for non-ZIP files."""
        buffer = io.BytesIO(b'This is not a ZIP file!')
        assert zipfile.is_zipfile(buffer) is False

        buffer = io.BytesIO(b'\x00\x01\x02\x03\x04\x05')
        assert zipfile.is_zipfile(buffer) is False


class TestZip64Archives:
    """Test ZIP64 archive handling."""

    def make_valid_zip64(self):
        """Create a valid ZIP64 archive with proper structure."""
        filename = b'test.txt'
        content = b'test1234'
        crc32_val = zlib.crc32(content) & 0xffffffff

        # Local file header
        local_header = (
            b'PK\x03\x04'  # Signature
            + b'\x2d\x00'  # Version needed (4.5 for zip64)
            + b'\x00\x00'  # Flags
            + b'\x00\x00'  # Compression (stored)
            + b'\x00\x00'  # Mod time
            + b'\x00\x00'  # Mod date
            + struct.pack('<I', crc32_val)  # CRC32 (computed)
            + b'\xff\xff\xff\xff'  # Compressed size (zip64 marker)
            + b'\xff\xff\xff\xff'  # Uncompressed size (zip64 marker)
            + struct.pack('<H', len(filename))  # Filename length
            + struct.pack('<H', 20)  # Extra field length (zip64 extra)
            + filename
        )

        # ZIP64 Extra field in local header
        local_zip64_extra = (
            b'\x01\x00'  # Tag (zip64)
            + struct.pack('<H', 16)  # Size
            + struct.pack('<Q', len(content))  # Uncompressed size
            + struct.pack('<Q', len(content))  # Compressed size
        )

        # Central directory header
        central_header = (
            b'PK\x01\x02'  # Signature
            + b'\x2d\x00'  # Version made by
            + b'\x2d\x00'  # Version needed
            + b'\x00\x00'  # Flags
            + b'\x00\x00'  # Compression
            + b'\x00\x00'  # Mod time
            + b'\x00\x00'  # Mod date
            + struct.pack('<I', crc32_val)  # CRC32 (computed)
            + b'\xff\xff\xff\xff'  # Compressed size (zip64 marker)
            + b'\xff\xff\xff\xff'  # Uncompressed size (zip64 marker)
            + struct.pack('<H', len(filename))  # Filename length
            + struct.pack('<H', 28)  # Extra field length
            + b'\x00\x00'  # Comment length
            + b'\xff\xff'  # Disk number (zip64 marker)
            + b'\x00\x00'  # Internal attrs
            + b'\x00\x00\x00\x00'  # External attrs
            + b'\xff\xff\xff\xff'  # Offset (zip64 marker)
            + filename
        )

        # ZIP64 extra field in central directory
        central_zip64_extra = (
            b'\x01\x00'  # Tag (zip64)
            + struct.pack('<H', 24)  # Size
            + struct.pack('<Q', len(content))  # Uncompressed size
            + struct.pack('<Q', len(content))  # Compressed size
            + struct.pack('<Q', 0)  # Header offset
        )

        # Calculate positions
        local_header_size = len(local_header) + len(local_zip64_extra) + len(content)
        central_dir_offset = local_header_size
        central_dir_size = len(central_header) + len(central_zip64_extra)
        zip64_eocd_offset = central_dir_offset + central_dir_size

        # ZIP64 End of Central Directory - with correct size (44)
        zip64_eocd = (
            b'PK\x06\x06'  # Signature
            + struct.pack('<Q', 44)  # Size of record (correctly set to 44 = sizeEndCentDir64 - 12)
            + b'\x2d\x00'  # Version made by
            + b'\x2d\x00'  # Version needed
            + b'\x00\x00\x00\x00'  # This disk
            + b'\x00\x00\x00\x00'  # Disk with central dir
            + struct.pack('<Q', 1)  # Entries on this disk
            + struct.pack('<Q', 1)  # Total entries
            + struct.pack('<Q', central_dir_size)  # Central dir size
            + struct.pack('<Q', central_dir_offset)  # Central dir offset
        )

        # ZIP64 End of Central Directory Locator (with correct offset)
        zip64_locator = (
            b'PK\x06\x07'  # Signature
            + b'\x00\x00\x00\x00'  # Disk number
            + struct.pack('<Q', zip64_eocd_offset)  # EOCD offset (correct)
            + b'\x01\x00\x00\x00'  # Total disks
        )

        # End of Central Directory
        eocd = (
            b'PK\x05\x06'  # Signature
            + b'\x00\x00'  # This disk
            + b'\x00\x00'  # Disk with central dir
            + b'\x01\x00'  # Entries on this disk
            + b'\x01\x00'  # Total entries
            + b'\xff\xff\xff\xff'  # Central dir size (zip64)
            + b'\xff\xff\xff\xff'  # Central dir offset (zip64)
            + b'\x00\x00'  # Comment length
        )

        # Assemble the ZIP file
        return (
            local_header
            + local_zip64_extra
            + content
            + central_header
            + central_zip64_extra
            + zip64_eocd
            + zip64_locator
            + eocd
        )

    def test_valid_zip64_opens(self):
        """Test that valid ZIP64 archives open correctly."""
        zip_data = self.make_valid_zip64()
        with zipfile.ZipFile(io.BytesIO(zip_data)) as zf:
            files = zf.namelist()
            assert 'test.txt' in files

    def test_valid_zip64_is_zipfile(self):
        """Test is_zipfile returns True for valid ZIP64."""
        zip_data = self.make_valid_zip64()
        assert zipfile.is_zipfile(io.BytesIO(zip_data)) is True

    def test_zip64_extract_content(self):
        """Test extracting content from valid ZIP64."""
        zip_data = self.make_valid_zip64()
        with zipfile.ZipFile(io.BytesIO(zip_data)) as zf:
            content = zf.read('test.txt')
            assert content == b'test1234'

    def test_zip64_getinfo(self):
        """Test getting file info from ZIP64 archive."""
        zip_data = self.make_valid_zip64()
        with zipfile.ZipFile(io.BytesIO(zip_data)) as zf:
            info = zf.getinfo('test.txt')
            assert info.file_size == 8
            assert info.compress_size == 8


class TestExtraction:
    """Test file extraction functionality."""

    def test_extract_to_tempdir(self):
        """Test extracting files to a temporary directory."""
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('file1.txt', 'Content 1')
            zf.writestr('dir/file2.txt', 'Content 2')

        buffer.seek(0)
        with tempfile.TemporaryDirectory() as tmpdir:
            with zipfile.ZipFile(buffer, 'r') as zf:
                zf.extractall(tmpdir)

            assert os.path.exists(os.path.join(tmpdir, 'file1.txt'))
            assert os.path.exists(os.path.join(tmpdir, 'dir', 'file2.txt'))

            with open(os.path.join(tmpdir, 'file1.txt')) as f:
                assert f.read() == 'Content 1'

    def test_extract_single_file(self):
        """Test extracting a single file."""
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('file1.txt', 'Content 1')
            zf.writestr('file2.txt', 'Content 2')

        buffer.seek(0)
        with tempfile.TemporaryDirectory() as tmpdir:
            with zipfile.ZipFile(buffer, 'r') as zf:
                zf.extract('file1.txt', tmpdir)

            assert os.path.exists(os.path.join(tmpdir, 'file1.txt'))
            # file2 should not exist since we only extracted file1
            assert not os.path.exists(os.path.join(tmpdir, 'file2.txt'))


class TestErrorHandling:
    """Test error handling for invalid files."""

    def test_not_a_zip_file(self):
        """Test opening non-ZIP file raises error."""
        buffer = io.BytesIO(b'Not a ZIP file content!')
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(buffer)

    def test_empty_file(self):
        """Test opening empty file raises error."""
        buffer = io.BytesIO(b'')
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(buffer)

    def test_truncated_zip(self):
        """Test opening truncated ZIP file raises error."""
        # Create valid ZIP, then truncate it
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zf:
            zf.writestr('test.txt', 'Hello, World!')

        data = buffer.getvalue()
        truncated = io.BytesIO(data[:len(data) // 2])

        with pytest.raises((zipfile.BadZipFile, OSError)):
            zipfile.ZipFile(truncated)
