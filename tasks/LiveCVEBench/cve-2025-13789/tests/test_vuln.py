#!/usr/bin/env python3
"""
Vulnerability tests for ZenTao PMS SSRF (CVE-2025-13789)

These tests verify the SSRF vulnerability status:
- FAIL in vulnerable state (vulnerable endpoint exists)
- PASS in fixed state (vulnerable endpoint removed)

The fix for CVE-2025-13789 removes the modelTestConnection function entirely.
When fixed, the endpoint either returns 404 or 200 with empty body (ZenTao's
default behavior for non-existent methods when debug is disabled).
"""

import pytest
import requests
import time
import os
import hashlib

ZENTAO_URL = os.environ.get('ZENTAO_URL', 'http://localhost/zentao')
ZENTAO_USER = os.environ.get('ZENTAO_USER', 'admin')
ZENTAO_PASS = os.environ.get('ZENTAO_PASS', '123456')

STARTUP_TIMEOUT = 120
SSRF_ENDPOINT = '/ai-modelTestConnection.html'


def md5_hash(text):
    """Calculate MD5 hash of a string"""
    return hashlib.md5(text.encode()).hexdigest()


def zentao_login(session, base_url, username, password):
    """
    Perform ZenTao login with proper password hashing.
    ZenTao 21.7+ uses md5(md5(password) + rand) for password submission.
    """
    # First, get the login page to establish cookies
    session.get(f"{base_url}/user-login.html", timeout=10)

    # Get the random token for password hashing
    rand_resp = session.get(f"{base_url}/user-refreshRandom.html", timeout=10)
    rand = rand_resp.text.strip()

    # Hash the password: md5(md5(password) + rand)
    hashed_password = md5_hash(md5_hash(password) + rand)

    # Perform login with proper headers (ZenTao requires AJAX-style request)
    login_data = {
        'account': username,
        'password': hashed_password,
        'passwordStrength': '1',
        'referer': '/zentao/',
        'verifyRand': rand,
        'keepLogin': '1'
    }

    headers = {
        'X-Requested-With': 'XMLHttpRequest',
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Origin': 'http://localhost',
        'Referer': f'{base_url}/user-login.html'
    }

    resp = session.post(
        f"{base_url}/user-login.html",
        data=login_data,
        headers=headers,
        allow_redirects=False,
        timeout=10
    )

    return resp


@pytest.fixture(scope='module')
def wait_for_zentao():
    """Wait for ZenTao to be ready"""
    start_time = time.time()
    while time.time() - start_time < STARTUP_TIMEOUT:
        try:
            resp = requests.get(f"{ZENTAO_URL}/", timeout=5)
            if resp.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    pytest.fail("ZenTao did not start within timeout")


@pytest.fixture(scope='module')
def authenticated_session(wait_for_zentao):
    """Create an authenticated session using ZenTao's hashed password login"""
    session = requests.Session()

    # Perform login with proper password hashing
    resp = zentao_login(session, ZENTAO_URL, ZENTAO_USER, ZENTAO_PASS)

    # ZenTao returns JSON on successful login
    try:
        json_resp = resp.json()
        if json_resp.get('result') != 'success':
            pytest.fail(f"Login failed: {json_resp.get('message', 'unknown error')}")
    except:
        pytest.fail("Login did not return valid JSON response")

    # Verify login was successful by checking if we can access protected pages
    check_resp = session.get(f"{ZENTAO_URL}/my/", timeout=10)

    # If still redirecting to login, authentication failed
    if 'login' in check_resp.url.lower() and 'logout' not in check_resp.text.lower():
        pytest.fail("Failed to authenticate with ZenTao")

    return session


def send_ssrf_payload(session, base_url):
    """Send SSRF payload to the vulnerable endpoint"""
    data = {
        'name': 'TestModel',
        'type': 'openai-gpt35',
        'vendor': 'openaiCompatible',
        'key': 'test123',
        'base': base_url
    }

    headers = {
        'X-Requested-With': 'XMLHttpRequest'
    }

    try:
        resp = session.post(
            f"{ZENTAO_URL}{SSRF_ENDPOINT}",
            data=data,
            headers=headers,
            timeout=15
        )
        return resp
    except requests.exceptions.Timeout:
        return None
    except requests.exceptions.RequestException as e:
        return None


def is_endpoint_fixed(resp):
    """
    Check if the response indicates the endpoint is fixed (function removed).

    When the modelTestConnection function is removed:
    - ZenTao returns HTTP 200 with empty body (debug disabled behavior)
    - Or HTTP 404 if framework returns proper not found

    When the function exists (vulnerable):
    - Returns HTTP 200 with JSON body containing connection status/error

    Returns True if endpoint appears to be fixed, False if vulnerable.
    """
    if resp is None:
        return False

    # 404 = clearly fixed
    if resp.status_code == 404:
        return True

    # 200 with empty body = fixed (ZenTao's default for non-existent methods)
    if resp.status_code == 200 and len(resp.text.strip()) == 0:
        return True

    # 200 with content - check if it's a vulnerable response
    # Vulnerable responses contain JSON with 'result' field showing connection status
    if resp.status_code == 200 and resp.text.strip():
        try:
            json_resp = resp.json()
            # If we get a result about connection test, it's vulnerable
            if 'result' in json_resp:
                # Check if this is a login timeout message - that's NOT the vulnerability
                msg = json_resp.get('message', '')
                if 'login' in msg.lower() or '登录' in msg or '超时' in msg:
                    # Session issue, not a vulnerability indicator
                    # But we can't confirm fix either - treat as error
                    return False
                # Actual connection test result = vulnerable
                return False
        except:
            pass

    return False


class TestSSRFVulnerabilityFixed:
    """
    Tests to verify the SSRF vulnerability has been fixed.

    The fix for CVE-2025-13789 removes the modelTestConnection() function.
    When fixed: endpoint returns 404 OR 200 with empty body
    When vulnerable: endpoint returns 200 with JSON connection result

    These tests should:
    - PASS when fixed (endpoint removed/non-functional)
    - FAIL when vulnerable (endpoint processes SSRF request)
    """

    def test_endpoint_removed(self, authenticated_session):
        """
        Test that the vulnerable endpoint has been removed.
        The fix removes modelTestConnection, so endpoint should not process requests.
        """
        resp = send_ssrf_payload(authenticated_session, 'http://127.0.0.1:80')

        assert resp is not None, "Request failed completely"

        # After fix: endpoint should be removed (404 or empty 200)
        # Before fix (vulnerable): endpoint processes request and returns JSON
        assert is_endpoint_fixed(resp), (
            f"Vulnerable endpoint still exists! Status: {resp.status_code}, "
            f"Response: {resp.text[:200]}"
        )

    def test_localhost_ssrf_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with localhost target"""
        resp = send_ssrf_payload(authenticated_session, 'http://localhost:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint still accessible with localhost target. Status: {resp.status_code}"
        )

    def test_internal_ip_ssrf_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with internal IP target"""
        resp = send_ssrf_payload(authenticated_session, 'http://10.0.0.1:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint still accessible with internal IP target. Status: {resp.status_code}"
        )

    def test_metadata_ssrf_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with AWS metadata URL"""
        resp = send_ssrf_payload(authenticated_session, 'http://169.254.169.254/latest/meta-data/')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint still accessible with metadata URL. Status: {resp.status_code}"
        )

    def test_file_protocol_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with file:// protocol"""
        resp = send_ssrf_payload(authenticated_session, 'file:///etc/passwd')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint still accessible with file protocol. Status: {resp.status_code}"
        )

    def test_port_scan_endpoint_removed(self, authenticated_session):
        """Test endpoint removal - cannot be used for port scanning"""
        resp = send_ssrf_payload(authenticated_session, 'http://127.0.0.1:3306')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint still accessible for port scanning. Status: {resp.status_code}"
        )


class TestMultipleSSRFVectors:
    """
    Test that the vulnerable endpoint is removed for various SSRF vectors.
    All tests check that the endpoint is fixed (returns 404 or empty 200).
    """

    def test_decimal_ip_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with decimal IP (127.0.0.1 = 2130706433)"""
        resp = send_ssrf_payload(authenticated_session, 'http://2130706433:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with decimal IP. Status: {resp.status_code}"
        )

    def test_hex_ip_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with hex IP"""
        resp = send_ssrf_payload(authenticated_session, 'http://0x7f000001:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with hex IP. Status: {resp.status_code}"
        )

    def test_octal_ip_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with octal IP"""
        resp = send_ssrf_payload(authenticated_session, 'http://0177.0.0.1:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with octal IP. Status: {resp.status_code}"
        )

    def test_short_ip_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with shortened IP"""
        resp = send_ssrf_payload(authenticated_session, 'http://127.1:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with short IP. Status: {resp.status_code}"
        )

    def test_ipv6_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with IPv6 localhost"""
        resp = send_ssrf_payload(authenticated_session, 'http://[::1]:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with IPv6. Status: {resp.status_code}"
        )

    def test_url_encoded_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with URL-encoded IP"""
        resp = send_ssrf_payload(authenticated_session, 'http://%31%32%37%2e%30%2e%30%2e%31:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with URL-encoded IP. Status: {resp.status_code}"
        )

    def test_dns_rebinding_endpoint_removed(self, authenticated_session):
        """Test endpoint removal with rebindable domain"""
        resp = send_ssrf_payload(authenticated_session, 'http://localtest.me:80')

        assert resp is not None, "Request failed"
        assert is_endpoint_fixed(resp), (
            f"Endpoint accessible with rebindable domain. Status: {resp.status_code}"
        )


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
