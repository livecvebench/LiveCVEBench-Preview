diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..fd4d0c5
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,100 @@
+import copy
+import os
+import sys
+import unittest
+from unittest.mock import MagicMock
+import logging
+
+# Suppress INFO level logs from the FATE framework
+logging.getLogger('federatedml').setLevel(logging.ERROR)
+
+# Add the project root to the python path to import federatedml module
+# Assume this script is in projects/FATE/ directory
+# and the federatedml folder is also in projects/FATE/
+# If running from projects/FATE, usually no path adjustment is needed
+project_path = os.path.dirname(os.path.abspath(__file__))
+if project_path not in sys.path:
+    sys.path.insert(0, project_path)
+
+try:
+    from federatedml.tree.hetero.hetero_decision_tree_guest import HeteroDecisionTreeGuest
+    from federatedml.tree.tree_core.node import Node
+    from federatedml.param.boosting_tree_param import DecisionTreeParam
+    from federatedml.util import consts
+except ImportError as e:
+    print(f"Module import failed. Please check your running directory or if federatedml module exists: {e}")
+    sys.exit(1)
+
+
+class TestPatchVerification(unittest.TestCase):
+    """
+    This test class verifies the correctness of patch 6feccf6d752184a6f9365d56a76fe627983e7139.
+    The patch is intended to remove sensitive information from tree nodes sent from guest to host.
+    """
+
+    def setUp(self):
+        """
+        Prepare the test, initialize necessary objects and mock dependencies.
+        """
+        # 1. Create default tree parameter object
+        tree_param = DecisionTreeParam()
+
+        # 2. Instantiate the HeteroDecisionTreeGuest to test
+        self.guest_tree = HeteroDecisionTreeGuest(tree_param)
+
+        # 3. Mock data transfer instance (transfer_inst)
+        # The patched code calls self.transfer_inst.tree.remote(...)
+        # We need to mock this call chain
+        mock_transfer_inst = MagicMock()
+        mock_transfer_inst.tree = MagicMock()
+        self.guest_tree.transfer_inst = mock_transfer_inst
+
+        # 4. Create some virtual tree nodes with sensitive information
+        node1 = Node(id=0, weight=1.1, sum_grad=10.1, sum_hess=20.1)
+        node2 = Node(id=1, weight=2.2, sum_grad=12.2, sum_hess=22.2)
+        self.guest_tree.tree_ = [node1, node2]
+
+        # 5. Save a deep copy of the original tree for verifying guest-side data remains unchanged
+        self.original_tree_copy = copy.deepcopy(self.guest_tree.tree_)
+
+    def test_sync_tree_removes_sensitive_info(self):
+        """
+        Test whether sync_tree successfully removes sensitive info and does not modify original data.
+        """
+        # Call the method under test
+        self.guest_tree.sync_tree()
+
+        # Get the mock remote method
+        mock_remote = self.guest_tree.transfer_inst.tree.remote
+
+        # Assert: remote method was called once
+        self.assertTrue(mock_remote.called)
+        mock_remote.assert_called_once()
+
+        # Get arguments used to call remote
+        # Signature: remote(obj, role=consts.HOST, idx=-1)
+        # We care about the first positional argument obj
+        call_args, call_kwargs = mock_remote.call_args
+        sent_tree_nodes = call_args[0]
+
+        # Assert: sensitive info in sent tree nodes has been removed (set to None)
+        self.assertEqual(len(sent_tree_nodes), 2)
+        for node in sent_tree_nodes:
+            self.assertIsNone(node.weight, "weight should be removed")
+            self.assertIsNone(node.sum_grad, "sum_grad should be removed")
+            self.assertIsNone(node.sum_hess, "sum_hess should be removed")
+            # Ensure other info is retained
+            self.assertIsNotNone(node.id)
+
+        # Assert: guest-side original tree nodes were not modified
+        for i in range(len(self.guest_tree.tree_)):
+            guest_node = self.guest_tree.tree_[i]
+            original_node = self.original_tree_copy[i]
+
+            self.assertEqual(guest_node.weight, original_node.weight)
+            self.assertEqual(guest_node.sum_grad, original_node.sum_grad)
+            self.assertEqual(guest_node.sum_hess, original_node.sum_hess)
+
+
+if __name__ == '__main__':
+    unittest.main() 
\ No newline at end of file
