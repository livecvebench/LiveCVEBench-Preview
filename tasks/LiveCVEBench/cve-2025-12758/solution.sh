#!/bin/bash
set -e

cd /app

echo "Applying fix for isLength Unicode variation selector bug..."

# Find the isLength.js file in the validator package
# Could be in lib/ (CommonJS) or src/lib/ (ES modules)
VALIDATOR_LIB_PATH="/app/node_modules/validator/lib/isLength.js"
VALIDATOR_SRC_PATH="/app/node_modules/validator/src/lib/isLength.js"

# Use Node.js to apply the fix reliably (handles Unicode escapes properly)
node << 'EOF'
const fs = require('fs');

// Possible paths where isLength.js might be
const possiblePaths = [
  '/app/node_modules/validator/lib/isLength.js',
  '/app/node_modules/validator/src/lib/isLength.js'
];

let fixedCount = 0;

for (const filePath of possiblePaths) {
  if (fs.existsSync(filePath)) {
    let content = fs.readFileSync(filePath, 'utf8');

    // The vulnerable regex pattern (matches all FE0F/FE0E):
    // str.match(/(\uFE0F|\uFE0E)/g)
    //
    // The fixed regex pattern (only matches selector AFTER a non-selector char):
    // str.match(/[^\uFE0F\uFE0E][\uFE0F\uFE0E]/g)

    // Match the vulnerable pattern - handle both escaped and literal Unicode
    const vulnerablePatterns = [
      // Pattern with escaped Unicode
      /str\.match\(\/\(\\uFE0F\|\\uFE0E\)\/g\)/g,
      // Pattern with literal Unicode characters
      /str\.match\(\/\(\uFE0F\|\uFE0E\)\/g\)/g
    ];

    let wasFixed = false;
    for (const pattern of vulnerablePatterns) {
      if (pattern.test(content)) {
        content = content.replace(pattern, 'str.match(/[^\\uFE0F\\uFE0E][\\uFE0F\\uFE0E]/g)');
        wasFixed = true;
      }
    }

    // Also handle the case where it might be written differently
    // Look for the specific line pattern
    if (!wasFixed) {
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        // Check if this line contains the vulnerable regex for presentationSequences
        if (line.includes('presentationSequences') &&
            line.includes('str.match') &&
            (line.includes('\uFE0F') || line.includes('\\uFE0F'))) {
          // Replace with the fixed version
          lines[i] = "  const presentationSequences = str.match(/[^\\uFE0F\\uFE0E][\\uFE0F\\uFE0E]/g) || [];";
          wasFixed = true;
          break;
        }
      }
      if (wasFixed) {
        content = lines.join('\n');
      }
    }

    if (wasFixed) {
      fs.writeFileSync(filePath, content);
      console.log('Fixed:', filePath);
      fixedCount++;
    } else {
      console.log('No vulnerable pattern found in:', filePath);
    }
  }
}

if (fixedCount === 0) {
  console.error('Warning: No files were fixed. Checking file contents...');

  // Debug: show what's in the files
  for (const filePath of possiblePaths) {
    if (fs.existsSync(filePath)) {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('presentationSequences')) {
          console.log(`Line ${i+1} in ${filePath}:`, lines[i]);
        }
      }
    }
  }
  process.exit(1);
}

console.log('Fix applied successfully!');
EOF

echo "Fix applied successfully."
