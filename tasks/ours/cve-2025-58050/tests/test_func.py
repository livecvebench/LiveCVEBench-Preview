"""
Functional tests for PCRE2 regex matching engine.

These tests verify that basic PCRE2 functionality works correctly.
They should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import tempfile
import pytest


PCRE2TEST_BIN = "/app/build/pcre2test"


def run_pcre2test(pattern: str, subject: str) -> str:
    """Run pcre2test with given pattern and subject, return output."""
    input_text = f"{pattern}\n    {subject}\n"

    result = subprocess.run(
        [PCRE2TEST_BIN],
        input=input_text,
        capture_output=True,
        text=True,
        timeout=30
    )
    return result.stdout + result.stderr


def run_pcre2test_from_file(input_file: str) -> str:
    """Run pcre2test with input from file."""
    with open(input_file, 'r') as f:
        input_text = f.read()

    result = subprocess.run(
        [PCRE2TEST_BIN],
        input=input_text,
        capture_output=True,
        text=True,
        timeout=30
    )
    return result.stdout + result.stderr


class TestBasicMatching:
    """Test basic regex matching functionality."""

    def test_simple_pattern(self):
        """Test simple pattern matching."""
        output = run_pcre2test("/abc/", "abc")
        assert "0: abc" in output

    def test_no_match(self):
        """Test pattern that doesn't match."""
        output = run_pcre2test("/xyz/", "abc")
        assert "No match" in output

    def test_case_insensitive(self):
        """Test case-insensitive matching."""
        output = run_pcre2test("/ABC/i", "abc")
        assert "0: abc" in output


class TestCaptureGroups:
    """Test capture group functionality."""

    def test_single_capture(self):
        """Test single capture group."""
        output = run_pcre2test("/(a)/", "a")
        assert "0: a" in output
        assert "1: a" in output

    def test_multiple_captures(self):
        """Test multiple capture groups."""
        output = run_pcre2test("/(a)(b)(c)/", "abc")
        assert "0: abc" in output
        assert "1: a" in output
        assert "2: b" in output
        assert "3: c" in output

    def test_nested_captures(self):
        """Test nested capture groups."""
        output = run_pcre2test("/((a)(b))/", "ab")
        assert "0: ab" in output
        assert "1: ab" in output
        assert "2: a" in output
        assert "3: b" in output

    def test_quantified_capture(self):
        """Test capture groups with quantifiers."""
        output = run_pcre2test("/(a+)/", "aaa")
        assert "0: aaa" in output
        assert "1: aaa" in output


class TestBackreferences:
    """Test backreference functionality."""

    def test_simple_backreference(self):
        """Test simple backreference."""
        output = run_pcre2test("/(a)\\1/", "aa")
        assert "0: aa" in output

    def test_backreference_no_match(self):
        """Test backreference that doesn't match."""
        output = run_pcre2test("/(a)\\1/", "ab")
        assert "No match" in output

    def test_multiple_backreferences(self):
        """Test multiple backreferences."""
        output = run_pcre2test("/(a)(b)\\1\\2/", "abab")
        assert "0: abab" in output

    def test_backreference_with_quantifier(self):
        """Test backreference to quantified group."""
        output = run_pcre2test("/(a+)\\1/", "aaaa")
        assert "0: aaaa" in output


class TestAssertions:
    """Test assertion functionality."""

    def test_lookahead(self):
        """Test positive lookahead."""
        output = run_pcre2test("/a(?=b)/", "ab")
        assert "0: a" in output

    def test_negative_lookahead(self):
        """Test negative lookahead."""
        output = run_pcre2test("/a(?!b)/", "ac")
        assert "0: a" in output

    def test_lookbehind(self):
        """Test positive lookbehind."""
        output = run_pcre2test("/(?<=a)b/", "ab")
        assert "0: b" in output


class TestControlVerbs:
    """Test control verb functionality."""

    def test_accept_basic(self):
        """Test basic ACCEPT verb."""
        output = run_pcre2test("/(a)(*ACCEPT)b/", "a")
        assert "0: a" in output

    def test_fail_verb(self):
        """Test FAIL verb."""
        output = run_pcre2test("/a(*FAIL)/", "a")
        assert "No match" in output

    def test_skip_verb(self):
        """Test SKIP verb."""
        output = run_pcre2test("/a(*SKIP)b|ab/", "ab")
        assert "0: ab" in output


class TestSCSBasic:
    """Test basic Scan Substring functionality (without ACCEPT)."""

    def test_scs_simple(self):
        """Test basic SCS assertion without ACCEPT."""
        output = run_pcre2test("/(abc)(*scs:(1)abc)/", "abc")
        assert "0: abc" in output
        assert "1: abc" in output

    def test_scs_partial_match(self):
        """Test SCS with partial substring match."""
        output = run_pcre2test("/(abc)(*scs:(1)a)/", "abc")
        assert "0: abc" in output

    def test_scs_no_match(self):
        """Test SCS that doesn't match."""
        output = run_pcre2test("/(abc)(*scs:(1)x)/", "abc")
        assert "No match" in output


class TestPCRE2TestExecution:
    """Test that pcre2test binary is functional."""

    def test_binary_exists(self):
        """Verify pcre2test binary exists and is executable."""
        assert os.path.exists(PCRE2TEST_BIN), f"pcre2test not found at {PCRE2TEST_BIN}"
        assert os.access(PCRE2TEST_BIN, os.X_OK), f"pcre2test is not executable"

    def test_version_output(self):
        """Test pcre2test can show version info."""
        result = subprocess.run(
            [PCRE2TEST_BIN, "-C"],
            capture_output=True,
            text=True,
            timeout=10
        )
        assert result.returncode == 0
        # Should contain PCRE2 version information
        assert "PCRE2" in result.stdout or "pcre2" in result.stdout.lower()
