"""
Functional tests for tcprewrite.
These tests verify that the basic functionality of tcprewrite works correctly.
They should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import tempfile
import struct


def create_simple_pcap(filepath):
    """
    Create a minimal valid pcap file with one simple Ethernet/IPv4 packet.
    This packet is NOT truncated (caplen == len).
    """
    # pcap global header (24 bytes)
    # magic_number, version_major, version_minor, thiszone, sigfigs, snaplen, network
    global_header = struct.pack('<IHHiIII',
        0xa1b2c3d4,  # magic number (little-endian)
        2,           # version major
        4,           # version minor
        0,           # thiszone (GMT)
        0,           # sigfigs
        65535,       # snaplen
        1            # network (LINKTYPE_ETHERNET)
    )

    # Create a simple Ethernet frame with IPv4 packet
    # Ethernet header (14 bytes): dst MAC + src MAC + EtherType
    eth_header = bytes([
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55,  # dst MAC
        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,  # src MAC
        0x08, 0x00                            # EtherType (IPv4)
    ])

    # IPv4 header (20 bytes minimum)
    # Version/IHL, DSCP/ECN, Total Length, ID, Flags/Fragment, TTL, Protocol, Checksum, Src IP, Dst IP
    ip_header = bytes([
        0x45,        # Version (4) + IHL (5 = 20 bytes)
        0x00,        # DSCP + ECN
        0x00, 0x14,  # Total length (20 bytes, header only)
        0x00, 0x01,  # Identification
        0x00, 0x00,  # Flags + Fragment offset
        0x40,        # TTL (64)
        0x06,        # Protocol (TCP)
        0x00, 0x00,  # Header checksum (0 for simplicity)
        0x7f, 0x00, 0x00, 0x01,  # Source IP (127.0.0.1)
        0x7f, 0x00, 0x00, 0x01   # Dest IP (127.0.0.1)
    ])

    packet_data = eth_header + ip_header
    packet_len = len(packet_data)

    # pcap packet header (16 bytes)
    # ts_sec, ts_usec, incl_len, orig_len
    packet_header = struct.pack('<IIII',
        1000000000,  # timestamp seconds
        0,           # timestamp microseconds
        packet_len,  # incl_len (captured length)
        packet_len   # orig_len (original length) - SAME as caplen, not truncated
    )

    with open(filepath, 'wb') as f:
        f.write(global_header)
        f.write(packet_header)
        f.write(packet_data)


def create_multi_packet_pcap(filepath, num_packets=5):
    """
    Create a pcap file with multiple valid packets.
    """
    # pcap global header
    global_header = struct.pack('<IHHiIII',
        0xa1b2c3d4, 2, 4, 0, 0, 65535, 1
    )

    with open(filepath, 'wb') as f:
        f.write(global_header)

        for i in range(num_packets):
            # Ethernet header
            eth_header = bytes([
                0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                0x08, 0x00
            ])

            # IPv4 header with varying IDs
            ip_header = bytes([
                0x45, 0x00,
                0x00, 0x14,
                0x00, i + 1,  # Different ID for each packet
                0x00, 0x00,
                0x40, 0x06,
                0x00, 0x00,
                0x7f, 0x00, 0x00, 0x01,
                0x7f, 0x00, 0x00, 0x02
            ])

            packet_data = eth_header + ip_header
            packet_len = len(packet_data)

            packet_header = struct.pack('<IIII',
                1000000000 + i,
                0,
                packet_len,
                packet_len
            )

            f.write(packet_header)
            f.write(packet_data)


class TestTcprewriteBasicFunctionality:
    """Test basic tcprewrite functionality."""

    def test_tcprewrite_exists(self):
        """Verify tcprewrite binary is available."""
        result = subprocess.run(
            ['which', 'tcprewrite'],
            capture_output=True,
            text=True
        )
        assert result.returncode == 0, "tcprewrite binary not found in PATH"

    def test_tcprewrite_version(self):
        """Verify tcprewrite can report its version."""
        result = subprocess.run(
            ['tcprewrite', '--version'],
            capture_output=True,
            text=True
        )
        # Version command exits with 0 and shows version info
        # Note: tcprewrite outputs version to stdout (combined output)
        assert result.returncode == 0, f"tcprewrite --version failed: {result.stderr}"
        combined_output = (result.stdout + result.stderr).lower()
        assert 'tcprewrite' in combined_output or 'version' in combined_output

    def test_tcprewrite_help(self):
        """Verify tcprewrite help works."""
        result = subprocess.run(
            ['tcprewrite', '--help'],
            capture_output=True,
            text=True
        )
        assert result.returncode == 0, f"tcprewrite --help failed: {result.stderr}"
        assert 'fixlen' in result.stdout.lower() or 'usage' in result.stdout.lower()


class TestTcprewriteProcessing:
    """Test tcprewrite file processing capabilities."""

    def test_process_simple_pcap(self):
        """Verify tcprewrite can process a simple valid pcap file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'input.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            create_simple_pcap(input_file)

            result = subprocess.run(
                ['tcprewrite', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            assert result.returncode == 0, f"tcprewrite failed: {result.stderr}"
            assert os.path.exists(output_file), "Output file was not created"
            assert os.path.getsize(output_file) > 0, "Output file is empty"

    def test_process_multi_packet_pcap(self):
        """Verify tcprewrite can process pcap with multiple packets."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'multi.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            create_multi_packet_pcap(input_file, num_packets=10)

            result = subprocess.run(
                ['tcprewrite', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            assert result.returncode == 0, f"tcprewrite failed: {result.stderr}"
            assert os.path.exists(output_file), "Output file was not created"

    def test_fixlen_trunc_option(self):
        """Verify --fixlen trunc option works on normal pcap."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'input.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            create_simple_pcap(input_file)

            result = subprocess.run(
                ['tcprewrite', '--fixlen', 'trunc', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            assert result.returncode == 0, f"tcprewrite --fixlen trunc failed: {result.stderr}"
            assert os.path.exists(output_file), "Output file was not created"

    def test_fixlen_pad_normal_packet(self):
        """Verify --fixlen pad works on non-truncated packets (normal case)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'input.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            # Create a normal pcap where caplen == len (not truncated)
            create_simple_pcap(input_file)

            result = subprocess.run(
                ['tcprewrite', '--fixlen', 'pad', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            assert result.returncode == 0, f"tcprewrite --fixlen pad failed on normal pcap: {result.stderr}"
            assert os.path.exists(output_file), "Output file was not created"

    def test_output_to_stdout(self):
        """Verify tcprewrite can write to /dev/null."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'input.pcap')

            create_simple_pcap(input_file)

            result = subprocess.run(
                ['tcprewrite', '-i', input_file, '-o', '/dev/null'],
                capture_output=True,
                text=True,
                timeout=30
            )

            assert result.returncode == 0, f"tcprewrite to /dev/null failed: {result.stderr}"


class TestTcprewriteEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_empty_input_handling(self):
        """Verify tcprewrite handles a pcap with only header (no packets)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'empty.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            # Write only global header, no packets
            global_header = struct.pack('<IHHiIII',
                0xa1b2c3d4, 2, 4, 0, 0, 65535, 1
            )
            with open(input_file, 'wb') as f:
                f.write(global_header)

            result = subprocess.run(
                ['tcprewrite', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            # Should handle empty pcap gracefully (either succeed or give meaningful error)
            # We just verify it doesn't crash with a signal
            assert result.returncode >= 0 or result.returncode == 0, \
                f"tcprewrite crashed on empty pcap with signal {-result.returncode}"

    def test_large_packet_count(self):
        """Verify tcprewrite handles pcap with many packets."""
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'large.pcap')
            output_file = os.path.join(tmpdir, 'output.pcap')

            create_multi_packet_pcap(input_file, num_packets=100)

            result = subprocess.run(
                ['tcprewrite', '-i', input_file, '-o', output_file],
                capture_output=True,
                text=True,
                timeout=60
            )

            assert result.returncode == 0, f"tcprewrite failed on large pcap: {result.stderr}"
