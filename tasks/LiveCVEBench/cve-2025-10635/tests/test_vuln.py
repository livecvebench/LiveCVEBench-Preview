#!/usr/bin/env python3
"""
Vulnerability tests for Find Me On WordPress plugin.
Tests for SQL injection vulnerability in the linkId parameter.

These tests verify that SQL injection is NOT possible (i.e., the vulnerability is fixed).
- VULNERABLE environment: Tests FAIL (SQL injection works, causing delays)
- FIXED environment: Tests PASS (SQL injection blocked, no delays)
"""

import pytest
import requests
import time
import os

BASE_URL = os.environ.get("WP_URL", "http://localhost")
ADMIN_USER = os.environ.get("WP_ADMIN_USER", "admin")
ADMIN_PASS = os.environ.get("WP_ADMIN_PASS", "admin123")


class WordPressSession:
    """Helper class to manage WordPress authentication."""

    def __init__(self, base_url, username, password):
        self.base_url = base_url.rstrip("/")
        self.username = username
        self.password = password
        self.session = requests.Session()
        self._logged_in = False

    def login(self):
        """Login to WordPress and get session cookies."""
        if self._logged_in:
            return True

        login_url = f"{self.base_url}/wp-login.php"

        # Get the login page first
        self.session.get(login_url, timeout=10)

        # Perform login
        login_data = {
            "log": self.username,
            "pwd": self.password,
            "wp-submit": "Log In",
            "redirect_to": f"{self.base_url}/wp-admin/",
            "testcookie": "1"
        }

        response = self.session.post(login_url, data=login_data, allow_redirects=True, timeout=10)
        self._logged_in = "wordpress_logged_in" in str(self.session.cookies) or "wp-admin" in response.url
        return self._logged_in

    def ajax_request(self, action, data=None, timeout=30):
        """Make an AJAX request to WordPress."""
        ajax_url = f"{self.base_url}/wp-admin/admin-ajax.php"
        request_data = {"action": action}
        if data:
            request_data.update(data)
        return self.session.post(ajax_url, data=request_data, timeout=timeout)


@pytest.fixture(scope="module")
def wp_session():
    """Create and return a logged-in WordPress session."""
    session = WordPressSession(BASE_URL, ADMIN_USER, ADMIN_PASS)

    # Wait for WordPress to be ready
    max_retries = 30
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/wp-login.php", timeout=5)
            if response.status_code == 200:
                break
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    else:
        pytest.skip("WordPress not available")

    if not session.login():
        pytest.skip("Could not login to WordPress")

    return session


class TestSQLInjectionVulnerability:
    """
    Test for SQL injection vulnerability in linkId parameter.

    All tests use time-based blind SQL injection with nested subqueries
    to definitively prove whether the vulnerability exists.

    The nested subquery pattern is required because:
    - The vulnerable code: DELETE FROM wp_find_me_on WHERE id=<payload>
    - Simple SLEEP() doesn't execute in DELETE context
    - Nested subquery forces MySQL to evaluate the SLEEP()

    Each test should:
    - FAIL if vulnerable (SQL injection executes, causing delay)
    - PASS if fixed (SQL injection blocked, immediate response)
    """

    def test_sqli_nested_subquery_sleep(self, wp_session):
        """
        Test time-based SQL injection using nested subquery with SLEEP.
        Standard pattern for MySQL/MariaDB time-based blind SQLi.
        """
        payload = "1 AND (SELECT 7595 FROM (SELECT(SLEEP(3)))aGSD)"

        start_time = time.time()
        response = wp_session.ajax_request(
            "find_me_on_delete_network",
            {"linkId": payload},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, f"SQL injection detected! Response took {elapsed:.2f}s (expected < 2.5s)"

    def test_sqli_subtraction_subquery(self, wp_session):
        """
        Test time-based SQL injection using subtraction with subquery.
        Alternative pattern that bypasses some filters.
        """
        payload = "1-(SELECT 0 FROM (SELECT SLEEP(3))a)"

        start_time = time.time()
        response = wp_session.ajax_request(
            "find_me_on_delete_network",
            {"linkId": payload},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, f"SQL injection via subtraction detected! Response took {elapsed:.2f}s"

    def test_sqli_count_subquery(self, wp_session):
        """
        Test time-based SQL injection using COUNT with nested subquery.
        Uses aggregate function to force evaluation.
        """
        payload = "1 AND (SELECT count(*) FROM (SELECT(SLEEP(3)))t)"

        start_time = time.time()
        response = wp_session.ajax_request(
            "find_me_on_delete_network",
            {"linkId": payload},
            timeout=15
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2.5, f"SQL injection via COUNT detected! Response took {elapsed:.2f}s"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
