#!/bin/bash
# Solution script for PubNet StorageController upload endpoint authorization fix
set -e

# Source code is in /src, not /app (Dockerfile copies src to /src for patching)
CONTROLLER_FILE="/src/PubNet.API/Controllers/StorageController.cs"

echo "Applying fix to StorageController.cs..."

# Check if file exists
if [ ! -f "$CONTROLLER_FILE" ]; then
    echo "Error: $CONTROLLER_FILE not found"
    exit 1
fi

# Create backup
cp "$CONTROLLER_FILE" "${CONTROLLER_FILE}.bak"

# Apply the fix using a heredoc to replace the vulnerable code
# The fix adds signature validation to the Upload endpoint

cat > /tmp/fix.patch << 'PATCHEOF'
--- a/PubNet.API/Controllers/StorageController.cs
+++ b/PubNet.API/Controllers/StorageController.cs
@@ -38,13 +38,14 @@ public Task<UploadEndpointData> GenerateUploadEndpointData(HttpRequest request,
 	{
 		cancellationToken.ThrowIfCancellationRequested();

-		var url = _endpointHelper.GenerateFullyQualified(request, "/api/storage/upload");
-		var fields = new Dictionary<string, string>
+		var url = _endpointHelper.GenerateFullyQualified(request, "/api/storage/upload", new Dictionary<string, string?>
 		{
-			{ "author-id", author.Id.ToString() },
-		};
+			{ "authorId", author.Id.ToString() },
+		});
+
+		url = _endpointHelper.SignEndpoint(url);

-		return Task.FromResult(new UploadEndpointData(url, fields));
+		return Task.FromResult(new UploadEndpointData(url, new()));
 	}

 	[HttpPost("upload")]
@@ -52,8 +53,11 @@ public Task<UploadEndpointData> GenerateUploadEndpointData(HttpRequest request,
 	[ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ErrorResponse))]
 	[ProducesResponseType(StatusCodes.Status411LengthRequired, Type = typeof(ErrorResponse))]
 	[ProducesResponseType(StatusCodes.Status413PayloadTooLarge, Type = typeof(ErrorResponse))]
-	public async Task<IActionResult> Upload()
+	public async Task<IActionResult> Upload([FromQuery] int? authorId)
 	{
+		if (!_endpointHelper.ValidateSignature(Request.QueryString.ToString()))
+			return BadRequest(ErrorResponse.InvalidSignedUrl);
+
 		const long maxUploadSize = 100_000_000; // 100 MB

 		var size = Request.Headers.ContentLength;
@@ -70,10 +74,9 @@ public async Task<IActionResult> Upload()
 		if (packageFile is null)
 			return BadRequest(ErrorResponse.MissingPackageFile);

-		if (!Request.Form.ContainsKey("author-id"))
+		if (authorId is null)
 			return BadRequest(ErrorResponse.MissingFields);

-		var authorId = int.Parse(Request.Form["author-id"].ToString());
 		var author = await _db.Authors.FindAsync(authorId);
 		if (author is null)
 			return BadRequest(ErrorResponse.InvalidAuthorId);
PATCHEOF

# Try to apply the patch
cd /src
if patch -p1 --dry-run < /tmp/fix.patch 2>/dev/null; then
    echo "Applying patch..."
    patch -p1 < /tmp/fix.patch
    echo "Patch applied successfully"
else
    echo "Patch cannot be applied directly, using sed-based fix..."

    # Restore from backup if patch failed partially
    cp "${CONTROLLER_FILE}.bak" "$CONTROLLER_FILE"

    # Fix 1: Update GenerateUploadEndpointData method to sign the URL
    # Change: var url = _endpointHelper.GenerateFullyQualified(request, "/api/storage/upload");
    # To: var url = _endpointHelper.GenerateFullyQualified(request, "/api/storage/upload", new Dictionary<string, string?> { { "authorId", author.Id.ToString() } });
    sed -i 's|var url = _endpointHelper\.GenerateFullyQualified(request, "/api/storage/upload");|var url = _endpointHelper.GenerateFullyQualified(request, "/api/storage/upload", new Dictionary<string, string?>\n\t\t{\n\t\t\t{ "authorId", author.Id.ToString() },\n\t\t});|' "$CONTROLLER_FILE"

    # Fix 2: Remove the old fields dictionary and add URL signing
    sed -i '/var fields = new Dictionary<string, string>/,/};/c\        url = _endpointHelper.SignEndpoint(url);' "$CONTROLLER_FILE"

    # Fix 3: Change return to use empty dictionary
    sed -i 's|return Task\.FromResult(new UploadEndpointData(url, fields));|return Task.FromResult(new UploadEndpointData(url, new()));|' "$CONTROLLER_FILE"

    # Fix 4: Change Upload method signature to accept authorId from query
    sed -i 's|public async Task<IActionResult> Upload()|public async Task<IActionResult> Upload([FromQuery] int? authorId)|' "$CONTROLLER_FILE"

    # Fix 5: Add signature validation at the start of Upload method
    # Insert after the method signature opening brace
    sed -i '/public async Task<IActionResult> Upload(\[FromQuery\] int? authorId)/,/{/{
        s/{/{\n\t\tif (!_endpointHelper.ValidateSignature(Request.QueryString.ToString()))\n\t\t\treturn BadRequest(ErrorResponse.InvalidSignedUrl);\n/
    }' "$CONTROLLER_FILE"

    # Fix 6: Remove form-based author-id check and parsing
    sed -i '/if (!Request\.Form\.ContainsKey("author-id"))/,/return BadRequest(ErrorResponse\.MissingFields);/c\        if (authorId is null)\n            return BadRequest(ErrorResponse.MissingFields);' "$CONTROLLER_FILE"

    # Fix 7: Remove the line that parses author-id from form
    sed -i '/var authorId = int\.Parse(Request\.Form\["author-id"\]\.ToString());/d' "$CONTROLLER_FILE"

    echo "Sed-based fix applied"
fi

# Clean up
rm -f /tmp/fix.patch

# Rebuild the project from source
echo "Rebuilding the project..."
cd /src

# Backup the appsettings files before publish overwrites them
echo "Backing up configuration files..."
cp /app/appsettings.Production.json /tmp/appsettings.Production.json.bak 2>/dev/null || true
cp /app/appsettings.json /tmp/appsettings.json.bak 2>/dev/null || true

# Build and publish to /app where the running app looks for DLLs
if [ -f "PubNet.API/PubNet.API.csproj" ]; then
    echo "Building PubNet.API..."
    dotnet build PubNet.API/PubNet.API.csproj -c Release --no-restore 2>&1 || dotnet build PubNet.API/PubNet.API.csproj -c Release 2>&1
    echo "Publishing to /app..."
    dotnet publish PubNet.API/PubNet.API.csproj -c Release -o /app --no-build 2>&1 || dotnet publish PubNet.API/PubNet.API.csproj -c Release -o /app 2>&1
elif [ -f "PubNet.API.csproj" ]; then
    dotnet build PubNet.API.csproj -c Release --no-restore 2>&1 || dotnet build PubNet.API.csproj -c Release 2>&1
    dotnet publish PubNet.API.csproj -c Release -o /app --no-build 2>&1 || dotnet publish PubNet.API.csproj -c Release -o /app 2>&1
else
    # Try to build the solution
    dotnet build PubNet.sln -c Release --no-restore 2>&1 || dotnet build PubNet.sln -c Release 2>&1
    dotnet publish PubNet.API/PubNet.API.csproj -c Release -o /app 2>&1
fi

# Restore the appsettings files after publish
echo "Restoring configuration files..."
cp /tmp/appsettings.Production.json.bak /app/appsettings.Production.json 2>/dev/null || true
cp /tmp/appsettings.json.bak /app/appsettings.json 2>/dev/null || true

echo "Build completed"

# Restart the service so changes take effect
echo "Restarting the API service..."

# Kill the running dotnet process
pkill -f "dotnet.*PubNet" || true
pkill -f "PubNet.API" || true

# Give it a moment to clean up
sleep 3

echo "Fix applied successfully. The service will be restarted by the entrypoint."
