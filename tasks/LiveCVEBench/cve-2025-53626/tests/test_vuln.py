"""
Vulnerability tests for pdfme expression evaluator sandbox bypass.

These tests verify that malicious payloads are properly blocked.
They should:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerable version (5.4.0) allows:
1. XSS sandbox escape via Object.getOwnPropertyDescriptor and Object.getPrototypeOf
2. Prototype pollution via __lookupGetter__ accessor method
"""
import subprocess
import json
import pytest


def run_expression(expression: str, variables: dict = None) -> str:
    """
    Run an expression through the pdfme expression evaluator.
    Returns the result of the expression evaluation.
    """
    variables = variables or {}

    test_script = f'''
const {{ replacePlaceholders }} = require('/app/packages/common/dist/cjs/src/index.js');

const content = {json.dumps(expression)};
const variables = {json.dumps(variables)};
const schemas = [];

try {{
    const result = replacePlaceholders({{ content, variables, schemas }});
    console.log(JSON.stringify({{ success: true, result }}));
}} catch (error) {{
    console.log(JSON.stringify({{ success: false, error: error.message }}));
}}
'''

    result = subprocess.run(
        ['node', '-e', test_script],
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        return f"ERROR: {result.stderr}"

    try:
        output = json.loads(result.stdout.strip())
        if output.get('success'):
            return output['result']
        return f"ERROR: {output.get('error', 'Unknown error')}"
    except json.JSONDecodeError:
        return result.stdout.strip()


class TestSandboxEscapeXSS:
    """
    Test XSS payloads that escape the sandbox.

    These tests FAIL when the vulnerability exists (payload executes).
    They PASS when fixed (payload is blocked/returned unchanged).
    """

    def test_xss_payload_primary(self):
        """
        Primary XSS payload using arrow function to pass Object.getOwnPropertyDescriptor
        and Object.getPrototypeOf as parameters, then chain to Function constructor.

        Attack chain:
        1. Arrow function (f, g) => receives getOwnPropertyDescriptor and getPrototypeOf
        2. g(Object) = Object.getPrototypeOf(Object) = Function.prototype
        3. f(Function.prototype, "constructor") = getOwnPropertyDescriptor(Function.prototype, "constructor")
        4. .value = Function constructor
        5. Function("return 42")() = 42

        In vulnerable state: returns "42" (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ ((f, g) => f(g(Object), "constructor").value)(Object.getOwnPropertyDescriptor, Object.getPrototypeOf)("return 42")() }'
        result = run_expression(payload)
        assert result == payload, f"XSS payload was executed! Result: {result}"

    def test_xss_payload_alternative(self):
        """
        Alternative XSS payload using object property assignment pattern.

        Same attack chain but using object literals to store function references.

        In vulnerable state: returns "42" (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ { f: Object.getOwnPropertyDescriptor }.f({ g: Object.getPrototypeOf }.g(Object), "constructor").value("return 42")() }'
        result = run_expression(payload)
        assert result == payload, f"Alternative XSS payload was executed! Result: {result}"


class TestAccessorMethods:
    """
    Test legacy accessor methods that enable prototype pollution.

    These methods (__lookupGetter__, __lookupSetter__, __defineGetter__)
    are NOT blocked in vulnerable version 5.4.0.
    """

    def test_lookupGetter_accessible(self):
        """
        __lookupGetter__ should be blocked.

        In vulnerable state: returns "function get __proto__..." (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ {}.__lookupGetter__("__proto__") }'
        result = run_expression(payload)
        # In vulnerable version, this returns the getter function
        assert result == payload, f"__lookupGetter__ was accessible! Result: {result}"

    def test_lookupSetter_accessible(self):
        """
        __lookupSetter__ should be blocked.

        In vulnerable state: returns "undefined" (there's no setter) (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ {}.__lookupSetter__("test") }'
        result = run_expression(payload)
        # In vulnerable version, this returns undefined (no setter exists)
        # but the method WAS accessible, which is the vulnerability
        assert result == payload, f"__lookupSetter__ was accessible! Result: {result}"

    def test_defineGetter_accessible(self):
        """
        __defineGetter__ should be blocked.

        In vulnerable state: returns "undefined" (method executed) (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ {}.__defineGetter__("test", () => "hacked") }'
        result = run_expression(payload)
        assert result == payload, f"__defineGetter__ was accessible! Result: {result}"

    def test_lookupGetter_on_variable(self):
        """
        __lookupGetter__ on user-provided variable should be blocked.

        In vulnerable state: returns a function or undefined (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ obj.__lookupGetter__("prop") }'
        result = run_expression(payload, {"obj": {"prop": "value"}})
        assert result == payload, f"__lookupGetter__ on variable was accessible! Result: {result}"


class TestPrototypePollution:
    """
    Test prototype pollution attack via __lookupGetter__.

    The attack uses __lookupGetter__("__proto__") to get Object.prototype reference,
    then uses Object.assign to add properties to it.
    """

    def test_prototype_pollution_payload(self):
        """
        Prototype pollution via __lookupGetter__ and Object.assign.

        This payload:
        1. { f: {}.__lookupGetter__("__proto__") }.f() gets Object.prototype
        2. { assign: Object.assign }.assign() stores Object.assign reference
        3. Calls assign(Object.prototype, { polluted: "yes" })

        In vulnerable state: payload evaluates and may pollute (FAIL)
        In fixed state: returns payload unchanged (PASS)
        """
        payload = '{ { assign: Object.assign }.assign({ f: {}.__lookupGetter__("__proto__") }.f(), { polluted: "yes" }) }'
        result = run_expression(payload)
        # In vulnerable version, the payload evaluates (returns [object Object] or similar)
        assert result == payload, f"Prototype pollution payload was evaluated! Result: {result}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
