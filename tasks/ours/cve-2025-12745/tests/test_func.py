#!/usr/bin/env python3
"""
Functionality tests for ArrayBuffer.prototype.slice() in QuickJS.
These tests verify that basic ArrayBuffer operations work correctly.
Should PASS in both vulnerable and fixed states.
"""
import subprocess
import pytest
import tempfile
import os

QJS_BINARY = "/app/quickjs/qjs"


def run_js(code: str, timeout: int = 10) -> subprocess.CompletedProcess:
    """Run JavaScript code using QuickJS and return the result."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(code)
        f.flush()
        temp_path = f.name

    try:
        result = subprocess.run(
            [QJS_BINARY, temp_path],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result
    finally:
        os.unlink(temp_path)


class TestArrayBufferBasics:
    """Test basic ArrayBuffer functionality."""

    def test_arraybuffer_creation(self):
        """Test that ArrayBuffer can be created."""
        code = """
let buf = new ArrayBuffer(100);
if (buf.byteLength !== 100) {
    throw new Error("ArrayBuffer creation failed");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_arraybuffer_resizable_creation(self):
        """Test that resizable ArrayBuffer can be created."""
        code = """
let buf = new ArrayBuffer(100, { maxByteLength: 200 });
if (buf.byteLength !== 100) {
    throw new Error("Initial byteLength wrong");
}
if (buf.maxByteLength !== 200) {
    throw new Error("maxByteLength wrong");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_arraybuffer_resize(self):
        """Test that resizable ArrayBuffer can be resized."""
        code = """
let buf = new ArrayBuffer(100, { maxByteLength: 200 });
buf.resize(150);
if (buf.byteLength !== 150) {
    throw new Error("Resize failed, got " + buf.byteLength);
}
buf.resize(50);
if (buf.byteLength !== 50) {
    throw new Error("Shrink failed, got " + buf.byteLength);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"


class TestArrayBufferSlice:
    """Test ArrayBuffer.prototype.slice() functionality."""

    def test_basic_slice(self):
        """Test basic slice operation."""
        code = """
let buf = new ArrayBuffer(100);
let view = new Uint8Array(buf);
for (let i = 0; i < 100; i++) view[i] = i;

let sliced = buf.slice(10, 20);
let slicedView = new Uint8Array(sliced);
if (slicedView.length !== 10) {
    throw new Error("Wrong slice length: " + slicedView.length);
}
if (slicedView[0] !== 10) {
    throw new Error("Wrong slice content at [0]: " + slicedView[0]);
}
if (slicedView[9] !== 19) {
    throw new Error("Wrong slice content at [9]: " + slicedView[9]);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_negative_indices(self):
        """Test slice with negative indices."""
        code = """
let buf = new ArrayBuffer(50);
let slice1 = buf.slice(-10);
if (slice1.byteLength !== 10) {
    throw new Error("Negative start slice failed: " + slice1.byteLength);
}

let slice2 = buf.slice(10, -10);
if (slice2.byteLength !== 30) {
    throw new Error("Negative end slice failed: " + slice2.byteLength);
}

let slice3 = buf.slice(-20, -10);
if (slice3.byteLength !== 10) {
    throw new Error("Both negative slice failed: " + slice3.byteLength);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_empty(self):
        """Test empty slice."""
        code = """
let buf = new ArrayBuffer(100);
let slice1 = buf.slice(50, 50);
if (slice1.byteLength !== 0) {
    throw new Error("Equal indices should produce empty slice");
}

let slice2 = buf.slice(60, 40);
if (slice2.byteLength !== 0) {
    throw new Error("end < start should produce empty slice");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_full_copy(self):
        """Test slice with no arguments (full copy)."""
        code = """
let buf = new ArrayBuffer(25);
let view = new Uint8Array(buf);
for (let i = 0; i < 25; i++) view[i] = i * 2;

let slice = buf.slice();
if (slice.byteLength !== 25) {
    throw new Error("Full slice wrong length: " + slice.byteLength);
}

let sliceView = new Uint8Array(slice);
for (let i = 0; i < 25; i++) {
    if (sliceView[i] !== i * 2) {
        throw new Error("Full slice content wrong at " + i);
    }
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_from_start(self):
        """Test slice with only start argument."""
        code = """
let buf = new ArrayBuffer(100);
let slice = buf.slice(75);
if (slice.byteLength !== 25) {
    throw new Error("Slice from start failed: " + slice.byteLength);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_out_of_bounds(self):
        """Test slice with out-of-bounds indices (should clamp)."""
        code = """
let buf = new ArrayBuffer(50);

let slice1 = buf.slice(100);
if (slice1.byteLength !== 0) {
    throw new Error("Start beyond end should produce empty slice");
}

let slice2 = buf.slice(0, 200);
if (slice2.byteLength !== 50) {
    throw new Error("End beyond length should clamp to length");
}

let slice3 = buf.slice(-200, 10);
if (slice3.byteLength !== 10) {
    throw new Error("Negative start beyond should clamp to 0");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"


class TestArrayBufferSliceResizable:
    """Test ArrayBuffer.prototype.slice() with resizable buffers."""

    def test_slice_resizable_basic(self):
        """Test basic slice on resizable buffer."""
        code = """
let buf = new ArrayBuffer(100, { maxByteLength: 200 });
let view = new Uint8Array(buf);
for (let i = 0; i < 100; i++) view[i] = i;

let slice = buf.slice(25, 75);
if (slice.byteLength !== 50) {
    throw new Error("Slice length wrong: " + slice.byteLength);
}

let sliceView = new Uint8Array(slice);
if (sliceView[0] !== 25 || sliceView[49] !== 74) {
    throw new Error("Slice content wrong");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_slice_after_resize_within_range(self):
        """Test slice after resizing buffer (slice range still valid)."""
        code = """
let buf = new ArrayBuffer(100, { maxByteLength: 200 });
let view = new Uint8Array(buf);
for (let i = 0; i < 100; i++) view[i] = i;

buf.resize(150);
// Data in first 100 bytes should be preserved
let slice = buf.slice(10, 50);
let sliceView = new Uint8Array(slice);
if (sliceView[0] !== 10) {
    throw new Error("Content not preserved after grow");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"


class TestTypedArrays:
    """Test TypedArray functionality that uses ArrayBuffer."""

    def test_uint8array_from_slice(self):
        """Test creating Uint8Array from sliced buffer."""
        code = """
let buf = new ArrayBuffer(100);
let view = new Uint8Array(buf);
for (let i = 0; i < 100; i++) view[i] = 255 - i;

let sliced = buf.slice(10, 30);
let slicedView = new Uint8Array(sliced);

if (slicedView.length !== 20) {
    throw new Error("Wrong length");
}
if (slicedView[0] !== 245) {
    throw new Error("Wrong value at 0: " + slicedView[0]);
}
if (slicedView[19] !== 226) {
    throw new Error("Wrong value at 19: " + slicedView[19]);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"

    def test_int32array_from_slice(self):
        """Test creating Int32Array from sliced buffer."""
        code = """
let buf = new ArrayBuffer(40);  // 10 int32s
let view = new Int32Array(buf);
for (let i = 0; i < 10; i++) view[i] = i * 1000;

let sliced = buf.slice(8, 24);  // bytes 8-24 = int32s at indices 2,3,4
let slicedView = new Int32Array(sliced);

if (slicedView.length !== 4) {
    throw new Error("Wrong length: " + slicedView.length);
}
if (slicedView[0] !== 2000) {
    throw new Error("Wrong value: " + slicedView[0]);
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"


class TestDataView:
    """Test DataView functionality with ArrayBuffer."""

    def test_dataview_on_slice(self):
        """Test DataView on sliced buffer."""
        code = """
let buf = new ArrayBuffer(100);
let dv = new DataView(buf);
dv.setInt32(20, 0x12345678);

let sliced = buf.slice(20, 28);
let slicedDv = new DataView(sliced);

if (slicedDv.getInt32(0) !== 0x12345678) {
    throw new Error("DataView read wrong value");
}
print("PASS");
"""
        result = run_js(code)
        assert "PASS" in result.stdout, f"Failed: {result.stdout}{result.stderr}"


class TestResizableSliceBoundary:
    """Test boundary cases for slice on resizable buffers with species override."""

    def test_resize_to_exact_required_size(self):
        """
        If buffer is resized to exactly the required size, slice should work.
        slice(100, 200) needs byte_length >= 200
        """
        code = """
let buf = new ArrayBuffer(500, { maxByteLength: 1000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(200);  // Resize to exactly what's needed
        return new ArrayBuffer(len);
    }
});

let error = null;
let result = null;
try {
    result = buf.slice(100, 200);
} catch (e) {
    error = e;
}

if (error) {
    if (error instanceof TypeError) {
        print("PASS: TypeError thrown even at boundary (strict)");
    } else {
        print("FAIL: Unexpected error: " + error);
    }
} else if (result && result.byteLength === 100) {
    print("PASS: Slice succeeded with exact size");
} else {
    print("FAIL: Unknown result");
}
"""
        result = run_js(code)
        assert "PASS" in result.stdout, (
            f"Unexpected behavior. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_to_more_than_required(self):
        """
        If buffer is resized but still large enough, slice should work.
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(600);  // Still larger than needed for slice(100, 500)
        return new ArrayBuffer(len);
    }
});

let result = null;
let error = null;
try {
    result = buf.slice(100, 500);  // Needs 500 bytes, we have 600
} catch (e) {
    error = e;
}

if (result && result.byteLength === 400) {
    print("PASS: Slice succeeded with sufficient size");
} else if (error instanceof TypeError) {
    print("PASS: TypeError thrown even when size sufficient (strict)");
} else {
    print("FAIL: Unexpected: " + (error || "no result"));
}
"""
        result = run_js(code)
        assert "PASS" in result.stdout, (
            f"Unexpected behavior. Output: {result.stdout}{result.stderr}"
        )

    def test_normal_slice_without_species_override(self):
        """Normal slice without Symbol.species override should work."""
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
let view = new Uint8Array(buf);
for (let i = 0; i < 1000; i++) view[i] = i % 256;

let slice = buf.slice(100, 200);
let sliceView = new Uint8Array(slice);

if (slice.byteLength === 100 && sliceView[0] === 100 && sliceView[99] === 199) {
    print("PASS: Normal slice works correctly");
} else {
    print("FAIL: Normal slice broken");
}
"""
        result = run_js(code)
        assert "PASS" in result.stdout, (
            f"Normal slice broken. Output: {result.stdout}{result.stderr}"
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
