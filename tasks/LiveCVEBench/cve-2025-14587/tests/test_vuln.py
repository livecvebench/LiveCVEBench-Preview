"""
Vulnerability tests for Online Pet Shop Management System.
These tests verify that SQL injection vulnerability is present (before fix) or mitigated (after fix).

Expected behavior:
- FAIL in vulnerable state (SQL injection is exploitable)
- PASS in fixed state (SQL injection is mitigated)
"""

import pytest
import requests
import time
import re

BASE_URL = "http://localhost"
VULNERABLE_ENDPOINT = f"{BASE_URL}/pet1/availableframe.php"

# Threshold for time-based detection (in seconds)
TIME_THRESHOLD_LOW = 2.5   # Minimum delay to confirm injection worked
TIME_THRESHOLD_NORMAL = 2.0  # Normal response should be under this


def make_order_request(name_payload, timeout=30):
    """Helper function to make order requests with a given name payload."""
    order_data = {
        "name": name_payload,
        "foodid": "2",
        "address": "Test Address",
        "contact": "1234567890",
        "oqty": "1",
        "otype": "Deliver",
        "datep": "2024-12-25",
        "savechanges": "1"
    }
    return requests.post(VULNERABLE_ENDPOINT, data=order_data, timeout=timeout)


class TestTimeBasedSQLInjection:
    """Test time-based SQL injection attack vectors."""

    def test_sleep_injection_basic(self):
        """
        Test basic SLEEP injection in name parameter.
        Vulnerable: Response delayed by 3+ seconds
        Fixed: Response returns quickly (< 2 seconds)
        """
        # Subquery technique ensures SLEEP executes properly
        payload = "test' AND (SELECT 1 FROM (SELECT SLEEP(3))a)-- -"

        start_time = time.time()
        try:
            response = make_order_request(payload, timeout=15)
            elapsed_time = time.time() - start_time
        except requests.exceptions.Timeout:
            elapsed_time = 15  # Timed out means injection likely worked

        # After fix, response should be fast (no SQL sleep executed)
        assert elapsed_time < TIME_THRESHOLD_LOW, \
            f"Time-based SQL injection detected! Response took {elapsed_time:.2f}s (payload: SLEEP(3))"

    def test_sleep_injection_subquery(self):
        """
        Test SLEEP injection using subquery technique.
        This bypasses some simple filters.
        """
        # Use prefix 'test' and subquery form
        payload = "test' AND (SELECT 1 FROM (SELECT SLEEP(3))x)-- -"

        start_time = time.time()
        try:
            response = make_order_request(payload, timeout=15)
            elapsed_time = time.time() - start_time
        except requests.exceptions.Timeout:
            elapsed_time = 15

        assert elapsed_time < TIME_THRESHOLD_LOW, \
            f"Time-based SQL injection (subquery) detected! Response took {elapsed_time:.2f}s"

    def test_sleep_injection_benchmark(self):
        """
        Test BENCHMARK-based timing injection.
        Alternative to SLEEP for time-based detection.
        """
        # BENCHMARK in subquery form - use 50M iterations for ~3s delay
        payload = "test' AND (SELECT 1 FROM (SELECT BENCHMARK(50000000,SHA1('test')))a)-- -"

        start_time = time.time()
        try:
            response = make_order_request(payload, timeout=15)
            elapsed_time = time.time() - start_time
        except requests.exceptions.Timeout:
            elapsed_time = 15

        # Benchmark should not execute after fix
        assert elapsed_time < TIME_THRESHOLD_LOW, \
            f"Time-based SQL injection (BENCHMARK) detected! Response took {elapsed_time:.2f}s"

    def test_conditional_sleep_injection(self):
        """
        Test conditional SLEEP using IF statement.
        Tests if conditional logic is being evaluated.
        """
        # Conditional SLEEP in subquery form
        payload = "test' AND (SELECT 1 FROM (SELECT IF(1=1,SLEEP(3),0))a)-- -"

        start_time = time.time()
        try:
            response = make_order_request(payload, timeout=15)
            elapsed_time = time.time() - start_time
        except requests.exceptions.Timeout:
            elapsed_time = 15

        assert elapsed_time < TIME_THRESHOLD_LOW, \
            f"Conditional time-based SQL injection detected! Response took {elapsed_time:.2f}s"


class TestErrorBasedSQLInjection:
    """Test error-based SQL injection attack vectors."""

    def test_extractvalue_injection(self):
        """
        Test EXTRACTVALUE-based error injection.
        Vulnerable: MySQL error in response with extracted data
        Fixed: No SQL error, treated as literal string
        """
        payload = "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for MySQL error patterns that would indicate injection worked
        error_patterns = [
            "xpath syntax error",
            "extractvalue",
            "concat",
            "mysql",
            "mariadb",
            "5.5.",
            "5.6.",
            "5.7.",
            "8.0.",
            "10.0.",
            "10.1.",
        ]

        injection_detected = any(pattern in response_text for pattern in error_patterns)

        # Also check for version string patterns (data extraction)
        version_pattern = re.search(r'\d+\.\d+\.\d+', response.text)
        if version_pattern and ("mysql" in response_text.lower() or "mariadb" in response_text.lower()):
            injection_detected = True

        assert not injection_detected, \
            f"Error-based SQL injection detected! Response contains database info"

    def test_updatexml_injection(self):
        """
        Test UPDATEXML-based error injection.
        Alternative technique to EXTRACTVALUE.
        """
        payload = "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT user()),0x7e),1)-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for UPDATEXML error revealing data or PHP warnings from SQL errors
        error_indicators = [
            "xpath syntax error",
            "updatexml",
            "root@",
            "@localhost",
            "warning",  # PHP warning indicates SQL error occurred
            "mysqli_num_rows",  # PHP mysqli error
        ]

        injection_detected = any(indicator in response_text for indicator in error_indicators)

        assert not injection_detected, \
            f"UPDATEXML error-based SQL injection detected!"

    def test_double_query_error_injection(self):
        """
        Test double query (floor/rand) error injection for data extraction.
        """
        payload = "' OR (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT version()),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for duplicate entry error which indicates injection
        error_indicators = [
            "duplicate entry",
            "group by",
            "floor(rand",
        ]

        injection_detected = any(indicator in response_text for indicator in error_indicators)

        assert not injection_detected, \
            f"Double query error-based SQL injection detected!"


class TestBooleanBasedSQLInjection:
    """Test boolean-based SQL injection attack vectors."""

    def test_or_true_injection(self):
        """
        Test basic OR 1=1 injection.
        Vulnerable: Modified query behavior (e.g., returns all rows or triggers max order limit)
        Fixed: Treated as literal string, normal processing
        """
        # First get baseline response with normal input
        baseline_response = make_order_request("NormalTestUser123")

        # Now test with OR injection - this should cause the SELECT to return ALL rows
        # If there are >=5 rows, it will show "maximum order of 5" message
        # If it causes SQL error, it will show "Sorry unable to process"
        payload = "' OR '1'='1"
        injected_response = make_order_request(payload)

        response_text = injected_response.text.lower()

        # In vulnerable state, the injection causes abnormal behavior:
        # Either SQL error (Sorry unable to process) or max order limit
        # Also check for PHP warnings
        vulnerability_indicators = [
            "sorry unable to process",  # SQL error occurred
            "maximum order of 5",  # OR 1=1 caused all rows to be returned
            "warning",  # PHP warning from SQL error
            "mysqli_num_rows",  # PHP mysqli error
            "sql syntax",  # Direct SQL error exposed
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Boolean-based SQL injection detected - query behavior was modified"

    def test_rlike_boolean_injection(self):
        """
        Test RLIKE-based boolean injection.
        Used by sqlmap for boolean-based detection.
        """
        payload = "test' RLIKE (SELECT (CASE WHEN (1=1) THEN 'test' ELSE 0x28 END))-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for signs that SQL processed the injection
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "sql syntax",
            "rlike",
            "regexp",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"RLIKE boolean injection detected - SQL processed the payload"

    def test_and_false_injection(self):
        """
        Test AND 1=2 injection for false condition.
        """
        # This payload forces the condition to always be false
        payload = "test' AND '1'='2"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, the false condition affects query behavior
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "sql syntax",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Boolean-based (AND false) SQL injection detected"


class TestUnionBasedSQLInjection:
    """Test UNION-based SQL injection attack vectors."""

    def test_union_select_injection(self):
        """
        Test UNION SELECT injection for data extraction.
        """
        payload = "' UNION SELECT 1,2,3,4,5,6,7,8,9,10-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, UNION injection causes SQL errors or different behavior
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "syntax error",
            "different number of columns",  # UNION column count mismatch
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"UNION-based SQL injection detected - SQL processed the payload"

    def test_union_information_schema(self):
        """
        Test UNION injection to extract table names from information_schema.
        """
        payload = "' UNION SELECT table_name,2,3,4,5,6,7,8,9,10 FROM information_schema.tables-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for information_schema data leakage or SQL errors
        vulnerability_indicators = [
            "information_schema",
            "tblorders",
            "tblcnp",
            "admininfo",
            "character_sets",
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"UNION injection detected - SQL processed the payload!"


class TestCommentAndBypassTechniques:
    """Test various SQL injection bypass techniques."""

    def test_comment_dash_injection(self):
        """Test injection with -- comment."""
        payload = "admin'-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, the comment truncates the query causing issues
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Comment injection detected - SQL processed the payload"

    def test_comment_hash_injection(self):
        """Test injection with # comment."""
        payload = "admin'#"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, # comment causes SQL issues
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "syntax",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Hash comment injection detected - SQL processed the payload"

    def test_null_byte_injection(self):
        """Test injection with null byte bypass attempt."""
        payload = "admin'%00"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # Check for signs of SQL processing the injected quote
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Null byte injection detected - SQL processed the payload"

    def test_case_variation_injection(self):
        """Test case variation bypass (SeLeCt, uNiOn, etc.)."""
        payload = "' uNiOn SeLeCt 1,2,3,4,5,6,7,8,9,10-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, case variation UNION causes SQL errors
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "syntax",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Case variation bypass detected - SQL processed the query"


class TestSecondOrderAndAdvanced:
    """Test for second-order and advanced injection scenarios."""

    def test_stacked_queries(self):
        """
        Test stacked queries injection (multiple statements).
        Dangerous as it could allow INSERT/UPDATE/DELETE/DROP.
        """
        payload = "test'; DROP TABLE test_injection;-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, stacked query causes SQL issues
        # (mysqli doesn't support multi-query by default, so single quote breaks it)
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Stacked query injection detected - SQL processed the payload"

    def test_insert_injection(self):
        """
        Test that injection in INSERT statement is prevented.
        The name parameter is also used in an INSERT query.
        """
        # This payload would break the INSERT query structure
        payload = "test','injected_addr','1234567890',999,99,'injected',NULL,'Deliver','2024-01-01')-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, this breaks the INSERT query
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "syntax",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"INSERT injection detected - SQL processed the payload"


class TestSpecialCharacterHandling:
    """Test proper handling of special characters after fix."""

    def test_single_quote_in_name(self):
        """Test that single quotes in names are handled safely."""
        payload = "O'Brien"  # Legitimate name with apostrophe
        response = make_order_request(payload)

        response_text = response.text.lower()

        # In vulnerable state, unescaped quote causes SQL issues
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
            "fatal",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"Single quote handling failed - SQL injection vulnerability exists"

    def test_double_quote_in_name(self):
        """Test SQL injection with double quote combined with single quote."""
        # Use single quote with double quote to test SQL handling
        payload = "test'\" OR 1=1-- -"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # The single quote breaks SQL even with double quote
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"SQL injection detected via quote combination"

    def test_backslash_in_name(self):
        """Test SQL injection with backslash escape bypass attempt."""
        # Use single quote after backslash to test escape handling
        # In some contexts \' escapes the quote, but we add another quote
        payload = "test\\\\' OR 1=1 OR ''='"
        response = make_order_request(payload)

        response_text = response.text.lower()

        # The payload structure should cause SQL issues
        vulnerability_indicators = [
            "sorry unable to process",
            "warning",
            "mysqli",
        ]

        has_vulnerability = any(indicator in response_text for indicator in vulnerability_indicators)

        assert not has_vulnerability, \
            f"SQL injection detected via backslash escape bypass"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
