#!/bin/bash
set -e
cd /app

echo "Applying code execution safety fix to analysis_tools.py..."

# Target file
TARGET_FILE="/app/backend/tools/analysis_tools.py"

# Check if the file exists
if [ ! -f "$TARGET_FILE" ]; then
    echo "Error: $TARGET_FILE not found"
    exit 1
fi

# Check if fix has already been applied (look for ast import which is added by the fix)
if grep -q "^import ast$" "$TARGET_FILE"; then
    echo "Fix appears to already be applied (ast import found). Verifying..."
    if grep -q "unsafe_calls = {\"eval\", \"exec\", \"open\", \"__import__\"}" "$TARGET_FILE"; then
        echo "Fix is already in place. Skipping."
        exit 0
    fi
fi

# Create a Python script to apply the fix
cat > /tmp/apply_fix.py << 'PYEOF'
import re
import sys

filepath = '/app/backend/tools/analysis_tools.py'

with open(filepath, 'r') as f:
    content = f.read()

# Step 1: Add ast import if not present
if 'import ast' not in content:
    # Find the import contextlib line and add ast import after it
    if 'import contextlib' in content:
        content = re.sub(
            r'(import contextlib)(\n)',
            r'\1\2import ast\2',
            content
        )
        print("Added 'import ast' import after contextlib")
    else:
        # Fallback: add after the first import line
        content = re.sub(
            r'(^import [^\n]+)(\n)',
            r'\1\2import ast\2',
            content,
            count=1,
            flags=re.MULTILINE
        )
        print("Added 'import ast' import after first import")

# Step 2: Replace the execute_analysis_code_safely function
# Find the old function and replace it entirely

old_function_pattern = r'''async def execute_analysis_code_safely\(code: str, data_dict: str\) -> tuple\[str, str\]:
    """
    Execute the analysis code in a safe, controlled environment\.
    Returns a tuple of \(result_text, error_message\)
    """
    data_dict = json\.loads\(data_dict\)
    # Create a string buffer to capture print outputs
    stdout_buffer = io\.StringIO\(\)
    result_text = ""
    error_message = ""

    # Create namespace for code execution with limited imports
    namespace = \{
        # Core data libraries
        "pd": pd,
        "np": np,
        "data_dict": data_dict,

        # Math and statistics
        "math": __import__\("math"\),
        "random": __import__\("random"\),
        "statistics": __import__\("statistics"\),

        # Advanced statistics \(if available\)
        "scipy": __import__\("scipy"\) if "scipy" in sys\.modules else None,
        "stats": __import__\("scipy\.stats"\) if "scipy\.stats" in sys\.modules else None,
        "sm": __import__\("statsmodels\.api"\) if "statsmodels\.api" in sys\.modules else None,
        "smf": __import__\("statsmodels\.formula\.api"\) if "statsmodels\.formula\.api" in sys\.modules else None,

        # Data encoding
        "json": json,
        "BytesIO": io\.BytesIO,

        # Empty containers for results
        "final_result": ""
    \}

    # Wrap the code to capture and return results
    wrapped_code = f"""
try:
    # Execute the analysis code
\{textwrap\.indent\(code, '    '\)\}

except Exception as e:
    import traceback
    final_result = f"Error during execution: \{\{str\(e\)\}\}\\\\n\\\\nTraceback: \{\{traceback\.format_exc\(\)\}\}"
"""

    try:
        # Redirect stdout to capture print statements
        with contextlib\.redirect_stdout\(stdout_buffer\):
            # Execute code with restricted globals
            exec\(wrapped_code, namespace\)

        # Get the captured output
        stdout_output = stdout_buffer\.getvalue\(\)

        # Get any result value
        result_text = namespace\.get\("final_result", ""\)
        if not result_text and stdout_output:
            result_text = stdout_output


    except Exception as e:
        error_message = f"Error executing code: \{str\(e\)\}"
        LOGGER\.error\(error_message\)

    return result_text, error_message'''

new_function = '''async def execute_analysis_code_safely(code: str, data_dict: str) -> tuple[str, str]:
    """Execute analysis code in a restricted environment.

    The provided ``code`` string is parsed to ensure it doesn't contain unsafe
    constructs such as import statements or direct calls to ``exec``/``eval``.
    A custom namespace with limited built-ins is then used to execute the code.

    This function also restricts file system access, particularly preventing
    access to sensitive directories like /etc.

    Returns:
        tuple[str, str]: ``(result_text, error_message)``
    """
    data_dict = json.loads(data_dict)

    try:
        tree = ast.parse(code)
    except SyntaxError as exc:  # pragma: no cover - defensive
        return "", f"Syntax error in analysis code: {exc}"

    unsafe_calls = {"eval", "exec", "open", "__import__"}
    for node in ast.walk(tree):
        if (
            isinstance(node, ast.Call)
            and isinstance(node.func, ast.Name)
            and node.func.id in unsafe_calls
        ):
            return "", f"Use of '{node.func.id}' is not allowed"

    # Check for direct attempts to access /etc via string literals
    for node in ast.walk(tree):
        if isinstance(node, ast.Str) and node.s and isinstance(node.s, str):
            path = node.s
            if path.startswith('/etc/'):
                return "", f"Access to /etc directory is not permitted"

    stdout_buffer = io.StringIO()
    result_text = ""
    error_message = ""

    def _safe_open(*_: Any, **__: Any) -> None:
        raise PermissionError("File operations are not permitted")

    def _safe_import(
        name: str,
        globals: dict | None = None,
        locals: dict | None = None,
        fromlist: tuple[str] | tuple = (),
        level: int = 0,
    ):
        allowed_prefixes = (
            "pandas",
            "numpy",
            "math",
            "random",
            "statistics",
            "scipy",
            "statsmodels",
            "json",
        )
        if not any(name.startswith(prefix) for prefix in allowed_prefixes):
            raise ImportError(f"Import of '{name}' is not allowed")
        return __import__(name, globals, locals, fromlist, level)

    safe_builtins: dict[str, Any] = {
        "abs": abs,
        "all": all,
        "any": any,
        "bool": bool,
        "dict": dict,
        "enumerate": enumerate,
        "float": float,
        "int": int,
        "len": len,
        "list": list,
        "max": max,
        "min": min,
        "pow": pow,
        "print": print,
        "range": range,
        "sum": sum,
        "zip": zip,
        "str": str,
        "set": set,
        "tuple": tuple,
        "Exception": Exception,
        "open": _safe_open,
        "__import__": _safe_import,
    }

    namespace = {
        "pd": pd,
        "np": np,
        "data_dict": data_dict,
        "math": __import__("math"),
        "random": __import__("random"),
        "statistics": __import__("statistics"),
        "scipy": __import__("scipy") if "scipy" in sys.modules else None,
        "stats": __import__("scipy.stats") if "scipy.stats" in sys.modules else None,
        "sm": __import__("statsmodels.api") if "statsmodels.api" in sys.modules else None,
        "smf": __import__("statsmodels.formula.api") if "statsmodels.formula.api" in sys.modules else None,
        "json": json,
        "BytesIO": io.BytesIO,
        "final_result": "",
        "__builtins__": safe_builtins,
    }

    # Wrap the code to capture and return results
    wrapped_code = f"""
try:
    # Execute the analysis code
{textwrap.indent(code, '    ')}

except Exception as e:
    final_result = f"Error during execution: {{str(e)}}"
"""

    try:
        # Redirect stdout to capture print statements
        with contextlib.redirect_stdout(stdout_buffer):
            # Execute code with restricted globals
            exec(wrapped_code, namespace)

        # Get the captured output
        stdout_output = stdout_buffer.getvalue()

        # Get any result value
        result_text = namespace.get("final_result", "")
        if not result_text and stdout_output:
            result_text = stdout_output


    except Exception as e:
        error_message = f"Error executing code: {str(e)}"
        LOGGER.error(error_message)

    return result_text, error_message'''

# Try to find and replace the function using a simpler pattern
# First, let's try to locate the function start

func_start = 'async def execute_analysis_code_safely(code: str, data_dict: str) -> tuple[str, str]:'

if func_start in content:
    # Find the start position
    start_idx = content.find(func_start)

    # Find the next function definition or class to determine the end
    # Look for patterns like "async def " or "def " at the start of a line after our function
    rest_of_file = content[start_idx + len(func_start):]

    # Find the next top-level function (not indented async def or def)
    import re
    next_func_match = re.search(r'\n(?=async def [a-z_]+\(|def [a-z_]+\()', rest_of_file)

    if next_func_match:
        end_idx = start_idx + len(func_start) + next_func_match.start()
    else:
        # If no next function, the function goes to the end
        end_idx = len(content)

    # Replace the function
    content = content[:start_idx] + new_function + content[end_idx:]
    print("Replaced execute_analysis_code_safely function")
else:
    print("Warning: Could not find the vulnerable function to replace")
    sys.exit(1)

# Write the fixed content
with open(filepath, 'w') as f:
    f.write(content)

print("Fix applied successfully!")
PYEOF

# Run the Python fix script
python3 /tmp/apply_fix.py

# Ensure ast import is present with a direct sed command as backup
if ! grep -q "^import ast$" "$TARGET_FILE"; then
    echo "Python script didn't add ast import, using sed as backup..."
    sed -i '/^import contextlib$/a import ast' "$TARGET_FILE"
    echo "Added ast import via sed"
fi

# Verify the fix was applied
if grep -q "unsafe_calls = {\"eval\", \"exec\", \"open\", \"__import__\"}" "$TARGET_FILE"; then
    echo "Verification: Fix successfully applied!"
else
    echo "Warning: Fix verification failed. Manual inspection recommended."
fi

echo "Fix applied successfully!"
