"""
Vulnerability tests for filestream_vscanf uninitialized variable bug.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable - uninitialized variable causes issues)
- PASS in fixed state (vulnerability is mitigated - variable is initialized)

The vulnerability: In filestream_vscanf(), the local variable 'sublen' is used
uninitialized when sscanf() fails to match input (returns 0 or EOF before %n
is processed). This causes:
1. Out-of-bounds read when accessing memory beyond the buffer
2. Corrupted file position from garbage seek offset

Detection method:
- Source code analysis of /app/file_stream.c (the actual vulnerable source)
- The test harness has its own safe implementation for runtime testing
"""

import subprocess
import pytest
import os
import re


# Path to the compiled test harness
TEST_HARNESS = "/tests/test_harness"
TEST_HARNESS_ASAN = "/tests/test_harness_asan"

# Path to the actual vulnerable source code (from Dockerfile COPY)
# solution.sh modifies this file
APP_SOURCE_FILE = "/app/file_stream.c"


def get_harness():
    """Get the path to an available test harness"""
    if os.path.exists(TEST_HARNESS):
        return TEST_HARNESS
    if os.path.exists(TEST_HARNESS_ASAN):
        return TEST_HARNESS_ASAN
    pytest.fail("Test harness not found. Run compile_harness.sh first.")


def get_asan_harness():
    """Get the ASan-enabled test harness"""
    if os.path.exists(TEST_HARNESS_ASAN):
        return TEST_HARNESS_ASAN
    return None


def check_source_vulnerability():
    """
    Check if the source code at /app/file_stream.c has the vulnerability.

    Returns True if vulnerable (sublen not initialized), False if fixed.
    """
    source_file = APP_SOURCE_FILE
    if not os.path.exists(source_file):
        # Fallback for local testing
        pytest.skip(f"Source file not found: {source_file}")

    with open(source_file, 'r') as f:
        content = f.read()

    # Look for the vulnerable pattern in filestream_vscanf function
    # The vulnerable code has: int sublen; (without initialization)
    # The fixed code has:      int sublen = 0;

    # Find the filestream_vscanf function
    vscanf_match = re.search(r'int filestream_vscanf\s*\([^)]*\)\s*\{([^}]+(?:\{[^}]*\}[^}]*)*)\}', content, re.DOTALL)
    if not vscanf_match:
        # Try a simpler pattern
        if 'filestream_vscanf' not in content:
            pytest.skip("filestream_vscanf function not found in source")

    # Check for the variable declaration pattern
    # Look for "int sublen;" without "= 0" nearby
    lines = content.split('\n')
    in_vscanf = False

    for line in lines:
        if 'filestream_vscanf' in line and 'int ' in line:
            in_vscanf = True

        if in_vscanf:
            # Skip comment-only lines
            stripped = line.strip()
            if stripped.startswith('*') or stripped.startswith('//'):
                continue

            # Check for uninitialized sublen declaration
            # Match patterns like "int sublen;" or "int        sublen;"
            if re.search(r'\bint\s+sublen\s*;', line) and '= 0' not in line:
                return True  # Vulnerable

            # Check for initialized sublen declaration
            if re.search(r'\bint\s+sublen\s*=\s*0', line):
                return False  # Fixed

            # End of function
            if 'va_end(args_copy)' in line:
                break

    # If we couldn't find the pattern, assume not vulnerable
    return False


class TestVulnerabilitySourceCode:
    """
    Test vulnerability by analyzing source code.

    This is the most reliable detection method for uninitialized variable bugs
    since runtime behavior can be non-deterministic depending on stack state.
    """

    def test_sublen_initialization(self):
        """
        Verify that the 'sublen' variable is properly initialized to 0 in /app/file_stream.c.

        Vulnerable code:  int sublen;
        Fixed code:       int sublen = 0;
        """
        if check_source_vulnerability():
            pytest.fail(
                f"Vulnerability found in {APP_SOURCE_FILE}: 'sublen' is not initialized in filestream_vscanf().\n"
                f"Fix: Change 'int sublen;' to 'int sublen = 0;'"
            )

    def test_source_check_via_harness(self):
        """
        Use the C test harness's source code check.
        This provides a cross-verification of our Python check.
        """
        harness = get_harness()
        result = subprocess.run(
            [harness, "vuln_source"],
            capture_output=True,
            text=True,
            timeout=30
        )

        if result.returncode == 100 or "VULN:" in result.stdout:
            pytest.fail(f"Source code check detected vulnerability: {result.stdout}")

        assert "PASS" in result.stdout or "SKIP" in result.stdout, \
            f"Unexpected output: {result.stdout}"


class TestVulnerabilityBehavioral:
    """
    Behavioral tests that attempt to trigger the vulnerability at runtime.

    Note: These tests also verify the source code to ensure vulnerability
    detection is reliable, since uninitialized variable behavior is
    non-deterministic at runtime.
    """

    def test_format_mismatch(self):
        """
        Test %d format with non-numeric input "abc".

        When sscanf fails to match, %n doesn't write to sublen.
        Vulnerable: sublen contains garbage, file position may be abnormal
        Fixed: sublen is 0, file position stays at start
        """
        harness = get_harness()
        result = subprocess.run(
            [harness, "vuln_mismatch"],
            capture_output=True,
            text=True,
            timeout=30
        )

        # Check behavioral indicators
        if "VULN:" in result.stdout or result.returncode == 100:
            pytest.fail(f"Behavioral test detected vulnerability: {result.stdout}")

        # Also verify source code
        if check_source_vulnerability():
            pytest.fail(f"Source code analysis detected uninitialized 'sublen' variable in {APP_SOURCE_FILE}")

        assert result.returncode == 0, f"Test failed: {result.stdout}\n{result.stderr}"

    def test_character_class_mismatch(self):
        """
        Test %[0-9] format with non-digit input "xyz".
        """
        harness = get_harness()
        result = subprocess.run(
            [harness, "vuln_charclass"],
            capture_output=True,
            text=True,
            timeout=30
        )

        # Check behavioral indicators
        if "VULN:" in result.stdout or result.returncode == 100:
            pytest.fail(f"Vulnerability detected: {result.stdout}")

        if check_source_vulnerability():
            pytest.fail(f"Source code analysis detected uninitialized 'sublen' variable in {APP_SOURCE_FILE}")

        assert result.returncode == 0, f"Test failed: {result.stdout}\n{result.stderr}"

    def test_repeated_mismatches(self):
        """
        Repeated format mismatches to catch intermittent issues.

        Running multiple times increases the chance of catching garbage values.
        """
        harness = get_harness()
        result = subprocess.run(
            [harness, "vuln_repeated"],
            capture_output=True,
            text=True,
            timeout=60
        )

        # Check behavioral indicators
        if "VULN:" in result.stdout or result.returncode == 100:
            pytest.fail(f"Vulnerability detected: {result.stdout}")

        if check_source_vulnerability():
            pytest.fail(f"Source code analysis detected uninitialized 'sublen' variable in {APP_SOURCE_FILE}")

        assert result.returncode == 0


class TestVulnerabilityASan:
    """
    Test vulnerability detection via AddressSanitizer.

    ASan can detect out-of-bounds memory access when the garbage sublen
    value causes bufiter to point outside the buffer.
    """

    def test_asan_all_vuln_scenarios(self):
        """
        Run all vulnerability scenarios with ASan.
        """
        asan_harness = get_asan_harness()
        if not asan_harness:
            pytest.skip("ASan build not available")

        result = subprocess.run(
            [asan_harness, "all_vuln"],
            capture_output=True,
            text=True,
            timeout=120,
            env={**os.environ, "ASAN_OPTIONS": "detect_leaks=0:halt_on_error=0"}
        )

        # Check for ASan error reports
        asan_errors = [
            "AddressSanitizer",
            "stack-buffer-overflow",
            "heap-buffer-overflow",
            "SUMMARY: AddressSanitizer"
        ]

        for error in asan_errors:
            if error in result.stderr:
                pytest.fail(
                    f"ASan detected memory error (vulnerability present):\n"
                    f"{result.stderr[:2000]}"
                )

        if "VULN:" in result.stdout:
            pytest.fail(f"Vulnerability indicators found: {result.stdout}")


class TestVulnerabilityComprehensive:
    """Comprehensive tests combining multiple detection methods"""

    def test_all_vulnerability_checks(self):
        """
        Run all vulnerability tests through the harness.
        This is the main vulnerability test that combines source and behavioral checks.
        """
        harness = get_harness()
        result = subprocess.run(
            [harness, "all_vuln"],
            capture_output=True,
            text=True,
            timeout=120
        )

        # Any vulnerability indicator means the fix is not applied
        if result.returncode == 100:
            pytest.fail(f"Vulnerability tests failed: {result.stdout}")

        if "VULN:" in result.stdout:
            pytest.fail(f"Vulnerability detected: {result.stdout}")

        # We should see PASS messages
        assert "PASS" in result.stdout or "SKIP" in result.stdout, \
            f"Expected PASS in output: {result.stdout}"

    def test_consistency_across_runs(self):
        """
        Verify consistent behavior across multiple runs.

        Uninitialized variables can cause non-deterministic behavior,
        so we run tests multiple times to catch intermittent issues.
        Also checks source code for reliable vulnerability detection.
        """
        harness = get_harness()
        failures = []

        for i in range(3):
            result = subprocess.run(
                [harness, "vuln_mismatch"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 100 or "VULN:" in result.stdout:
                failures.append(f"Run {i+1}: {result.stdout.strip()}")

        if failures:
            pytest.fail(
                f"Inconsistent behavior across runs ({len(failures)}/3 failures):\n" +
                "\n".join(failures)
            )

        # Also check source code for vulnerability
        if check_source_vulnerability():
            pytest.fail(f"Source code analysis detected uninitialized 'sublen' variable in {APP_SOURCE_FILE}")


class TestVulnerabilityEdgeCases:
    """Edge case tests for comprehensive coverage"""

    def test_empty_file(self):
        """Test behavior with empty input file"""
        import tempfile

        # Create empty test file
        testfile = tempfile.mktemp(suffix='.txt')
        with open(testfile, 'w') as f:
            pass  # Empty file

        try:
            harness = get_harness()
            # Use the harness's general tests
            result = subprocess.run(
                [harness, "all_vuln"],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 100 or "VULN:" in result.stdout:
                pytest.fail(f"Edge case vulnerability: {result.stdout}")

        finally:
            os.unlink(testfile)

    def test_whitespace_only_input(self):
        """Test behavior with whitespace-only input"""
        import tempfile

        testfile = tempfile.mktemp(suffix='.txt')
        with open(testfile, 'w') as f:
            f.write("   \n\t\n  ")

        try:
            harness = get_harness()
            result = subprocess.run(
                [harness, "all_vuln"],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 100 or "VULN:" in result.stdout:
                pytest.fail(f"Whitespace edge case vulnerability: {result.stdout}")

        finally:
            os.unlink(testfile)

    def test_special_characters(self):
        """Test behavior with special character input"""
        import tempfile

        testfile = tempfile.mktemp(suffix='.txt')
        with open(testfile, 'w') as f:
            f.write("!@#$%^&*()\n")

        try:
            harness = get_harness()
            result = subprocess.run(
                [harness, "vuln_mismatch"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 100 or "VULN:" in result.stdout:
                pytest.fail(f"Special char vulnerability: {result.stdout}")

            # Also check source code for vulnerability
            if check_source_vulnerability():
                pytest.fail(f"Source code analysis detected uninitialized 'sublen' variable in {APP_SOURCE_FILE}")

        finally:
            os.unlink(testfile)
