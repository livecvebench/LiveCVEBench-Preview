"""
Vulnerability tests for FreshRSS access control issue.
These tests verify that the vulnerability is properly fixed:
- FAIL in vulnerable state (data is exposed to unauthenticated users)
- PASS in fixed state (endpoints properly require authentication)
"""

import pytest
import requests
import time
import json
import re

BASE_URL = "http://localhost"
TIMEOUT = 10


class TestActualizeEndpointAccessControl:
    """
    Tests for the actualize endpoint access control.
    This endpoint returns feed information and should require authentication.
    """

    def test_actualize_unauthenticated_returns_403(self):
        """Unauthenticated request to actualize should return 403."""
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Actualize endpoint should return 403 for unauthenticated users, got {response.status_code}"

    def test_actualize_no_feed_data_leak(self):
        """Unauthenticated request should not leak feed data."""
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            timeout=TIMEOUT
        )
        # Should not contain JSON feed data
        content = response.text.lower()
        # If it's a 403, the response should not contain feed-related data
        assert "categories" not in content or response.status_code == 403, \
            "Actualize endpoint leaking category data to unauthenticated users"
        assert "feeds" not in content or response.status_code == 403, \
            "Actualize endpoint leaking feed data to unauthenticated users"

    def test_actualize_no_cookies_still_blocked(self):
        """Request with empty cookies should still be blocked."""
        session = requests.Session()
        session.cookies.clear()
        response = session.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Actualize should block requests with no cookies, got {response.status_code}"

    def test_actualize_with_invalid_session_blocked(self):
        """Request with invalid session cookie should be blocked."""
        # Use alphanumeric session ID (PHP session IDs only allow A-Z, a-z, 0-9, "-", ",")
        cookies = {"FreshRSS": "invalidsessiontoken12345abcdef"}
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            cookies=cookies,
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Actualize should block requests with invalid session, got {response.status_code}"


class TestNbUnreadsPerFeedAccessControl:
    """
    Tests for the nbUnreadsPerFeed endpoint access control.
    This endpoint returns unread counts and should require authentication.
    """

    def test_nbunreads_unauthenticated_returns_403(self):
        """Unauthenticated request to nbUnreadsPerFeed should return 403."""
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=nbUnreadsPerFeed",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"nbUnreadsPerFeed should return 403 for unauthenticated users, got {response.status_code}"

    def test_nbunreads_no_stats_leak(self):
        """Unauthenticated request should not leak statistics."""
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=nbUnreadsPerFeed",
            timeout=TIMEOUT
        )
        content = response.text.lower()
        # Should not contain unread count data
        assert "categories" not in content or response.status_code == 403, \
            "nbUnreadsPerFeed endpoint leaking category data"
        assert "tags" not in content or response.status_code == 403, \
            "nbUnreadsPerFeed endpoint leaking tag data"

    def test_nbunreads_empty_session_blocked(self):
        """Request with cleared session should be blocked."""
        session = requests.Session()
        # Get a fresh session, then clear any cookies
        session.get(f"{BASE_URL}/", timeout=TIMEOUT)
        session.cookies.clear()
        response = session.get(
            f"{BASE_URL}/i/?c=javascript&a=nbUnreadsPerFeed",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"nbUnreadsPerFeed should block cleared sessions, got {response.status_code}"

    def test_nbunreads_with_fake_cookie_blocked(self):
        """Request with fake auth cookie should be blocked."""
        cookies = {"FreshRSS": "fakeauthcookie123"}
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=nbUnreadsPerFeed",
            cookies=cookies,
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"nbUnreadsPerFeed should block fake cookies, got {response.status_code}"

    def test_nbunreads_ajax_parameter_doesnt_bypass(self):
        """Adding ajax parameter should not bypass auth."""
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=nbUnreadsPerFeed&ajax=true",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"nbUnreadsPerFeed should not be bypassed with ajax param, got {response.status_code}"


class TestTagUpdateAccessControl:
    """
    Tests for the tag update endpoint access control.
    This endpoint returns tag details and should require authentication.
    """

    def test_tag_update_unauthenticated_returns_403(self):
        """Unauthenticated request to tag update should return 403."""
        response = requests.get(
            f"{BASE_URL}/i/?c=tag&a=update&id=1",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Tag update should return 403 for unauthenticated users, got {response.status_code}"

    def test_tag_update_id_enumeration_blocked(self):
        """Enumeration of tag IDs should be blocked for unauthenticated users."""
        # Try multiple IDs - all should return 403
        for tag_id in [1, 2, 3, 5, 10]:
            response = requests.get(
                f"{BASE_URL}/i/?c=tag&a=update&id={tag_id}",
                timeout=TIMEOUT
            )
            assert response.status_code == 403, \
                f"Tag update id={tag_id} should return 403, got {response.status_code}"

    def test_tag_update_no_tag_name_leak(self):
        """Unauthenticated request should not leak tag names."""
        response = requests.get(
            f"{BASE_URL}/i/?c=tag&a=update&id=1",
            timeout=TIMEOUT
        )
        # Even if the response is HTML, we should check for 403 first
        assert response.status_code == 403, \
            f"Tag update should block before revealing tag info, got {response.status_code}"

    def test_tag_update_ajax_mode_blocked(self):
        """Ajax mode should not bypass authentication."""
        response = requests.get(
            f"{BASE_URL}/i/?c=tag&a=update&id=1&ajax=true",
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Tag update ajax mode should be blocked, got {response.status_code}"

    def test_tag_update_with_spoofed_headers_blocked(self):
        """Spoofed headers should not bypass authentication."""
        headers = {
            "X-Requested-With": "XMLHttpRequest",
            "Accept": "application/json",
            "X-Forwarded-For": "127.0.0.1",
        }
        response = requests.get(
            f"{BASE_URL}/i/?c=tag&a=update&id=1",
            headers=headers,
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Tag update should block spoofed headers, got {response.status_code}"


class TestMultipleEndpointsConsistency:
    """Tests to ensure consistent access control across all affected endpoints."""

    def test_all_endpoints_return_403_consistently(self):
        """All affected endpoints should return 403 consistently."""
        endpoints = [
            "/i/?c=javascript&a=actualize",
            "/i/?c=javascript&a=nbUnreadsPerFeed",
            "/i/?c=tag&a=update&id=1",
            "/i/?c=tag&a=update&id=2",
        ]
        results = {}
        for endpoint in endpoints:
            response = requests.get(f"{BASE_URL}{endpoint}", timeout=TIMEOUT)
            results[endpoint] = response.status_code

        # All should be 403
        for endpoint, status in results.items():
            assert status == 403, \
                f"Endpoint {endpoint} returned {status}, expected 403"


class TestBypassAttempts:
    """Tests for various authentication bypass attempts."""

    def test_referrer_spoofing_blocked(self):
        """Test that referrer spoofing doesn't bypass auth."""
        headers = {
            "Referer": f"{BASE_URL}/i/?c=index&a=index",
        }
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            headers=headers,
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Referrer spoofing should not bypass auth, got {response.status_code}"

    def test_origin_header_spoofing_blocked(self):
        """Test that origin header spoofing doesn't bypass auth."""
        headers = {
            "Origin": BASE_URL,
        }
        response = requests.get(
            f"{BASE_URL}/i/?c=javascript&a=actualize",
            headers=headers,
            timeout=TIMEOUT
        )
        assert response.status_code == 403, \
            f"Origin spoofing should not bypass auth, got {response.status_code}"
