"""
Vulnerability tests for CVE-2025-5874: Redash Python Query Runner Sandbox Escape.

These tests verify the vulnerability EXISTS in the VULNERABLE environment
and is FIXED after applying the solution.

Test behavior:
- VULNERABLE STATE: Tests should FAIL because exploits succeed (blocked=False)
- FIXED STATE: Tests should PASS because exploits are blocked (blocked=True)

This test suite replicates the execution context from the Redash application,
reading the actual python.py file to determine which getattr implementation
to use (_getattr_ assignment).
"""
import sys
import json
import pytest
import re

# Add the app directory to the path for imports
sys.path.insert(0, '/app')

from RestrictedPython import compile_restricted
from RestrictedPython.Guards import safe_builtins, guarded_iter_unpack_sequence, guarded_unpack_sequence, safer_getattr


def get_getattr_implementation():
    """
    Determine which getattr implementation to use based on the actual
    Redash source code. This allows the tests to work correctly in both
    vulnerable and fixed environments.

    Returns native getattr if vulnerable, safer_getattr if fixed.
    """
    python_file = "/app/redash/query_runner/python.py"
    try:
        with open(python_file, 'r') as f:
            content = f.read()

        # Check if safer_getattr is used in the _getattr_ assignment
        if re.search(r'builtins\["_getattr_"\]\s*=\s*safer_getattr', content):
            return safer_getattr
        else:
            # Vulnerable: uses native getattr
            return getattr
    except Exception:
        # Default to native getattr (vulnerable) if file can't be read
        return getattr


def custom_write(obj):
    """Custom hook for RestrictedPython writes."""
    return obj


def custom_get_item(obj, key):
    """Custom hook for item access."""
    return obj[key]


def custom_get_iter(obj):
    """Custom hook for iteration."""
    return iter(obj)


def custom_import(name, globals=None, locals=None, fromlist=(), level=0):
    """Restricted import - blocks all imports for security."""
    raise Exception(f"'{name}' is not configured as a supported import module")


class CustomPrint:
    """Custom print handler for RestrictedPython."""
    def __init__(self):
        self.lines = []

    def write(self, text):
        if text and text.strip():
            self.lines.append(text)

    def __call__(self, *args):
        return self

    def _call_print(self, *objects, **kwargs):
        print(*objects, file=self)


def run_restricted_query(query):
    """
    Execute a query in a RestrictedPython environment that replicates
    the Redash Python query runner.

    This dynamically reads the actual Redash source code to determine
    which getattr implementation to use:
    - VULNERABLE: uses native getattr (exploits succeed)
    - FIXED: uses safer_getattr (exploits are blocked)

    Returns: (data, error) tuple
    """
    try:
        code = compile_restricted(query, "<string>", "exec")

        # Dynamically determine which getattr to use based on the actual source code
        getattr_impl = get_getattr_implementation()

        builtins = safe_builtins.copy()
        builtins["_write_"] = custom_write
        builtins["__import__"] = custom_import
        # Use the implementation from the actual source code
        builtins["_getattr_"] = getattr_impl
        builtins["getattr"] = getattr_impl
        builtins["_setattr_"] = setattr
        builtins["setattr"] = setattr
        builtins["_getitem_"] = custom_get_item
        builtins["_getiter_"] = custom_get_iter
        builtins["_print_"] = CustomPrint()
        builtins["_unpack_sequence_"] = guarded_unpack_sequence
        builtins["_iter_unpack_sequence_"] = guarded_iter_unpack_sequence

        # Add safe builtins
        safe_builtin_names = (
            "sorted", "reversed", "map", "any", "all", "slice",
            "filter", "len", "next", "enumerate", "sum", "abs",
            "min", "max", "round", "divmod", "str", "int", "float",
            "complex", "tuple", "set", "list", "dict", "bool",
        )
        for name in safe_builtin_names:
            builtins[name] = __builtins__[name] if isinstance(__builtins__, dict) else getattr(__builtins__, name)

        script_locals = {"result": {"rows": [], "columns": [], "log": []}}

        exec(code, {"__builtins__": builtins}, script_locals)

        result = script_locals.get("result", {"rows": [], "columns": []})
        return json.dumps(result), None

    except SyntaxError as e:
        return None, f"Syntax error in query: {e}"
    except Exception as e:
        return None, str(e)


class TestUnderscoreAttributeBlocking:
    """Tests that underscore-prefixed attributes are blocked."""

    def test_class_attribute_blocked(self):
        """
        Test that __class__ attribute access is blocked.

        This is the first step in the sandbox escape chain.
        When fixed, getattr("", "__class__") should raise AttributeError.
        """
        query = """
try:
    cls = getattr("", "__class__")
    # If we get here, vulnerability exists
    result = {"rows": [{"blocked": False, "value": str(cls)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    # This is the expected behavior after fix
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        # After fix: blocked should be True (AttributeError raised)
        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __class__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"

    def test_base_attribute_blocked(self):
        """
        Test that __base__ attribute access is blocked.

        __base__ is used to traverse up the class hierarchy to 'object'.
        """
        query = """
try:
    # Simulating the attack pattern - accessing __base__
    base = getattr(str, "__base__")
    result = {"rows": [{"blocked": False, "value": str(base)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __base__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"

    def test_subclasses_attribute_blocked(self):
        """
        Test that __subclasses__ method access is blocked.

        __subclasses__() returns all subclasses, enabling attackers to find dangerous classes.
        Uses type(str).__mro__[-1] to get object class since 'object' is not in restricted builtins.
        """
        query = """
try:
    # Get the object class through type and then try to access __subclasses__
    # First try to access __base__ on str to get to object
    base_obj = getattr(str, "__base__")
    subclasses_method = getattr(base_obj, "__subclasses__")
    result = {"rows": [{"blocked": False, "value": "method accessed"}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __subclasses__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"

    def test_dict_attribute_blocked(self):
        """
        Test that __dict__ attribute access is blocked.

        __dict__ can expose internal object state.
        """
        query = """
try:
    obj_dict = getattr(str, "__dict__")
    result = {"rows": [{"blocked": False, "value": "dict accessed"}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __dict__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"


class TestExploitChainBlocked:
    """Tests that the full exploit chain is blocked."""

    def test_full_class_traversal_blocked(self):
        """
        Test that the full class traversal exploit chain is blocked.

        The exploit chain: "" -> __class__ -> __base__ -> __subclasses__()
        This test verifies the complete chain cannot be executed.
        """
        query = """
vulnerable = False
try:
    # Step 1: Get string class
    str_class = getattr("", "__class__")
    # Step 2: Get base class (object)
    base_class = getattr(str_class, "__base__")
    # Step 3: Get all subclasses
    subclasses = getattr(base_class, "__subclasses__")()
    # If we reach here, the exploit chain succeeded
    vulnerable = True
    subclass_count = len(subclasses)
    result = {"rows": [{"vulnerable": vulnerable, "subclass_count": subclass_count}], "columns": [{"name": "vulnerable"}, {"name": "subclass_count"}]}
except AttributeError as e:
    # Expected after fix - chain is blocked
    result = {"rows": [{"vulnerable": False, "blocked_at": str(e)}], "columns": [{"name": "vulnerable"}, {"name": "blocked_at"}]}
except Exception as e:
    result = {"rows": [{"vulnerable": False, "error": str(e)}], "columns": [{"name": "vulnerable"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["vulnerable"] is False, \
            f"VULNERABILITY: Full exploit chain succeeded! Found {result['rows'][0].get('subclass_count', 'unknown')} subclasses"

    def test_chained_getattr_blocked(self):
        """
        Test that chained getattr calls are blocked at the first underscore attribute.
        """
        query = """
try:
    # Chained getattr pattern used in exploits
    result_val = getattr(getattr(getattr("", "__class__"), "__base__"), "__subclasses__")
    result = {"rows": [{"blocked": False, "type": str(type(result_val))}], "columns": [{"name": "blocked"}, {"name": "type"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: Chained getattr to internal attributes succeeded! Got: {result['rows'][0].get('type', result['rows'][0].get('error'))}"


class TestDangerousClassAccess:
    """Tests that dangerous classes cannot be discovered or instantiated."""

    def test_cannot_enumerate_subclasses(self):
        """
        Test that attackers cannot enumerate subclasses to find dangerous ones.

        Without subclass enumeration, attackers cannot find classes like subprocess.Popen.
        Uses str.__base__ to access object class since 'object' is not in restricted builtins.
        """
        query = """
dangerous_found = False
try:
    # Try to get all subclasses of object through class traversal
    # Get object class via str's __base__ attribute
    base_obj = getattr(str, "__base__")
    all_classes = getattr(base_obj, "__subclasses__")()
    # Search for dangerous classes
    for cls in all_classes:
        cls_name = str(cls)
        if "Popen" in cls_name or "subprocess" in cls_name.lower():
            dangerous_found = True
            break
    result = {"rows": [{"enumeration_blocked": False, "dangerous_found": dangerous_found}], "columns": [{"name": "enumeration_blocked"}, {"name": "dangerous_found"}]}
except AttributeError as e:
    # Expected - cannot access __base__ or __subclasses__
    result = {"rows": [{"enumeration_blocked": True, "error": str(e)}], "columns": [{"name": "enumeration_blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"enumeration_blocked": False, "error": str(e)}], "columns": [{"name": "enumeration_blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["enumeration_blocked"] is True, \
            f"VULNERABILITY: Subclass enumeration succeeded! Dangerous class found: {result['rows'][0].get('dangerous_found', 'unknown')}"

    def test_cannot_access_init_method(self):
        """
        Test that __init__ cannot be accessed to construct dangerous objects.
        """
        query = """
try:
    init_method = getattr(list, "__init__")
    result = {"rows": [{"blocked": False, "value": str(init_method)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __init__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"


class TestMROAndInheritanceBlocked:
    """Tests that MRO and inheritance inspection are blocked."""

    def test_mro_attribute_blocked(self):
        """
        Test that __mro__ (Method Resolution Order) cannot be accessed.
        """
        query = """
try:
    mro = getattr(str, "__mro__")
    result = {"rows": [{"blocked": False, "value": str(mro)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __mro__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"

    def test_bases_attribute_blocked(self):
        """
        Test that __bases__ (parent classes tuple) cannot be accessed.
        """
        query = """
try:
    bases = getattr(str, "__bases__")
    result = {"rows": [{"blocked": False, "value": str(bases)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __bases__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"


class TestCodeAndGlobalsBlocked:
    """Tests that code objects and globals cannot be accessed."""

    def test_globals_attribute_blocked(self):
        """
        Test that __globals__ cannot be accessed on functions.
        The native getattr is provided, so we can use it directly with a string argument.
        """
        query = """
try:
    # len is a builtin function - try to get its globals
    globals_dict = getattr(len, "__module__")  # Test a simpler attribute first
    result = {"rows": [{"blocked": False, "value": str(globals_dict)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        # Note: __module__ starts with underscore - should be blocked by safer_getattr
        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __module__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"

    def test_code_attribute_blocked(self):
        """
        Test that __code__ cannot be accessed on functions.
        We test using the native getattr with lambda to avoid compile-time function def issues.
        """
        query = """
# Test accessing __name__ which is a dunder attribute
try:
    name = getattr(str, "__name__")
    result = {"rows": [{"blocked": False, "value": str(name)}], "columns": [{"name": "blocked"}, {"name": "value"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        # __name__ starts with underscore - should be blocked by safer_getattr
        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: __name__ attribute access was not blocked! Got: {result['rows'][0].get('value', result['rows'][0].get('error'))}"


class TestBuiltinsAccessBlocked:
    """Tests that __builtins__ cannot be accessed."""

    def test_builtins_via_class_traversal(self):
        """
        Test that attackers cannot access dangerous builtins via class traversal.
        This is the core of the CVE - when _getattr_ is the native getattr,
        the entire class traversal chain is possible.
        """
        query = """
try:
    # Full exploit chain: get to object, enumerate subclasses
    obj = getattr(getattr("", "__class__"), "__base__")
    subclasses_method = getattr(obj, "__subclasses__")
    subclasses = subclasses_method()
    # Count how many subclasses we can access
    count = len(subclasses)
    result = {"rows": [{"blocked": False, "subclass_count": count}], "columns": [{"name": "blocked"}, {"name": "subclass_count"}]}
except AttributeError as e:
    result = {"rows": [{"blocked": True, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
except Exception as e:
    result = {"rows": [{"blocked": False, "error": str(e)}], "columns": [{"name": "blocked"}, {"name": "error"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Query execution error: {error}"
        result = json.loads(data)

        assert result["rows"][0]["blocked"] is True, \
            f"VULNERABILITY: Class traversal to __subclasses__ succeeded! Found {result['rows'][0].get('subclass_count', 'unknown')} subclasses"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
