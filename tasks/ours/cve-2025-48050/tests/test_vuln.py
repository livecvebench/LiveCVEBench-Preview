"""
Vulnerability tests for path traversal in the static file server.
These tests verify that path traversal attacks are blocked.

Expected behavior:
- FAIL in vulnerable state (path traversal succeeds, files are exposed)
- PASS in fixed state (path traversal is blocked with 403 Forbidden)
"""

import socket
import time


def exploit_path_traversal(host='localhost', port=8000, target_file='/etc/passwd'):
    """
    Attempt to exploit path traversal to read arbitrary files.
    Returns the file contents if successful (vulnerability exists), None if blocked.

    Uses raw sockets to send the request exactly as specified, bypassing
    HTTP client normalizations that might sanitize the path.
    """
    # Build traversal path - enough ../ to reach root from any location
    traversal = '/../../../../../../../..' + target_file

    # Raw HTTP request
    request = f"GET {traversal} HTTP/1.1\r\nHost: {host}:{port}\r\nConnection: close\r\n\r\n"

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        sock.sendall(request.encode())

        response = b''
        while True:
            data = sock.recv(4096)
            if not data:
                break
            response += data
        sock.close()

        response_str = response.decode('utf-8', errors='ignore')

        # Check if we got blocked (fixed server)
        if '403 Forbidden' in response_str:
            return None  # Fixed - blocked
        if '404 Not Found' in response_str:
            return None  # File not found or blocked

        # Extract body (after headers)
        if '\r\n\r\n' in response_str:
            body = response_str.split('\r\n\r\n', 1)[1]
            # Check for typical passwd content
            if 'root:' in body or ':x:' in body or '/bin' in body:
                return body

        return None
    except Exception as e:
        print(f"Error during exploit attempt: {e}")
        return None


def get_response_status(host='localhost', port=8000, path='/'):
    """
    Send HTTP request and return status code and body.
    """
    request = f"GET {path} HTTP/1.1\r\nHost: {host}:{port}\r\nConnection: close\r\n\r\n"

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        sock.sendall(request.encode())

        response = b''
        while True:
            data = sock.recv(4096)
            if not data:
                break
            response += data
        sock.close()

        response_str = response.decode('utf-8', errors='ignore')

        # Parse status code
        lines = response_str.split('\r\n')
        if lines:
            status_line = lines[0]
            parts = status_line.split(' ', 2)
            if len(parts) >= 2:
                status_code = int(parts[1])
            else:
                status_code = 0
        else:
            status_code = 0

        # Extract body
        body = ''
        if '\r\n\r\n' in response_str:
            body = response_str.split('\r\n\r\n', 1)[1]

        return status_code, body
    except Exception as e:
        return None, str(e)


def test_path_traversal_to_etc_passwd_blocked():
    """
    Path traversal attempts to read /etc/passwd should be blocked.

    In vulnerable state: Returns file contents -> FAILS
    In fixed state: Returns 403 Forbidden -> PASSES
    """
    result = exploit_path_traversal(target_file='/etc/passwd')

    assert result is None, \
        f"Path traversal vulnerability exists! Server exposed /etc/passwd contents:\n{result[:200] if result else ''}..."


def test_path_traversal_returns_403():
    """
    Path traversal requests should return 403 Forbidden status.

    In vulnerable state: Returns 200 with file contents -> FAILS
    In fixed state: Returns 403 Forbidden -> PASSES
    """
    traversal_path = '/../../../../../../../etc/passwd'
    status_code, body = get_response_status(path=traversal_path)

    assert status_code == 403, \
        f"Expected 403 Forbidden for path traversal, got status {status_code}"
    assert '403 Forbidden' in body, \
        f"Expected '403 Forbidden' in response body, got: {body[:100]}"


def test_multiple_path_traversal_variants():
    """
    Various path traversal patterns should all be blocked.
    """
    traversal_patterns = [
        '/../../../etc/passwd',
        '/../../../../../../etc/passwd',
        '/../../../../../../../etc/shadow',
        '/../../../../../../../etc/hosts',
    ]

    for pattern in traversal_patterns:
        status_code, body = get_response_status(path=pattern)

        # Should be blocked (403) or file not found (404)
        # In vulnerable state, might be 200 with content
        assert status_code in [403, 404], \
            f"Path traversal pattern '{pattern}' was not blocked! Status: {status_code}"


def test_cannot_read_system_files():
    """
    Attempts to read common system files should fail.
    """
    sensitive_files = [
        '/etc/passwd',
        '/etc/shadow',
        '/etc/hosts',
    ]

    for target in sensitive_files:
        result = exploit_path_traversal(target_file=target)
        assert result is None, \
            f"Was able to read {target} via path traversal! Content: {result[:100] if result else ''}..."


def test_deep_traversal_blocked():
    """
    Deep path traversal with many ../ sequences should be blocked.
    """
    # Use excessive number of ../ to ensure we reach root
    deep_traversal = '/' + '../' * 20 + 'etc/passwd'
    status_code, body = get_response_status(path=deep_traversal)

    # Should be blocked
    assert status_code in [403, 404], \
        f"Deep path traversal was not blocked! Status: {status_code}"

    # Verify we didn't get passwd content
    assert 'root:' not in body and ':x:' not in body, \
        f"Deep traversal exposed file contents: {body[:100]}"
