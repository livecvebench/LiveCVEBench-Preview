#!/usr/bin/env python3
"""
Template testing helper script.
This script tests template rendering using the actual Skyvern code path.
It imports and uses the same template rendering approach as the application.
"""

import sys
import os

# Add the app directory to the path to import skyvern modules
sys.path.insert(0, '/app')

def get_template_renderer():
    """
    Get the template renderer based on what's available in the Skyvern codebase.
    This dynamically imports from the actual codebase to test real behavior.
    """
    try:
        # Try to import from the actual block.py to see how it renders templates
        from skyvern.forge.sdk.workflow.models.block import Block

        # Check if the module uses SandboxedEnvironment (fixed) or Template (vulnerable)
        import skyvern.forge.sdk.workflow.models.block as block_module

        if hasattr(block_module, 'jinja_sandbox_env'):
            # Fixed version - uses SandboxedEnvironment
            return block_module.jinja_sandbox_env.from_string
        else:
            # Vulnerable version - uses Template directly
            from jinja2 import Template
            return lambda x: Template(x)
    except ImportError:
        # Fallback: Try to determine which template approach is in use
        try:
            # Read the actual source file to determine which approach is used
            block_file = '/app/skyvern/forge/sdk/workflow/models/block.py'
            with open(block_file, 'r') as f:
                content = f.read()

            if 'SandboxedEnvironment' in content and 'jinja_sandbox_env' in content:
                # Fixed version
                from jinja2.sandbox import SandboxedEnvironment
                sandbox_env = SandboxedEnvironment()
                return sandbox_env.from_string
            else:
                # Vulnerable version
                from jinja2 import Template
                return lambda x: Template(x)
        except Exception:
            # Ultimate fallback - check import in current environment
            from jinja2 import Template
            return lambda x: Template(x)


def render_template(template_string, context=None):
    """Render a template string with the given context."""
    if context is None:
        context = {}

    try:
        renderer = get_template_renderer()
        template = renderer(template_string)
        result = template.render(context)
        return result
    except Exception as e:
        return f"SecurityError: {type(e).__name__}: {str(e)}"


# Test cases for functionality tests
FUNC_TESTS = {
    'basic_var': ('Hello {{ name }}', {'name': 'World'}),
    'numeric': ('{{ 1 + 1 }}', {}),
    'string_concat': ('{{ a ~ b }}', {'a': 'Hello', 'b': 'World'}),
    'conditional': ('{{ "yes" if flag else "no" }}', {'flag': True}),
    'list_access': ('{{ items[1] }}', {'items': ['first', 'second', 'third']}),
    'dict_access': ('{{ data.key1 }}', {'data': {'key1': 'value1', 'key2': 'value2'}}),
    'loop': ('{% for item in items %}{{ item }}{% endfor %}', {'items': ['a', 'b', 'c']}),
    'nested_dict': ('{{ block_1.output }}', {'block_1': {'output': 'output_value'}}),
    'multi_var': ('Name: {{ name }}, Age: {{ age }}', {'name': 'John', 'age': 30}),
    'filter': ('{{ name | upper }}', {'name': 'hello'}),
    'default_filter': ('{{ missing | default("default_value") }}', {}),
    'empty': ('', {}),
    'plain_text': ('This is plain text with no templates', {}),
}

# Test cases for vulnerability tests (SSTI payloads)
VULN_TESTS = {
    # Class hierarchy access
    'ssti_class': ('{{ ().__class__ }}', {}),
    'ssti_base': ('{{ ().__class__.__base__ }}', {}),
    'ssti_subclasses': ('{{ ().__class__.__base__.__subclasses__() }}', {}),
    'ssti_mro': ('{{ "".__class__.__mro__ }}', {}),

    # Builtins access
    'ssti_builtins': ('{{ "".__class__.__mro__[1].__subclasses__()[0].__init__.__globals__["__builtins__"] }}', {}),
    'ssti_globals': ('{{ "".__class__.__init__.__globals__ }}', {}),

    # Code execution attempts
    'ssti_rce_warning': (
        '{% for x in ().__class__.__base__.__subclasses__() %}'
        '{% if "warning" in x.__name__ %}'
        '{{ x()._module.__builtins__["__import__"]("os").popen("id").read() }}'
        '{% endif %}{% endfor %}',
        {}
    ),
    'ssti_os_import': (
        '{% for x in ().__class__.__base__.__subclasses__() %}'
        '{% if "warning" in x.__name__ %}'
        '{{ x()._module.__builtins__["__import__"]("os") }}'
        '{% endif %}{% endfor %}',
        {}
    ),
    'ssti_subprocess': (
        '{% for x in ().__class__.__base__.__subclasses__() %}'
        '{% if "Popen" in x.__name__ %}'
        '{{ x(["id"],stdout=-1).communicate() }}'
        '{% endif %}{% endfor %}',
        {}
    ),
    'ssti_file_read': (
        '{% for x in ().__class__.__base__.__subclasses__() %}'
        '{% if "warning" in x.__name__ %}'
        '{{ x()._module.__builtins__["open"]("/etc/passwd").read() }}'
        '{% endif %}{% endfor %}',
        {}
    ),

    # Encoded/bypass payloads
    'ssti_attr_bypass': ('{{ ()|attr("__class__")|attr("__base__") }}', {}),
    'ssti_getitem': ('{{ ()["__class__"] }}', {}),
    'ssti_format': ('{{ "%s"|format(().__class__.__base__) }}', {}),

    # Multi-step exploits
    'ssti_config': ('{{ config }}', {}),
    'ssti_lipsum': ('{{ lipsum.__globals__ }}', {}),
    'ssti_cycler': ('{{ cycler.__init__.__globals__ }}', {}),
    'ssti_joiner': ('{{ joiner.__init__.__globals__ }}', {}),
}


def main():
    if len(sys.argv) < 2:
        print("Usage: template_helper.py <test_name>")
        print(f"Available func tests: {list(FUNC_TESTS.keys())}")
        print(f"Available vuln tests: {list(VULN_TESTS.keys())}")
        sys.exit(1)

    test_name = sys.argv[1]

    # Look up the test
    if test_name in FUNC_TESTS:
        template_str, context = FUNC_TESTS[test_name]
    elif test_name in VULN_TESTS:
        template_str, context = VULN_TESTS[test_name]
    else:
        print(f"Unknown test: {test_name}")
        sys.exit(1)

    # Handle empty template case
    if template_str == '':
        print("empty")
        sys.exit(0)

    result = render_template(template_str, context)
    print(result)


if __name__ == '__main__':
    main()
