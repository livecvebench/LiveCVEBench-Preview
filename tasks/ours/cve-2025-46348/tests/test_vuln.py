"""
Vulnerability tests for YesWiki archive API access control issue.

These tests verify that the authentication bypass vulnerability is fixed.
In the vulnerable state, unauthenticated users can access archive endpoints.
After the fix, these endpoints should require admin authentication.

Test behavior:
- FAIL in vulnerable state (endpoints accessible without auth)
- PASS in fixed state (endpoints require authentication)
"""
import pytest
import requests
import time
import os

BASE_URL = os.environ.get("TARGET_URL", "http://localhost")
TIMEOUT = 30

# Response codes that indicate authentication is required
AUTH_REQUIRED_CODES = [401, 403, 302, 303]


def wait_for_app():
    """Wait for the application to be ready."""
    max_retries = 15
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/", timeout=TIMEOUT)
            if response.status_code in [200, 301, 302, 303]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


class TestArchiveListingAccessControl:
    """Test that archive listing endpoints require authentication."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure application is ready before tests."""
        assert wait_for_app(), "Application did not become ready"

    def test_archive_list_requires_auth(self):
        """
        GET /api/archives should require admin authentication.

        Vulnerable behavior: Returns 200 with list of archives
        Fixed behavior: Returns 401/403 or redirects to login
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive listing accessible without auth! Status: {response.status_code}. " \
            f"Expected authentication requirement (401/403/302)"

    def test_archive_list_with_trailing_slash_requires_auth(self):
        """
        GET /api/archives/ should also require authentication.

        Tests the alternate route pattern with trailing slash.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives/",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive listing (trailing slash) accessible without auth! Status: {response.status_code}"

    def test_archive_list_no_json_data_leak(self):
        """
        Verify that archive data is not leaked in response body.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        # If somehow 200 is returned, body should not contain archive data
        if response.status_code == 200:
            pytest.fail(
                f"Archive listing returned 200! Response: {response.text[:500]}"
            )


class TestArchiveStatusAccessControl:
    """Test that archive status endpoints require authentication."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure application is ready before tests."""
        assert wait_for_app(), "Application did not become ready"

    def test_archiving_status_requires_auth(self):
        """
        GET /api/archives/archivingStatus/ should require authentication.

        This endpoint reveals whether archiving is in progress.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives/archivingStatus/",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archiving status accessible without auth! Status: {response.status_code}"

    def test_forced_update_token_requires_auth(self):
        """
        GET /api/archives/forcedUpdateToken/ should require authentication.

        This endpoint returns sensitive token information.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives/forcedUpdateToken/",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Forced update token accessible without auth! Status: {response.status_code}"

    def test_archive_uid_status_requires_auth(self):
        """
        GET /api/archives/uidstatus/{uid} should require authentication.

        Even with a fake UID, should require auth first.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives/uidstatus/fake-uid-12345",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive UID status accessible without auth! Status: {response.status_code}"


class TestArchiveCreationAccessControl:
    """Test that archive creation requires authentication."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure application is ready before tests."""
        assert wait_for_app(), "Application did not become ready"

    def test_archive_creation_requires_auth(self):
        """
        POST /api/archives should require admin authentication.

        Vulnerable behavior: Creates backup and returns UID
        Fixed behavior: Returns 401/403 or redirects to login
        """
        data = {
            "action": "startArchive",
            "params[savefiles]": "true",
            "params[savedatabase]": "true",
            "callAsync": "false"
        }
        response = requests.post(
            f"{BASE_URL}/?api/archives",
            data=data,
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive creation accessible without auth! Status: {response.status_code}. " \
            f"Response: {response.text[:300]}"

    def test_archive_creation_with_different_params(self):
        """
        POST /api/archives with various parameters should all require auth.
        """
        # Try with minimal params
        data = {"action": "startArchive"}
        response = requests.post(
            f"{BASE_URL}/?api/archives",
            data=data,
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive creation (minimal params) accessible without auth! Status: {response.status_code}"

    def test_archive_creation_json_payload(self):
        """
        POST /api/archives with JSON payload should also require auth.
        """
        response = requests.post(
            f"{BASE_URL}/?api/archives",
            json={"action": "startArchive"},
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive creation (JSON) accessible without auth! Status: {response.status_code}"

    def test_archive_action_with_id_requires_auth(self):
        """
        POST /api/archives/{id} should require authentication.
        """
        response = requests.post(
            f"{BASE_URL}/?api/archives/test-archive-id",
            data={"action": "delete"},
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive action with ID accessible without auth! Status: {response.status_code}"


class TestArchiveDownloadAccessControl:
    """Test that archive download requires authentication."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure application is ready before tests."""
        assert wait_for_app(), "Application did not become ready"

    def test_archive_download_requires_auth(self):
        """
        GET /api/archives/{id} should require authentication.

        Even with a non-existent archive name, should require auth first.
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives/2025-01-01T00-00-00_archive.zip",
            timeout=TIMEOUT,
            allow_redirects=False
        )
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive download accessible without auth! Status: {response.status_code}"

    def test_archive_download_with_valid_id_requires_auth(self):
        """
        Verify archive download with a properly formatted archive ID requires auth.

        The endpoint should require authentication (401/403/302).
        This tests that even with a valid-looking archive ID pattern,
        authentication is still required.
        """
        # Use a valid-looking archive ID pattern (no path traversal)
        valid_archive_ids = [
            "test_archive",
            "backup_2025",
            "archive123",
        ]
        for archive_id in valid_archive_ids:
            response = requests.get(
                f"{BASE_URL}/?api/archives/{archive_id}",
                timeout=TIMEOUT,
                allow_redirects=False
            )
            # Should require authentication - NOT accept 404 as that would mean
            # the route is accessible but the archive doesn't exist
            assert response.status_code in AUTH_REQUIRED_CODES, \
                f"Archive download ({archive_id}) accessible without auth! Status: {response.status_code}. " \
                f"Expected authentication requirement (401/403/302)"

    def test_archive_download_various_extensions(self):
        """
        GET /api/archives/{id} with various extensions should require auth.
        """
        test_ids = [
            "backup.zip",
            "archive.tar.gz",
            "2025-01-01T12-30-45_archive.zip",
            "test_archive",
        ]
        for archive_id in test_ids:
            response = requests.get(
                f"{BASE_URL}/?api/archives/{archive_id}",
                timeout=TIMEOUT,
                allow_redirects=False
            )
            assert response.status_code in AUTH_REQUIRED_CODES, \
                f"Archive download ({archive_id}) accessible without auth! Status: {response.status_code}"


class TestMultipleEndpointsCombined:
    """Test multiple endpoints in combination to ensure comprehensive coverage."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure application is ready before tests."""
        assert wait_for_app(), "Application did not become ready"

    def test_all_archive_get_endpoints_require_auth(self):
        """
        All GET archive endpoints should require authentication.
        """
        endpoints = [
            "/?api/archives",
            "/?api/archives/",
            "/?api/archives/archivingStatus/",
            "/?api/archives/forcedUpdateToken/",
            "/?api/archives/uidstatus/test-uid",
            "/?api/archives/some-archive.zip",
        ]

        failed_endpoints = []
        for endpoint in endpoints:
            response = requests.get(
                f"{BASE_URL}{endpoint}",
                timeout=TIMEOUT,
                allow_redirects=False
            )
            if response.status_code not in AUTH_REQUIRED_CODES:
                failed_endpoints.append(
                    f"{endpoint} (status: {response.status_code})"
                )

        assert not failed_endpoints, \
            f"The following endpoints are accessible without auth: {failed_endpoints}"

    def test_all_archive_post_endpoints_require_auth(self):
        """
        All POST archive endpoints should require authentication.
        """
        endpoints_and_data = [
            ("/?api/archives", {"action": "startArchive"}),
            ("/?api/archives", {"action": "status"}),
            ("/?api/archives/test-id", {"action": "delete"}),
        ]

        failed_endpoints = []
        for endpoint, data in endpoints_and_data:
            response = requests.post(
                f"{BASE_URL}{endpoint}",
                data=data,
                timeout=TIMEOUT,
                allow_redirects=False
            )
            if response.status_code not in AUTH_REQUIRED_CODES:
                failed_endpoints.append(
                    f"{endpoint} (status: {response.status_code})"
                )

        assert not failed_endpoints, \
            f"The following POST endpoints are accessible without auth: {failed_endpoints}"

    def test_no_information_leak_on_auth_failure(self):
        """
        Authentication failures should not leak sensitive information.

        This test verifies that:
        1. The archive endpoint requires authentication (vulnerability is fixed)
        2. If auth is required, error responses don't leak sensitive info
        """
        response = requests.get(
            f"{BASE_URL}/?api/archives",
            timeout=TIMEOUT,
            allow_redirects=False
        )

        # First, endpoint MUST require authentication
        assert response.status_code in AUTH_REQUIRED_CODES, \
            f"Archive endpoint accessible without auth! Status: {response.status_code}. " \
            f"Expected authentication requirement (401/403/302)"

        # If we get here, auth is required - verify no sensitive info leaked
        sensitive_patterns = [
            "filename",
            ".zip",
            "archive_",
            "backup",
            "database",
        ]
        for pattern in sensitive_patterns:
            if pattern in response.text.lower():
                # Only fail if it looks like actual archive data
                if '"filename"' in response.text or '".zip"' in response.text:
                    pytest.fail(
                        f"Sensitive information leaked in auth error response: {pattern}"
                    )
