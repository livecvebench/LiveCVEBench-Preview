
import { Action } from '/app/src/proxy/actions/Action';
// Try to import the processor. If it doesn't exist, we can't test it (and it's vulnerable if we expect it to exist for security)
let checkHiddenCommits;
try {
    checkHiddenCommits = require('/app/src/proxy/processors/push-action/checkHiddenCommits');
} catch (e) {
    console.log("MODULE_NOT_FOUND");
    process.exit(0);
}

const { exec } = checkHiddenCommits;
const cp = require('child_process');

// Mock child_process to simulate the vulnerability check
// We want to simulate a scenario where verify-pack returns a commit that is NOT in rev-list
// This represents a "hidden commit" introduced via a packfile
const originalSpawnSync = cp.spawnSync;

cp.spawnSync = (cmd, args, options) => {
    const cmdStr = args.join(' ');
    
    // Simulate git rev-list (commits introduced by this push)
    // Return a single valid commit
    if (cmdStr.includes('rev-list')) {
        return { 
            stdout: 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\n'
        };
    }
    
    // Simulate git verify-pack (commits actually in the packfile)
    // Return the valid commit PLUS a hidden one
    if (cmdStr.includes('verify-pack')) {
        return { 
            stdout: 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0 commit\nh1d2d3n4c5o6m7m8i9t0h1e2r3e4f5o6r7e8v9e0 commit\n'
        };
    }

    return { stdout: '' };
};

async function runTest() {
    // Action constructor signature in v1.19.1: constructor(id, type, method, timestamp, repo)
    const action = new Action('test-id', 'push', 'POST', new Date().toISOString(), 'test-org/test-repo');
    action.commitFrom = 'base_commit_hash';
    action.commitTo = 'a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0';
    action.newIdxFiles = ['pack-test.idx'];
    
    try {
        const result = await exec({}, action);
        
        // If we get here without error, the check failed to detect the hidden commit
        if (!result.error) {
            console.log("VULNERABLE: Hidden commit was not detected");
            process.exit(1);
        } else {
            console.log("DEBUG: lastStep = " + JSON.stringify(result.lastStep, null, 2));
            
            // The actual error message is in 'errorMessage' or 'content'
            const lastStep = result.lastStep || {};
            const errorMsg = String(lastStep.errorMessage || "");
            const contentMsg = String(lastStep.content || "");
            const logs = Array.isArray(lastStep.logs) ? lastStep.logs.join("\n") : "";
            
            if (errorMsg.includes('Unreferenced commits') || 
                contentMsg.includes('Unreferenced commits') ||
                logs.includes('Unreferenced commits')) {
                console.log("FIXED: Hidden commit detected");
                process.exit(0);
            } else {
                console.log("UNKNOWN_ERROR_CONTENT: Expected 'Unreferenced commits' not found in result");
                process.exit(1);
            }
        }
    } catch (error) {
        // If the function throws, check if it's the expected error (though usually it sets action.error)
        console.log("EXCEPTION: " + error.message);
        process.exit(1);
    }
}

runTest();
