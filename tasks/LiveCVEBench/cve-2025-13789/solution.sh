#!/bin/bash
# Solution script for ZenTao PMS SSRF vulnerability (CVE-2025-13789)
# This script removes the vulnerable modelTestConnection function from module/ai/control.php

set -e

echo "[*] Applying fix for SSRF vulnerability in ZenTao PMS..."

# ZenTao installation paths (check both common locations)
ZENTAO_PATHS=(
    "/opt/zbox/app/zentao"
    "/var/www/html/zentao"
    "/var/www/zentao"
    "/app"
)

CONTROL_FILE=""
for path in "${ZENTAO_PATHS[@]}"; do
    if [ -f "$path/module/ai/control.php" ]; then
        CONTROL_FILE="$path/module/ai/control.php"
        break
    fi
done

if [ -z "$CONTROL_FILE" ]; then
    echo "[-] Could not find ZenTao installation"
    echo "[-] Searched paths: ${ZENTAO_PATHS[*]}"

    # Try to find it
    FOUND_FILE=$(find / -name "control.php" -path "*/module/ai/*" 2>/dev/null | head -1)
    if [ -n "$FOUND_FILE" ]; then
        CONTROL_FILE="$FOUND_FILE"
        echo "[+] Found control.php at: $CONTROL_FILE"
    else
        echo "[-] Could not locate module/ai/control.php"
        exit 1
    fi
fi

echo "[+] Found control.php at: $CONTROL_FILE"

# Create backup
cp "$CONTROL_FILE" "$CONTROL_FILE.bak"
echo "[+] Created backup: $CONTROL_FILE.bak"

# Use Python to reliably remove the function
# This is more robust than sed for PHP code with nested braces
python3 << 'PYTHON_SCRIPT'
import re
import sys

control_files = [
    "/opt/zbox/app/zentao/module/ai/control.php",
    "/var/www/html/zentao/module/ai/control.php",
    "/var/www/zentao/module/ai/control.php",
    "/app/module/ai/control.php",
]

control_file = None
for path in control_files:
    try:
        with open(path, 'r') as f:
            content = f.read()
            control_file = path
            break
    except FileNotFoundError:
        continue

if control_file is None:
    # Try to find via glob
    import glob
    found = glob.glob('/*/module/ai/control.php') + glob.glob('/*/*/module/ai/control.php') + glob.glob('/*/*/*/module/ai/control.php')
    if found:
        control_file = found[0]
        with open(control_file, 'r') as f:
            content = f.read()
    else:
        print("[-] Could not find control.php")
        sys.exit(1)

print(f"[*] Processing: {control_file}")

# Check if function exists
if 'modelTestConnection' not in content:
    print("[*] modelTestConnection function not found - may already be fixed")
    sys.exit(0)

# Pattern to match the entire modelTestConnection function including its docblock
# The function structure is:
# /**
#  * Model test connection.
#  * ...
#  */
# public function modelTestConnection($modelID = 0)
# {
#     ... (function body with nested braces)
# }

# First, try to match with docblock
pattern_with_docblock = r'/\*\*\s*\n\s*\*\s*Model test connection\..*?public function modelTestConnection\s*\([^)]*\)\s*\{'

match = re.search(pattern_with_docblock, content, re.DOTALL)

if match:
    # Find the function start
    func_start = match.start()
    # Now find the matching closing brace
    brace_pos = match.end() - 1  # Position of opening brace
    brace_count = 1
    pos = brace_pos + 1

    while pos < len(content) and brace_count > 0:
        if content[pos] == '{':
            brace_count += 1
        elif content[pos] == '}':
            brace_count -= 1
        pos += 1

    func_end = pos

    # Remove the function (and any trailing whitespace/newlines)
    while func_end < len(content) and content[func_end] in '\n\r\t ':
        func_end += 1

    new_content = content[:func_start] + content[func_end:]

    with open(control_file, 'w') as f:
        f.write(new_content)

    print("[+] Successfully removed modelTestConnection function with docblock")
else:
    # Try pattern without docblock
    pattern_no_docblock = r'public function modelTestConnection\s*\([^)]*\)\s*\{'

    match = re.search(pattern_no_docblock, content)

    if match:
        # Find function boundaries
        func_start = match.start()
        brace_pos = match.end() - 1
        brace_count = 1
        pos = brace_pos + 1

        while pos < len(content) and brace_count > 0:
            if content[pos] == '{':
                brace_count += 1
            elif content[pos] == '}':
                brace_count -= 1
            pos += 1

        func_end = pos

        # Skip trailing whitespace
        while func_end < len(content) and content[func_end] in '\n\r\t ':
            func_end += 1

        new_content = content[:func_start] + content[func_end:]

        with open(control_file, 'w') as f:
            f.write(new_content)

        print("[+] Successfully removed modelTestConnection function")
    else:
        print("[-] Could not find modelTestConnection function pattern")
        sys.exit(1)

# Verify the fix
with open(control_file, 'r') as f:
    new_content = f.read()

if 'modelTestConnection' in new_content:
    print("[-] Warning: modelTestConnection may still exist in file")
else:
    print("[+] Verification passed: modelTestConnection function removed")

# Syntax check
import subprocess
result = subprocess.run(['php', '-l', control_file], capture_output=True, text=True)
if result.returncode == 0:
    print("[+] PHP syntax check passed")
else:
    print(f"[-] PHP syntax error: {result.stderr}")
    # Restore backup
    import shutil
    shutil.copy(f"{control_file}.bak", control_file)
    print("[!] Restored backup due to syntax error")
    sys.exit(1)

PYTHON_SCRIPT

PYTHON_EXIT=$?

if [ $PYTHON_EXIT -ne 0 ]; then
    echo "[-] Python fix script failed, trying sed fallback..."

    # Restore from backup
    cp "$CONTROL_FILE.bak" "$CONTROL_FILE"

    # Alternative: Use sed (less reliable but may work for some cases)
    # This tries to remove lines between the function declaration and next public function
    sed -i.sed '/public function modelTestConnection/,/^    public function/{/^    public function/!d}' "$CONTROL_FILE" 2>/dev/null || true

    # Verify
    if grep -q "modelTestConnection" "$CONTROL_FILE"; then
        echo "[-] Sed fallback also failed"
        cp "$CONTROL_FILE.bak" "$CONTROL_FILE"
        exit 1
    fi
fi

# Restart any running PHP-FPM or Apache processes to load the fixed code
echo "[*] Attempting to restart web services..."

# Try common restart methods
if command -v apachectl &> /dev/null; then
    apachectl restart 2>/dev/null || true
fi

if command -v apache2ctl &> /dev/null; then
    apache2ctl restart 2>/dev/null || true
fi

if command -v service &> /dev/null; then
    service apache2 restart 2>/dev/null || true
    service httpd restart 2>/dev/null || true
    service php-fpm restart 2>/dev/null || true
fi

if command -v systemctl &> /dev/null; then
    systemctl restart apache2 2>/dev/null || true
    systemctl restart httpd 2>/dev/null || true
    systemctl restart php-fpm 2>/dev/null || true
fi

# For zbox installations
if [ -f "/opt/zbox/zbox" ]; then
    /opt/zbox/zbox restart apache 2>/dev/null || true
fi

# Kill any PHP processes directly (will be restarted by web server)
pkill -f "php-fpm" 2>/dev/null || true

echo "[+] Fix applied successfully!"
echo "[+] The vulnerable modelTestConnection function has been removed from $CONTROL_FILE"
