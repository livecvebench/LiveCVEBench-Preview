#!/usr/bin/env python3
"""
Functional tests for School Management System.

These tests verify that the application works correctly for authenticated users.
All tests should PASS in both vulnerable and fixed states.
"""

import pytest
import requests
import time
import os

BASE_URL = os.environ.get("APP_URL", "http://localhost")


class TestApplicationHealth:
    """Test that the application is running and accessible."""

    def test_application_is_running(self):
        """Verify the application is accessible."""
        max_retries = 10
        for i in range(max_retries):
            try:
                response = requests.get(f"{BASE_URL}/", timeout=10)
                assert response.status_code in [200, 302, 301], \
                    f"Application not accessible, status: {response.status_code}"
                return
            except requests.exceptions.RequestException:
                if i < max_retries - 1:
                    time.sleep(2)
                    continue
                raise

    def test_login_page_accessible(self):
        """Verify login page is accessible."""
        response = requests.get(f"{BASE_URL}/", timeout=10, allow_redirects=True)
        assert response.status_code == 200


class TestAuthenticationFlow:
    """Test authentication mechanisms."""

    def test_login_with_valid_credentials(self):
        """Verify login works with valid admin credentials."""
        session = requests.Session()

        # Attempt login with admin credentials
        response = session.post(
            f"{BASE_URL}/login-backend.php",
            data={
                "email": "admin@gmail.com",
                "password": "123"
            },
            timeout=10,
            allow_redirects=False
        )

        # Login should redirect (302) or return success indicator
        # Check that we got a session cookie
        assert "PHPSESSID" in session.cookies or response.status_code in [200, 302], \
            "Login did not establish session"

    def test_login_with_invalid_credentials(self):
        """Verify login fails with invalid credentials."""
        session = requests.Session()

        response = session.post(
            f"{BASE_URL}/login-backend.php",
            data={
                "email": "invalid@example.com",
                "password": "wrongpassword"
            },
            timeout=10,
            allow_redirects=True
        )

        # With invalid credentials, should not get admin access
        # The response should indicate failure or redirect to login
        assert response.status_code in [200, 302, 401], \
            f"Unexpected status code: {response.status_code}"


class TestAuthenticatedOperations:
    """Test that authenticated users can perform operations."""

    @pytest.fixture
    def authenticated_session(self):
        """Create an authenticated session."""
        session = requests.Session()

        # Login as admin
        response = session.post(
            f"{BASE_URL}/login-backend.php",
            data={
                "email": "admin@gmail.com",
                "password": "123"
            },
            timeout=10,
            allow_redirects=True
        )

        return session

    def test_authenticated_edit_subject(self, authenticated_session):
        """Verify authenticated user can edit subjects."""
        # Use the test subject ID that exists in database
        response = authenticated_session.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "Mathematics",
                "subject_id": "12c6672ac911a253"  # Hindi -> Mathematics
            },
            timeout=10
        )

        # Response should be "success" or contain appropriate message
        # For authenticated users, the operation should work
        assert response.status_code in [200, 401], \
            f"Unexpected status: {response.status_code}"

        # If we get 401, it means auth is now required (fixed state)
        # If we get 200 with "success", the operation worked
        if response.status_code == 200:
            # Either "success" or "Unable to edit" (if ID doesn't exist exactly)
            assert any(x in response.text for x in ["success", "Unable to edit", "Unauthorized"]), \
                f"Unexpected response: {response.text}"

    def test_authenticated_add_subject(self, authenticated_session):
        """Verify authenticated user can add subjects."""
        import random
        unique_subject = f"TestSubject_{random.randint(10000, 99999)}"

        response = authenticated_session.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": unique_subject,
                "class": "10"
            },
            timeout=10
        )

        assert response.status_code in [200, 401], \
            f"Unexpected status: {response.status_code}"

        if response.status_code == 200:
            assert any(x in response.text for x in ["success", "already exists", "Unauthorized"]), \
                f"Unexpected response: {response.text}"


class TestDatabaseOperations:
    """Test that database operations work correctly."""

    def test_subjects_endpoint_responds(self):
        """Verify the subjects endpoint is functional."""
        session = requests.Session()

        # Login first
        session.post(
            f"{BASE_URL}/login-backend.php",
            data={
                "email": "admin@gmail.com",
                "password": "123"
            },
            timeout=10
        )

        # Try to access subjects-related page
        response = session.get(
            f"{BASE_URL}/admin_panel/subjects.php",
            timeout=10,
            allow_redirects=True
        )

        # Should get a response (may redirect to login if session not working)
        assert response.status_code in [200, 302], \
            f"Subjects page not accessible: {response.status_code}"


class TestEndpointResponses:
    """Test that endpoints respond with expected formats."""

    def test_edit_subject_returns_expected_format(self):
        """Verify editSubject.php returns expected response format."""
        # Without auth, should get either the response or 401
        response = requests.post(
            f"{BASE_URL}/assets/editSubject.php",
            data={
                "subject": "Test",
                "subject_id": "nonexistent_id"
            },
            timeout=10
        )

        # Should get either:
        # - 401 Unauthorized (fixed)
        # - 200 with "Unable to edit" (vulnerable, ID not found)
        # - 200 with "success" (vulnerable, ID found)
        assert response.status_code in [200, 401], \
            f"Unexpected status: {response.status_code}"

    def test_add_subject_returns_expected_format(self):
        """Verify addSubject.php returns expected response format."""
        response = requests.post(
            f"{BASE_URL}/assets/addSubject.php",
            json={
                "subject": "TestSubject",
                "class": "99"
            },
            timeout=10
        )

        assert response.status_code in [200, 401], \
            f"Unexpected status: {response.status_code}"

    def test_invalid_request_method(self):
        """Verify GET request is rejected appropriately."""
        response = requests.get(
            f"{BASE_URL}/assets/editSubject.php",
            timeout=10
        )

        # GET should return "Invalid request!" or 401
        assert response.status_code in [200, 401], \
            f"Unexpected status: {response.status_code}"

        if response.status_code == 200:
            assert "Invalid request" in response.text or "Unauthorized" in response.text
