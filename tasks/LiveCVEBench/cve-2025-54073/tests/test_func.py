"""
Functional tests for the MCP Package Docs Server.

These tests verify that the application works correctly for legitimate use cases.
They should PASS in both vulnerable and fixed states.
"""

import subprocess
import json
import time
import os
import signal
import pytest

# The MCP server communicates via JSON-RPC over stdio
# We need to send properly formatted JSON-RPC requests

def send_mcp_request(server_process, method, params):
    """Send a JSON-RPC request to the MCP server and get response."""
    request = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": method,
        "params": params
    }
    request_str = json.dumps(request) + "\n"

    try:
        server_process.stdin.write(request_str)
        server_process.stdin.flush()

        # Read response (with timeout protection)
        response_line = server_process.stdout.readline()
        if response_line:
            return json.loads(response_line)
    except Exception as e:
        return {"error": str(e)}

    return None


class TestBasicFunctionality:
    """Test basic functionality of the package docs server."""

    def test_server_starts_successfully(self):
        """Test that the server process can start without immediate errors."""
        # Start the server process
        proc = subprocess.Popen(
            ["node", "/app/build/index.js"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd="/app"
        )

        # Give it a moment to start
        time.sleep(1)

        # Check if process is still running (poll returns None if running)
        is_running = proc.poll() is None

        # Cleanup
        proc.terminate()
        try:
            proc.wait(timeout=3)
        except subprocess.TimeoutExpired:
            proc.kill()

        assert is_running, "Server should start and stay running"

    def test_server_responds_to_list_tools(self):
        """Test that the server responds to the list_tools request."""
        proc = subprocess.Popen(
            ["node", "/app/build/index.js"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd="/app"
        )

        time.sleep(1)

        # Send initialize request first (required by MCP protocol)
        init_request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": "2024-11-05",
                "capabilities": {},
                "clientInfo": {"name": "test", "version": "1.0"}
            }
        }

        try:
            proc.stdin.write(json.dumps(init_request) + "\n")
            proc.stdin.flush()

            # Read the response
            response = proc.stdout.readline()

            # The server should respond with some data
            assert response, "Server should respond to initialize request"

            resp_data = json.loads(response)
            assert "result" in resp_data or "error" in resp_data, \
                "Response should contain result or error"
        finally:
            proc.terminate()
            try:
                proc.wait(timeout=3)
            except subprocess.TimeoutExpired:
                proc.kill()

    def test_valid_go_package_name_format(self):
        """Test that valid Go package names are accepted."""
        # This tests that the server can handle valid package names
        # without errors in the processing logic

        valid_names = [
            "fmt",
            "encoding/json",
            "net/http",
            "github.com/user/repo",
            "golang.org/x/tools"
        ]

        for name in valid_names:
            # Check that the name passes basic validation
            # (only contains valid characters)
            import re
            pattern = r'^[a-zA-Z0-9.\-_/]+$'
            assert re.match(pattern, name), \
                f"Valid package name '{name}' should match validation pattern"

    def test_valid_python_package_name_format(self):
        """Test that valid Python package names are accepted."""
        valid_names = [
            "requests",
            "numpy",
            "flask",
            "scikit-learn",
            "python_dateutil"
        ]

        for name in valid_names:
            # Check that the name passes basic validation
            import re
            pattern = r'^[a-zA-Z0-9.\-_/]+$'
            assert re.match(pattern, name), \
                f"Valid package name '{name}' should match validation pattern"


class TestInputValidation:
    """Test input validation for package names."""

    def test_sanitization_removes_special_chars(self):
        """Test that special characters would be removed by proper sanitization."""
        # These are the characters that should be filtered out
        dangerous_chars = [';', '|', '&', '$', '`', '(', ')', '{', '}',
                         '<', '>', '!', '*', '?', '[', ']', '"', "'", '\\']

        for char in dangerous_chars:
            test_name = f"package{char}name"
            # After proper sanitization, only alphanumeric, dots, hyphens,
            # underscores, and forward slashes should remain
            import re
            sanitized = re.sub(r'[^a-zA-Z0-9.\-_/]', '', test_name)
            assert sanitized == "packagename", \
                f"Character '{char}' should be removed from package name"

    def test_valid_chars_preserved(self):
        """Test that valid characters are preserved during sanitization."""
        valid_name = "github.com/user/my-package_v2"
        import re
        sanitized = re.sub(r'[^a-zA-Z0-9.\-_/]', '', valid_name)
        assert sanitized == valid_name, \
            "Valid characters should be preserved during sanitization"


class TestBuildArtifacts:
    """Test that build artifacts exist and are valid."""

    def test_build_directory_exists(self):
        """Test that the build directory exists."""
        assert os.path.exists("/app/build"), "Build directory should exist"

    def test_main_entry_point_exists(self):
        """Test that the main entry point exists."""
        assert os.path.exists("/app/build/index.js"), \
            "Main entry point (build/index.js) should exist"

    def test_package_docs_server_built(self):
        """Test that the package docs server module is built."""
        assert os.path.exists("/app/build/package-docs-server.js"), \
            "Package docs server module should be built"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
