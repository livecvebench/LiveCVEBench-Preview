"""
Vulnerability tests for tcprewrite CVE-2025-9157.
These tests verify the use-after-free vulnerability status:
- FAIL in vulnerable state (crashes when processing truncated packets with --fixlen pad)
- PASS in fixed state (handles truncated packets without crashing)
"""

import subprocess
import os
import tempfile
import struct
import signal


# Path to the PoC pcap file provided in task-deps
POC_PCAP_PATH = '/tests/poc.pcap'


def create_truncated_packet_pcap(filepath, orig_len=167, cap_len=93):
    """
    Create a pcap file with a truncated packet where len > caplen.
    This triggers the vulnerable code path in untrunc_packet().

    Args:
        filepath: Output file path
        orig_len: Original packet length (will be set in pcap header)
        cap_len: Captured length (actual data we provide, less than orig_len)
    """
    # pcap global header (24 bytes)
    global_header = struct.pack('<IHHiIII',
        0xa1b2c3d4,  # magic number (little-endian)
        2,           # version major
        4,           # version minor
        0,           # thiszone (GMT)
        0,           # sigfigs
        65535,       # snaplen
        1            # network (LINKTYPE_ETHERNET)
    )

    # Create Ethernet + IPv4 packet data (only cap_len bytes)
    # Ethernet header (14 bytes)
    eth_header = bytes([
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55,  # dst MAC
        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,  # src MAC
        0x08, 0x00                            # EtherType (IPv4)
    ])

    # IPv4 header (20 bytes)
    # Total length field is 2 bytes, big-endian
    ip_total_len = orig_len - 14  # Total length (includes IP payload)
    ip_header = bytes([
        0x45, 0x00,                          # Version, IHL, DSCP, ECN
        (ip_total_len >> 8) & 0xFF,          # Total length high byte
        ip_total_len & 0xFF,                 # Total length low byte
        0x00, 0x01,                          # Identification
        0x00, 0x00,                          # Flags, Fragment offset
        0x40, 0x06,                          # TTL, Protocol (TCP)
        0x00, 0x00,                          # Checksum (0 for simplicity)
        0x7f, 0x00, 0x00, 0x01,              # Source IP
        0x7f, 0x00, 0x00, 0x01               # Dest IP
    ])

    # Add padding to reach cap_len (simulating partial capture)
    packet_data = eth_header + ip_header
    if len(packet_data) < cap_len:
        packet_data += bytes(cap_len - len(packet_data))
    packet_data = packet_data[:cap_len]  # Truncate to cap_len

    # pcap packet header with len > caplen (truncated packet)
    packet_header = struct.pack('<IIII',
        1000000000,  # timestamp seconds
        0,           # timestamp microseconds
        cap_len,     # incl_len (captured length) - what we actually have
        orig_len     # orig_len (original length) - larger than caplen!
    )

    with open(filepath, 'wb') as f:
        f.write(global_header)
        f.write(packet_header)
        f.write(packet_data)


def create_multiple_truncated_pcap(filepath, num_packets=5):
    """
    Create a pcap file with multiple truncated packets.
    """
    global_header = struct.pack('<IHHiIII',
        0xa1b2c3d4, 2, 4, 0, 0, 65535, 1
    )

    with open(filepath, 'wb') as f:
        f.write(global_header)

        for i in range(num_packets):
            orig_len = 150 + i * 10  # Varying original lengths
            cap_len = 80 + i * 5     # Varying captured lengths (all < orig_len)

            eth_header = bytes([
                0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                0x08, 0x00
            ])

            ip_header = bytes([
                0x45, 0x00,
                0x00, min(orig_len - 14, 255),
                0x00, i + 1,
                0x00, 0x00,
                0x40, 0x06,
                0x00, 0x00,
                0x7f, 0x00, 0x00, 0x01,
                0x7f, 0x00, 0x00, 0x01
            ])

            packet_data = eth_header + ip_header
            if len(packet_data) < cap_len:
                packet_data += bytes(cap_len - len(packet_data))
            packet_data = packet_data[:cap_len]

            packet_header = struct.pack('<IIII',
                1000000000 + i, 0, cap_len, orig_len
            )

            f.write(packet_header)
            f.write(packet_data)


def run_tcprewrite_fixlen_pad(input_file, timeout=30):
    """
    Run tcprewrite with --fixlen pad option and return the result.
    """
    result = subprocess.run(
        ['tcprewrite', '--fixlen', 'pad', '-i', input_file, '-o', '/dev/null'],
        capture_output=True,
        text=True,
        timeout=timeout
    )
    return result


class TestUseAfterFreeVulnerability:
    """
    Test for the use-after-free vulnerability in tcprewrite.

    The vulnerability occurs in untrunc_packet() when processing truncated
    packets with --fixlen pad. The safe_realloc() call can move the packet
    buffer, leaving stale pointers that cause use-after-free when accessed.
    """

    def test_poc_file_crash(self):
        """
        Test with the provided PoC pcap file.

        Vulnerable version: Crashes with SIGABRT or memory error
        Fixed version: Completes successfully with return code 0
        """
        # Check if PoC file exists
        if os.path.exists(POC_PCAP_PATH):
            input_file = POC_PCAP_PATH
        else:
            # Create our own if PoC not available
            with tempfile.TemporaryDirectory() as tmpdir:
                input_file = os.path.join(tmpdir, 'poc.pcap')
                create_truncated_packet_pcap(input_file, orig_len=167, cap_len=93)
                self._run_crash_test(input_file)
                return

        self._run_crash_test(input_file)

    def _run_crash_test(self, input_file):
        """Helper to run the crash test and verify results."""
        result = run_tcprewrite_fixlen_pad(input_file)

        # Check for crash indicators
        crash_signals = [-signal.SIGABRT, -signal.SIGSEGV, -signal.SIGBUS, 134, 139, 138]

        assert result.returncode not in crash_signals and result.returncode >= 0, \
            f"tcprewrite crashed with return code {result.returncode}. " \
            f"Stderr: {result.stderr}"

        # Should exit cleanly
        assert result.returncode == 0, \
            f"tcprewrite failed with return code {result.returncode}. " \
            f"Stderr: {result.stderr}"

    def test_truncated_packet_small_difference(self):
        """
        Test with truncated packet where len slightly exceeds caplen.
        This is a subtle case that might be missed.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'small_diff.pcap')
            # orig_len just 1 byte more than cap_len
            create_truncated_packet_pcap(input_file, orig_len=100, cap_len=99)

            result = run_tcprewrite_fixlen_pad(input_file)

            assert result.returncode == 0, \
                f"tcprewrite crashed on small truncation difference: {result.returncode}"

    def test_truncated_packet_large_difference(self):
        """
        Test with truncated packet where len significantly exceeds caplen.
        Larger reallocation more likely to move memory.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'large_diff.pcap')
            # Large difference between orig_len and cap_len
            create_truncated_packet_pcap(input_file, orig_len=1000, cap_len=100)

            result = run_tcprewrite_fixlen_pad(input_file)

            assert result.returncode == 0, \
                f"tcprewrite crashed on large truncation difference: {result.returncode}"

    def test_multiple_truncated_packets(self):
        """
        Test with multiple truncated packets in sequence.
        Multiple reallocations increase chance of memory movement.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'multi_trunc.pcap')
            create_multiple_truncated_pcap(input_file, num_packets=10)

            result = run_tcprewrite_fixlen_pad(input_file)

            assert result.returncode == 0, \
                f"tcprewrite crashed on multiple truncated packets: {result.returncode}"

    def test_boundary_packet_sizes(self):
        """
        Test various boundary packet sizes to find edge cases.
        """
        test_cases = [
            (64, 34),     # Minimum Ethernet frame size area
            (128, 64),    # Small packet
            (256, 128),   # Medium packet
            (512, 256),   # Larger packet
            (1500, 750),  # MTU boundary
            (1518, 759),  # Ethernet max frame
            (9000, 4500), # Jumbo frame area
        ]

        with tempfile.TemporaryDirectory() as tmpdir:
            for orig_len, cap_len in test_cases:
                input_file = os.path.join(tmpdir, f'boundary_{orig_len}_{cap_len}.pcap')
                create_truncated_packet_pcap(input_file, orig_len=orig_len, cap_len=cap_len)

                result = run_tcprewrite_fixlen_pad(input_file)

                assert result.returncode == 0, \
                    f"tcprewrite crashed on packet size {orig_len}/{cap_len}: {result.returncode}"


class TestMemoryCorruptionIndicators:
    """
    Additional tests looking for memory corruption indicators.
    """

    def test_repeated_processing(self):
        """
        Process the same truncated file multiple times.
        Memory corruption may manifest after repeated operations.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'repeated.pcap')
            create_truncated_packet_pcap(input_file, orig_len=200, cap_len=100)

            for i in range(5):
                result = run_tcprewrite_fixlen_pad(input_file)

                assert result.returncode == 0, \
                    f"tcprewrite crashed on iteration {i+1}: {result.returncode}"

    def test_alternating_packet_types(self):
        """
        Create pcap with alternating truncated and non-truncated packets.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'alternating.pcap')

            global_header = struct.pack('<IHHiIII',
                0xa1b2c3d4, 2, 4, 0, 0, 65535, 1
            )

            with open(input_file, 'wb') as f:
                f.write(global_header)

                for i in range(10):
                    eth_header = bytes([
                        0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                        0x08, 0x00
                    ])

                    ip_header = bytes([
                        0x45, 0x00, 0x00, 0x14,
                        0x00, i + 1, 0x00, 0x00,
                        0x40, 0x06, 0x00, 0x00,
                        0x7f, 0x00, 0x00, 0x01,
                        0x7f, 0x00, 0x00, 0x01
                    ])

                    packet_data = eth_header + ip_header
                    cap_len = len(packet_data)

                    # Alternate between truncated and non-truncated
                    if i % 2 == 0:
                        orig_len = cap_len + 50  # Truncated
                    else:
                        orig_len = cap_len  # Non-truncated

                    packet_header = struct.pack('<IIII',
                        1000000000 + i, 0, cap_len, orig_len
                    )

                    f.write(packet_header)
                    f.write(packet_data)

            result = run_tcprewrite_fixlen_pad(input_file)

            assert result.returncode == 0, \
                f"tcprewrite crashed on alternating packets: {result.returncode}"

    def test_stderr_for_error_messages(self):
        """
        Check stderr for AddressSanitizer or other error messages.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'stderr_check.pcap')
            create_truncated_packet_pcap(input_file, orig_len=200, cap_len=100)

            result = run_tcprewrite_fixlen_pad(input_file)

            # Check for ASAN messages
            asan_indicators = [
                'AddressSanitizer',
                'heap-use-after-free',
                'heap-buffer-overflow',
                'ASAN',
                'ERROR: ',
                'freed by thread',
                'previously allocated'
            ]

            for indicator in asan_indicators:
                assert indicator not in result.stderr, \
                    f"Memory error detected in stderr: {indicator}"

            assert result.returncode == 0, \
                f"tcprewrite failed: {result.returncode}"


class TestDefenseInDepthValidation:
    """
    Test the secondary fix that validates pkthdr.len against MAX_SNAPLEN.
    """

    def test_oversized_packet_length(self):
        """
        Test with packet where orig_len exceeds reasonable bounds.
        The fix should reject packets with len > MAX_SNAPLEN.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            input_file = os.path.join(tmpdir, 'oversized.pcap')

            # MAX_SNAPLEN is typically 65535
            # Create packet with len > MAX_SNAPLEN
            global_header = struct.pack('<IHHiIII',
                0xa1b2c3d4, 2, 4, 0, 0, 65535, 1
            )

            eth_header = bytes([
                0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                0x08, 0x00
            ])

            ip_header = bytes([
                0x45, 0x00, 0x00, 0x14,
                0x00, 0x01, 0x00, 0x00,
                0x40, 0x06, 0x00, 0x00,
                0x7f, 0x00, 0x00, 0x01,
                0x7f, 0x00, 0x00, 0x01
            ])

            packet_data = eth_header + ip_header
            cap_len = len(packet_data)
            orig_len = 70000  # Exceeds MAX_SNAPLEN (65535)

            packet_header = struct.pack('<IIII',
                1000000000, 0, cap_len, orig_len
            )

            with open(input_file, 'wb') as f:
                f.write(global_header)
                f.write(packet_header)
                f.write(packet_data)

            result = run_tcprewrite_fixlen_pad(input_file)

            # After the secondary fix, this should be rejected with an error message
            # rather than crashing
            # The fix adds: errx(-1, "Frame too big, len %d exceeds %d", pkthdr.len, MAX_SNAPLEN)
            crash_signals = [-signal.SIGABRT, -signal.SIGSEGV, -signal.SIGBUS]

            assert result.returncode not in crash_signals, \
                f"tcprewrite crashed instead of rejecting oversized packet: {result.returncode}"

            # Also check for ASAN errors which indicate memory corruption
            asan_indicators = ['AddressSanitizer', 'heap-use-after-free', 'heap-buffer-overflow']
            for indicator in asan_indicators:
                assert indicator not in result.stderr, \
                    f"Memory corruption detected with oversized packet: {indicator}"

            # Should exit cleanly (either success or controlled error)
            assert result.returncode == 0 or 'Frame too big' in result.stderr, \
                f"Unexpected failure mode: {result.returncode}"
