diff --git a/poc/total-js.test.js b/poc/total-js.test.js
new file mode 100644
index 0000000..3599b37
--- /dev/null
+++ b/poc/total-js.test.js
@@ -0,0 +1,61 @@
+// poc/total-js.test.js
+const fs = require('fs');
+const path = './total_js';
+
+jest.setTimeout(10000);
+
+describe('Command injection in total.js (regression test)', () => {
+  beforeEach(() => {
+    try {
+      if (fs.existsSync(path)) fs.unlinkSync(path);
+    } catch (e) {
+      // ignore cleanup errors
+    }
+  });
+
+  afterAll(() => {
+    try {
+      if (fs.existsSync(path)) fs.unlinkSync(path);
+    } catch (e) {
+      // ignore
+    }
+  });
+
+  test('untrusted input must NOT create files (fix should prevent injection)', async () => {
+    // ensure clean start
+    expect(fs.existsSync(path)).toBe(false);
+
+    // load image implementation (support both export styles)
+    const mod = require('../image.js');
+    const ImageImpl = mod && (mod.Image || mod);
+
+    if (!ImageImpl) {
+      throw new Error('Could not require ../image.js or find exported Image');
+    }
+
+    // create instance - support both Image.load() and new Image()
+    let image;
+    if (typeof ImageImpl.load === 'function') {
+      image = ImageImpl.load('');
+    } else {
+      image = new ImageImpl();
+    }
+
+    if (!image || typeof image.stream !== 'function') {
+      throw new Error('Image instance does not expose stream(type, writer) function');
+    }
+
+    // malicious payload passed as the "type" argument (this used to be abused)
+    const payload = ';touch total_js;';
+
+    // call the API in the same way vulnerability was previously triggered
+    image.stream(payload);
+
+    // wait briefly for any background shell/child process the vulnerable code might spawn
+    await new Promise((resolve) => setTimeout(resolve, 1000));
+
+    // SECURITY ASSERTION: file must NOT exist after calling stream with untrusted input
+    expect(fs.existsSync(path)).toBe(false);
+  });
+});
+
