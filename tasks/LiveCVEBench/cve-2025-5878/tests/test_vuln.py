"""
Vulnerability tests for ESAPI SQL encoding backslash-quote bypass.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerability allows SQL injection bypass when input contains a backslash
followed by a single quote (\'). In the vulnerable version:
- Backslash passes through unchanged
- Single quote is doubled to ''
- Result: \'' which allows SQL injection

In the fixed version, the method should either:
1. Throw an exception (method disabled by default)
2. Properly escape/reject backslash characters
"""

import subprocess
import pytest
import os

# Path to the test harness JAR in the container
TEST_JAR = "/app/target/esapi-test-1.0-SNAPSHOT-jar-with-dependencies.jar"


def run_encode_test(codec_type: str, input_str: str) -> dict:
    """
    Run the ESAPI encode test and return results.

    Args:
        codec_type: 'oracle' or 'mysql_ansi' or 'mysql_standard'
        input_str: The input string to encode

    Returns:
        dict with 'encoded' (string result or None), 'exception' (bool), 'message' (str)
    """
    cmd = [
        "java", "-cp", TEST_JAR,
        "com.test.ESAPIEncoderTest",
        codec_type,
        input_str
    ]

    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=30
    )

    stdout = result.stdout.strip()
    stderr = result.stderr.strip()

    # Parse the output
    response = {
        'encoded': None,
        'exception': False,
        'message': ''
    }

    if "EXCEPTION:" in stdout:
        response['exception'] = True
        response['message'] = stdout.split("EXCEPTION:", 1)[1].strip()
    elif "ENCODED:" in stdout:
        response['encoded'] = stdout.split("ENCODED:", 1)[1].strip()
    else:
        response['message'] = stdout + "\n" + stderr

    return response


def is_vulnerable_pattern(encoded: str, original_backslash_quote: str) -> bool:
    """
    Check if the encoded output contains the vulnerable pattern.

    The vulnerable pattern is when:
    - Input contains \' (backslash + single quote)
    - Output contains \'' (backslash + two single quotes)

    This allows the backslash to escape the first quote, leaving the second
    quote to break out of the SQL string context.
    """
    if encoded is None:
        return False

    # Check for the vulnerable pattern: backslash followed by two quotes
    # This happens when backslash passes through unchanged and quote is doubled
    if "\\'\\''" in encoded or "\\'" in encoded:
        # More specific check: the pattern \'' should not exist if properly fixed
        # In vulnerable version: \' -> \'' (backslash + two quotes)
        # Count the quotes - if backslash is followed by exactly 2 quotes, it's vulnerable
        import re
        # Pattern: backslash followed by two single quotes
        vulnerable_pattern = re.search(r"\\''", encoded)
        if vulnerable_pattern:
            return True

    return False


class TestOracleCodecBackslashBypass:
    """Test Oracle codec backslash-quote bypass vulnerability."""

    def test_basic_backslash_quote_bypass(self):
        """
        Basic backslash-quote bypass attack.
        Input: \'
        Vulnerable output: \'' (allows SQL injection)
        Fixed: Exception thrown OR backslash properly handled
        """
        result = run_encode_test("oracle", "\\'")

        # Fixed version should throw exception OR not produce vulnerable pattern
        if result['exception']:
            # Method is disabled - vulnerability is mitigated
            assert True
        else:
            # If no exception, verify the output doesn't contain vulnerable pattern
            encoded = result['encoded']
            # The vulnerable pattern is \'' - backslash followed by two quotes
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Vulnerability present: input \\' encoded to {encoded}"

    def test_sql_injection_payload_or_1_equals_1(self):
        """
        SQL injection with OR 1=1 payload.
        Input: \' OR 1=1--
        Vulnerable: Allows bypass of SQL string context
        """
        result = run_encode_test("oracle", "\\' OR 1=1--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            # Check if vulnerable pattern exists
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"SQL injection bypass possible: {encoded}"

    def test_union_based_injection(self):
        """
        UNION-based SQL injection payload.
        Input: \' UNION SELECT password FROM users--
        """
        result = run_encode_test("oracle", "\\' UNION SELECT password FROM users--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"UNION injection bypass possible: {encoded}"

    def test_multiple_backslash_quotes(self):
        """
        Multiple backslash-quote sequences in input.
        Input: \' AND \' OR \'
        """
        result = run_encode_test("oracle", "\\' AND \\' OR \\'")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Multiple backslash-quote bypass: {encoded}"

    def test_embedded_backslash_quote(self):
        """
        Backslash-quote embedded in normal text.
        Input: admin\\' OR 1=1--
        """
        result = run_encode_test("oracle", "admin\\' OR 1=1--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Embedded backslash-quote bypass: {encoded}"


class TestMySQLANSICodecBackslashBypass:
    """Test MySQL ANSI mode backslash-quote bypass vulnerability."""

    def test_basic_backslash_quote_bypass(self):
        """
        Basic backslash-quote bypass in MySQL ANSI mode.
        Input: \'
        Vulnerable output: \'' (allows SQL injection)
        """
        result = run_encode_test("mysql_ansi", "\\'")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"MySQL ANSI vulnerability present: {encoded}"

    def test_time_based_blind_injection(self):
        """
        Time-based blind SQL injection payload.
        Input: \' AND IF(1=1,SLEEP(5),1)--
        """
        result = run_encode_test("mysql_ansi", "\\' AND IF(1=1,SLEEP(5),1)--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Time-based injection bypass possible: {encoded}"

    def test_boolean_blind_injection(self):
        """
        Boolean-based blind SQL injection.
        Input: \' AND 1=1 AND \'x\'=\'x
        """
        result = run_encode_test("mysql_ansi", "\\' AND 1=1 AND \\'x\\'=\\'x")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Boolean blind injection bypass: {encoded}"

    def test_stacked_queries(self):
        """
        Stacked queries injection attempt.
        Input: \'; DROP TABLE users;--
        """
        result = run_encode_test("mysql_ansi", "\\'; DROP TABLE users;--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Stacked queries bypass possible: {encoded}"


class TestMySQLStandardModeComparison:
    """
    Test MySQL Standard mode for comparison - this verifies even Standard mode
    doesn't fully protect against the ESAPI vulnerability design flaw.

    In the vulnerable version (2.6.2.0), the encodeForSQL method is fundamentally
    flawed in its approach - even MySQL Standard mode relies on the broken
    encoding API that should not be used.
    """

    def test_standard_mode_uses_dangerous_api(self):
        """
        Even though MySQL Standard mode escapes backslashes properly,
        the encodeForSQL API itself is dangerous and should not be used.
        In vulnerable version, the API is accessible without warnings.
        This test verifies the API is usable (vulnerable version behavior).
        In fixed version, the API should throw an exception.
        """
        result = run_encode_test("mysql_standard", "\\'")

        if result['exception']:
            # Exception means method is disabled - this is the FIXED behavior
            assert True
        else:
            # In vulnerable version, the API works without warning
            # This is the vulnerability - the dangerous API is accessible
            # We want this test to FAIL to demonstrate the vulnerability
            assert result['exception'], \
                f"Dangerous encodeForSQL API is accessible without exception: {result['encoded']}"


class TestEdgeCasesAndVariations:
    """Test edge cases and payload variations."""

    def test_double_backslash_quote(self):
        """
        Double backslash before quote.
        Input: \\\\'
        This still contains \' which should be vulnerable.
        """
        result = run_encode_test("oracle", "\\\\\\'")

        if result['exception']:
            # Exception means method is disabled - FIXED behavior
            assert True
        else:
            # Vulnerable version: double backslash + quote -> double backslash + two quotes
            # Still contains the \'' pattern
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Double backslash-quote still vulnerable: {encoded}"

    def test_quote_backslash_quote(self):
        """
        Quote-backslash-quote sequence.
        Input: '\\'
        Contains backslash-quote which should produce vulnerable output.
        """
        result = run_encode_test("oracle", "'\\\\'")

        if result['exception']:
            # Exception means method is disabled - FIXED behavior
            assert True
        else:
            encoded = result['encoded']
            # The input contains \' which should produce vulnerable \''
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Quote-backslash-quote is vulnerable: {encoded}"

    def test_url_decoded_payload(self):
        """
        Test what would be a URL-decoded payload (%5c%27 = \\').
        The actual backslash-quote characters after URL decoding.
        """
        # %5c = \, %27 = '
        # After URL decode: \'
        result = run_encode_test("oracle", "\\' OR 1=1--")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"URL-decoded payload bypass: {encoded}"

    def test_mixed_quotes_and_backslashes(self):
        """
        Mixed single quotes and backslashes.
        Input: test\\' OR ''='
        """
        result = run_encode_test("oracle", "test\\' OR ''='")

        if result['exception']:
            assert True
        else:
            encoded = result['encoded']
            assert not is_vulnerable_pattern(encoded, "\\'"), \
                f"Mixed quotes/backslashes bypass: {encoded}"

    def test_comment_injection_variants(self):
        """
        Various SQL comment injection variants.
        """
        payloads = [
            "\\' OR 1=1--",
            "\\' OR 1=1#",
            "\\' OR 1=1/*",
            "\\' OR 1=1;--",
        ]

        for payload in payloads:
            result = run_encode_test("mysql_ansi", payload)

            if result['exception']:
                continue  # Fixed
            else:
                encoded = result['encoded']
                assert not is_vulnerable_pattern(encoded, "\\'"), \
                    f"Comment injection variant bypass with {payload}: {encoded}"


class TestSecurityBoundaries:
    """Test that the fix properly blocks the vulnerable method."""

    def test_method_disabled_by_default(self):
        """
        In fixed version, encodeForSQL should be disabled by default.
        It should throw an exception unless explicitly enabled.

        In vulnerable version, the method is accessible without restriction.
        This test verifies the vulnerability - the dangerous API is accessible.
        """
        # Test with any codec - should throw if fixed
        result = run_encode_test("oracle", "test")

        # In FIXED version: exception with "disabled" message
        # In VULNERABLE version: method works without exception

        if result['exception']:
            # Method is disabled - this is the FIXED behavior
            msg_lower = result['message'].lower()
            # Accept various messages indicating the method is blocked
            assert any(term in msg_lower for term in [
                "disabled", "not enabled", "not configured", "deprecated",
                "denied", "blocked", "unsafe", "security"
            ]), f"Exception but unexpected message: {result['message']}"
        else:
            # Vulnerable version - method is accessible without exception
            # This test should FAIL to demonstrate the vulnerability
            assert result['exception'], \
                f"Dangerous encodeForSQL method is accessible: returned {result['encoded']}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
