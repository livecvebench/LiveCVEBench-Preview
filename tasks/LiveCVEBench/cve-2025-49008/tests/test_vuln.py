"""
Vulnerability tests for Atheos IDE Git integration.
Tests for argument injection vulnerability in Git operations (CVE-2025-49008).

These tests verify that:
- FAIL in vulnerable state (vulnerability is exploitable, file IS created)
- PASS in fixed state (vulnerability is mitigated, file is NOT created)

The vulnerability allows argument injection via git --upload-pack option.
The execute.php trait uses escapeshellcmd() which doesn't prevent argument injection,
and then un-escapes # characters, allowing comments to be injected.
"""

import pytest
import requests
from requests.exceptions import ReadTimeout, Timeout
import os
import time
import uuid

# API endpoint must be controller.php for proper routing
BASE_URL = os.environ.get("APP_URL", "http://localhost/controller.php")
USERNAME = os.environ.get("ATHEOS_USER", "admin")
PASSWORD = os.environ.get("ATHEOS_PASS", "admin")
TIMEOUT = 10
# Short timeout for vulnerability tests - tee will block on stdin causing timeout
# but the file creation happens immediately, so we use a shorter timeout
VULN_TIMEOUT = 2


def get_authenticated_session():
    """Helper to create an authenticated session."""
    session = requests.Session()
    response = session.post(
        BASE_URL,
        data={
            "target": "user",
            "action": "authenticate",
            "username": USERNAME,
            "password": PASSWORD
        },
        timeout=TIMEOUT
    )
    if response.status_code != 200:
        raise Exception(f"Authentication failed: {response.text}")
    return session


def init_test_repo(session, repo_path):
    """Helper to initialize a Git repository."""
    import subprocess

    # First ensure the directory exists
    os.makedirs(repo_path, exist_ok=True)
    # Change ownership to www-data so PHP can write to it
    subprocess.run(["chown", "-R", "www-data:www-data", repo_path], check=False)
    subprocess.run(["chmod", "-R", "775", repo_path], check=False)

    response = session.post(
        BASE_URL,
        data={
            "target": "codegit",
            "action": "init",
            "type": "repo",
            "repo": repo_path
        },
        timeout=TIMEOUT
    )
    return response


def check_file_exists(filepath):
    """Check if a file exists."""
    return os.path.exists(filepath)


def remove_file_if_exists(filepath):
    """Remove a file if it exists, for test cleanup."""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception:
        pass


def attempt_injection(session, repo_path, proof_file, transfer_type="fetch", pack_option="--upload-pack"):
    """
    Attempt the argument injection and return whether the file was created.

    This uses a short timeout because tee blocks waiting for stdin,
    but it creates the file immediately before blocking.
    """
    remove_file_if_exists(proof_file)

    try:
        response = session.post(
            BASE_URL,
            data={
                "target": "codegit",
                "action": "transfer",
                "type": transfer_type,
                "repo": repo_path,
                "remote": f"{pack_option}=/usr/bin/tee",
                "branch": f"{proof_file} #"
            },
            timeout=VULN_TIMEOUT
        )
    except (ReadTimeout, Timeout):
        # Timeout is expected when tee blocks waiting for input
        # The file creation happens before the block
        pass
    except Exception as e:
        # Other errors might occur but we only care about file creation
        pass

    # Small delay to ensure file system is synced
    time.sleep(0.2)

    # Check if file was created
    file_created = check_file_exists(proof_file)

    # Cleanup
    remove_file_if_exists(proof_file)

    return file_created


class TestArgumentInjection:
    """
    Test argument injection via --upload-pack option.

    The vulnerability works by:
    1. Putting --upload-pack=/usr/bin/tee in the 'remote' parameter
    2. Putting '/tmp/target_file #' in the 'branch' parameter
    3. The # is un-escaped by str_replace("\\#", "#", $cmd) in execute.php
    4. Git executes: git fetch --upload-pack=/usr/bin/tee /tmp/target_file #
    5. /usr/bin/tee is called with /tmp/target_file as argument, creating the file
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.session = get_authenticated_session()
        self.test_repo_path = "/var/www/html/workspace/vuln_test_repo"
        # Ensure directory exists
        os.makedirs(self.test_repo_path, exist_ok=True)
        init_test_repo(self.session, self.test_repo_path)
        yield

    def test_upload_pack_injection_with_hash_comment(self):
        """
        Test the primary argument injection attack vector.

        This uses the actual working payload:
        - remote: --upload-pack=/usr/bin/tee
        - branch: /tmp/proof_file #

        The # comment is un-escaped by execute.php, allowing the injection.

        Vulnerable: File IS created (tee command executes) - test FAILS
        Fixed: File is NOT created (arguments are properly escaped) - test PASSES
        """
        unique_id = uuid.uuid4().hex[:8]
        proof_file = f"/tmp/vuln_proof_hash_{unique_id}"

        file_created = attempt_injection(
            self.session,
            self.test_repo_path,
            proof_file,
            transfer_type="fetch"
        )

        # PASS if file was NOT created (fixed), FAIL if created (vulnerable)
        assert not file_created, \
            f"VULNERABILITY DETECTED: Argument injection via --upload-pack succeeded. " \
            f"File '{proof_file}' was created through git argument injection with hash comment bypass."

    def test_upload_pack_injection_alternate_payload(self):
        """
        Test injection with a different unique filename.

        This tests the same vulnerability with different file paths to ensure
        the vulnerability is consistently exploitable.
        """
        unique_id = uuid.uuid4().hex[:8]
        proof_file = f"/tmp/vuln_proof_alt_{unique_id}"

        file_created = attempt_injection(
            self.session,
            self.test_repo_path,
            proof_file,
            transfer_type="fetch"
        )

        assert not file_created, \
            f"VULNERABILITY DETECTED: Alternate payload injection succeeded."


class TestPullInjection:
    """Test injection via git pull operation."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.session = get_authenticated_session()
        self.test_repo_path = "/var/www/html/workspace/vuln_pull_test"
        os.makedirs(self.test_repo_path, exist_ok=True)
        init_test_repo(self.session, self.test_repo_path)
        yield

    def test_pull_operation_injection(self):
        """
        Test argument injection via pull operation.
        """
        unique_id = uuid.uuid4().hex[:8]
        proof_file = f"/tmp/vuln_proof_pull_{unique_id}"

        file_created = attempt_injection(
            self.session,
            self.test_repo_path,
            proof_file,
            transfer_type="pull"
        )

        assert not file_created, \
            f"VULNERABILITY DETECTED: Pull operation injection succeeded."


class TestHashCommentBypass:
    """
    Test the hash comment bypass specifically.

    The execute.php trait has this vulnerable code:
    $cmd = str_replace("\\#", "#", $cmd);

    This un-escapes # after escapeshellcmd(), enabling comment injection.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.session = get_authenticated_session()
        self.test_repo_path = "/var/www/html/workspace/vuln_hash_test"
        os.makedirs(self.test_repo_path, exist_ok=True)
        init_test_repo(self.session, self.test_repo_path)
        yield

    def test_hash_comment_enables_injection(self):
        """
        Verify that the hash comment bypass is the key to exploitation.

        Without the # un-escaping in execute.php, the injection would fail
        because git would try to interpret trailing arguments.
        """
        unique_id = uuid.uuid4().hex[:8]
        proof_file = f"/tmp/vuln_hash_bypass_{unique_id}"

        file_created = attempt_injection(
            self.session,
            self.test_repo_path,
            proof_file,
            transfer_type="fetch"
        )

        assert not file_created, \
            "VULNERABILITY DETECTED: Hash comment bypass allowed injection."


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
