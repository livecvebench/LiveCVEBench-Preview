"""
Functionality tests for Aim query system.
These tests should PASS in both vulnerable and fixed states.
They verify that legitimate query functionality is preserved.
"""

import pytest
import requests
import time
import urllib.parse

# Aim server URL - runs on port 43800 by default
BASE_URL = "http://localhost:43800"


def wait_for_server(url, timeout=60):
    """Wait for the Aim server to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{url}/api/runs/search/run/", timeout=5)
            if response.status_code in [200, 400]:  # Server is up
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


@pytest.fixture(scope="module", autouse=True)
def ensure_server_ready():
    """Ensure the Aim server is running and ready before tests."""
    if not wait_for_server(BASE_URL):
        pytest.skip("Aim server is not available")


class TestLegitimateQueries:
    """Tests for legitimate query functionality that must work before and after fix."""

    def test_basic_archived_query(self):
        """Test basic query for non-archived runs."""
        query = "run.archived == False"
        encoded_query = urllib.parse.quote(query)

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # Should return 200 OK (may have empty results if no runs exist)
        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_by_run_name(self):
        """Test that querying by run name works."""
        query = 'run.name == "test_run" or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_with_string_contains(self):
        """Test string operations in queries."""
        query = '"test" in run.name or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_with_boolean_operators(self):
        """Test boolean operators (and, or) in queries."""
        query = "(run.archived == False) and (run.name != None)"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_with_comparison_operators(self):
        """Test comparison operators in queries."""
        query = "run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_empty_query(self):
        """Test that empty query returns results (using default archived filter)."""
        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_metric_search_endpoint(self):
        """Test the metric search endpoint works."""
        query = "run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/metric/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # May return 200 or 404 depending on setup, but not 500
        assert response.status_code in [200, 404], f"Unexpected status {response.status_code}: {response.text}"


class TestQuerySyntax:
    """Tests for various query syntax variations."""

    def test_query_with_parentheses(self):
        """Test nested parentheses in queries."""
        query = "((run.archived == False))"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_with_not_operator(self):
        """Test NOT operator in queries."""
        query = "not run.archived"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"

    def test_query_with_none_check(self):
        """Test None comparison in queries."""
        query = "run.name != None and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Expected 200, got {response.status_code}: {response.text}"


class TestAPIResponseFormat:
    """Tests for API response format consistency."""

    def test_response_is_streaming(self):
        """Test that API returns a valid streaming response (MessagePack format)."""
        query = "run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200
        # Aim uses streaming MessagePack response format, not JSON
        # Verify we get content back
        assert len(response.content) > 0, "Response should have content"

    def test_response_with_limit_parameter(self):
        """Test that limit parameter is respected."""
        query = "run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 5},
            timeout=30
        )

        assert response.status_code == 200
