<?php
/**
 * Test helper script for ZIP extraction functionality.
 *
 * This script dynamically loads and executes the actual unzip() method body
 * from the installed WireFileTools.php file using eval().
 *
 * This ensures we are testing the REAL code, not a reimplementation.
 *
 * Usage: php test_helper.php unzip /path/to/file.zip
 */

// Ensure we're running from the app directory
chdir('/var/www/html');

/**
 * Execute the actual unzip method from WireFileTools.php
 */
function executeRealUnzip($zipFile, $destDir) {
    $wireFileToolsPath = '/var/www/html/wire/core/WireFileTools.php';

    // Read the actual source file
    $source = file_get_contents($wireFileToolsPath);

    // Extract the unzip method body
    $pattern = '/public\s+function\s+unzip\s*\(\s*\$file\s*,\s*\$dst\s*\)\s*\{/';
    if (!preg_match($pattern, $source, $matches, PREG_OFFSET_CAPTURE)) {
        throw new Exception("Could not find unzip method in WireFileTools.php");
    }

    $startPos = $matches[0][1] + strlen($matches[0][0]);

    // Find the matching closing brace
    $braceCount = 1;
    $pos = $startPos;
    $len = strlen($source);

    while ($pos < $len && $braceCount > 0) {
        $char = $source[$pos];
        if ($char === '{') $braceCount++;
        if ($char === '}') $braceCount--;
        $pos++;
    }

    $methodBody = substr($source, $startPos, $pos - $startPos - 1);

    // Prepare the code for standalone execution
    // Replace $this-> method calls with our implementations
    $executableCode = $methodBody;

    // Replace $this->filesException calls with throw new Exception
    $executableCode = preg_replace(
        '/\$this->filesException\s*\(\s*__FUNCTION__\s*,\s*/',
        'throw new Exception(',
        $executableCode
    );

    // Replace $this->mkdir calls with mkdir
    $executableCode = preg_replace(
        '/\$this->mkdir\s*\(\s*([^,]+),\s*true\s*\)/',
        'mkdir($1, 0755, true)',
        $executableCode
    );

    // Replace $this->wire()->config->chmodFile and chmodDir
    $executableCode = preg_replace(
        '/\$this->wire\(\)->config->chmodFile/',
        "'0644'",
        $executableCode
    );
    $executableCode = preg_replace(
        '/\$this->wire\(\)->config->chmodDir/',
        "'0755'",
        $executableCode
    );

    // Replace namespaced ZipArchive with global
    $executableCode = str_replace('\\ZipArchive', 'ZipArchive', $executableCode);
    $executableCode = str_replace('new ZipArchive', 'new \\ZipArchive', $executableCode);

    // Set up variables
    $file = $zipFile;
    $dst = rtrim($destDir, '/' . DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;

    // Create destination directory if needed
    if (!is_dir($dst)) {
        mkdir($dst, 0755, true);
    }

    // Build the complete executable code
    $fullCode = '
        $file = ' . var_export($file, true) . ';
        $dst = ' . var_export($dst, true) . ';
        ' . $executableCode . '
        return $names;
    ';

    // Execute the actual method body
    try {
        $names = eval($fullCode);
        return $names;
    } catch (Exception $e) {
        throw $e;
    }
}

/**
 * Recursively remove a directory
 */
function rmdirRecursive($dir) {
    if (!is_dir($dir)) return;

    $files = array_diff(scandir($dir), ['.', '..']);
    foreach ($files as $file) {
        $path = "$dir/$file";
        if (is_dir($path)) {
            rmdirRecursive($path);
        } else {
            unlink($path);
        }
    }
    rmdir($dir);
}

// ============================================================
// Main execution
// ============================================================

$action = $argv[1] ?? 'help';

if ($action !== 'unzip') {
    echo "Usage: php test_helper.php unzip /path/to/file.zip\n";
    exit(1);
}

$zipFile = $argv[2] ?? null;

if (!$zipFile || !file_exists($zipFile)) {
    fwrite(STDERR, "Error: ZIP file not found: $zipFile\n");
    exit(1);
}

$tmpDir = sys_get_temp_dir() . '/pw_unzip_test_' . uniqid() . '/';

try {
    $result = executeRealUnzip($zipFile, $tmpDir);

    echo "SUCCESS: Extracted " . count($result) . " files\n";

    // Cleanup
    if (is_dir($tmpDir)) {
        rmdirRecursive($tmpDir);
    }

    exit(0);
} catch (Exception $e) {
    fwrite(STDERR, "REJECTED: " . $e->getMessage() . "\n");

    // Cleanup on error
    if (is_dir($tmpDir)) {
        rmdirRecursive($tmpDir);
    }

    exit(1);
}
