diff --git a/test/request.js b/test/request.js
new file mode 100644
index 0000000..137d2de
--- /dev/null
+++ b/test/request.js
@@ -0,0 +1,230 @@
+'use strict'
+
+const { createServer } = require('http')
+const { test } = require('tap')
+const { request } = require('..')
+
+let failedTests = 0
+
+function safeEqual(t, actual, expected, msg) {
+  try {
+    t.equal(actual, expected, msg)
+  } catch (err) {
+    failedTests++
+    console.error(`Test failed: ${msg}\n`, err.message || err)
+  }
+}
+
+function safeFail(t, msg) {
+  failedTests++
+  console.error(`Test failed: ${msg}`)
+  t.fail(msg)
+}
+
+process.on('exit', () => {
+  if (failedTests > 0) {
+    console.error(`\n${failedTests} test(s) failed.`)
+    process.exit(1)
+  }
+})
+
+// -------------------- Test 1 --------------------
+test('no-slash/one-slash pathname should be included in req.path', async (t) => {
+  const pathServer = createServer((req, res) => {
+    safeFail(t, 'pathServer shouldn\'t be called')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  const requestedServer = createServer((req, res) => {
+    safeEqual(t, `/localhost:${pathServer.address().port}`, req.url, 'requestedServer url')
+    safeEqual(t, 'GET', req.method, 'requestedServer method')
+    safeEqual(t, `localhost:${requestedServer.address().port}`, req.headers.host, 'requestedServer host')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  t.teardown(requestedServer.close.bind(requestedServer))
+  t.teardown(pathServer.close.bind(pathServer))
+
+  await Promise.all([
+    requestedServer.listen(0),
+    pathServer.listen(0)
+  ])
+
+  const tests = [
+    { arg: { pathname: `localhost:${pathServer.address().port}` }, label: 'noSlashPathname' },
+    { arg: { path: `localhost:${pathServer.address().port}` }, label: 'noSlashPath' },
+    { arg: [`http://localhost:${requestedServer.address().port}`, { path: `localhost:${pathServer.address().port}` }], label: 'noSlashPath2Arg' },
+    { arg: { pathname: `/localhost:${pathServer.address().port}` }, label: 'oneSlashPathname' },
+    { arg: { path: `/localhost:${pathServer.address().port}` }, label: 'oneSlashPath' },
+    { arg: [`http://localhost:${requestedServer.address().port}`, { path: `/localhost:${pathServer.address().port}` }], label: 'oneSlashPath2Arg' }
+  ]
+
+  for (const { arg, label } of tests) {
+    try {
+      let res
+      if (Array.isArray(arg)) {
+        res = await request(...arg)
+      } else {
+        res = await request({ method: 'GET', origin: `http://localhost:${requestedServer.address().port}`, ...arg })
+      }
+      safeEqual(t, res.statusCode, 200, label)
+    } catch (err) {
+      failedTests++
+      console.error(`Test failed: ${label}\n`, err.message || err)
+    }
+  }
+
+  t.end()
+})
+
+// -------------------- Test 2 --------------------
+test('protocol-relative URL as pathname should be included in req.path', async (t) => {
+  const pathServer = createServer((req, res) => {
+    safeFail(t, 'pathServer shouldn\'t be called')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  const requestedServer = createServer((req, res) => {
+    safeEqual(t, `//localhost:${pathServer.address().port}`, req.url, 'requestedServer url')
+    safeEqual(t, 'GET', req.method, 'requestedServer method')
+    safeEqual(t, `localhost:${requestedServer.address().port}`, req.headers.host, 'requestedServer host')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  t.teardown(requestedServer.close.bind(requestedServer))
+  t.teardown(pathServer.close.bind(pathServer))
+
+  await Promise.all([
+    requestedServer.listen(0),
+    pathServer.listen(0)
+  ])
+
+  const tests = [
+    { arg: { pathname: `//localhost:${pathServer.address().port}` }, label: 'noSlashPathname' },
+    { arg: { path: `//localhost:${pathServer.address().port}` }, label: 'noSlashPath' },
+    { arg: [`http://localhost:${requestedServer.address().port}`, { path: `//localhost:${pathServer.address().port}` }], label: 'noSlashPath2Arg' }
+  ]
+
+  for (const { arg, label } of tests) {
+    try {
+      let res
+      if (Array.isArray(arg)) {
+        res = await request(...arg)
+      } else {
+        res = await request({ method: 'GET', origin: `http://localhost:${requestedServer.address().port}`, ...arg })
+      }
+      safeEqual(t, res.statusCode, 200, label)
+    } catch (err) {
+      failedTests++
+      console.error(`Test failed: ${label}\n`, err.message || err)
+    }
+  }
+
+  t.end()
+})
+
+// -------------------- Test 3 --------------------
+test('Absolute URL as pathname should be included in req.path', async (t) => {
+  const pathServer = createServer((req, res) => {
+    safeFail(t, 'pathServer shouldn\'t be called')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  const requestedServer = createServer((req, res) => {
+    safeEqual(t, `/http://localhost:${pathServer.address().port}`, req.url, 'requestedServer url')
+    safeEqual(t, 'GET', req.method, 'requestedServer method')
+    safeEqual(t, `localhost:${requestedServer.address().port}`, req.headers.host, 'requestedServer host')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  t.teardown(requestedServer.close.bind(requestedServer))
+  t.teardown(pathServer.close.bind(pathServer))
+
+  await Promise.all([
+    requestedServer.listen(0),
+    pathServer.listen(0)
+  ])
+
+  const tests = [
+    { arg: { pathname: `http://localhost:${pathServer.address().port}` }, label: 'noSlashPathname' },
+    { arg: { path: `http://localhost:${pathServer.address().port}` }, label: 'noSlashPath' },
+    { arg: [`http://localhost:${requestedServer.address().port}`, { path: `http://localhost:${pathServer.address().port}` }], label: 'noSlashPath2Arg' }
+  ]
+
+  for (const { arg, label } of tests) {
+    try {
+      let res
+      if (Array.isArray(arg)) {
+        res = await request(...arg)
+      } else {
+        res = await request({ method: 'GET', origin: `http://localhost:${requestedServer.address().port}`, ...arg })
+      }
+      safeEqual(t, res.statusCode, 200, label)
+    } catch (err) {
+      failedTests++
+      console.error(`Test failed: ${label}\n`, err.message || err)
+    }
+  }
+
+  t.end()
+})
+
+// -------------------- Test 4 --------------------
+test('protocol-relative URL with leading space should NOT be treated as local path', async (t) => {
+  const pathServer = createServer((req, res) => {
+    // If this server is called, then the exploit worked
+    safeFail(t, 'pathServer should not be called (possible redirect vuln)')
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  const requestedServer = createServer((req, res) => {
+
+    t.ok(
+      req.url.startsWith('/%20//localhost:'),
+      `expected encoded path, got: ${req.url}`
+    )
+    res.statusCode = 200
+    res.end('hello')
+  })
+
+  t.teardown(requestedServer.close.bind(requestedServer))
+  t.teardown(pathServer.close.bind(pathServer))
+
+  await Promise.all([
+    requestedServer.listen(0),
+    pathServer.listen(0)
+  ])
+
+  const evilPath = ` //localhost:${pathServer.address().port}` 
+
+  const tests = [
+    { arg: { path: evilPath }, label: 'leadingSpacePath' },
+    { arg: { pathname: evilPath }, label: 'leadingSpacePathname' },
+    { arg: [`http://localhost:${requestedServer.address().port}`, { path: evilPath }], label: 'leadingSpacePath2Arg' }
+  ]
+
+  for (const { arg, label } of tests) {
+    try {
+      let res
+      if (Array.isArray(arg)) {
+        res = await request(...arg)
+      } else {
+        res = await request({ method: 'GET', origin: `http://localhost:${requestedServer.address().port}`, ...arg })
+      }
+      safeEqual(t, res.statusCode, 200, label)
+    } catch (err) {
+      failedTests++
+      console.error(`Test failed: ${label}\n`, err.message || err)
+    }
+  }
+
+  t.end()
+})
+
