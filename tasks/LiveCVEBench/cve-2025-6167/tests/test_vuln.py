"""
Vulnerability tests for path traversal in python-a2a.

These tests verify that path traversal attacks are properly prevented.

EXPECTED BEHAVIOR:
- FAIL when vulnerability is present (path traversal works, file created outside storage)
- PASS when vulnerability is fixed (path traversal is blocked)

The tests focus on attack vectors that ACTUALLY WORK in the vulnerable version.
"""

import pytest
import requests
import time
import os

BASE_URL = os.environ.get("APP_URL", "http://localhost:8080")


# Valid workflow structure required by the API (must have nodes and edges)
def make_workflow_payload(workflow_id, name="Test Workflow"):
    """Create a valid workflow payload with the given ID."""
    return {
        "id": workflow_id,
        "name": name,
        "description": "Test workflow",
        "version": "1.0",
        "nodes": [
            {"id": "node1", "name": "Start", "type": "INPUT", "config": {}},
            {"id": "node2", "name": "End", "type": "OUTPUT", "config": {}}
        ],
        "edges": [
            {"id": "edge1", "source_node_id": "node1", "target_node_id": "node2", "edge_type": "DATA"}
        ]
    }


@pytest.fixture(scope="module")
def wait_for_app():
    """Wait for the application to be ready."""
    max_retries = 30
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/", timeout=2)
            if response.status_code == 200:
                return True
        except requests.exceptions.ConnectionError:
            pass
        time.sleep(1)
    pytest.fail("Application did not start in time")


def cleanup_file(filepath):
    """Remove file if it exists."""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception:
        pass


class TestPathTraversalVulnerability:
    """
    Test the core path traversal vulnerability.

    These tests use attack vectors that actually work in the vulnerable version.
    All tests should FAIL when vulnerability exists, PASS when fixed.
    """

    def test_relative_path_traversal_to_tmp(self, wait_for_app):
        """
        Test ../../../tmp/ path traversal.

        This is the primary attack vector for the path traversal vulnerability.
        The vulnerable code uses os.path.join() without validation,
        allowing ../ sequences to escape the storage directory.
        """
        target_file = "/tmp/vuln_test_relative.json"
        cleanup_file(target_file)

        payload = make_workflow_payload("../../../tmp/vuln_test_relative", "Path Traversal Test")

        response = requests.post(
            f"{BASE_URL}/api/workflows/",
            json=payload,
            timeout=10
        )

        file_created = os.path.exists(target_file)
        cleanup_file(target_file)

        # In vulnerable state: file IS created, response is 201
        # In fixed state: file NOT created, response is 400
        assert not file_created, "VULNERABLE: Path traversal allowed - file was created in /tmp"
        assert response.status_code == 400, f"VULNERABLE: Expected 400 for path traversal, got {response.status_code}"

    def test_deep_relative_path_traversal(self, wait_for_app):
        """
        Test ../../../../../../tmp/ deep path traversal.

        Multiple ../ sequences should be blocked.
        """
        target_file = "/tmp/vuln_test_deep.json"
        cleanup_file(target_file)

        payload = make_workflow_payload("../../../../../../tmp/vuln_test_deep", "Deep Traversal Test")

        response = requests.post(
            f"{BASE_URL}/api/workflows/",
            json=payload,
            timeout=10
        )

        file_created = os.path.exists(target_file)
        cleanup_file(target_file)

        assert not file_created, "VULNERABLE: Deep path traversal allowed - file was created in /tmp"
        assert response.status_code == 400, f"VULNERABLE: Expected 400 for deep path traversal, got {response.status_code}"

    def test_absolute_path_injection(self, wait_for_app):
        """
        Test /tmp/... absolute path injection.

        os.path.join() with an absolute path as second argument
        ignores the first argument entirely, allowing direct file writes.
        """
        target_file = "/tmp/vuln_test_absolute.json"
        cleanup_file(target_file)

        payload = make_workflow_payload("/tmp/vuln_test_absolute", "Absolute Path Test")

        response = requests.post(
            f"{BASE_URL}/api/workflows/",
            json=payload,
            timeout=10
        )

        file_created = os.path.exists(target_file)
        cleanup_file(target_file)

        assert not file_created, "VULNERABLE: Absolute path injection allowed - file was created in /tmp"
        assert response.status_code == 400, f"VULNERABLE: Expected 400 for absolute path, got {response.status_code}"

    def test_traversal_with_unique_filename(self, wait_for_app):
        """
        Test path traversal with timestamp to ensure unique test.
        """
        timestamp = int(time.time())
        target_file = f"/tmp/vuln_test_{timestamp}.json"
        cleanup_file(target_file)

        payload = make_workflow_payload(f"../../../tmp/vuln_test_{timestamp}", "Timestamped Test")

        response = requests.post(
            f"{BASE_URL}/api/workflows/",
            json=payload,
            timeout=10
        )

        file_created = os.path.exists(target_file)
        cleanup_file(target_file)

        assert not file_created, "VULNERABLE: Path traversal with unique filename - file was created in /tmp"
        assert response.status_code == 400, f"VULNERABLE: Expected 400 for path traversal, got {response.status_code}"

    def test_no_files_escape_storage_directory(self, wait_for_app):
        """
        Comprehensive test: attempt multiple traversal vectors and verify
        no files are created outside the storage directory.
        """
        test_files = [
            "/tmp/escape_test_1.json",
            "/tmp/escape_test_2.json",
            "/tmp/escape_test_3.json",
        ]

        # Clean up before test
        for f in test_files:
            cleanup_file(f)

        # Attack vectors that work in vulnerable version
        attack_ids = [
            "../../../tmp/escape_test_1",
            "../../../../../../tmp/escape_test_2",
            "/tmp/escape_test_3",
        ]

        for attack_id in attack_ids:
            payload = make_workflow_payload(attack_id, "Escape Test")
            try:
                requests.post(
                    f"{BASE_URL}/api/workflows/",
                    json=payload,
                    timeout=10
                )
            except Exception:
                pass

        # Check if any files were created
        files_created = [f for f in test_files if os.path.exists(f)]

        # Clean up
        for f in test_files:
            cleanup_file(f)

        assert len(files_created) == 0, f"VULNERABLE: Files escaped storage directory: {files_created}"
