"""
Vulnerability tests for WeGIA product management module.
These tests verify that the SQL injection vulnerability is properly fixed.

FAIL in vulnerable state (SQL injection is exploitable)
PASS in fixed state (SQL injection is mitigated)
"""

import pytest
import requests
import time
import uuid

BASE_URL = "http://localhost:80"

# Threshold for time-based detection (seconds)
SLEEP_TIME = 3
TIME_THRESHOLD = 2.5  # If response takes longer than this, injection worked


class TestSQLInjectionTimeBasedDescricao:
    """Test time-based blind SQL injection via descricao parameter."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_sleep_injection_basic(self):
        """Test basic SLEEP injection in descricao parameter using OR to bypass short-circuit."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR SLEEP({SLEEP_TIME})-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        # If fixed, response should be quick (< threshold)
        # If vulnerable, response will be delayed by SLEEP_TIME
        assert elapsed < TIME_THRESHOLD, \
            f"Time-based SQL injection detected! Response took {elapsed:.2f}s (expected < {TIME_THRESHOLD}s)"

    def test_sleep_injection_comment_terminator(self):
        """Test SLEEP injection with SQL comment terminator using OR."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR SLEEP({SLEEP_TIME}) OR '",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Time-based SQL injection detected! Response took {elapsed:.2f}s"

    def test_sleep_injection_or_condition(self):
        """Test SLEEP injection with OR condition."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR SLEEP({SLEEP_TIME}) OR '",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Time-based SQL injection detected! Response took {elapsed:.2f}s"

    def test_sleep_injection_benchmark(self):
        """Test SLEEP injection using subquery with SLEEP."""
        unique_id = str(uuid.uuid4())[:8]
        # Use a subquery approach that reliably triggers SLEEP
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR (SELECT * FROM (SELECT SLEEP({SLEEP_TIME}))a)-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        # BENCHMARK should not cause significant delay if properly parameterized
        assert elapsed < TIME_THRESHOLD, \
            f"Time-based SQL injection detected via BENCHMARK! Response took {elapsed:.2f}s"


class TestSQLInjectionUnionBased:
    """Test UNION-based SQL injection attempts with timing detection."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_union_select_injection(self):
        """Test UNION SELECT injection attempt with timing verification."""
        unique_id = str(uuid.uuid4())[:8]
        # Use OR SLEEP to verify SQL is being interpreted
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' UNION SELECT SLEEP({SLEEP_TIME}),1-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        # If vulnerable, UNION SELECT SLEEP will cause delay
        assert elapsed < TIME_THRESHOLD, \
            f"UNION SELECT SQL injection detected! Response took {elapsed:.2f}s"

    def test_union_all_select_version(self):
        """Test UNION ALL SELECT with timing verification."""
        unique_id = str(uuid.uuid4())[:8]
        # Use SLEEP in UNION to verify injection
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' UNION ALL SELECT SLEEP({SLEEP_TIME}),NULL-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        # If vulnerable, UNION ALL SELECT SLEEP will cause delay
        assert elapsed < TIME_THRESHOLD, \
            f"UNION ALL SELECT SQL injection detected! Response took {elapsed:.2f}s"


class TestSQLInjectionErrorBased:
    """Test error-based SQL injection attempts."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_extractvalue_error_injection(self):
        """Test EXTRACTVALUE error-based injection."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": "' AND EXTRACTVALUE(1,CONCAT(0x7e,version()))-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        response = self.session.post(
            f"{BASE_URL}/controle/control.php",
            data=payload,
            timeout=30
        )

        response_text = response.text.lower()
        # Should not expose version through error-based injection
        assert "~5." not in response_text and "~8." not in response_text and "~10." not in response_text, \
            "Error-based SQL injection may have exposed version"

    def test_updatexml_error_injection(self):
        """Test UPDATEXML error-based injection."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": "' AND UPDATEXML(1,CONCAT(0x7e,database()),1)-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        response = self.session.post(
            f"{BASE_URL}/controle/control.php",
            data=payload,
            timeout=30
        )

        response_text = response.text.lower()
        # Should not expose database name through error injection
        assert "~wegia" not in response_text, \
            "Error-based SQL injection may have exposed database name"

    def test_sql_syntax_error_exposure(self):
        """Test that SQL syntax errors are not exposed."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": "' INVALID SQL SYNTAX HERE",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        response = self.session.post(
            f"{BASE_URL}/controle/control.php",
            data=payload,
            timeout=30
        )

        response_text = response.text.lower()
        # Should not expose MySQL-specific error details
        # Note: "syntax error" alone may appear in PHP session warnings, so use SQL-specific patterns
        sensitive_patterns = ["near 'invalid", "you have an error in your sql", "pdoexception", "sqlstate"]
        for pattern in sensitive_patterns:
            assert pattern not in response_text, \
                f"SQL error message exposed in response: found '{pattern}'"


class TestSQLInjectionBooleanBased:
    """Test boolean-based blind SQL injection attempts with timing verification."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_boolean_true_false_timing(self):
        """Test boolean-based injection using timing to verify SQL interpretation."""
        unique_id = str(uuid.uuid4())[:8]

        # Boolean condition with SLEEP - if SQL is interpreted, SLEEP will execute
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR (SELECT SLEEP({SLEEP_TIME}) FROM dual WHERE 1=1)-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        # If vulnerable, SQL boolean with SLEEP will cause delay
        assert elapsed < TIME_THRESHOLD, \
            f"Boolean-based SQL injection detected! Response took {elapsed:.2f}s"


class TestSQLInjectionSpecialPayloads:
    """Test various SQL injection payloads and bypass techniques."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_stacked_queries(self):
        """Test stacked queries injection using subquery SLEEP."""
        unique_id = str(uuid.uuid4())[:8]
        # Use a different syntax to ensure SLEEP always executes
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR 1=(SELECT SLEEP({SLEEP_TIME}))-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Stacked query injection may have succeeded! Response took {elapsed:.2f}s"

    def test_url_encoded_payload(self):
        """Test URL-encoded SQL injection payload using OR SLEEP."""
        unique_id = str(uuid.uuid4())[:8]
        # OR SLEEP payload (will be URL-encoded by requests automatically)
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR SLEEP({SLEEP_TIME})-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"URL-encoded SQL injection may have succeeded! Response took {elapsed:.2f}s"

    def test_case_variation_bypass(self):
        """Test case variation to bypass filters using OR."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' oR sLeEp({SLEEP_TIME}) oR '",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Case variation SQL injection may have succeeded! Response took {elapsed:.2f}s"

    def test_double_encoding_bypass(self):
        """Test double URL encoding bypass attempt using OR."""
        unique_id = str(uuid.uuid4())[:8]
        # Standard OR SLEEP payload
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR SLEEP({SLEEP_TIME}) OR '",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Double encoding bypass may have succeeded! Response took {elapsed:.2f}s"

    def test_multiline_injection(self):
        """Test multiline SQL injection using OR."""
        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}'\nOR SLEEP({SLEEP_TIME})\nOR '",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"Multiline SQL injection may have succeeded! Response took {elapsed:.2f}s"


class TestSQLInjectionViaJSON:
    """Test SQL injection via different content types."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', 'test_session_id')

    def test_json_payload_injection(self):
        """Test SQL injection via additional form encoding variation."""
        # Note: The PHP endpoint partially parses JSON but uses $_REQUEST for some params
        # This test uses standard form encoding with a variation of the SLEEP payload

        unique_id = str(uuid.uuid4())[:8]
        payload = {
            "nomeClasse": "ProdutoControle",
            "metodo": "incluir",
            "descricao": f"{unique_id}' OR IF(1=1,SLEEP({SLEEP_TIME}),0)-- -",
            "codigo": f"INJTST{unique_id}",
            "preco": "1.00",
            "id_categoria": "1",
            "id_unidade": "1"
        }

        start_time = time.time()
        try:
            response = self.session.post(
                f"{BASE_URL}/controle/control.php",
                data=payload,
                timeout=30
            )
        except requests.exceptions.Timeout:
            elapsed = 30
        else:
            elapsed = time.time() - start_time

        assert elapsed < TIME_THRESHOLD, \
            f"IF-based SQL injection may have succeeded! Response took {elapsed:.2f}s"
