diff --git a/poc/flag.html b/poc/flag.html
new file mode 100644
index 0000000..9586564
--- /dev/null
+++ b/poc/flag.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<html>
+<body>
+
+<h1>CISPA</h1>
+<p>vulns4js! is here.</p>
+
+</body>
+</html> 
\ No newline at end of file
diff --git a/poc/fast-http.test.js b/poc/fast-http.test.js
new file mode 100644
index 0000000..8ba5e11
--- /dev/null
+++ b/poc/fast-http.test.js
@@ -0,0 +1,77 @@
+// poc/fast-http.test.js
+const path = require("path");
+const fs = require("fs");
+const http = require("http");
+
+const pathToFlag = path.resolve(__dirname, "./flag.html");
+
+function genstr() {
+  // craft a long path traversal that tries to reach the flag file
+  return "/..".repeat(50) + pathToFlag;
+}
+
+test("Path traversal should NOT leak file contents (fix should make this pass)", (done) => {
+  expect.assertions(1);
+
+  // ensure flag file with known content exists for the test
+  const flagContent = "<!DOCTYPE html>\n<html>\n<body>\n\n<h1>CISPA</h1>\n<p>vulns4js! is here.</p>\n\n</body>\n</html>";
+  fs.writeFileSync(pathToFlag, flagContent, "utf8");
+
+  // require the vulnerable module under test
+  const Server = require("fast-http");
+
+  // start the server (use the same constructor/signature from the PoC)
+  const srv = new Server(8080, "./", true);
+
+  // small delay to let the server start listening
+  setTimeout(() => {
+    const options = {
+      hostname: "127.0.0.1",
+      port: 8080,
+      path: genstr(), // send the crafted path-as-is
+      method: "GET",
+    };
+
+    const req = http.request(options, (res) => {
+      let body = "";
+      res.setEncoding("utf8");
+      res.on("data", (chunk) => (body += chunk));
+      res.on("end", () => {
+        // cleanup server and flag file
+        try {
+          if (srv && typeof srv.close === "function") srv.close();
+        } catch (e) {
+          // ignore
+        }
+        try {
+          if (fs.existsSync(pathToFlag)) fs.unlinkSync(pathToFlag);
+        } catch (e) {
+          // ignore
+        }
+
+        // EXPECTATION:
+        // We expect the server NOT to return the exact flag file contents.
+        // - If the server is vulnerable (before fix) it will return the file and this expectation will FAIL.
+        // - After the fix (no path traversal) the server will not return the flag contents and the test will PASS.
+        expect(body).not.toBe(flagContent);
+
+        done();
+      });
+    });
+
+    req.on("error", (err) => {
+      // on network error treat as safe (no leak) and pass the expectation
+      try {
+        if (srv && typeof srv.close === "function") srv.close();
+      } catch (e) {}
+      try {
+        if (fs.existsSync(pathToFlag)) fs.unlinkSync(pathToFlag);
+      } catch (e) {}
+      expect(true).toBe(true);
+      done();
+    });
+
+    req.end();
+  }, 100);
+});
+
