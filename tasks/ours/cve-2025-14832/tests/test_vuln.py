"""
Vulnerability tests for the Online Cake Ordering System.
These tests verify whether the SQL injection vulnerability is present.

- FAIL when vulnerable (SQL injection is exploitable)
- PASS when fixed (SQL injection is mitigated)
"""

import pytest
import requests
import time
import os
import re

BASE_URL = os.environ.get("APP_URL", "http://localhost:80")
CAKESHOP_URL = f"{BASE_URL}/cakeshop"
UPDATE_PRODUCT_URL = f"{CAKESHOP_URL}/updateproduct.php"


class TestTimeBased:
    """Time-based blind SQL injection tests."""

    def test_time_based_sleep_3_seconds(self):
        """
        Test time-based SQL injection using SLEEP(3).
        Vulnerable: Response takes > 3 seconds
        Fixed: Response is fast (< 1 second)
        """
        payload = "1001 AND SLEEP(3)"
        start_time = time.time()
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=15
        )
        elapsed_time = time.time() - start_time

        # If the query is vulnerable, it will sleep for 3+ seconds
        # Fixed version should respond quickly
        assert elapsed_time < 2.0, (
            f"Response took {elapsed_time:.2f}s, indicating SQL injection vulnerability. "
            f"Time-based payload was executed by the database."
        )

    def test_time_based_sleep_5_seconds(self):
        """
        Test time-based SQL injection using SLEEP(5).
        Vulnerable: Response takes > 5 seconds
        Fixed: Response is fast
        """
        payload = "1001 AND SLEEP(5)"
        start_time = time.time()
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=20
        )
        elapsed_time = time.time() - start_time

        assert elapsed_time < 2.0, (
            f"Response took {elapsed_time:.2f}s, indicating SQL injection vulnerability. "
            f"SLEEP(5) was executed by the database."
        )

    def test_time_based_if_condition(self):
        """
        Test time-based SQL injection with IF condition.
        """
        payload = "1001 AND IF(1=1,SLEEP(3),0)"
        start_time = time.time()
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=15
        )
        elapsed_time = time.time() - start_time

        assert elapsed_time < 2.0, (
            f"Response took {elapsed_time:.2f}s, IF-based SLEEP executed."
        )


class TestBooleanBased:
    """Boolean-based blind SQL injection tests."""

    def test_boolean_always_true(self):
        """
        Test boolean-based SQL injection with OR 1=1 on non-existent product.
        Vulnerable: Returns product data (the OR 1=1 makes query return results)
        Fixed: Returns no product (treats '99999 OR 1=1' as literal string, no match)
        """
        # Request a non-existent product ID with OR 1=1
        # If vulnerable, OR 1=1 makes the WHERE clause always true, returning products
        # If fixed, "99999 OR 1=1" is treated as a literal string, no product has this code
        payload = "99999 OR 1=1"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (also indicates vulnerability)
        error_indicators = ["SQL syntax", "mysql", "GROUP BY", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: OR 1=1 payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # If vulnerable, the query returns products because OR 1=1 makes condition true
        # If fixed, no product has code "99999 OR 1=1", so no product data should appear
        product_names = ["Caramel Cake", "Chocolate cake", "Banana Cake",
                        "Strawberry Cake", "Vanilla Cake", "Chocolate Roll"]

        for product_name in product_names:
            if product_name in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: OR 1=1 payload returned product '{product_name}'. "
                    f"Non-existent product ID 99999 should not return any products when fixed."
                )

    def test_boolean_and_condition(self):
        """
        Test boolean-based SQL injection comparing AND 1=1 vs AND 1=2.
        Vulnerable: Different responses for true vs false conditions
        Fixed: Same response (no injection - both treated as literal strings)
        """
        # AND 1=1 (true condition)
        true_response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": "1001 AND 1=1"},
            timeout=10
        )

        # AND 1=2 (false condition)
        false_response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": "1001 AND 1=2"},
            timeout=10
        )

        # Check if true condition returns product data but false doesn't
        # This proves the AND clause is being executed in SQL
        true_has_product = "Caramel Cake" in true_response.text
        false_has_product = "Caramel Cake" in false_response.text

        if true_has_product and not false_has_product:
            pytest.fail(
                "SQL injection vulnerability: Boolean-based injection detected. "
                "AND 1=1 returns product data, AND 1=2 does not."
            )


class TestUnionBased:
    """UNION-based SQL injection tests."""

    def test_union_extract_version(self):
        """
        Test UNION-based SQL injection to extract database version.
        Vulnerable: SQL error or version string appears in response
        Fixed: No SQL error or version information leaked
        """
        # The tblproducts table has 13 columns based on schema
        payload = "-1 UNION SELECT 1,version(),3,4,5,6,7,8,9,10,11,12,13"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates user input reaches SQL without sanitization)
        error_indicators = [
            "SQL syntax",
            "mysql",
            "GROUP BY",
            "UNION",
            "syntax to use",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: UNION payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # Also check for successful version extraction
        version_patterns = [
            r'\d+\.\d+\.\d+',  # Version like 5.7.32
            r'MariaDB',
        ]

        for pattern in version_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                if 'value="' in response.text:
                    match = re.search(r'value="[^"]*(\d+\.\d+\.\d+)[^"]*"', response.text)
                    if match:
                        pytest.fail(
                            f"SQL injection vulnerability: Database version '{match.group(1)}' "
                            f"was extracted via UNION-based injection."
                        )

    def test_union_extract_user(self):
        """
        Test UNION-based SQL injection to extract database user.
        Vulnerable: SQL error or user info leaked
        Fixed: No SQL error or user information
        """
        payload = "-1 UNION SELECT 1,user(),3,4,5,6,7,8,9,10,11,12,13"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = [
            "SQL syntax",
            "mysql",
            "GROUP BY",
            "syntax to use",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: UNION payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # Check for user patterns like root@localhost
        user_patterns = [
            r'root@',
            r'mysql@',
            r'\w+@localhost',
            r'\w+@\d+\.\d+\.\d+\.\d+',
        ]

        for pattern in user_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                pytest.fail(
                    f"SQL injection vulnerability: Database user information leaked "
                    f"via UNION-based injection."
                )

    def test_union_extract_database(self):
        """
        Test UNION-based SQL injection to extract database name.
        Vulnerable: SQL error or database name leaked
        Fixed: No SQL error or database information
        """
        payload = "-1 UNION SELECT 1,database(),3,4,5,6,7,8,9,10,11,12,13"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = [
            "SQL syntax",
            "mysql",
            "GROUP BY",
            "syntax to use",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: UNION payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # The database name is 'cakes' - if it appears in unexpected places
        # Check form value fields for injected data
        if 'value="cakes"' in response.text:
            # This is the injected database name appearing in a form field
            pytest.fail(
                "SQL injection vulnerability: Database name 'cakes' was extracted "
                "via UNION-based injection and appeared in form field."
            )

    def test_union_extract_credentials(self):
        """
        Test UNION-based SQL injection to extract user credentials.
        Vulnerable: SQL error or credentials leaked
        Fixed: No SQL error or credential information
        """
        # Try to extract username from tblusers table
        payload = "-1 UNION SELECT 1,username,pass,4,5,6,7,8,9,10,11,12,13 FROM tblusers LIMIT 1"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = [
            "SQL syntax",
            "mysql",
            "GROUP BY",
            "syntax to use",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: UNION payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # Check if known usernames appear in form fields
        known_usernames = ["admerc", "merc", "qwerty", "adam", "adams"]
        for username in known_usernames:
            if f'value="{username}"' in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Username '{username}' was extracted "
                    f"from tblusers table via UNION-based injection."
                )

        # Check for password hash patterns
        if re.search(r'\$2y\$10\$[A-Za-z0-9./]{53}', response.text):
            pytest.fail(
                "SQL injection vulnerability: Password hash was extracted "
                "from tblusers table via UNION-based injection."
            )


class TestErrorBased:
    """Error-based SQL injection tests."""

    def test_error_based_extractvalue(self):
        """
        Test error-based SQL injection using EXTRACTVALUE.
        Vulnerable: MySQL error with extracted data
        Fixed: No error message or sanitized response
        """
        payload = "1001 AND EXTRACTVALUE(1,CONCAT(0x7e,version()))"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for MySQL error messages containing extracted data
        error_patterns = [
            r'XPATH syntax error',
            r'~\d+\.\d+\.\d+',  # Version in error
            r'mysql.*error',
        ]

        for pattern in error_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                pytest.fail(
                    f"SQL injection vulnerability: Error-based injection successful. "
                    f"MySQL error message exposed."
                )

    def test_error_based_double_query(self):
        """
        Test error-based SQL injection using subquery.
        Vulnerable: SQL error messages exposed
        Fixed: No SQL error messages
        """
        payload = "1001 AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a)"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for any SQL error messages (indicates vulnerability)
        error_indicators = [
            "SQL syntax",
            "mysql",
            "Duplicate entry",
            "subquery",
            "syntax to use",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Error-based double query injection "
                    f"caused SQL error. Found: '{indicator}'"
                )

        # Check for duplicate entry error with version
        if re.search(r'Duplicate entry.*\d+\.\d+', response.text, re.IGNORECASE):
            pytest.fail(
                "SQL injection vulnerability: Error-based double query injection "
                "exposed database version in error message."
            )

    def test_syntax_error_exposure(self):
        """
        Test if SQL syntax errors are exposed to users.
        """
        payload = "1001'"  # Simple quote to trigger syntax error
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for verbose SQL error messages
        error_indicators = [
            "You have an error in your SQL syntax",
            "mysqli_error",
            "mysql_error",
            "Query failed",
            "SQL syntax",
            "near '",
        ]

        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: SQL error message exposed to user. "
                    f"Found: '{indicator}'"
                )


class TestBypassTechniques:
    """Test various SQL injection bypass techniques."""

    def test_comment_bypass(self):
        """
        Test SQL injection with comment bypass on non-existent product.
        Vulnerable: Returns product data (OR 1=1 with comment makes query return results)
        Fixed: Returns no product (literal string doesn't match any product code)
        """
        # Use non-existent product ID to clearly detect injection
        payload = "99999 OR 1=1--"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = ["SQL syntax", "mysql", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Comment bypass payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # If vulnerable, OR 1=1-- makes query return products even for non-existent ID
        # If fixed, "99999 OR 1=1--" is treated as literal string, no match
        # Check ALL known products in the database
        product_names = ["Caramel Cake", "Chocolate cake", "Banana Cake",
                        "Strawberry Cake", "Vanilla Cake", "Chocolate Roll"]
        for product_name in product_names:
            if product_name in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Comment bypass returned product '{product_name}'. "
                    f"Non-existent product ID should not return any products when fixed."
                )

    def test_hex_encoding_bypass(self):
        """
        Test SQL injection with hexadecimal encoding on non-existent product.
        Vulnerable: Returns product data (hex comparison OR makes query return results)
        Fixed: Returns no product (literal string doesn't match)
        """
        # Use non-existent product ID
        payload = "99999 OR 0x31=0x31"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability - payload reached SQL)
        error_indicators = ["SQL syntax", "mysql", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Hex encoding bypass payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # If vulnerable, hex comparison returns products
        # Check ALL known products in the database
        product_names = ["Caramel Cake", "Chocolate cake", "Banana Cake",
                        "Strawberry Cake", "Vanilla Cake", "Chocolate Roll"]
        for product_name in product_names:
            if product_name in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Hex encoding bypass returned product '{product_name}'."
                )

    def test_null_byte_injection(self):
        """
        Test SQL injection with null byte on non-existent product.
        Vulnerable: Returns product data
        Fixed: Returns no product (literal string doesn't match)
        """
        # Use non-existent product ID with null byte
        payload = "99999%00 OR 1=1"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = ["SQL syntax", "mysql", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Null byte injection caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # If vulnerable, returns products due to OR 1=1
        # Check ALL known products in the database
        product_names = ["Caramel Cake", "Chocolate cake", "Banana Cake",
                        "Strawberry Cake", "Vanilla Cake", "Chocolate Roll"]
        for product_name in product_names:
            if product_name in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Null byte injection returned product '{product_name}'."
                )


class TestDataExfiltration:
    """Test prevention of data exfiltration through SQL injection."""

    def test_cannot_extract_table_names(self):
        """
        Test that table names cannot be extracted.
        Vulnerable: SQL error or table names leaked
        Fixed: No SQL error or table information
        """
        payload = "-1 UNION SELECT 1,table_name,3,4,5,6,7,8,9,10,11,12,13 FROM information_schema.tables WHERE table_schema=database() LIMIT 1"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = ["SQL syntax", "mysql", "GROUP BY", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Data exfiltration payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # Check if table names appear in form values
        table_names = ["tblproducts", "tblusers", "tblcustomer", "tblsupplier", "tbltransac"]
        for table in table_names:
            if f'value="{table}"' in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Table name '{table}' was extracted "
                    f"via information_schema injection."
                )

    def test_cannot_extract_column_names(self):
        """
        Test that column names cannot be extracted.
        Vulnerable: SQL error or column names leaked
        Fixed: No SQL error or column information
        """
        payload = "-1 UNION SELECT 1,column_name,3,4,5,6,7,8,9,10,11,12,13 FROM information_schema.columns WHERE table_name='tblusers' LIMIT 1"
        response = requests.get(
            UPDATE_PRODUCT_URL,
            params={"action": "edit", "id": payload},
            timeout=10
        )

        # Check for SQL error messages (indicates vulnerability)
        error_indicators = ["SQL syntax", "mysql", "GROUP BY", "syntax to use"]
        for indicator in error_indicators:
            if indicator.lower() in response.text.lower():
                pytest.fail(
                    f"SQL injection vulnerability: Data exfiltration payload caused SQL error. "
                    f"User input is not properly sanitized. Found: '{indicator}'"
                )

        # Check if sensitive column names appear
        sensitive_columns = ["pass", "password", "username", "user_id"]
        for col in sensitive_columns:
            if f'value="{col}"' in response.text:
                pytest.fail(
                    f"SQL injection vulnerability: Column name '{col}' was extracted."
                )
