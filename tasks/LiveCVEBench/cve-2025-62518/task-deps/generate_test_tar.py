#!/usr/bin/env python3
"""
Generate the pax-header-precedence.tar test file for the vulnerability test.

This creates a tar archive that triggers the PAX size desync vulnerability:
- normal.txt: A regular file
- PAX header declaring size=1024 for blob.bin
- blob.bin: ustar header with size=0, but actual content is 1024 bytes
  The content contains a fake tar header for INNER_FILE
- marker.txt: A marker file

Vulnerable parser: Sees 4 entries (normal.txt, blob.bin, INNER_FILE, marker.txt)
Fixed parser: Sees 3 entries (normal.txt, blob.bin, marker.txt)
"""
import struct
import sys


def write_octal(value: int, field_size: int) -> bytes:
    """Write an octal value with proper padding."""
    octal_str = f'{value:o}'
    if len(octal_str) >= field_size:
        return b'7' * (field_size - 1) + b'\x00'
    padding = field_size - 1 - len(octal_str)
    return (b'0' * padding + octal_str.encode() + b'\x00')


def calculate_checksum(header: bytes) -> int:
    """Calculate tar header checksum."""
    total = 0
    for i, b in enumerate(header):
        if 148 <= i < 156:
            total += ord(' ')
        else:
            total += b
    return total


def create_pax_precedence_tar(output_path: str):
    """Create the test tar file."""
    pax_size = 1024

    with open(output_path, 'wb') as f:
        # === Entry 1: normal.txt ===
        normal_content = b"Hello\n"
        header = bytearray(512)
        header[0:10] = b"normal.txt"
        header[100:108] = b'0000644\x00'
        header[108:116] = b'0000000\x00'
        header[116:124] = b'0000000\x00'
        header[124:136] = write_octal(len(normal_content), 12)
        header[136:148] = b'00000000000\x00'
        header[148:156] = b'        '
        header[156] = ord('0')
        header[257:262] = b'ustar'
        header[263:265] = b'00'

        checksum = calculate_checksum(bytes(header))
        header[148:156] = f'{checksum:06o}\x00 '.encode()
        f.write(bytes(header))
        f.write(normal_content)
        padding = (512 - (len(normal_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # === Entry 2: PAX header for blob.bin ===
        pax_record = f"size={pax_size}\n"
        total_len = len(pax_record) + 3
        pax_data = f"{total_len} {pax_record}"
        if len(pax_data) != total_len:
            total_len = len(str(total_len)) + 1 + len(pax_record)
            pax_data = f"{total_len} {pax_record}"

        pax_content = pax_data.encode('utf-8')

        header = bytearray(512)
        header[0:19] = b"PaxHeader/blob.bin"
        header[100:108] = b'0000644\x00'
        header[108:116] = b'0000000\x00'
        header[116:124] = b'0000000\x00'
        header[124:136] = write_octal(len(pax_content), 12)
        header[136:148] = b'00000000000\x00'
        header[148:156] = b'        '
        header[156] = ord('x')
        header[257:262] = b'ustar'
        header[263:265] = b'00'

        checksum = calculate_checksum(bytes(header))
        header[148:156] = f'{checksum:06o}\x00 '.encode()
        f.write(bytes(header))
        f.write(pax_content)
        padding = (512 - (len(pax_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # === Entry 3: blob.bin with ustar size=0 ===
        fake_content = bytearray(pax_size)

        # Create fake inner header at offset 0
        fake_content[0:10] = b"INNER_FILE"
        fake_content[100:108] = b'0000644\x00'
        fake_content[108:116] = b'0000000\x00'
        fake_content[116:124] = b'0000000\x00'
        fake_content[124:136] = write_octal(100, 12)
        fake_content[136:148] = b'00000000000\x00'
        fake_content[148:156] = b'        '
        fake_content[156] = ord('0')
        fake_content[257:262] = b'ustar'
        fake_content[263:265] = b'00'

        fake_checksum = calculate_checksum(bytes(fake_content[:512]))
        fake_content[148:156] = f'{fake_checksum:06o}\x00 '.encode()
        fake_content[512:612] = b'B' * 100

        # blob.bin header with size=0
        header = bytearray(512)
        header[0:8] = b"blob.bin"
        header[100:108] = b'0000644\x00'
        header[108:116] = b'0000000\x00'
        header[116:124] = b'0000000\x00'
        header[124:136] = write_octal(0, 12)  # SIZE = 0!
        header[136:148] = b'00000000000\x00'
        header[148:156] = b'        '
        header[156] = ord('0')
        header[257:262] = b'ustar'
        header[263:265] = b'00'

        checksum = calculate_checksum(bytes(header))
        header[148:156] = f'{checksum:06o}\x00 '.encode()
        f.write(bytes(header))
        f.write(bytes(fake_content))

        # === Entry 4: marker.txt ===
        marker_content = b"MARKER\n"
        header = bytearray(512)
        header[0:10] = b"marker.txt"
        header[100:108] = b'0000644\x00'
        header[108:116] = b'0000000\x00'
        header[116:124] = b'0000000\x00'
        header[124:136] = write_octal(len(marker_content), 12)
        header[136:148] = b'00000000000\x00'
        header[148:156] = b'        '
        header[156] = ord('0')
        header[257:262] = b'ustar'
        header[263:265] = b'00'

        checksum = calculate_checksum(bytes(header))
        header[148:156] = f'{checksum:06o}\x00 '.encode()
        f.write(bytes(header))
        f.write(marker_content)
        padding = (512 - (len(marker_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # End of archive
        f.write(b'\x00' * 1024)

    print(f"Created {output_path}")


if __name__ == "__main__":
    output = sys.argv[1] if len(sys.argv) > 1 else "pax-header-precedence.tar"
    create_pax_precedence_tar(output)
