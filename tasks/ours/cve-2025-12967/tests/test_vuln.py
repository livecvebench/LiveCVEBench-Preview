"""
Vulnerability tests for search_path hijacking.
These tests verify that unqualified function calls are vulnerable to shadowing.

Test behavior:
- FAIL in vulnerable state (unqualified calls execute attacker's function)
- PASS in fixed state (qualified calls bypass attacker's function)
"""
import pytest
import psycopg2
import os
import time
import subprocess

# Database connection parameters
DB_HOST = os.environ.get('DB_HOST', 'localhost')
DB_PORT = os.environ.get('DB_PORT', '5432')
DB_NAME = os.environ.get('DB_NAME', 'testdb')
DB_USER = os.environ.get('DB_USER', 'postgres')
DB_PASS = os.environ.get('DB_PASS', 'postgres')

# Test users
ATTACKER_USER = 'attacker'
ATTACKER_PASS = 'attacker123'
VICTIM_USER = 'victim'
VICTIM_PASS = 'victim123'


def get_connection(user=None, password=None):
    """Get a database connection."""
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        dbname=DB_NAME,
        user=user or DB_USER,
        password=password or DB_PASS
    )


def wait_for_db(max_retries=30, delay=1):
    """Wait for database to be ready."""
    for i in range(max_retries):
        try:
            conn = get_connection()
            conn.close()
            return True
        except psycopg2.OperationalError:
            time.sleep(delay)
    return False


def setup_test_environment():
    """Set up test users and attack environment."""
    conn = get_connection()
    conn.autocommit = True
    cursor = conn.cursor()

    # Create test users if they don't exist
    try:
        cursor.execute(f"CREATE USER {ATTACKER_USER} WITH PASSWORD '{ATTACKER_PASS}'")
    except psycopg2.errors.DuplicateObject:
        pass

    try:
        cursor.execute(f"CREATE USER {VICTIM_USER} WITH PASSWORD '{VICTIM_PASS}' SUPERUSER")
    except psycopg2.errors.DuplicateObject:
        pass

    # Grant attacker the ability to create objects in public schema
    cursor.execute(f"GRANT USAGE, CREATE ON SCHEMA public TO {ATTACKER_USER}")

    # Create attack tracking table
    cursor.execute("""
        DROP TABLE IF EXISTS public.attack_log;
        CREATE TABLE public.attack_log (
            id SERIAL PRIMARY KEY,
            function_name TEXT,
            caller_user TEXT,
            attack_time TIMESTAMP DEFAULT NOW()
        );
        GRANT ALL ON public.attack_log TO PUBLIC;
        GRANT USAGE, SELECT ON SEQUENCE public.attack_log_id_seq TO PUBLIC;
    """)

    cursor.close()
    conn.close()


def create_trojan_function(func_name, return_type, return_value):
    """Create a trojan function in public schema that logs when called."""
    conn = get_connection(ATTACKER_USER, ATTACKER_PASS)
    conn.autocommit = True
    cursor = conn.cursor()

    # Drop existing function if present
    cursor.execute(f"DROP FUNCTION IF EXISTS public.{func_name}()")

    # Create trojan function
    cursor.execute(f"""
        CREATE OR REPLACE FUNCTION public.{func_name}()
        RETURNS {return_type} AS $$
        BEGIN
            -- Log the attack
            INSERT INTO public.attack_log (function_name, caller_user)
            VALUES ('{func_name}', current_user);
            -- Return a value that indicates hijacking
            RETURN {return_value};
        END;
        $$ LANGUAGE plpgsql SECURITY INVOKER;
    """)

    cursor.close()
    conn.close()


def clear_attack_log():
    """Clear the attack log table."""
    conn = get_connection()
    conn.autocommit = True
    cursor = conn.cursor()
    cursor.execute("TRUNCATE public.attack_log")
    cursor.close()
    conn.close()


def get_attack_log_count(function_name=None):
    """Get the number of entries in the attack log."""
    conn = get_connection()
    cursor = conn.cursor()
    if function_name:
        cursor.execute(
            "SELECT COUNT(*) FROM public.attack_log WHERE function_name = %s",
            (function_name,)
        )
    else:
        cursor.execute("SELECT COUNT(*) FROM public.attack_log")
    count = cursor.fetchone()[0]
    cursor.close()
    conn.close()
    return count


def execute_app_query(query):
    """
    Execute a query as the 'victim' user, simulating the application.
    This simulates what the vulnerable application does internally.
    """
    # Read the query from the application's db_queries.py file
    # The application uses these queries internally
    conn = get_connection(VICTIM_USER, VICTIM_PASS)
    conn.autocommit = True  # Enable autocommit so trojan INSERTs are persisted
    cursor = conn.cursor()
    cursor.execute(query)
    result = cursor.fetchone()[0]
    cursor.close()
    conn.close()
    return result


def get_app_version_query():
    """Read the version query from the application."""
    try:
        with open('/app/src/db_queries.py', 'r') as f:
            content = f.read()
            # Extract VERSION_QUERY value
            for line in content.split('\n'):
                if 'VERSION_QUERY' in line and '=' in line:
                    # Parse the query string
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        query = parts[1].strip().strip('"').strip("'")
                        return query
    except Exception:
        pass
    # Default vulnerable query if we can't read the file
    return "SELECT version()"


def get_app_database_query():
    """Read the database query from the application."""
    try:
        with open('/app/src/db_queries.py', 'r') as f:
            content = f.read()
            for line in content.split('\n'):
                if 'DATABASE_QUERY' in line and '=' in line:
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        query = parts[1].strip().strip('"').strip("'")
                        return query
    except Exception:
        pass
    return "SELECT current_database()"


def get_app_recovery_query():
    """Read the recovery status query from the application."""
    try:
        with open('/app/src/db_queries.py', 'r') as f:
            content = f.read()
            for line in content.split('\n'):
                if 'RECOVERY_QUERY' in line and '=' in line:
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        query = parts[1].strip().strip('"').strip("'")
                        return query
    except Exception:
        pass
    return "SELECT pg_is_in_recovery()"


def get_app_time_query():
    """Read the time query from the application."""
    try:
        with open('/app/src/db_queries.py', 'r') as f:
            content = f.read()
            for line in content.split('\n'):
                if 'TIME_QUERY' in line and '=' in line:
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        query = parts[1].strip().strip('"').strip("'")
                        return query
    except Exception:
        pass
    return "SELECT now()"


class TestSearchPathHijacking:
    """Test cases for search_path function hijacking vulnerability."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment before each test."""
        assert wait_for_db(), "Database is not ready"
        setup_test_environment()
        clear_attack_log()

    def test_version_function_not_hijacked(self):
        """
        Test that version() query is not susceptible to hijacking.

        This test:
        1. Creates a trojan version() function in public schema
        2. Executes the application's version query as victim
        3. Verifies the trojan was NOT executed (attack log empty)

        FAIL = Trojan executed (vulnerability exists)
        PASS = Trojan not executed (function properly qualified)
        """
        # Attacker creates trojan function
        create_trojan_function('version', 'text', "'HIJACKED-version'")

        # Get the query the application uses
        query = get_app_version_query()

        # Execute as victim (simulating the application)
        result = execute_app_query(query)

        # Check if attack was logged - if so, vulnerability exists
        attack_count = get_attack_log_count('version')

        # The test passes if no attack was logged AND result is legitimate
        assert attack_count == 0, \
            f"version() was hijacked! Attack logged {attack_count} times. " \
            f"Query used: {query}"
        assert "PostgreSQL" in result, \
            f"version() returned unexpected value: {result}. Query: {query}"

    def test_current_database_function_not_hijacked(self):
        """
        Test that current_database() query is not susceptible to hijacking.

        FAIL = Trojan executed (vulnerability exists)
        PASS = Trojan not executed (function properly qualified)
        """
        # Attacker creates trojan function
        create_trojan_function('current_database', 'text', "'HIJACKED-database'")

        # Get the query the application uses
        query = get_app_database_query()

        # Execute as victim
        result = execute_app_query(query)

        # Check if attack was logged
        attack_count = get_attack_log_count('current_database')

        assert attack_count == 0, \
            f"current_database() was hijacked! Attack logged {attack_count} times. " \
            f"Query used: {query}"
        assert result == DB_NAME, \
            f"current_database() returned unexpected value: {result}. Query: {query}"

    def test_pg_is_in_recovery_function_not_hijacked(self):
        """
        Test that pg_is_in_recovery() query is not susceptible to hijacking.

        FAIL = Trojan executed (vulnerability exists)
        PASS = Trojan not executed (function properly qualified)
        """
        # Attacker creates trojan function
        create_trojan_function('pg_is_in_recovery', 'boolean', 'true')

        # Get the query the application uses
        query = get_app_recovery_query()

        # Execute as victim
        result = execute_app_query(query)

        # Check if attack was logged
        attack_count = get_attack_log_count('pg_is_in_recovery')

        assert attack_count == 0, \
            f"pg_is_in_recovery() was hijacked! Attack logged {attack_count} times. " \
            f"Query used: {query}"

    def test_now_function_not_hijacked(self):
        """
        Test that now() query is not susceptible to hijacking.

        FAIL = Trojan executed (vulnerability exists)
        PASS = Trojan not executed (function properly qualified)
        """
        # Attacker creates trojan function that returns a suspicious timestamp
        create_trojan_function('now', 'timestamp with time zone',
                               "'1970-01-01 00:00:00+00'::timestamptz")

        # Get the query the application uses
        query = get_app_time_query()

        # Execute as victim
        result = execute_app_query(query)

        # Check if attack was logged
        attack_count = get_attack_log_count('now')

        assert attack_count == 0, \
            f"now() was hijacked! Attack logged {attack_count} times. " \
            f"Query used: {query}"
        # Also verify the timestamp is reasonable (not 1970)
        assert result.year >= 2020, \
            f"now() returned suspicious timestamp: {result}. Query: {query}"


class TestMultipleHijackingAttempts:
    """Test multiple simultaneous hijacking attempts."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment before each test."""
        assert wait_for_db(), "Database is not ready"
        setup_test_environment()
        clear_attack_log()

    def test_all_functions_secure_simultaneously(self):
        """
        Test that all functions are secure when all trojans are present.

        This simulates a sophisticated attacker who shadows multiple functions.
        """
        # Create trojan functions for all commonly used functions
        create_trojan_function('version', 'text', "'HIJACKED'")
        create_trojan_function('current_database', 'text', "'HIJACKED'")
        create_trojan_function('pg_is_in_recovery', 'boolean', 'true')
        create_trojan_function('now', 'timestamp with time zone',
                               "'1970-01-01 00:00:00+00'::timestamptz")

        # Execute all application queries
        queries = [
            ('version', get_app_version_query()),
            ('current_database', get_app_database_query()),
            ('pg_is_in_recovery', get_app_recovery_query()),
            ('now', get_app_time_query()),
        ]

        for func_name, query in queries:
            execute_app_query(query)

        # Check total attacks logged
        total_attacks = get_attack_log_count()

        assert total_attacks == 0, \
            f"Functions were hijacked! Total attacks: {total_attacks}"


class TestDifferentHijackingTechniques:
    """Test various hijacking techniques and bypasses."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment before each test."""
        assert wait_for_db(), "Database is not ready"
        setup_test_environment()
        clear_attack_log()

    def test_case_sensitivity_bypass(self):
        """
        Test that case variations don't bypass protection.
        PostgreSQL function names are case-insensitive.
        """
        # Try creating trojans with different case
        conn = get_connection(ATTACKER_USER, ATTACKER_PASS)
        conn.autocommit = True
        cursor = conn.cursor()

        cursor.execute("""
            CREATE OR REPLACE FUNCTION public.VERSION()
            RETURNS text AS $$
            BEGIN
                INSERT INTO public.attack_log (function_name, caller_user)
                VALUES ('VERSION_uppercase', current_user);
                RETURN 'HIJACKED-UPPERCASE';
            END;
            $$ LANGUAGE plpgsql SECURITY INVOKER;
        """)
        cursor.close()
        conn.close()

        # Execute the application query
        query = get_app_version_query()
        result = execute_app_query(query)

        # Check for attacks
        attack_count = get_attack_log_count()
        assert attack_count == 0, \
            f"Case variation bypass succeeded! Attacks: {attack_count}"

    def test_schema_qualified_attacker_function(self):
        """
        Test that even if attacker creates public.function_name,
        the application calls pg_catalog.function_name.
        """
        # Attacker explicitly creates in public schema
        conn = get_connection(ATTACKER_USER, ATTACKER_PASS)
        conn.autocommit = True
        cursor = conn.cursor()

        cursor.execute("""
            CREATE OR REPLACE FUNCTION public.version()
            RETURNS text AS $$
            BEGIN
                INSERT INTO public.attack_log (function_name, caller_user)
                VALUES ('version_public_explicit', current_user);
                RETURN 'HIJACKED-PUBLIC-EXPLICIT';
            END;
            $$ LANGUAGE plpgsql SECURITY INVOKER;
        """)
        cursor.close()
        conn.close()

        # Application query should use pg_catalog prefix
        query = get_app_version_query()
        result = execute_app_query(query)

        attack_count = get_attack_log_count('version_public_explicit')
        assert attack_count == 0, \
            f"Public schema function was called instead of pg_catalog! " \
            f"Query: {query}"

    def test_search_path_manipulation_resistance(self):
        """
        Test that even with modified search_path, qualified calls work.
        """
        # Create trojan
        create_trojan_function('version', 'text', "'HIJACKED-SEARCHPATH'")

        # Execute with modified search_path
        conn = get_connection(VICTIM_USER, VICTIM_PASS)
        conn.autocommit = True  # Enable autocommit so trojan INSERTs are persisted
        cursor = conn.cursor()

        # Set search_path to prioritize public
        cursor.execute("SET search_path TO public, pg_catalog")

        # Get and execute the application query
        query = get_app_version_query()
        cursor.execute(query)
        result = cursor.fetchone()[0]

        cursor.close()
        conn.close()

        # Check for attacks
        attack_count = get_attack_log_count('version')

        assert attack_count == 0, \
            f"search_path manipulation bypassed protection! " \
            f"Query: {query}, Result: {result}"


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment before each test."""
        assert wait_for_db(), "Database is not ready"
        setup_test_environment()
        clear_attack_log()

    def test_repeated_calls_not_hijacked(self):
        """Test that repeated calls don't get hijacked on any attempt."""
        create_trojan_function('version', 'text', "'HIJACKED-REPEATED'")

        query = get_app_version_query()

        # Call multiple times
        for i in range(5):
            result = execute_app_query(query)
            assert "PostgreSQL" in result, f"Call {i+1} was hijacked: {result}"

        attack_count = get_attack_log_count()
        assert attack_count == 0, f"Some calls were hijacked: {attack_count}"

    def test_concurrent_trojan_creation_and_call(self):
        """Test that function call races with trojan creation."""
        # First call without trojan
        query = get_app_version_query()
        result1 = execute_app_query(query)

        # Create trojan
        create_trojan_function('version', 'text', "'HIJACKED-RACE'")

        # Second call with trojan present
        result2 = execute_app_query(query)

        attack_count = get_attack_log_count()
        assert attack_count == 0, f"Race condition exploited: {attack_count} attacks"
        assert "PostgreSQL" in result1
        assert "PostgreSQL" in result2
