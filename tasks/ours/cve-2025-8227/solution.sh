#!/bin/bash
# Solution script for ChanCMS code execution vulnerability
# Fixes the unsafe use of new Function() in the collect controller
set -e

cd /app

echo "=== Applying fix to collect.js ==="

# The vulnerable file is at app/modules/cms/controller/collect.js
TARGET_FILE="/app/app/modules/cms/controller/collect.js"

# Check if file exists
if [ ! -f "$TARGET_FILE" ]; then
    echo "Error: Target file not found: $TARGET_FILE"
    exit 1
fi

# Backup original file
cp "$TARGET_FILE" "${TARGET_FILE}.bak"

# Create the fixed version of collect.js
cat > "$TARGET_FILE" << 'FIXED_CODE'
import * as cheerio from "cheerio";
import { isValidTargetUrl } from "../../../middleware/guard.js";
import { cleanHtml } from "../../../middleware/clearhtml.js";
const {
  common: { success, fail },
  helper: { formatDateFields },
} = Chan;

import collect from "../service/collect.js";

class CollectController extends Chan.Controller {
  constructor() {
    super();
  }
  async getPages(req, res, next) {
    try {
      let arr = [];
      const { targetUrl, listTag, charset } = req.body;
      if (!isValidTargetUrl(targetUrl)) {
        return "不允许访问的目标地址";
      }
      const data = await collect.common(targetUrl, charset);
      const $ = cheerio.load(data.toString(), { decodeEntities: false });
      $(`${listTag}`).each(function () {
        arr.push($(this).attr("href"));
      });
      res.json({ ...success, data: arr });
    } catch (error) {
      next(error);
    }
  }

  //测试列表所有地址
  async getArticle(req, res, next) {
    try {
      const {
        taskUrl,
        titleTag,
        articleTag,
        parseData,
        charset = "utf8",
      } = req.body;

      // 1. Fetch page content
      const dataStr = await collect.common(taskUrl, charset);
      const $ = cheerio.load(dataStr.toString(), { decodeEntities: false });

      // 2. Extract title
      const title = $(titleTag).text().trim();

      // 3. Extract content
      let $content = $(articleTag).clone();
      let html = $content.html();

      // 4. FIX: Parse parseData as JSON config (safe - no code execution)
      // Previously used: new Function('data', parseData) which allowed RCE
      let cleanOptions = {};
      try {
        cleanOptions = JSON.parse(parseData) || {};
      } catch (error) {
        console.log("error--->", error);
        return res.json({
          ...fail,
          msg: "Invalid JSON configuration",
          data: error.toString(),
        });
      }
      html = cleanHtml(html, cleanOptions);

      res.json({
        ...success,
        data: {
          title,
          article: html,
        },
      });
    } catch (error) {
      next(error);
    }
  }

  // Create
  async create(req, res, next) {
    try {
      const body = req.body;
      const data = await collect.create(body);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }

  // Delete
  async delete(req, res, next) {
    try {
      const { id } = req.query;
      const data = await collect.delete(id);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }

  // Update
  async update(req, res, next) {
    try {
      const body = req.body;
      const data = await collect.update(body);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }

  // Detail
  async detail(req, res, next) {
    try {
      const { id } = req.query;
      const data = await collect.detail(id);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }

  // Search
  async search(req, res, next) {
    try {
      const { cur, keyword, pageSize = 10 } = req.query;
      const data = await collect.search(keyword, cur, pageSize);
      data.list = formatDateFields(data.list);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }

  // List
  async list(req, res, next) {
    try {
      const { cur, pageSize = 10 } = req.query;
      let data = await collect.list(cur, pageSize);
      data.list = formatDateFields(data.list);
      res.json({ ...success, data: data });
    } catch (err) {
      next(err);
    }
  }
}

export default new CollectController();
FIXED_CODE

echo "=== Fix applied to collect.js ==="

# Ensure clearhtml.js exists and has the cleanHtml function
CLEARHTML_FILE="/app/app/middleware/clearhtml.js"
if [ ! -f "$CLEARHTML_FILE" ]; then
    echo "=== Creating clearhtml.js middleware ==="
    mkdir -p /app/app/middleware
    cat > "$CLEARHTML_FILE" << 'CLEARHTML_CODE'
import * as cheerio from "cheerio";

/**
 * Generic HTML cleaning function for article collection
 * @param {string} html - Original HTML content
 * @param {Object} inputOptions - Configuration options
 * @returns {string} Cleaned HTML
 */
export const cleanHtml = (html, inputOptions = {}) => {
  try {
    const defaultOptions = {
      imagePrefix: null,
      removeSelectors: "script, style, iframe",
      removeTextPatterns: [
        /^来源：/,
        /^作者：/,
        /^编辑：/,
        /^责任编辑：/,
        /^发布时间：/,
        /^时间：/,
        /^阅读量：/,
        /^点击下载/,
        /^点击查看原文/,
        /^分享到：/,
        /^相关新闻：/,
        /^推荐阅读：/,
        /^广告：/,
        /^赞助商：/,
      ],
      keepStyles: ["text-align: center;", "text-align:center"],
      removeAttributes: [
        "class",
        "id",
        "onclick",
        "onload",
        "alt",
        "title",
        "border",
        "width",
        "height",
      ],
      removeEmptyTags: ["span", "p", "div", "li"],
      unwrapLinks: true,
      collapseWhitespace: true,
      removeHtmlComments: true,
      sanitizeUrls: true,
    };

    const options = { ...defaultOptions, ...inputOptions };

    const {
      imagePrefix,
      removeSelectors,
      removeTextPatterns,
      keepStyles,
      removeAttributes,
      removeEmptyTags,
      unwrapLinks,
      sanitizeUrls,
      removeHtmlComments,
    } = options;

    const $ = cheerio.load(html, { decodeEntities: false });

    // 1. Complete image domain
    if (imagePrefix) {
      $("img").each((i, elem) => {
        const $img = $(elem);
        let src = $img.attr("src");
        if (!src) return;

        src = src.trim();
        if (/^https?:\/\//i.test(src)) return;
        if (src.startsWith("//")) src = "https:" + src;
        else if (src.startsWith("/"))
          src = imagePrefix.replace(/\/+$/, "") + "/" + src.replace(/^\/+/, "");
        else src = imagePrefix.replace(/\/+$/, "") + "/" + src;

        $img.attr("src", src);
      });
    }

    // 2. Remove specified selectors
    if (removeSelectors) {
      $(removeSelectors).remove();
    }

    // 3. Remove elements with interference text
    $("p, div, span, li").each((i, elem) => {
      const $elem = $(elem);
      const text = $elem.text().trim();
      if (
        removeTextPatterns.some((re) => re.test(text)) &&
        $elem.children().length === 0 &&
        text.length < 100
      ) {
        $elem.remove();
      }
    });

    // 4. Clean style attributes
    $("*").each((i, elem) => {
      const $elem = $(elem);
      const style = $elem.attr("style");
      if (!style) return;

      const keep = keepStyles.find((k) => style.includes(k));
      if (keep) {
        $elem.attr("style", keep);
      } else {
        $elem.removeAttr("style");
      }
    });

    // 5. Remove specified attributes
    removeAttributes.forEach((attr) => {
      $(`[${attr}]`).removeAttr(attr);
    });

    // 6. Remove a tags, keep text
    if (unwrapLinks) {
      $("a").each((i, elem) => {
        $(elem).replaceWith($(elem).html());
      });
    }

    // 7. Clean javascript: protocol
    if (sanitizeUrls) {
      $("a, img, [href], [src]").each((i, elem) => {
        const $elem = $(elem);
        ["href", "src"].forEach((attr) => {
          const val = $elem.attr(attr);
          if (val && val.trim().toLowerCase().startsWith("javascript:")) {
            $elem.removeAttr(attr);
          }
        });
      });
    }

    // 8. Remove empty tags
    if (Array.isArray(removeEmptyTags)) {
      removeEmptyTags.forEach((tag) => {
        $(tag)
          .filter(function () {
            return (
              $(this).text().trim() === "" && $(this).children().length === 0
            );
          })
          .remove();
      });
    }

    // 9. Get final HTML
    let resultHtml = $("body").html() || "";

    // 10. Remove HTML comments
    if (removeHtmlComments) {
      resultHtml = resultHtml.replace(/<!--[\s\S]*?-->/g, "");
    }

    // 11. Collapse whitespace
    if (options.collapseWhitespace) {
      resultHtml = resultHtml.replace(/\s+/g, " ").trim();
    }
    return resultHtml;
  } catch (error) {
    console.log("error--->", error);
    return "";
  }
};
CLEARHTML_CODE
    echo "=== clearhtml.js created ==="
fi

echo "=== Restarting application ==="

# Signal the Node.js process to restart gracefully
# The entrypoint.sh has a loop that will restart the app automatically
# Run in background so the docker exec session exits before the kill happens
# This prevents signal propagation issues
NODE_PID=$(pidof node 2>/dev/null) || true
if [ -n "$NODE_PID" ]; then
    echo "Scheduling Node.js process restart (PID: $NODE_PID)..."
    # Create a restart script that runs after this script exits
    nohup sh -c "sleep 1 && kill $NODE_PID" > /dev/null 2>&1 &
else
    echo "Warning: Could not find Node.js process to kill"
fi

echo "=== Fix complete ==="
echo "The application will be restarted by the entrypoint."
