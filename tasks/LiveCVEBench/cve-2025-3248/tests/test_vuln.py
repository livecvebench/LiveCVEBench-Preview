"""
Vulnerability tests for the code validation endpoint.
These tests verify the vulnerability status:
- FAIL when vulnerable (unauthenticated access allowed)
- PASS when fixed (authentication required)
"""

import requests
import pytest
import time

BASE_URL = "http://localhost:7860"
TIMEOUT = 30

# Both 401 and 403 are valid authentication failure responses
# 401 = Unauthorized (no credentials)
# 403 = Forbidden (credentials invalid or not permitted)
AUTH_FAILURE_CODES = [401, 403]


def wait_for_server(max_retries=60, delay=2):
    """Wait for the server to be ready."""
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/health", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


@pytest.fixture(scope="module", autouse=True)
def ensure_server_ready():
    """Ensure the server is ready before running tests."""
    if not wait_for_server():
        pytest.skip("Server not available")


class TestUnauthenticatedAccess:
    """Test that unauthenticated access is blocked after fix."""

    def test_simple_code_requires_auth(self):
        """
        Test that simple code validation requires authentication.

        VULNERABLE: Returns 200 with validation result
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {"code": "def hello(): pass"}

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        # After fix, should require authentication
        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}. " \
            "Endpoint should require authentication."

    def test_valid_function_definition_requires_auth(self):
        """
        Test that valid function definitions require authentication.

        VULNERABLE: Returns 200 with empty errors
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {
            "code": """
def calculate_sum(a, b):
    return a + b
"""
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"

    def test_code_with_imports_requires_auth(self):
        """
        Test that code with imports requires authentication.

        VULNERABLE: Returns 200 and validates imports
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {
            "code": """
import os
def get_cwd():
    return os.getcwd()
"""
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"


class TestCodeExecutionBlocked:
    """
    Test that code execution is blocked without authentication.
    These tests use various code patterns that would execute if the
    endpoint is accessible.
    """

    def test_default_argument_pattern_blocked(self):
        """
        Test that default argument pattern is blocked.

        VULNERABLE: Executes the code and returns output in errors
        FIXED: Returns 401/403 before any code processing
        """
        # This pattern would execute code at function definition time
        payload = {
            "code": 'def test_func(x=exec("raise Exception(\'EXEC_OCCURRED\')")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        # Must return auth failure - not allow any code processing
        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}. " \
            "Unauthenticated requests should be rejected before code processing."

        # Double check: response should NOT contain execution evidence
        if response.status_code == 200:
            # If somehow we got 200, ensure no code execution happened
            data = response.json()
            errors_str = str(data)
            assert "EXEC_OCCURRED" not in errors_str, \
                "Code execution detected! This is a critical vulnerability."

    def test_decorator_pattern_blocked(self):
        """
        Test that decorator pattern is blocked.

        VULNERABLE: Executes decorator at definition time
        FIXED: Returns 401/403 before any code processing
        """
        payload = {
            "code": '@exec("raise Exception(\'DECORATOR_EXEC\')")\ndef foo(): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"

    def test_subprocess_execution_blocked(self):
        """
        Test that subprocess execution patterns are blocked.

        VULNERABLE: Executes subprocess and returns output
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {
            "code": 'def poc(x=exec("raise Exception(__import__(\'subprocess\').check_output(\'echo SUBPROCESS_TEST\', shell=True))")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"

        # Additional safety check
        if response.status_code == 200:
            response_text = response.text
            assert "SUBPROCESS_TEST" not in response_text, \
                "Subprocess execution detected in response!"

    def test_os_command_execution_blocked(self):
        """
        Test that OS command execution is blocked.

        VULNERABLE: Would execute 'id' command
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {
            "code": 'def rce(x=exec("raise Exception(__import__(\'os\').popen(\'id\').read())")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"

    def test_file_read_blocked(self):
        """
        Test that file read attempts are blocked.

        VULNERABLE: Would read /etc/passwd
        FIXED: Returns 401/403 (authentication required)
        """
        payload = {
            "code": 'def file_leak(x=exec("raise Exception(open(\'/etc/passwd\').read()[:100])")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Expected authentication failure (401/403), got {response.status_code}"

        # Safety check for data leak
        if response.status_code == 200:
            assert "root:" not in response.text, \
                "File content leaked in response!"


class TestMultiplePayloadVariations:
    """Test various payload variations to ensure comprehensive protection."""

    def test_nested_exec_blocked(self):
        """Test nested exec patterns are blocked."""
        payload = {
            "code": 'def nested(x=exec(exec.__class__.__name__ + "(\'raise Exception(42)\')")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_eval_pattern_blocked(self):
        """Test eval patterns are blocked."""
        payload = {
            "code": 'def use_eval(x=eval("__import__(\'os\').getcwd()")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_compile_exec_pattern_blocked(self):
        """Test compile+exec patterns are blocked."""
        payload = {
            "code": 'def compile_test(x=exec(compile("raise Exception(123)", "", "exec"))): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_lambda_default_blocked(self):
        """Test lambda with exec in default is blocked."""
        payload = {
            "code": 'test = lambda x=exec("raise Exception(\'LAMBDA_EXEC\')"): x'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_class_decorator_blocked(self):
        """Test class decorators with exec are blocked."""
        payload = {
            "code": '@exec("raise Exception(\'CLASS_EXEC\')")\nclass Test: pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES


class TestBypassAttempts:
    """Test potential bypass attempts are blocked."""

    def test_encoded_strings_blocked(self):
        """Test that encoded string payloads are blocked."""
        # Base64-like obfuscation attempt
        payload = {
            "code": 'def bypass(x=exec(bytes([114,97,105,115,101,32,69,120,99,101,112,116,105,111,110]).decode())): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_getattr_bypass_blocked(self):
        """Test getattr-based bypass attempts are blocked."""
        payload = {
            "code": 'def getattr_test(x=getattr(__builtins__, "exec")("raise Exception(1)")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_import_bypass_blocked(self):
        """Test __import__ bypass attempts are blocked."""
        payload = {
            "code": 'def import_test(x=__import__("os").system("echo BYPASS")): pass'
        }

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_empty_auth_header_blocked(self):
        """Test that empty Authorization header doesn't bypass auth."""
        payload = {"code": "def test(): pass"}

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={
                "Content-Type": "application/json",
                "Authorization": ""
            },
            timeout=TIMEOUT
        )

        assert response.status_code in AUTH_FAILURE_CODES

    def test_invalid_bearer_token_blocked(self):
        """Test that invalid Bearer token doesn't work."""
        payload = {"code": "def test(): pass"}

        response = requests.post(
            f"{BASE_URL}/api/v1/validate/code",
            json=payload,
            headers={
                "Content-Type": "application/json",
                "Authorization": "Bearer invalid_token_12345"
            },
            timeout=TIMEOUT
        )

        # Should still be rejected (401 or 403)
        assert response.status_code in AUTH_FAILURE_CODES, \
            f"Invalid token should be rejected, got {response.status_code}"
