diff --git a/pkg/router/v1/v1api_test.go b/pkg/router/v1/v1api_test.go
new file mode 100644
index 0000000..88f636f
--- /dev/null
+++ b/pkg/router/v1/v1api_test.go
@@ -0,0 +1,85 @@
+package v1
+
+import (
+	"testing"
+	"time"
+
+	"github.com/golang-jwt/jwt"            // JWT generation library
+	"github.com/kataras/iris/v12"          // Iris framework
+	"github.com/kataras/iris/v12/httptest" // Iris testing utilities
+)
+
+func Test_CVE_2023_22480_Kubeconfig_Access_Control(t *testing.T) {
+	// Create a test Iris application
+	app := iris.New()
+	V1(app.Party("/")) // Assume V1 function is defined in the same package
+
+	// Create a test client
+	e := httptest.New(t, app)
+
+	t.Run("Unauthorized access to kubeconfig route should be denied", func(t *testing.T) {
+		resp := e.GET("/v1/clusters/kubeconfig/my-cluster").Expect()
+
+		// Verify status code
+		status := resp.Raw().StatusCode
+		if status != iris.StatusUnauthorized {
+			t.Errorf(
+				"Unauthorized access should return 401, got %d instead. Route may not be properly protected",
+				status,
+			)
+		}
+	})
+
+	// t.Run("Authorized access to kubeconfig route should be allowed", func(t *testing.T) {
+	// 	token := generateValidJWTToken(t)
+	// 	t.Log("here")
+	// 	resp := e.GET("/v1/clusters/kubeconfig/my-cluster").
+	// 		WithHeader("Authorization", "Bearer "+token).
+	// 		Expect()
+	// 	t.Log(resp.Body().Raw())
+	// 	status := resp.Raw().StatusCode
+	// 	if status != iris.StatusOK {
+	// 		t.Errorf(
+	// 			"Authorized access should return 200, got %d instead. Check authentication middleware",
+	// 			status,
+	// 		)
+	// 	}
+	// })
+
+	t.Run("Whitelist route should allow anonymous access", func(t *testing.T) {
+		resp := e.GET("/v1/captcha").Expect()
+
+		status := resp.Raw().StatusCode
+		if status != iris.StatusOK {
+			t.Errorf(
+				"Whitelist route should return 200, got %d instead. Check whitelist configuration",
+				status,
+			)
+		}
+	})
+}
+
+// generateValidJWTToken generates a valid JWT token
+func generateValidJWTToken(t *testing.T) string {
+	// Create a token with valid claims
+	claims := jwt.MapClaims{
+		"user": "testuser", // Adjust according to actual user model
+		"exp":  time.Now().Add(1 * time.Hour).Unix(),
+		"iss":  "kubeoperator",
+		// Add other claims required by the application
+	}
+
+	// Use the same signing method as the project
+	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
+
+	// Signing key - must match the one used by the application
+	// In a real project, this can be read from configuration
+	secretKey := []byte("your-application-secret-key")
+
+	signedToken, err := token.SignedString(secretKey)
+	if err != nil {
+		t.Fatalf("Failed to generate JWT: %v", err)
+	}
+
+	return signedToken
+}
