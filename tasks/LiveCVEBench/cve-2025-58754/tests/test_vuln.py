"""
Vulnerability tests for maxContentLength bypass on data: URIs.

These tests verify that maxContentLength is properly enforced for data: URIs.
- FAIL in vulnerable state (limit is bypassed, vulnerability exists)
- PASS in fixed state (limit is properly enforced)
"""
import subprocess
import pytest


def run_node_test(script: str, timeout: int = 30) -> dict:
    """Run a Node.js script and return the result."""
    result = subprocess.run(
        ['node', '--input-type=module', '-e', script],
        capture_output=True,
        text=True,
        timeout=timeout,
        cwd='/app'
    )
    return {
        'returncode': result.returncode,
        'stdout': result.stdout.strip(),
        'stderr': result.stderr.strip()
    }


class TestMaxContentLengthEnforcement:
    """Tests that verify maxContentLength is enforced for data: URIs."""

    def test_basic_size_limit_enforcement(self):
        """
        Data URI exceeding maxContentLength should be rejected.

        Creates ~1KB of decoded data but sets limit to 100 bytes.
        Fixed version: Throws ERR_BAD_RESPONSE with "maxContentLength size of 100 exceeded"
        Vulnerable version: Returns 200 OK (limit bypassed)
        """
        script = '''
import axios from 'axios';

// Create ~1KB of data (1024 bytes decoded)
const testData = Buffer.alloc(1024, 'X').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100  // 100 bytes limit
    });

    // If we get here, the limit was bypassed - VULNERABLE
    console.log('VULNERABLE: maxContentLength bypass - got status ' + response.status);
    console.log('Response data length: ' + response.data.length);
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: maxContentLength properly enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed - limit not enforced: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_larger_payload_enforcement(self):
        """
        Larger data URI (10KB) exceeding small limit should be rejected.
        """
        script = '''
import axios from 'axios';

// Create ~10KB of data
const testData = Buffer.alloc(10240, 'Y').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 500  // 500 bytes limit
    });

    console.log('VULNERABLE: limit bypassed with 10KB payload');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 500 exceeded')) {
        console.log('SECURE: large payload rejected correctly');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_exact_boundary_rejection(self):
        """
        Data URI exactly 1 byte over limit should be rejected.
        """
        script = '''
import axios from 'axios';

// Create exactly 101 bytes of data (1 byte over 100 limit)
const testData = Buffer.alloc(101, 'Z').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100  // 100 bytes limit
    });

    console.log('VULNERABLE: 101-byte payload accepted with 100-byte limit');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: boundary check works correctly');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']


class TestDifferentEncodingsBypass:
    """Test that size limit is enforced regardless of encoding format."""

    def test_non_base64_data_url_enforcement(self):
        """
        Non-base64 data URL exceeding limit should be rejected.
        """
        script = '''
import axios from 'axios';

// Create URL-encoded data exceeding limit
const largeText = 'X'.repeat(500);
const encoded = encodeURIComponent(largeText);
const dataUrl = `data:text/plain,${encoded}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100  // 100 bytes limit
    });

    console.log('VULNERABLE: non-base64 limit bypass');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: non-base64 data URL limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_base64_with_url_encoded_padding_enforcement(self):
        """
        Base64 data with URL-encoded padding (%3D) exceeding limit should be rejected.
        """
        script = '''
import axios from 'axios';

// Create base64 data with URL-encoded padding
const testData = Buffer.alloc(512, 'A').toString('base64');
// Replace = with %3D to test URL-encoded padding handling
const encodedPadding = testData.replace(/=/g, '%3D');
const dataUrl = `data:text/plain;base64,${encodedPadding}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100
    });

    console.log('VULNERABLE: URL-encoded base64 limit bypass');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: URL-encoded base64 limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_mixed_mime_type_enforcement(self):
        """
        Data URL with different MIME types should still enforce limits.
        """
        script = '''
import axios from 'axios';

// Test with application/octet-stream MIME type
const binaryData = Buffer.alloc(1000, 0xFF).toString('base64');
const dataUrl = `data:application/octet-stream;base64,${binaryData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 50
    });

    console.log('VULNERABLE: octet-stream limit bypass');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 50 exceeded')) {
        console.log('SECURE: octet-stream limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']


class TestResponseTypesBypass:
    """Test that size limit is enforced regardless of responseType."""

    def test_stream_response_type_enforcement(self):
        """
        Even with responseType='stream', limit should be enforced BEFORE allocation.
        """
        script = '''
import axios from 'axios';

const testData = Buffer.alloc(2048, 'S').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100,
        responseType: 'stream'
    });

    // In vulnerable version, stream is returned without size check
    console.log('VULNERABLE: stream responseType bypasses limit');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: stream responseType limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_text_response_type_enforcement(self):
        """
        With responseType='text', limit should still be enforced.
        """
        script = '''
import axios from 'axios';

const testData = Buffer.alloc(1500, 'T').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 200,
        responseType: 'text'
    });

    console.log('VULNERABLE: text responseType bypasses limit');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 200 exceeded')) {
        console.log('SECURE: text responseType limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_arraybuffer_response_type_enforcement(self):
        """
        With responseType='arraybuffer', limit should still be enforced.
        """
        script = '''
import axios from 'axios';

const testData = Buffer.alloc(800, 'B').toString('base64');
const dataUrl = `data:application/octet-stream;base64,${testData}`;

try {
    const response = await axios.get(dataUrl, {
        maxContentLength: 100,
        responseType: 'arraybuffer'
    });

    console.log('VULNERABLE: arraybuffer responseType bypasses limit');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        console.log('SECURE: arraybuffer responseType limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']


class TestErrorMessageConsistency:
    """Test that error messages are consistent with HTTP response limits."""

    def test_error_code_is_err_bad_response(self):
        """
        Error code should be ERR_BAD_RESPONSE, matching HTTP behavior.
        """
        script = '''
import axios from 'axios';

const testData = Buffer.alloc(500, 'E').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    await axios.get(dataUrl, { maxContentLength: 50 });
    console.log('VULNERABLE: no error thrown');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE') {
        console.log('SECURE: correct error code');
        process.exit(0);
    } else {
        console.log('WRONG ERROR CODE: ' + error.code);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_error_message_format(self):
        """
        Error message should match the format "maxContentLength size of N exceeded".
        """
        script = '''
import axios from 'axios';

const testData = Buffer.alloc(300, 'M').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;
const limit = 75;

try {
    await axios.get(dataUrl, { maxContentLength: limit });
    console.log('VULNERABLE: no error thrown');
    process.exit(1);
} catch (error) {
    const expectedMessage = `maxContentLength size of ${limit} exceeded`;
    if (error.message.includes(expectedMessage)) {
        console.log('SECURE: correct error message format');
        process.exit(0);
    } else {
        console.log('WRONG MESSAGE: ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_zero_max_content_length(self):
        """
        maxContentLength=0 should reject any non-empty data URL.
        """
        script = '''
import axios from 'axios';

const testData = Buffer.from('A').toString('base64');  // Just 1 byte
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    await axios.get(dataUrl, { maxContentLength: 0 });
    console.log('VULNERABLE: 0 limit should reject all data');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 0 exceeded')) {
        console.log('SECURE: zero limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_very_small_limit(self):
        """
        Very small maxContentLength (1 byte) should work correctly.
        """
        script = '''
import axios from 'axios';

// 10 bytes of data
const testData = Buffer.alloc(10, 'X').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    await axios.get(dataUrl, { maxContentLength: 1 });
    console.log('VULNERABLE: 1 byte limit bypassed');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 1 exceeded')) {
        console.log('SECURE: tiny limit enforced');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']

    def test_moderately_large_payload(self):
        """
        Test with a moderately large payload (50KB).
        """
        script = '''
import axios from 'axios';

// 50KB of data
const testData = Buffer.alloc(50 * 1024, 'L').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

try {
    await axios.get(dataUrl, { maxContentLength: 1000 });
    console.log('VULNERABLE: 50KB payload accepted with 1KB limit');
    process.exit(1);
} catch (error) {
    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 1000 exceeded')) {
        console.log('SECURE: large payload rejected');
        process.exit(0);
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout']


class TestPreAllocationCheck:
    """Test that size is checked BEFORE memory allocation."""

    def test_large_payload_no_memory_spike(self):
        """
        Even with very large payload, rejection should happen quickly
        without significant memory allocation.

        This is a behavioral test - the fix should estimate size
        before decoding/allocating.
        """
        script = '''
import axios from 'axios';

// Create a large payload (~1MB)
const testData = Buffer.alloc(1024 * 1024, 'P').toString('base64');
const dataUrl = `data:text/plain;base64,${testData}`;

const startMem = process.memoryUsage().heapUsed;

try {
    await axios.get(dataUrl, { maxContentLength: 100 });
    console.log('VULNERABLE: 1MB payload accepted');
    process.exit(1);
} catch (error) {
    const endMem = process.memoryUsage().heapUsed;
    const memDiff = endMem - startMem;

    if (error.code === 'ERR_BAD_RESPONSE' &&
        error.message.includes('maxContentLength size of 100 exceeded')) {
        // Memory increase should be minimal (less than 500KB)
        // If vulnerable, it would allocate ~1MB
        if (memDiff < 500 * 1024) {
            console.log('SECURE: pre-allocation check works');
            process.exit(0);
        } else {
            console.log('MEMORY SPIKE: ' + Math.round(memDiff / 1024) + 'KB increase');
            // Still passing if error is correct, memory check is informational
            process.exit(0);
        }
    } else {
        console.log('UNEXPECTED ERROR: ' + error.code + ' - ' + error.message);
        process.exit(1);
    }
}
'''
        result = run_node_test(script)
        assert result['returncode'] == 0, f"Test failed: {result['stdout']} {result['stderr']}"
        assert 'SECURE' in result['stdout'] or 'MEMORY SPIKE' in result['stdout']
