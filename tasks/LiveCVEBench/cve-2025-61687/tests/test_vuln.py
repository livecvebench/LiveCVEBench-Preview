#!/usr/bin/env python3
"""
Vulnerability tests for the file upload attachment API.
These tests verify that input validation is properly implemented.

In VULNERABLE state: These tests should FAIL (vulnerability is exploitable)
In FIXED state: These tests should PASS (vulnerability is mitigated)

The key vulnerability is CVE-2025-61687:
- No UUID validation on chatflowId/chatId parameters
- No path traversal prevention
- Unrestricted file type uploads
"""

import os
import io
import uuid
import pytest
import requests
import time
import urllib.parse

BASE_URL = os.environ.get("BASE_URL", "http://localhost:3000")
API_TIMEOUT = 30


def wait_for_service(max_retries=30, delay=2):
    """Wait for the service to be ready."""
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/api/v1/ping", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


class TestUUIDValidation:
    """Test that chatflowId and chatId parameters require valid UUID format."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_invalid_chatflow_id_rejected(self):
        """Test that non-UUID chatflowId is rejected with 400."""
        invalid_id = "not-a-valid-uuid"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{invalid_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Fixed version should return 400 Bad Request for invalid UUID
        # Vulnerable version returns 200 with file upload results
        assert response.status_code == 400, \
            f"Expected 400 for invalid chatflowId, got {response.status_code}. " \
            f"Response: {response.text[:200]}"

    def test_invalid_chat_id_rejected(self):
        """Test that non-UUID chatId is rejected with 400."""
        chatflow_id = str(uuid.uuid4())
        invalid_id = "not-a-valid-uuid"
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{invalid_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Fixed version should return 400 Bad Request for invalid UUID
        # Vulnerable version returns 200 (or 500 for chatflow not found)
        assert response.status_code == 400, \
            f"Expected 400 for invalid chatId, got {response.status_code}. " \
            f"Response: {response.text[:200]}"

    def test_numeric_only_id_rejected(self):
        """Test that numeric-only IDs are rejected (not UUID format)."""
        numeric_id = "12345678901234567890"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{numeric_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for numeric-only chatflowId, got {response.status_code}"


class TestPathTraversalPrevention:
    """Test that path traversal attempts are blocked."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_backslash_traversal_blocked(self):
        """Test that backslash path traversal is blocked."""
        traversal_id = "..\\..\\etc"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{urllib.parse.quote(traversal_id)}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for backslash traversal, got {response.status_code}"

    def test_encoded_backslash_blocked(self):
        """Test that URL-encoded backslash (%5c) is blocked."""
        traversal_id = "%2e%2e%5c%2e%2e%5cetc"  # ..\..\ encoded
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{traversal_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for encoded backslash traversal, got {response.status_code}"

    def test_encoded_forward_slash_blocked(self):
        """Test that URL-encoded forward slash (%2f) is blocked."""
        traversal_id = "%2e%2e%2f%2e%2e%2fetc"  # ../../etc encoded
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{traversal_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for encoded slash traversal, got {response.status_code}"

    def test_mixed_encoding_traversal_blocked(self):
        """Test that mixed encoding traversal attempts are blocked."""
        # Mix of plain and encoded characters
        traversal_id = "..%2f..%2fetc"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{traversal_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for mixed encoding traversal, got {response.status_code}"

    def test_double_encoding_traversal_blocked(self):
        """Test that double-encoded traversal is blocked."""
        # Double encoded .. = %252e%252e
        traversal_id = "%252e%252e%252f%252e%252e"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{traversal_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Should be blocked - not valid UUID
        assert response.status_code == 400, \
            f"Expected 400 for double-encoded traversal, got {response.status_code}"


class TestDangerousFileUpload:
    """Test that dangerous file types are handled properly."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_javascript_file_with_valid_uuid_but_nonexistent_chatflow(self):
        """
        Test uploading a .js file with valid UUIDs.
        In fixed version: Should fail with 404 (chatflow not found) because
        the UUID validation passes but the chatflow doesn't exist in DB.
        """
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        js_content = b"console.log('test script');"
        files = {
            "files": ("script.js", io.BytesIO(js_content), "application/javascript")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Fixed version should return 404 (chatflow not found after UUID validation)
        # OR 400 if additional file type validation is implemented
        # Vulnerable version returns 200 with file upload success
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for .js upload to non-existent chatflow, got {response.status_code}. " \
            f"Response: {response.text[:200]}"

    def test_shell_script_upload_blocked(self):
        """Test that shell script uploads are handled properly."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        sh_content = b"#!/bin/bash\necho 'malicious'\n"
        files = {
            "files": ("script.sh", io.BytesIO(sh_content), "application/x-sh")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # After fix, should return 404 (chatflow doesn't exist) or 400
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for .sh upload, got {response.status_code}"

    def test_python_script_upload_blocked(self):
        """Test that Python script uploads are handled properly."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        py_content = b"#!/usr/bin/env python3\nimport os\nos.system('whoami')\n"
        files = {
            "files": ("malicious.py", io.BytesIO(py_content), "text/x-python")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code in [400, 404], \
            f"Expected 400/404 for .py upload, got {response.status_code}"

    def test_executable_disguised_as_text_blocked(self):
        """Test that executable content disguised as text is handled properly."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        # Node.js content but with .txt extension
        malicious_content = b"const { exec } = require('child_process'); exec('id');"
        files = {
            "files": ("innocent.txt", io.BytesIO(malicious_content), "text/plain")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Should be blocked because chatflow doesn't exist (after UUID validation)
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for upload with non-existent chatflow, got {response.status_code}"


class TestChatflowExistenceValidation:
    """Test that uploads to non-existent chatflows are rejected."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_random_uuid_chatflow_rejected(self):
        """Test that uploads with random (non-existent) chatflow UUID are rejected."""
        # Generate a random UUID that doesn't correspond to a real chatflow
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        files = {
            "files": ("test.txt", io.BytesIO(b"test content"), "text/plain")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Fixed version should check if chatflow exists and return 404
        # Vulnerable version returns 200 (accepts any UUID format)
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for non-existent chatflow, got {response.status_code}"

    def test_nil_uuid_chatflow_rejected(self):
        """Test that nil UUID (all zeros) is rejected."""
        nil_uuid = "00000000-0000-0000-0000-000000000000"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{nil_uuid}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Nil UUID is technically valid format but chatflow won't exist
        # Fixed version should return 400 (invalid UUID v4 - missing version 4 marker)
        # or 404 (chatflow not found)
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for nil UUID, got {response.status_code}"

    def test_uuid_v1_format_rejected(self):
        """Test that UUID v1 format is rejected (only v4 should be valid)."""
        # This is a UUID v1 format (version 1 in 13th character position)
        uuid_v1 = "550e8400-e29b-11d4-a716-446655440000"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{uuid_v1}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # UUID v1 should be rejected - only v4 is valid
        # Note: Some implementations may accept any valid UUID format
        # At minimum, non-existent chatflow should return 404
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for UUID v1 format, got {response.status_code}"


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_uppercase_uuid_handling(self):
        """Test that uppercase UUIDs are handled correctly."""
        # UUID v4 in uppercase - should be valid format
        chatflow_id = str(uuid.uuid4()).upper()
        chat_id = str(uuid.uuid4()).upper()
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        # Uppercase UUIDs should be accepted (case-insensitive regex)
        # but chatflow won't exist, so 404 expected
        assert response.status_code in [400, 404], \
            f"Expected 400/404 for uppercase UUID, got {response.status_code}"

    def test_very_long_parameter_rejected(self):
        """Test that excessively long parameters are rejected."""
        long_id = "a" * 1000
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{long_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for excessively long chatflowId, got {response.status_code}"

    def test_unicode_in_parameter_rejected(self):
        """Test that unicode characters in parameters are rejected."""
        unicode_id = "测试-uuid-参数"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{urllib.parse.quote(unicode_id)}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for unicode in chatflowId, got {response.status_code}"

    def test_null_bytes_in_parameter_rejected(self):
        """Test that null bytes in parameters are rejected."""
        null_id = "test%00injection"
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{null_id}/{chat_id}"

        files = {"files": ("test.txt", io.BytesIO(b"test"), "text/plain")}
        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        assert response.status_code == 400, \
            f"Expected 400 for null bytes in chatflowId, got {response.status_code}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
