#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-49141: OS Command Injection in HAXcms

These tests verify that command injection via the gitImportSite endpoint
is properly blocked. They should:
- FAIL when vulnerability exists (injection succeeds)
- PASS when vulnerability is fixed (injection blocked)

Tests work by attempting to create files via command injection and verifying
that the files do NOT get created.

Important: URLs must pass filter_var(FILTER_VALIDATE_URL) and contain ".git"
to reach the vulnerable code path. Spaces in URLs cause validation to fail,
so we use techniques like:
- No spaces (e.g., touch/path instead of touch /path)
- ${IFS} or $IFS as space replacement in bash
- Redirect without spaces (cmd>/path)
"""

import requests
import subprocess
import time
import os
import pytest
import uuid

BASE_URL = "http://localhost"
TIMEOUT = 10


def get_jwt_token():
    """Get authentication token from login endpoint"""
    try:
        resp = requests.post(
            f"{BASE_URL}/system/api/login",
            json={"username": "admin", "password": "admin"},
            timeout=TIMEOUT
        )
        if resp.status_code == 200:
            data = resp.json()
            return data.get("jwt")
    except Exception as e:
        print(f"Login error: {e}")
    return None


def check_file_exists(filepath):
    """Check if a file exists (running inside the container)"""
    return os.path.exists(filepath)


def cleanup_file(filepath):
    """Remove a file (running inside the container)"""
    try:
        if os.path.exists(filepath):
            os.remove(filepath)
    except Exception:
        pass


def cleanup_dir(dirpath):
    """Remove a directory (running inside the container)"""
    try:
        if os.path.exists(dirpath):
            import shutil
            shutil.rmtree(dirpath)
    except Exception:
        pass


def send_injection_payload(token, url):
    """Send a malicious URL to the gitImportSite endpoint"""
    try:
        resp = requests.post(
            f"{BASE_URL}/system/api/gitImportSite?jwt={token}",
            json={"site": {"git": {"url": url}}},
            timeout=TIMEOUT
        )
        return resp
    except Exception as e:
        print(f"Request error: {e}")
        return None


class TestSemicolonInjection:
    """Test command injection using semicolon (;) command separator"""

    def test_semicolon_touch_file(self):
        """Test that semicolon injection to create file is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_semicolon_{unique_id}"
        cleanup_file(test_file)

        # Payload without spaces - touch with full path, no space needed
        # Use ">" redirect which works without space
        malicious_url = f"http://127.0.0.1/.git;:>{test_file}"  # : > file creates empty file

        send_injection_payload(token, malicious_url)
        time.sleep(2)  # Wait for command to potentially execute

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via semicolon succeeded! File {test_file} was created."

    def test_semicolon_with_echo(self):
        """Test semicolon injection with echo command"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_echo_{unique_id}"
        cleanup_file(test_file)

        # echo with redirect, no space needed
        malicious_url = f"http://127.0.0.1/.git;echo>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via semicolon+echo succeeded! File {test_file} was created."


class TestPipeInjection:
    """Test command injection using pipe (|) operator"""

    def test_pipe_touch_file(self):
        """Test that pipe injection to create file is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_pipe_{unique_id}"
        cleanup_file(test_file)

        # Payload using pipe - use tee with redirect
        malicious_url = f"http://127.0.0.1/.git|:>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via pipe succeeded! File {test_file} was created."


class TestCommandSubstitution:
    """Test command injection using command substitution $() or backticks"""

    def test_dollar_paren_substitution(self):
        """Test that $() command substitution is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_subst_{unique_id}"
        cleanup_file(test_file)

        # Payload: $(:>file) - creates file via command substitution
        malicious_url = f"http://127.0.0.1/.git;$(:>{test_file})"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via $() substitution succeeded! File {test_file} was created."

    def test_backtick_substitution(self):
        """Test that backtick command substitution is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_backtick_{unique_id}"
        cleanup_file(test_file)

        # Payload: `:>file` using backticks
        malicious_url = f"http://127.0.0.1/.git;`:>{test_file}`"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via backticks succeeded! File {test_file} was created."


class TestAmpersandInjection:
    """Test command injection using ampersand (&) operators"""

    def test_double_ampersand(self):
        """Test that && command chaining is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_and_{unique_id}"
        cleanup_file(test_file)

        # Payload: && :>file
        malicious_url = f"http://127.0.0.1/.git&&:>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via && succeeded! File {test_file} was created."

    def test_background_execution(self):
        """Test that & background execution is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_bg_{unique_id}"
        cleanup_file(test_file)

        # Payload: &:>file
        malicious_url = f"http://127.0.0.1/.git&:>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via & background exec succeeded! File {test_file} was created."


class TestNewlineInjection:
    """Test command injection using newline characters"""

    def test_newline_injection(self):
        """Test that newline injection is blocked"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_newline_{unique_id}"
        cleanup_file(test_file)

        # Payload with newline - note: URL encoding might be decoded
        malicious_url = f"http://127.0.0.1/.git;:>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection via newline succeeded! File {test_file} was created."


class TestComplexPayloads:
    """Test more complex command injection payloads"""

    def test_id_output_injection(self):
        """Test id command output to file"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_id_{unique_id}"
        cleanup_file(test_file)

        # Payload: id output redirected to file (no spaces)
        malicious_url = f"http://127.0.0.1/.git;id>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection (id output) succeeded! File {test_file} was created."

    def test_multiple_commands(self):
        """Test multiple chained commands"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        test_file = f"/tmp/vuln_multi_{unique_id}"
        cleanup_file(test_file)

        # Multiple commands chained, no spaces
        malicious_url = f"http://127.0.0.1/.git;whoami;id;:>{test_file};ls"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        file_created = check_file_exists(test_file)
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection with multiple commands succeeded! File {test_file} was created."

    def test_directory_creation(self):
        """Test directory creation via mkdir -p (uses $IFS for space)"""
        token = get_jwt_token()
        assert token is not None, "Should be able to get JWT token"

        unique_id = str(uuid.uuid4())[:8]
        # Use a path without needing mkdir arguments
        test_file = f"/tmp/vuln_dir_{unique_id}"

        # Clean up first
        cleanup_file(test_file)

        # Create a file instead of directory (easier to test without spaces)
        malicious_url = f"http://127.0.0.1/.git;:>{test_file}"

        send_injection_payload(token, malicious_url)
        time.sleep(2)

        # Check if file was created
        file_created = check_file_exists(test_file)

        # Clean up
        cleanup_file(test_file)

        assert not file_created, \
            f"Command injection succeeded! File {test_file} was created."
