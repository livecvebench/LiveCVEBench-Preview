"""
Vulnerability tests for the pet profile page.
These tests verify that the vulnerability has been fixed.

VULNERABLE STATE: These tests will FAIL (injection payloads work/cause delays)
FIXED STATE: These tests will PASS (injection payloads are rejected with 400)
"""

import requests
import time
import os

# Base URL for the application
BASE_URL = os.environ.get("APP_URL", "http://localhost:80")

# Threshold for detecting time-based injection (seconds)
TIME_DELAY_THRESHOLD = 3.0
# Expected delay from SLEEP injection (seconds)
EXPECTED_SLEEP_DELAY = 5


def get_session_cookie():
    """
    Attempt to get a valid session by logging in.
    Returns session if successful.
    Also makes an initial request to profile_pet.php to set up $_SESSION['pet'].
    """
    session = requests.Session()

    try:
        login_url = f"{BASE_URL}/html/login.php"
        session.get(login_url, timeout=10)

        # Try logging in with default credentials
        # WeGIA uses 'cpf' and 'pwd' as field names
        login_data = {
            "cpf": "admin",
            "pwd": "wegia",
        }

        session.post(login_url, data=login_data, timeout=10, allow_redirects=True)

        # Make an initial request to profile_pet.php to set up $_SESSION['pet']
        # This follows the redirect chain through control.php
        profile_url = f"{BASE_URL}/html/pet/profile_pet.php"
        session.get(profile_url, params={"id_pet": "1"}, timeout=30, allow_redirects=True)

    except Exception as e:
        print(f"Login attempt failed: {e}")

    return session


class TestTimeBased:
    """
    Tests for time-based injection attacks.
    In vulnerable state: SLEEP payloads cause actual delays -> tests FAIL
    In fixed state: Invalid input rejected immediately with 400 -> tests PASS
    """

    def setup_method(self):
        """Set up session for each test."""
        self.session = get_session_cookie()
        self.url = f"{BASE_URL}/html/pet/profile_pet.php"

    def test_sleep_injection_5_seconds(self):
        """
        Test time-based injection with SLEEP(5).

        VULNERABLE: Request takes ~5 seconds (FAIL)
        FIXED: Request rejected immediately with 400 (PASS)
        """
        # Use UNION SELECT SLEEP() which works with this injection point
        payload = "1 UNION SELECT SLEEP(5)"
        params = {"id_pet": payload}

        start_time = time.time()
        try:
            resp = self.session.get(self.url, params=params, timeout=30)
            elapsed = time.time() - start_time

            # FIXED behavior: Should return 400 immediately
            # VULNERABLE behavior: Takes ~5 seconds due to SLEEP
            if resp.status_code == 400:
                # Fixed: Input validation rejected it
                assert elapsed < TIME_DELAY_THRESHOLD, \
                    f"Got 400 but took {elapsed}s (expected immediate rejection)"
            else:
                # If not 400, check for delay which indicates vulnerability
                assert elapsed < TIME_DELAY_THRESHOLD, \
                    f"Time-based injection succeeded: request took {elapsed}s"
        except requests.exceptions.Timeout:
            # Timeout also indicates vulnerability
            elapsed = time.time() - start_time
            assert False, f"Request timed out after {elapsed}s - injection likely succeeded"

    def test_sleep_injection_10_seconds(self):
        """
        Test time-based injection with SLEEP(10).

        VULNERABLE: Request takes ~10 seconds (FAIL)
        FIXED: Request rejected immediately with 400 (PASS)
        """
        # Use UNION SELECT SLEEP() which works with this injection point
        payload = "1 UNION SELECT SLEEP(10)"
        params = {"id_pet": payload}

        start_time = time.time()
        try:
            resp = self.session.get(self.url, params=params, timeout=30)
            elapsed = time.time() - start_time

            if resp.status_code == 400:
                assert elapsed < TIME_DELAY_THRESHOLD
            else:
                assert elapsed < TIME_DELAY_THRESHOLD, \
                    f"Time-based injection succeeded: request took {elapsed}s"
        except requests.exceptions.Timeout:
            elapsed = time.time() - start_time
            assert False, f"Request timed out after {elapsed}s"

    def test_benchmark_injection(self):
        """
        Test with BENCHMARK() function which can cause delays.

        VULNERABLE: Request hangs/delays (FAIL)
        FIXED: Request rejected with 400 (PASS)
        """
        # Use UNION SELECT SLEEP() as BENCHMARK might not cause sufficient delay
        # SLEEP is more reliable for time-based detection
        payload = "1 UNION SELECT SLEEP(5)"
        params = {"id_pet": payload}

        start_time = time.time()
        try:
            resp = self.session.get(self.url, params=params, timeout=30)
            elapsed = time.time() - start_time

            if resp.status_code == 400:
                assert elapsed < TIME_DELAY_THRESHOLD
            else:
                assert elapsed < TIME_DELAY_THRESHOLD, \
                    f"Time-based injection caused delay: {elapsed}s"
        except requests.exceptions.Timeout:
            elapsed = time.time() - start_time
            assert False, f"Request timed out after {elapsed}s"


class TestSQLInjectionPayloads:
    """
    Tests for various SQL injection payloads.
    In fixed state, all should return 400 for invalid input.
    """

    def setup_method(self):
        """Set up session for each test."""
        self.session = get_session_cookie()
        self.url = f"{BASE_URL}/html/pet/profile_pet.php"

    def test_single_quote_injection(self):
        """
        Test basic single quote injection.

        VULNERABLE: May cause SQL error or behave unexpectedly
        FIXED: Returns 400 for invalid input
        """
        payload = "1' OR '1'='1"
        params = {"id_pet": payload}

        start_time = time.time()
        resp = self.session.get(self.url, params=params, timeout=30)
        elapsed = time.time() - start_time

        # Fixed: Should return 400
        # Vulnerable: May return 200, 500, or other
        if resp.status_code == 400:
            # Correct behavior - input validation rejected it
            assert elapsed < TIME_DELAY_THRESHOLD
        else:
            # Not getting 400 means vulnerability may exist
            # Check response for signs of SQL error
            content = resp.text.lower()
            assert "sql" not in content and "syntax" not in content and "error" not in content, \
                "SQL injection payload caused SQL error in response"
            # If it's a 500, that's also a sign of vulnerability
            assert resp.status_code != 500, "Server error indicates potential injection"
            # For this specific CVE, the fix returns 400
            assert resp.status_code == 400, \
                f"Expected 400 for invalid input, got {resp.status_code}"

    def test_union_select_injection(self):
        """
        Test UNION SELECT injection.

        VULNERABLE: May expose data or cause errors
        FIXED: Returns 400 for invalid input
        """
        payload = "1 UNION SELECT 1,2,3,4,5--"
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        # Fixed behavior should reject with 400
        assert resp.status_code == 400, \
            f"Expected 400 for UNION injection, got {resp.status_code}"

    def test_comment_injection(self):
        """
        Test SQL comment injection.

        VULNERABLE: May bypass conditions
        FIXED: Returns 400 for invalid input
        """
        payload = "1; DROP TABLE pet--"
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for comment injection, got {resp.status_code}"

    def test_or_always_true(self):
        """
        Test OR 1=1 always-true condition.

        VULNERABLE: May bypass authentication/authorization
        FIXED: Returns 400 for invalid input
        """
        payload = "1 OR 1=1"
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for OR 1=1 payload, got {resp.status_code}"

    def test_double_quote_injection(self):
        """
        Test double quote injection.
        """
        payload = '1" OR "1"="1'
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for double quote injection, got {resp.status_code}"


class TestInvalidInputValidation:
    """
    Tests for proper input validation of non-integer values.
    In fixed state, invalid inputs should return HTTP 400.
    """

    def setup_method(self):
        """Set up session for each test."""
        self.session = get_session_cookie()
        self.url = f"{BASE_URL}/html/pet/profile_pet.php"

    def test_negative_pet_id(self):
        """
        Test that negative pet IDs are rejected.

        VULNERABLE: May be processed
        FIXED: Returns 400
        """
        params = {"id_pet": "-1"}

        resp = self.session.get(self.url, params=params, timeout=30)

        # Fixed behavior: negative IDs should be rejected
        assert resp.status_code == 400, \
            f"Expected 400 for negative ID, got {resp.status_code}"

    def test_zero_pet_id(self):
        """
        Test that zero pet ID is rejected.

        VULNERABLE: May cause unexpected behavior
        FIXED: Returns 400
        """
        params = {"id_pet": "0"}

        resp = self.session.get(self.url, params=params, timeout=30)

        # Fixed behavior: zero should be rejected (id_pet < 1)
        assert resp.status_code == 400, \
            f"Expected 400 for zero ID, got {resp.status_code}"

    def test_alphabetic_pet_id(self):
        """
        Test that alphabetic pet IDs are rejected.

        VULNERABLE: May cause errors or be processed
        FIXED: Returns 400
        """
        params = {"id_pet": "abc"}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for alphabetic ID, got {resp.status_code}"

    def test_special_characters(self):
        """
        Test that special characters are rejected.
        """
        params = {"id_pet": "!@#$%"}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for special characters, got {resp.status_code}"

    def test_empty_pet_id(self):
        """
        Test that empty pet ID is rejected.
        """
        params = {"id_pet": ""}

        resp = self.session.get(self.url, params=params, timeout=30)

        # Empty should be rejected
        assert resp.status_code == 400, \
            f"Expected 400 for empty ID, got {resp.status_code}"


class TestEncodedPayloads:
    """
    Tests for encoded/obfuscated injection payloads.
    """

    def setup_method(self):
        """Set up session for each test."""
        self.session = get_session_cookie()
        self.url = f"{BASE_URL}/html/pet/profile_pet.php"

    def test_url_encoded_sleep(self):
        """
        Test URL-encoded SLEEP injection.
        """
        # UNION SELECT SLEEP(5) - properly URL encoded by requests library
        payload = "1 UNION SELECT SLEEP(5)"
        params = {"id_pet": payload}

        start_time = time.time()
        try:
            resp = self.session.get(self.url, params=params, timeout=30)
            elapsed = time.time() - start_time

            if resp.status_code == 400:
                assert elapsed < TIME_DELAY_THRESHOLD
            else:
                assert elapsed < TIME_DELAY_THRESHOLD, \
                    f"Encoded SLEEP injection succeeded: {elapsed}s"
        except requests.exceptions.Timeout:
            assert False, "Request timed out - injection succeeded"

    def test_hex_encoded_value(self):
        """
        Test hex-encoded value injection.
        """
        # 0x31 is hex for '1'
        payload = "0x31 OR 1=1"
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for hex-encoded payload, got {resp.status_code}"

    def test_unicode_injection(self):
        """
        Test unicode character injection.
        """
        payload = "1\u0027 OR \u00271\u0027=\u00271"
        params = {"id_pet": payload}

        resp = self.session.get(self.url, params=params, timeout=30)

        assert resp.status_code == 400, \
            f"Expected 400 for unicode injection, got {resp.status_code}"


class TestErrorMessageValidation:
    """
    Tests to verify correct error message is returned.
    """

    def setup_method(self):
        """Set up session for each test."""
        self.session = get_session_cookie()
        self.url = f"{BASE_URL}/html/pet/profile_pet.php"

    def test_error_message_content(self):
        """
        Verify that the error message is correct for invalid input.

        VULNERABLE: Returns 200 with page content (not 400 error message)
        FIXED: Returns 400 with JSON error message
        """
        params = {"id_pet": "invalid"}

        resp = self.session.get(self.url, params=params, timeout=30)

        # In fixed state, should return 400 with proper error message
        assert resp.status_code == 400, \
            f"Expected 400 for invalid input 'invalid', got {resp.status_code}"

        # If we got 400, also check the error message content
        content = resp.text
        # The fix returns: json_encode('O id do pet informado não é válido.')
        assert "id" in content.lower() or "pet" in content.lower() or "inv" in content.lower(), \
            "Error message should indicate invalid pet ID"
