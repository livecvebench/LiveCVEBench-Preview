diff --git a/poc/im-metadata.test.js b/poc/im-metadata.test.js
new file mode 100644
index 0000000..e51fa09
--- /dev/null
+++ b/poc/im-metadata.test.js
@@ -0,0 +1,64 @@
+// tests/im-metadata.command-injection.test.js
+const fs = require('fs');
+const pathStr = './im-metadata';
+
+test('Command injection should NOT create files (fix should make this pass)', (done) => {
+  expect.assertions(2);
+
+  // cleanup before test
+  try {
+    if (fs.existsSync(pathStr)) fs.unlinkSync(pathStr);
+  } catch (e) {
+    // ignore cleanup errors
+  }
+
+  // 1) file must not exist before call
+  expect(fs.existsSync(pathStr)).toBe(false);
+
+  // require the module under test
+  const metadata = require('im-metadata');
+
+  // payload that would trigger command injection if vulnerable
+  const payload = './foo.jpg;touch im-metadata';
+
+  // call the function under test
+  let calledBack = false;
+  try {
+    const result = metadata(payload, { exif: true }, function (err, meta) {
+      calledBack = true;
+      finalize();
+    });
+
+    // if the module returns a Promise, wait for it
+    if (result && typeof result.then === 'function') {
+      result
+        .then(() => finalize())
+        .catch(() => finalize());
+      return;
+    }
+  } catch (e) {
+    // swallow synchronous exceptions and proceed to finalize
+  }
+
+  // fallback: if callback not invoked, wait a short time then finalize
+  setTimeout(() => {
+    if (!calledBack) finalize();
+  }, 200);
+
+  function finalize() {
+    const existsAfter = fs.existsSync(pathStr);
+
+    // cleanup if created by vulnerable code
+    try {
+      if (existsAfter) fs.unlinkSync(pathStr);
+    } catch (e) {
+      // ignore cleanup errors
+    }
+
+    // 2) expectation: file should NOT be created (fix -> test passes)
+    expect(existsAfter).toBe(false);
+
+    done();
+  }
+});
+
