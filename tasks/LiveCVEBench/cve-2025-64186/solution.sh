#!/bin/bash
# Solution script for PCR attestation validation vulnerability
# This fix adds proper validation to ensure received PCRs contain the minimal required set

set -e

# Ensure Go is in PATH (golang Docker image puts it in /usr/local/go/bin)
export PATH=$PATH:/usr/local/go/bin

cd /app

echo "Applying fix to attestation/pcrs.go..."

# Check if the fix is already applied (idempotent)
if grep -q "SatisfiedBy" /app/attestation/pcrs.go 2>/dev/null; then
    echo "Fix already applied (SatisfiedBy method exists)"
    exit 0
fi

# Create the fixed version of pcrs.go by adding the new methods
# We need to add isMinimalPCRSet() and SatisfiedBy() methods

# First, find where to insert (after the Equal method, before IsEmpty)
# We'll use sed to insert the new methods

# Create a temporary file with the new methods
cat > /tmp/new_methods.go << 'EOFMETHODS'

func (p *PCRs) isMinimalPCRSet() bool {
	return p.PCR0 != "" && p.PCR1 != "" && p.PCR2 != ""
}

// Check if the receivedPCRs meet the expectations of the provided PCRs.
// The PCRs given as a parameter are expected to be the PCRs received from the remote enclave.
//
// The `receivedPCRs` are compared against the current PCR object which is assumed to be a
// partial set of expected PCR values. Any set PCR values are expected to be equal to the
// corresponding `receivedPCRs` value.
//
// If any expected PCR value is not equal, this function returns false.
func (p *PCRs) SatisfiedBy(receivedPCRs PCRs) bool {
	// If the set of receivedPCRs has zero values for any of the minimally expected PCRs, short circuit
	if !receivedPCRs.isMinimalPCRSet() {
		return false
	}

	if p.PCR0 != "" && p.PCR0 != receivedPCRs.PCR0 {
		return false
	}

	if p.PCR1 != "" && p.PCR1 != receivedPCRs.PCR1 {
		return false
	}

	if p.PCR2 != "" && p.PCR2 != receivedPCRs.PCR2 {
		return false
	}

	if p.PCR8 != "" && p.PCR8 != receivedPCRs.PCR8 {
		return false
	}

	return true
}
EOFMETHODS

# Insert the new methods before the IsEmpty function
# Using sed to find the IsEmpty function and insert before it
sed -i '/^\/\/ IsEmpty checks if all PCRs/r /tmp/new_methods.go' /app/attestation/pcrs.go

# Alternative approach if the comment doesn't exist - insert after Equal method closing brace
# Check if insertion worked
if ! grep -q "SatisfiedBy" /app/attestation/pcrs.go; then
    echo "First insertion method failed, trying alternative..."

    # Find the line number of the last closing brace of Equal method (return true followed by })
    # and insert after it

    # Create a Python script to do the insertion more reliably
    python3 << 'EOFPYTHON'
import re

with open('/app/attestation/pcrs.go', 'r') as f:
    content = f.read()

new_methods = '''
func (p *PCRs) isMinimalPCRSet() bool {
	return p.PCR0 != "" && p.PCR1 != "" && p.PCR2 != ""
}

// Check if the receivedPCRs meet the expectations of the provided PCRs.
// The PCRs given as a parameter are expected to be the PCRs received from the remote enclave.
//
// The `receivedPCRs` are compared against the current PCR object which is assumed to be a
// partial set of expected PCR values. Any set PCR values are expected to be equal to the
// corresponding `receivedPCRs` value.
//
// If any expected PCR value is not equal, this function returns false.
func (p *PCRs) SatisfiedBy(receivedPCRs PCRs) bool {
	// If the set of receivedPCRs has zero values for any of the minimally expected PCRs, short circuit
	if !receivedPCRs.isMinimalPCRSet() {
		return false
	}

	if p.PCR0 != "" && p.PCR0 != receivedPCRs.PCR0 {
		return false
	}

	if p.PCR1 != "" && p.PCR1 != receivedPCRs.PCR1 {
		return false
	}

	if p.PCR2 != "" && p.PCR2 != receivedPCRs.PCR2 {
		return false
	}

	if p.PCR8 != "" && p.PCR8 != receivedPCRs.PCR8 {
		return false
	}

	return true
}
'''

# Find the end of Equal method and insert after it
# Pattern: the Equal method ends with "return true\n}"
pattern = r'(func \(p \*PCRs\) Equal\(pcrs PCRs\) bool \{[\s\S]*?return true\n\})'
match = re.search(pattern, content)

if match:
    insert_pos = match.end()
    content = content[:insert_pos] + new_methods + content[insert_pos:]
    with open('/app/attestation/pcrs.go', 'w') as f:
        f.write(content)
    print("Methods inserted after Equal method")
else:
    # Fallback: insert before IsEmpty
    pattern2 = r'(// IsEmpty checks)'
    if re.search(pattern2, content):
        content = re.sub(pattern2, new_methods + r'\n\1', content)
        with open('/app/attestation/pcrs.go', 'w') as f:
            f.write(content)
        print("Methods inserted before IsEmpty")
    else:
        # Last resort: append before the last function
        pattern3 = r'(func BuildStaticPcrProvider)'
        if re.search(pattern3, content):
            content = re.sub(pattern3, new_methods + r'\n\1', content)
            with open('/app/attestation/pcrs.go', 'w') as f:
                f.write(content)
            print("Methods inserted before BuildStaticPcrProvider")
        else:
            print("ERROR: Could not find insertion point")
            exit(1)
EOFPYTHON
fi

# Clean up temp file
rm -f /tmp/new_methods.go

# Verify the fix was applied
if grep -q "SatisfiedBy" /app/attestation/pcrs.go; then
    echo "Fix successfully applied!"

    # Verify the code compiles
    cd /app
    if go build ./attestation/...; then
        echo "Code compiles successfully"
    else
        echo "WARNING: Code may have syntax issues"
    fi
else
    echo "ERROR: Fix was not applied correctly"
    exit 1
fi

# Copy the test file to enable running the official tests
if [ -f /tests/pcrs_test.go ]; then
    cp /tests/pcrs_test.go /app/attestation/pcrs_test.go 2>/dev/null || true
fi

echo "Solution applied successfully"
