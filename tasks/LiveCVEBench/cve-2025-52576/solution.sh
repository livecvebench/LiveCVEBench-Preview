#!/bin/bash
# Solution script for Kanboard authentication CAPTCHA and rate limiting fix
# This script implements IP-based CAPTCHA tracking alongside username-based tracking

set -e

# Kanboard is installed at /var/www/html (Apache default) per Dockerfile
APP_DIR="/var/www/html"

# Create /app directory as a symlink for compatibility if solution is run from /app
if [ ! -d "/app" ]; then
    mkdir -p /app
fi

cd "$APP_DIR"

echo "=== Applying authentication fix ==="
echo "Working directory: $(pwd)"

# Step 1: Create the new CaptchaModel.php file
echo "Creating CaptchaModel.php..."
cat > "$APP_DIR/app/Model/CaptchaModel.php" << 'CAPTCHA_MODEL_EOF'
<?php

namespace Kanboard\Model;

use Kanboard\Core\Base;

/**
 * Captcha model
 *
 * @package  Kanboard\Model
 *
 * {"<IP_ADDRESS>": {"failed_login": <COUNT>, "lock_expiration_date": <TIMESTAMP>}}
 */
class CaptchaModel extends Base
{
    public function incrementFailedLogin($ipAddress)
    {
        $data = $this->getCaptchaData();
        if (!isset($data[$ipAddress])) {
            $data[$ipAddress] = ['failed_login' => 0, 'lock_expiration_date' => 0];
        }

        $data[$ipAddress]['failed_login']++;
        if ($data[$ipAddress]['failed_login'] >= BRUTEFORCE_CAPTCHA) {
            $data[$ipAddress]['lock_expiration_date'] = time() + BRUTEFORCE_LOCKDOWN_DURATION;
        }

        $this->setCaptchaData($data);
    }

    public function resetFailedLogin($ipAddress)
    {
        $data = $this->getCaptchaData();
        if (isset($data[$ipAddress])) {
            unset($data[$ipAddress]);
            $this->setCaptchaData($data);
        }
    }

    public function isLocked($ipAddress)
    {
        $data = $this->getCaptchaData();
        if (isset($data[$ipAddress]) && isset($data[$ipAddress]['lock_expiration_date'])) {
            return $data[$ipAddress]['lock_expiration_date'] > time();
        }
        return false;
    }

    protected function getCaptchaData()
    {
        $rawData = $this->configModel->getOption('captcha_data', '{}');
        $data = json_decode($rawData, true);
        if (!is_array($data)) {
            $data = [];
        }
        return $data;
    }

    protected function setCaptchaData(array $data)
    {
        $this->configModel->save(['captcha_data' => json_encode($data)]);
    }
}
CAPTCHA_MODEL_EOF

# Step 2: Modify AuthController.php - Add IP-based CAPTCHA check
echo "Patching AuthController.php..."
cat > "$APP_DIR/app/Controller/AuthController.php" << 'AUTH_CONTROLLER_EOF'
<?php

namespace Kanboard\Controller;

/**
 * Authentication Controller
 *
 * @package  Kanboard\Controller
 * @author   Frederic Guillot
 */
class AuthController extends BaseController
{
    /**
     * Display the form login
     *
     * @access public
     * @param array $values
     * @param array $errors
     */
    public function login(array $values = array(), array $errors = array())
    {
        if ($this->userSession->isLogged()) {
            $this->response->redirect($this->helper->url->to('DashboardController', 'show'));
        } else {
            $showCaptcha = false;
            if (! empty($values['username']) && $this->userLockingModel->hasCaptcha($values['username'])) {
                $showCaptcha = true;
            } elseif ($this->captchaModel->isLocked($this->request->getIpAddress())) {
                $showCaptcha = true;
            }
            $this->response->html($this->helper->layout->app('auth/index', array(
                'captcha' => $showCaptcha,
                'errors' => $errors,
                'values' => $values,
                'no_layout' => true,
                'title' => t('Login')
            )));
        }
    }

    /**
     * Check credentials
     *
     * @access public
     */
    public function check()
    {
        $values = $this->request->getValues();
        session_set('hasRememberMe', ! empty($values['remember_me']));
        list($valid, $errors) = $this->authValidator->validateForm($values);

        if ($valid) {
            $this->redirectAfterLogin();
        } else {
            $this->login($values, $errors);
        }
    }

    /**
     * Logout and destroy session
     *
     * @access public
     */
    public function logout()
    {
        if (! DISABLE_LOGOUT) {
            $this->checkCSRFParam();
            $this->sessionManager->close();
            $this->response->redirect($this->helper->url->to('AuthController', 'login'));
        } else {
            $this->response->redirect($this->helper->url->to('DashboardController', 'show'));
        }
    }
}
AUTH_CONTROLLER_EOF

# Step 3: Modify AuthValidator.php - Add IP-based CAPTCHA validation and generic error message
echo "Patching AuthValidator.php..."
cat > "$APP_DIR/app/Validator/AuthValidator.php" << 'AUTH_VALIDATOR_EOF'
<?php

namespace Kanboard\Validator;

use SimpleValidator\Validator;
use SimpleValidator\Validators;
use Gregwar\Captcha\CaptchaBuilder;

/**
 * Authentication Validator
 *
 * @package  Kanboard\Validator
 * @author   Frederic Guillot
 */
class AuthValidator extends BaseValidator
{
    /**
     * Validate user login form
     *
     * @access public
     * @param  array   $values           Form values
     * @return array   $valid, $errors   [0] = Success or not, [1] = List of errors
     */
    public function validateForm(array $values)
    {
        return $this->executeValidators(array('validateFields', 'validateLocking', 'validateCaptcha', 'validateCredentials'), $values);
    }

    /**
     * Validate credentials syntax
     *
     * @access protected
     * @param  array   $values           Form values
     * @return array   $valid, $errors   [0] = Success or not, [1] = List of errors
     */
    protected function validateFields(array $values)
    {
        $v = new Validator($values, array(
            new Validators\Required('username', t('The username is required')),
            new Validators\MaxLength('username', t('The maximum length is %d characters', 191), 191),
            new Validators\Required('password', t('The password is required')),
        ));

        return array(
            $v->execute(),
            $v->getErrors(),
        );
    }

    /**
     * Validate user locking
     *
     * @access protected
     * @param  array   $values           Form values
     * @return array   $valid, $errors   [0] = Success or not, [1] = List of errors
     */
    protected function validateLocking(array $values)
    {
        $result = true;
        $errors = array();

        if ($this->userLockingModel->isLocked($values['username'])) {
            $result = false;
            $errors['login'] = t('Your account is locked for %d minutes', BRUTEFORCE_LOCKDOWN_DURATION);
            $this->logger->error('Account locked: '.$values['username']);
        }

        return array($result, $errors);
    }

    /**
     * Validate password syntax
     *
     * @access protected
     * @param  array   $values           Form values
     * @return array   $valid, $errors   [0] = Success or not, [1] = List of errors
     */
    protected function validateCredentials(array $values)
    {
        $result = true;
        $errors = array();

        if (! $this->authenticationManager->passwordAuthentication($values['username'], $values['password'])) {
            $result = false;
            $errors['login'] = t('Bad username or password');
        }

        return array($result, $errors);
    }

    /**
     * Validate captcha
     *
     * @access protected
     * @param  array   $values           Form values
     * @return array
     */
    protected function validateCaptcha(array $values)
    {
        $result = true;
        $errors = array();

        if ($this->userLockingModel->hasCaptcha($values['username']) || $this->captchaModel->isLocked($this->request->getIpAddress())) {
            if (! session_exists('captcha')) {
                $result = false;
            } else {
                $builder = new CaptchaBuilder;
                $builder->setPhrase(session_get('captcha'));
                $result = $builder->testPhrase(isset($values['captcha']) ? $values['captcha'] : '');

                if (! $result) {
                    $errors['login'] = t('Bad username or password');
                }
            }
        }

        return array($result, $errors);
    }
}
AUTH_VALIDATOR_EOF

# Step 4: Modify AuthSubscriber.php - Add IP-based tracking for login success/failure
echo "Patching AuthSubscriber.php..."
cat > "$APP_DIR/app/Subscriber/AuthSubscriber.php" << 'AUTH_SUBSCRIBER_EOF'
<?php

namespace Kanboard\Subscriber;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Kanboard\Core\Security\AuthenticationManager;
use Kanboard\Core\Session\SessionManager;
use Kanboard\Event\AuthSuccessEvent;
use Kanboard\Event\AuthFailureEvent;

/**
 * Authentication Subscriber
 *
 * @package subscriber
 * @author  Frederic Guillot
 */
class AuthSubscriber extends BaseSubscriber implements EventSubscriberInterface
{
    /**
     * Get event listeners
     *
     * @static
     * @access public
     * @return array
     */
    public static function getSubscribedEvents()
    {
        return array(
            AuthenticationManager::EVENT_SUCCESS => 'afterLogin',
            AuthenticationManager::EVENT_FAILURE => 'onLoginFailure',
            SessionManager::EVENT_DESTROY => 'afterLogout',
        );
    }

    /**
     * After Login callback
     *
     * @access public
     * @param  AuthSuccessEvent $event
     */
    public function afterLogin(AuthSuccessEvent $event)
    {
        $this->logger->debug('Subscriber executed: '.__METHOD__);

        $userAgent = $this->request->getUserAgent();
        $ipAddress = $this->request->getIpAddress();

        $this->userLockingModel->resetFailedLogin($this->userSession->getUsername());
        $this->captchaModel->resetFailedLogin($ipAddress);

        $this->lastLoginModel->create(
            $event->getAuthType(),
            $this->userSession->getId(),
            $ipAddress,
            $userAgent
        );

        if ($event->getAuthType() === 'RememberMe') {
            $this->userSession->setPostAuthenticationAsValidated();
        }

        if (session_is_true('hasRememberMe') && ! $this->userSession->hasPostAuthentication()) {
            $session = $this->rememberMeSessionModel->create($this->userSession->getId(), $ipAddress, $userAgent);
            $this->rememberMeCookie->write($session['token'], $session['sequence'], $session['expiration']);
        }
    }

    /**
     * Destroy RememberMe session on logout
     *
     * @access public
     */
    public function afterLogout()
    {
        $this->logger->debug('Subscriber executed: '.__METHOD__);
        $credentials = $this->rememberMeCookie->read();

        if ($credentials !== false) {
            $session = $this->rememberMeSessionModel->find($credentials['token'], $credentials['sequence']);

            if (! empty($session)) {
                $this->rememberMeSessionModel->remove($session['id']);
            }

            $this->rememberMeCookie->remove();
        }
    }

    /**
     * Increment failed login counter
     *
     * @access public
     * @param AuthFailureEvent $event
     */
    public function onLoginFailure(AuthFailureEvent $event)
    {
        $this->logger->debug('Subscriber executed: '.__METHOD__);
        $username = $event->getUsername();
        $ipAddress = $this->request->getIpAddress();

        // IP-based captcha
        $this->captchaModel->incrementFailedLogin($ipAddress);

        if (! empty($username)) {
            // log login failure in web server log to allow fail2ban usage
            error_log('Kanboard: user '.$username.' authentication failure with IP address: '.$ipAddress);
            $this->userLockingModel->incrementFailedLogin($username);

            if ($this->userLockingModel->getFailedLogin($username) > BRUTEFORCE_LOCKDOWN) {
                $this->userLockingModel->lock($username, BRUTEFORCE_LOCKDOWN_DURATION);
            }
        }
        else {
            // log login failure in web server log to allow fail2ban usage
            error_log('Kanboard: user Unknown authentication failure with IP address: '.$ipAddress);
        }
    }
}
AUTH_SUBSCRIBER_EOF

# Step 5: Register CaptchaModel in the service container by adding it to the Model array
echo "Updating ClassProvider.php to register CaptchaModel..."

# The ClassProvider uses an array-based pattern where 'Model' array lists model class names
# We need to add 'CaptchaModel' to that array

# Use sed to add CaptchaModel after an existing model in the Model array
# Look for 'UserLockingModel' and add CaptchaModel before it (so it's in the Model section)
sed -i "/'UserLockingModel',/a\\            'CaptchaModel'," "$APP_DIR/app/ServiceProvider/ClassProvider.php"

# Step 6: Update Base.php to add property annotation for captchaModel (for IDE support)
echo "Updating Base.php with captchaModel property annotation..."

# Add the property annotation after existing @property annotations for Model
if grep -q "@property.*UserLockingModel" "$APP_DIR/app/Core/Base.php"; then
    sed -i '/@property.*UserLockingModel/a\ * @property \\Kanboard\\Model\\CaptchaModel $captchaModel' "$APP_DIR/app/Core/Base.php"
fi

# Step 7: Set correct permissions
echo "Setting correct permissions..."
chown -R www-data:www-data "$APP_DIR/app" 2>/dev/null || true
chmod -R 755 "$APP_DIR/app" 2>/dev/null || true

echo ""
echo "=== Fix applied successfully ==="
echo "Changes made:"
echo "  1. Created CaptchaModel.php - IP-based CAPTCHA tracking"
echo "  2. Updated AuthController.php - Check IP-based CAPTCHA lock"
echo "  3. Updated AuthValidator.php - Validate CAPTCHA by IP, generic error message"
echo "  4. Updated AuthSubscriber.php - Track IP on login success/failure"
echo "  5. Registered CaptchaModel in ClassProvider.php"
echo ""
echo "The authentication system now:"
echo "  - Shows CAPTCHA after 3 failed attempts from any IP (regardless of username validity)"
echo "  - Tracks failed login attempts by IP address"
echo "  - Uses generic error messages to prevent information leakage"
