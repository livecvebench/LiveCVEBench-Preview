// test_extractor.go - A minimal Go program that replicates esm.sh's tar extraction logic
// This is used by the Python tests to verify the vulnerability fix.
//
// Build: go build -o test_extractor test_extractor.go
// Usage: ./test_extractor <tarball_path> <extract_dir>

package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"os"
	"path"
	"strings"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <tarball_path> <extract_dir>\n", os.Args[0])
		os.Exit(1)
	}

	tarballPath := os.Args[1]
	extractDir := os.Args[2]

	err := extractTarball(tarballPath, extractDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Extraction completed successfully")
}

// extractTarball extracts a gzipped tarball to the specified directory.
// This replicates the logic from esm.sh's ghInstall function.
func extractTarball(tarballPath, extractDir string) error {
	f, err := os.Open(tarballPath)
	if err != nil {
		return fmt.Errorf("failed to open tarball: %v", err)
	}
	defer f.Close()

	// Unzip
	unzipped, err := gzip.NewReader(f)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %v", err)
	}
	defer unzipped.Close()

	// Create tar reader
	tr := tar.NewReader(unzipped)

	// Root directory for extraction (simulating node_modules/pkgname)
	rootDir := path.Join(extractDir, "node_modules", "test-pkg")

	for {
		h, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to read tar entry: %v", err)
		}

		// Strip tarball root dir (usually "package/")
		parts := strings.Split(h.Name, "/")
		if len(parts) <= 1 {
			continue
		}
		hname := strings.Join(parts[1:], "/")

		// Skip hidden files (starting with .)
		if strings.HasPrefix(hname, ".") {
			continue
		}

		// Skip empty names
		if hname == "" {
			continue
		}

		// THIS IS THE VULNERABLE LINE - no path.Clean() sanitization
		// In fixed version, this should be: fp := path.Join(rootDir, path.Clean(hname))
		fp := path.Join(rootDir, hname)

		// Handle directories
		if h.Typeflag == tar.TypeDir {
			if err := os.MkdirAll(fp, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", fp, err)
			}
			continue
		}

		// Skip non-regular files (symlinks, etc.)
		if h.Typeflag != tar.TypeReg {
			continue
		}

		// Ensure parent directory exists
		if err := os.MkdirAll(path.Dir(fp), 0755); err != nil {
			return fmt.Errorf("failed to create parent directory: %v", err)
		}

		// Create and write file
		outFile, err := os.OpenFile(fp, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
		if err != nil {
			return fmt.Errorf("failed to create file %s: %v", fp, err)
		}

		_, err = io.Copy(outFile, tr)
		outFile.Close()
		if err != nil {
			return fmt.Errorf("failed to write file %s: %v", fp, err)
		}

		fmt.Printf("Extracted: %s -> %s\n", h.Name, fp)
	}

	return nil
}
