"""
Vulnerability tests for Assimp BVH loader CVE-2025-6119.

Tests that verify the heap-use-after-free vulnerability exists.

- FAIL in vulnerable state (memory corruption detected by ASAN)
- PASS in fixed state (no ASAN errors)
"""

import subprocess
import os
import sys
import pytest
import signal

# Paths in the container
APP_DIR = "/app"
POC_BVH = "/app/task-deps/poc_bvh_uaf.bvh"
TEST_PROGRAM = "/app/build/bin/assimpd"


def run_assimp_with_asan(bvh_file: str, timeout: int = 60) -> subprocess.CompletedProcess:
    """
    Run assimp command on a BVH file with ASAN enabled.
    Returns the result with stdout/stderr for analysis.
    """
    cmd = [TEST_PROGRAM, "info", bvh_file]

    # ASAN options for reliable detection
    asan_options = (
        "detect_leaks=0:"
        "halt_on_error=1:"
        "print_stacktrace=1:"
        "abort_on_error=1"
    )

    env = {**os.environ, "ASAN_OPTIONS": asan_options}

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=APP_DIR,
            env=env
        )
        return result
    except subprocess.TimeoutExpired:
        # Timeout could indicate a hang due to corruption
        return subprocess.CompletedProcess(
            cmd, returncode=-1,
            stdout="", stderr="TIMEOUT: Process did not complete"
        )


def check_for_memory_errors(stderr: str, returncode: int) -> tuple:
    """
    Check for memory errors in the output.
    Returns (has_error, error_message).
    """
    # Check for ASAN-detected memory errors
    asan_errors = [
        "AddressSanitizer",
        "heap-use-after-free",
        "heap-buffer-overflow",
        "stack-buffer-overflow",
        "use-after-poison",
        "double-free",
        "ERROR: AddressSanitizer",
    ]

    for error in asan_errors:
        if error in stderr:
            return True, f"ASAN error detected: {error}"

    # Check for signals indicating crash (SIGABRT from ASAN)
    crash_signals = [
        (signal.SIGSEGV, "SEGV", "Segmentation fault"),
        (signal.SIGABRT, "ABRT", "Abort signal (ASAN)"),
        (signal.SIGBUS, "BUS", "Bus error"),
    ]

    for sig_num, sig_name, sig_desc in crash_signals:
        if returncode == -sig_num or returncode == 128 + sig_num:
            return True, f"Crash detected: {sig_desc} (signal {sig_name})"

    return False, ""


class TestHeapUseAfterFree:
    """
    Test that the PoC file triggers heap-use-after-free vulnerability.

    These tests should FAIL when vulnerability EXISTS (vulnerable state).
    These tests should PASS when vulnerability is FIXED.
    """

    def test_poc_file_no_heap_use_after_free(self):
        """
        Test that the PoC BVH file does not trigger heap-use-after-free.

        The PoC file contains a malformed BVH structure designed to trigger
        vector reallocation during parsing, which exposes the memory bug.

        VULNERABLE STATE: This test FAILS because ASAN detects heap-use-after-free
        FIXED STATE: This test PASSES because the vulnerability is patched
        """
        assert os.path.exists(POC_BVH), f"PoC file not found at {POC_BVH}"

        result = run_assimp_with_asan(POC_BVH)

        has_error, error_msg = check_for_memory_errors(result.stderr, result.returncode)

        # Test PASSES if no memory errors detected
        assert not has_error, (
            f"Memory corruption detected when loading PoC file.\n"
            f"Error: {error_msg}\n"
            f"Return code: {result.returncode}\n"
            f"Stderr: {result.stderr[:2000]}"
        )

    def test_poc_file_no_asan_abort(self):
        """
        Test that loading the PoC file does not cause an ASAN abort.

        VULNERABLE STATE: This test FAILS because ASAN aborts on memory error
        FIXED STATE: This test PASSES
        """
        result = run_assimp_with_asan(POC_BVH)

        # ASAN abort sends SIGABRT (signal 6)
        # returncode will be -6 or 134 (128 + 6)
        has_asan_abort = (
            result.returncode == -signal.SIGABRT or
            result.returncode == 128 + signal.SIGABRT or
            result.returncode == 134 or  # 128 + 6 explicitly
            ("AddressSanitizer" in result.stderr and result.returncode != 0)
        )

        assert not has_asan_abort, (
            f"ASAN abort when loading PoC file.\n"
            f"Return code: {result.returncode}\n"
            f"Stderr: {result.stderr[:2000]}"
        )

    def test_poc_in_isolated_subprocess(self):
        """
        Run the PoC test in a fully isolated subprocess to catch any crash.

        VULNERABLE STATE: This test FAILS because ASAN error is detected
        FIXED STATE: This test PASSES
        """
        # Python script to run in subprocess
        test_script = f'''
import subprocess
import sys
import os

result = subprocess.run(
    ["{TEST_PROGRAM}", "info", "{POC_BVH}"],
    capture_output=True,
    text=True,
    timeout=60,
    env={{**os.environ, "ASAN_OPTIONS": "detect_leaks=0:halt_on_error=1:abort_on_error=1"}}
)

# Check for ASAN errors
if "AddressSanitizer" in result.stderr or "heap-use-after-free" in result.stderr:
    print("ASAN_ERROR")
    sys.exit(1)

# Check for crash signals (negative or > 128)
if result.returncode < 0 or result.returncode > 128:
    print(f"CRASH_SIGNAL:{{result.returncode}}")
    sys.exit(1)

print("SUCCESS")
sys.exit(0)
'''

        # Run the test script in a subprocess
        proc = subprocess.run(
            [sys.executable, "-c", test_script],
            capture_output=True,
            text=True,
            timeout=120
        )

        output = proc.stdout + proc.stderr

        assert "ASAN_ERROR" not in output, "ASAN detected memory error in isolated test"
        assert "CRASH_SIGNAL" not in output, f"Crash detected: {output}"
        assert proc.returncode == 0, f"Isolated test failed with code {proc.returncode}: {output}"


if __name__ == "__main__":
    pytest.main([__file__, "-rA"])
