#!/usr/bin/env python3
"""
Vulnerability tests for buffer over-read in ArrayBuffer.prototype.slice().

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated - TypeError thrown)

The vulnerability occurs when a custom Symbol.species constructor resizes
the ArrayBuffer during a slice operation, causing out-of-bounds memory access.
"""
import subprocess
import pytest
import tempfile
import os
import signal

QJS_BINARY = "/app/quickjs/qjs"


def run_js(code: str, timeout: int = 10) -> subprocess.CompletedProcess:
    """Run JavaScript code using QuickJS and return the result."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(code)
        f.flush()
        temp_path = f.name

    try:
        result = subprocess.run(
            [QJS_BINARY, temp_path],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result
    finally:
        os.unlink(temp_path)


class TestBufferOverReadVulnerability:
    """
    Test the buffer over-read vulnerability in ArrayBuffer.prototype.slice().

    The vulnerability allows reading memory beyond the buffer when:
    1. A resizable ArrayBuffer is created
    2. Symbol.species is overridden to resize the buffer during slice()
    3. The slice offsets are calculated before resize, used after resize
    """

    def test_resize_during_slice_basic(self):
        """
        Basic test: resize buffer to smaller size during slice.

        Fixed behavior: Should throw TypeError
        Vulnerable behavior: Completes without error (unsafe memory read)
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(100);  // Shrink from 1000 to 100 bytes
        return new ArrayBuffer(len);
    }
});

let caught = false;
let errorType = "";
try {
    buf.slice(500, 1000);  // Tries to read bytes 500-1000 from 100-byte buffer
} catch (e) {
    caught = true;
    errorType = e.constructor.name;
}

if (caught && errorType === "TypeError") {
    print("FIXED: TypeError thrown as expected");
} else {
    print("VULNERABLE: No error - buffer over-read occurred");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_during_slice_extreme_shrink(self):
        """
        Extreme case: resize buffer to minimal size (1 byte).

        This maximizes the out-of-bounds read if vulnerable.
        """
        code = """
let buf = new ArrayBuffer(2000, { maxByteLength: 4000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(1);  // Shrink to just 1 byte
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(1000, 2000);  // Would read 1000 bytes starting at offset 1000
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_during_slice_to_zero(self):
        """
        Edge case: resize buffer to zero bytes.
        """
        code = """
let buf = new ArrayBuffer(500, { maxByteLength: 1000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(0);  // Shrink to zero bytes
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(100, 300);  // Would read 200 bytes from empty buffer
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_during_slice_start_at_zero(self):
        """
        Case where slice starts at offset 0 but buffer shrinks.
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(50);  // Shrink to 50 bytes
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(0, 500);  // Would read 500 bytes, but buffer is now 50
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_during_slice_full_range(self):
        """
        Case with full buffer slice that gets shrunk.
        """
        code = """
let buf = new ArrayBuffer(800, { maxByteLength: 1600 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(10);
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice();  // Full slice: 0 to 800, but buffer becomes 10 bytes
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_exactly_to_start_offset(self):
        """
        Resize buffer to exactly the start offset (still vulnerable).

        slice(100, 200) requires buffer to be at least 200 bytes.
        Resizing to 100 should trigger the protection.
        """
        code = """
let buf = new ArrayBuffer(500, { maxByteLength: 1000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(100);  // Resize to exactly start offset
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(100, 200);  // start=100, needs 200 bytes minimum
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_just_below_required(self):
        """
        Resize buffer to just 1 byte below required length.
        """
        code = """
let buf = new ArrayBuffer(300, { maxByteLength: 600 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(199);  // Just below the required 200
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(100, 200);  // Needs 200 bytes
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_resize_with_negative_slice_indices(self):
        """
        Test with negative slice indices (converted to positive offsets).
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(50);  // Much smaller than original
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    // slice(-500) on 1000-byte buffer = slice(500, 1000)
    // After resize to 50 bytes, this is out of bounds
    buf.slice(-500);
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_species_returns_different_constructor(self):
        """
        Test where species returns a constructor for a different buffer.
        The original buffer is still the one being read from.
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 2000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(10);  // Shrink original buffer
        // Return a new ArrayBuffer (doesn't matter, original is read)
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(500, 900);
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )

    def test_multiple_resizes_in_species(self):
        """
        Test with multiple resize operations in species constructor.
        """
        code = """
let buf = new ArrayBuffer(1000, { maxByteLength: 3000 });
Object.defineProperty(buf.constructor, Symbol.species, {
    value: function(len) {
        buf.resize(2000);  // First grow
        buf.resize(500);   // Then shrink
        buf.resize(100);   // Final very small size
        return new ArrayBuffer(len);
    }
});

let caught = false;
try {
    buf.slice(200, 800);
} catch (e) {
    if (e instanceof TypeError) caught = true;
}

if (caught) {
    print("FIXED: TypeError thrown");
} else {
    print("VULNERABLE: No error thrown");
}
"""
        result = run_js(code)
        assert "FIXED" in result.stdout, (
            f"Vulnerability not fixed. Output: {result.stdout}{result.stderr}"
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
