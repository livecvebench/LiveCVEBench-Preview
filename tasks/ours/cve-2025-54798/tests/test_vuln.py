"""
Vulnerability tests for the tmp library path validation bypass.
These tests verify that indirect path references cannot bypass validation.

- FAIL in vulnerable state (bypass is possible)
- PASS in fixed state (bypass is blocked)
"""
import subprocess
import os


def run_node_script(script, cwd='/app'):
    """Helper to run Node.js scripts and capture output."""
    result = subprocess.run(
        ['node', '-e', script],
        capture_output=True,
        text=True,
        cwd=cwd
    )
    return result


def test_symlink_dir_bypass_blocked():
    """
    Test that using a symlink as the dir option is blocked.

    Attack scenario:
    1. Create a symlink in /tmp pointing to a location outside /tmp
    2. Use this symlink as the 'dir' option
    3. Without fix: file is created outside /tmp (via symlink)
    4. With fix: error is thrown because real path is outside /tmp
    """
    script = '''
    const tmp = require('tmp');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    const targetDir = '/app/attack-target-dir';
    const tmpDir = os.tmpdir();
    const symlinkPath = path.join(tmpDir, 'bypass-test-link');

    // Cleanup from previous runs
    try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
    try { fs.unlinkSync(symlinkPath); } catch(e) {}

    // Setup: create target and symlink
    fs.mkdirSync(targetDir, { recursive: true });
    fs.symlinkSync(targetDir, symlinkPath);

    try {
        // Attempt bypass: use symlink name as dir option
        const result = tmp.fileSync({ dir: 'bypass-test-link' });

        // Check if file was actually created outside /tmp
        const realFilePath = fs.realpathSync(result.name);

        if (realFilePath.startsWith(targetDir)) {
            console.log('VULNERABLE: File written to ' + realFilePath);
            process.exit(1);
        } else {
            console.log('OK: File in expected location ' + realFilePath);
            process.exit(0);
        }
    } catch (err) {
        // Expected behavior after fix: error thrown
        if (err.message.includes('must be relative to') ||
            err.message.includes('ENOENT') ||
            err.code === 'ENOENT') {
            console.log('PROTECTED: ' + err.message);
            process.exit(0);
        }
        console.log('UNEXPECTED_ERROR: ' + err.message);
        process.exit(2);
    } finally {
        // Cleanup
        try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
        try { fs.unlinkSync(symlinkPath); } catch(e) {}
    }
    '''
    result = run_node_script(script)

    assert result.returncode == 0, \
        f"Symlink dir bypass not blocked!\nstdout: {result.stdout}\nstderr: {result.stderr}"
    assert 'VULNERABLE' not in result.stdout, \
        f"Symlink bypass succeeded: {result.stdout}"


def test_symlink_template_bypass_blocked():
    """
    Test that using a symlink in the template path is blocked.

    Similar to dir option, but using template option with symlink path.
    """
    script = '''
    const tmp = require('tmp');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    const targetDir = '/app/attack-target-template';
    const tmpDir = os.tmpdir();
    const symlinkPath = path.join(tmpDir, 'template-bypass-link');

    // Cleanup
    try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
    try { fs.unlinkSync(symlinkPath); } catch(e) {}

    // Setup
    fs.mkdirSync(targetDir, { recursive: true });
    fs.symlinkSync(targetDir, symlinkPath);

    try {
        // Attempt bypass via template option
        const result = tmp.fileSync({ template: 'template-bypass-link/file-XXXXXX' });

        const realFilePath = fs.realpathSync(result.name);

        if (realFilePath.startsWith(targetDir)) {
            console.log('VULNERABLE: File written to ' + realFilePath);
            process.exit(1);
        } else {
            console.log('OK: File in expected location ' + realFilePath);
            process.exit(0);
        }
    } catch (err) {
        if (err.message.includes('must be relative to') ||
            err.message.includes('ENOENT') ||
            err.code === 'ENOENT') {
            console.log('PROTECTED: ' + err.message);
            process.exit(0);
        }
        console.log('UNEXPECTED_ERROR: ' + err.message);
        process.exit(2);
    } finally {
        try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
        try { fs.unlinkSync(symlinkPath); } catch(e) {}
    }
    '''
    result = run_node_script(script)

    assert result.returncode == 0, \
        f"Symlink template bypass not blocked!\nstdout: {result.stdout}\nstderr: {result.stderr}"
    assert 'VULNERABLE' not in result.stdout, \
        f"Template bypass succeeded: {result.stdout}"


def test_async_symlink_bypass_blocked():
    """
    Test that async file() function also blocks symlink bypass.
    """
    script = '''
    const tmp = require('tmp');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    const targetDir = '/app/attack-target-async';
    const tmpDir = os.tmpdir();
    const symlinkPath = path.join(tmpDir, 'async-bypass-link');

    // Cleanup
    try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
    try { fs.unlinkSync(symlinkPath); } catch(e) {}

    // Setup
    fs.mkdirSync(targetDir, { recursive: true });
    fs.symlinkSync(targetDir, symlinkPath);

    tmp.file({ dir: 'async-bypass-link' }, (err, filePath, fd, cleanup) => {
        // Cleanup symlink and target
        const cleanupAll = () => {
            try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
            try { fs.unlinkSync(symlinkPath); } catch(e) {}
        };

        if (err) {
            if (err.message.includes('must be relative to') ||
                err.message.includes('ENOENT') ||
                err.code === 'ENOENT') {
                console.log('PROTECTED: ' + err.message);
                cleanupAll();
                process.exit(0);
            }
            console.log('UNEXPECTED_ERROR: ' + err.message);
            cleanupAll();
            process.exit(2);
        }

        // File was created - check if it's outside /tmp
        try {
            const realFilePath = fs.realpathSync(filePath);
            if (realFilePath.startsWith(targetDir)) {
                console.log('VULNERABLE: File written to ' + realFilePath);
                cleanup();
                cleanupAll();
                process.exit(1);
            } else {
                console.log('OK: File in expected location ' + realFilePath);
                cleanup();
                cleanupAll();
                process.exit(0);
            }
        } catch (e) {
            console.log('ERROR checking path: ' + e.message);
            cleanupAll();
            process.exit(2);
        }
    });
    '''
    result = run_node_script(script)

    assert result.returncode == 0, \
        f"Async symlink bypass not blocked!\nstdout: {result.stdout}\nstderr: {result.stderr}"
    assert 'VULNERABLE' not in result.stdout, \
        f"Async bypass succeeded: {result.stdout}"


def test_dirSync_symlink_bypass_blocked():
    """
    Test that dirSync() also blocks symlink bypass.
    """
    script = '''
    const tmp = require('tmp');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    const targetDir = '/app/attack-target-dirsync';
    const tmpDir = os.tmpdir();
    const symlinkPath = path.join(tmpDir, 'dirsync-bypass-link');

    // Cleanup
    try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
    try { fs.unlinkSync(symlinkPath); } catch(e) {}

    // Setup
    fs.mkdirSync(targetDir, { recursive: true });
    fs.symlinkSync(targetDir, symlinkPath);

    try {
        const result = tmp.dirSync({ dir: 'dirsync-bypass-link' });

        const realDirPath = fs.realpathSync(result.name);

        if (realDirPath.startsWith(targetDir)) {
            console.log('VULNERABLE: Directory written to ' + realDirPath);
            process.exit(1);
        } else {
            console.log('OK: Directory in expected location ' + realDirPath);
            process.exit(0);
        }
    } catch (err) {
        if (err.message.includes('must be relative to') ||
            err.message.includes('ENOENT') ||
            err.code === 'ENOENT') {
            console.log('PROTECTED: ' + err.message);
            process.exit(0);
        }
        console.log('UNEXPECTED_ERROR: ' + err.message);
        process.exit(2);
    } finally {
        try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
        try { fs.unlinkSync(symlinkPath); } catch(e) {}
    }
    '''
    result = run_node_script(script)

    assert result.returncode == 0, \
        f"dirSync symlink bypass not blocked!\nstdout: {result.stdout}\nstderr: {result.stderr}"
    assert 'VULNERABLE' not in result.stdout, \
        f"dirSync bypass succeeded: {result.stdout}"


def test_absolute_symlink_path_blocked():
    """
    Test that using absolute symlink path is also blocked.
    """
    script = '''
    const tmp = require('tmp');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');

    const targetDir = '/app/attack-target-absolute';
    const tmpDir = os.tmpdir();
    const symlinkPath = path.join(tmpDir, 'absolute-bypass-link');

    // Cleanup
    try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
    try { fs.unlinkSync(symlinkPath); } catch(e) {}

    // Setup
    fs.mkdirSync(targetDir, { recursive: true });
    fs.symlinkSync(targetDir, symlinkPath);

    try {
        // Use absolute path to symlink
        const result = tmp.fileSync({ dir: symlinkPath });

        const realFilePath = fs.realpathSync(result.name);

        if (realFilePath.startsWith(targetDir)) {
            console.log('VULNERABLE: File written to ' + realFilePath);
            process.exit(1);
        } else {
            console.log('OK: File in expected location ' + realFilePath);
            process.exit(0);
        }
    } catch (err) {
        if (err.message.includes('must be relative to') ||
            err.message.includes('ENOENT') ||
            err.code === 'ENOENT') {
            console.log('PROTECTED: ' + err.message);
            process.exit(0);
        }
        console.log('UNEXPECTED_ERROR: ' + err.message);
        process.exit(2);
    } finally {
        try { fs.rmSync(targetDir, { recursive: true, force: true }); } catch(e) {}
        try { fs.unlinkSync(symlinkPath); } catch(e) {}
    }
    '''
    result = run_node_script(script)

    assert result.returncode == 0, \
        f"Absolute symlink path bypass not blocked!\nstdout: {result.stdout}\nstderr: {result.stderr}"
    assert 'VULNERABLE' not in result.stdout, \
        f"Absolute path bypass succeeded: {result.stdout}"
