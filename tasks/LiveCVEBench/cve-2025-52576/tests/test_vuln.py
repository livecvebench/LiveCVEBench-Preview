"""
Vulnerability tests for Kanboard authentication system.

These tests verify the vulnerability status:
- FAIL on vulnerable version (vulnerability is exploitable)
- PASS on fixed version (vulnerability is mitigated)

The vulnerability involves:
1. Username enumeration via inconsistent CAPTCHA behavior
2. IP-based rate limiting bypass

BRUTEFORCE_CAPTCHA = 3 (attempts before CAPTCHA appears)
"""

import pytest
import requests
import re
import time
import os
import random

BASE_URL = os.environ.get("APP_URL", "http://localhost:8080")

# Test usernames
VALID_USERNAME = "admin"  # Known to exist in default Kanboard install
INVALID_USERNAME = "nonexistent_user_enumtest_12345"  # Should not exist
INVALID_PASSWORD = "wrongpassword12345"


class TestSession:
    """Manage session state for tests"""

    @staticmethod
    def get_session():
        return requests.Session()

    @staticmethod
    def get_csrf_token(session):
        """Extract CSRF token from login page"""
        response = session.get(f"{BASE_URL}/?controller=AuthController&action=login")
        match = re.search(r'name="csrf_token"\s+value="([^"]+)"', response.text)
        if match:
            return match.group(1)
        match = re.search(r'csrf_token["\']:\s*["\']([^"\']+)', response.text)
        if match:
            return match.group(1)
        return ""

    @staticmethod
    def has_captcha(response_text):
        """Check if CAPTCHA is present in response"""
        indicators = [
            'name="captcha"',
            'id="captcha"',
            'data:image/png;base64',  # Base64 CAPTCHA image
            'data:image/jpeg;base64',
            'captcha-image',
            '<img' in response_text.lower() and 'captcha' in response_text.lower(),
        ]
        return any(
            indicator in response_text if isinstance(indicator, str)
            else indicator
            for indicator in indicators
        )


class TestUsernameEnumeration:
    """
    Test username enumeration vulnerability via CAPTCHA behavior discrepancy.

    Vulnerability: Valid usernames trigger CAPTCHA after 3 failed attempts,
    but invalid usernames NEVER trigger CAPTCHA, allowing enumeration.

    Fix: CAPTCHA should trigger based on IP address, not just username.
    """

    def test_invalid_username_captcha_after_failures(self):
        """
        CRITICAL: Invalid username should show CAPTCHA after 3 failed attempts.

        Vulnerable behavior: CAPTCHA never appears for non-existent usernames
        Fixed behavior: CAPTCHA appears after 3 attempts regardless of username validity

        This test FAILS on vulnerable version, PASSES on fixed version.
        """
        session = TestSession.get_session()

        # Make 4 failed login attempts with an invalid username
        for i in range(4):
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": INVALID_USERNAME,
                    "password": f"wrongpassword_{i}",
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        # After 4 failed attempts, CAPTCHA should appear (if fixed)
        has_captcha = TestSession.has_captcha(response.text)

        # In FIXED version: CAPTCHA should appear regardless of username validity
        assert has_captcha, (
            "CAPTCHA should appear after 3 failed attempts even for non-existent usernames. "
            "This prevents username enumeration by observing CAPTCHA behavior."
        )

    def test_different_invalid_usernames_trigger_captcha(self):
        """
        Different invalid usernames from same IP should trigger CAPTCHA.

        Vulnerable: Each invalid username is treated separately, no CAPTCHA
        Fixed: IP is tracked, CAPTCHA appears after 3 total failures from same IP
        """
        session = TestSession.get_session()

        invalid_usernames = [
            "test_enum_user_1",
            "test_enum_user_2",
            "test_enum_user_3",
            "test_enum_user_4",
        ]

        # Try different invalid usernames
        for username in invalid_usernames:
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": username,
                    "password": INVALID_PASSWORD,
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        # After 4 failed attempts from same session/IP, CAPTCHA should appear
        has_captcha = TestSession.has_captcha(response.text)

        assert has_captcha, (
            "CAPTCHA should appear after multiple failed attempts from the same IP, "
            "even when using different invalid usernames."
        )

    def test_no_captcha_leak_for_invalid_vs_valid_usernames(self):
        """
        Verify CAPTCHA behavior is consistent between valid and invalid usernames.

        Vulnerable: Valid username shows CAPTCHA, invalid never does
        Fixed: Both should show CAPTCHA based on IP tracking
        """
        # Session 1: Test with valid username
        session1 = TestSession.get_session()
        for i in range(4):
            csrf_token = TestSession.get_csrf_token(session1)
            response1 = session1.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": VALID_USERNAME,
                    "password": f"wrong_{i}",
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        valid_has_captcha = TestSession.has_captcha(response1.text)

        # Session 2: Test with invalid username (different session to avoid IP tracking)
        session2 = TestSession.get_session()
        for i in range(4):
            csrf_token = TestSession.get_csrf_token(session2)
            response2 = session2.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": f"nonexistent_user_test_{random.randint(10000, 99999)}",
                    "password": f"wrong_{i}",
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        invalid_has_captcha = TestSession.has_captcha(response2.text)

        # Both scenarios should have consistent CAPTCHA behavior
        # In fixed version, both should show CAPTCHA
        assert invalid_has_captcha, (
            "CAPTCHA behavior must be consistent regardless of username validity. "
            "Invalid usernames should also trigger CAPTCHA after failed attempts."
        )


class TestIPBasedRateLimiting:
    """
    Test IP-based rate limiting for failed login attempts.

    Vulnerability: Only username-based tracking exists, IP-based tracking missing
    Fix: Implement IP-based tracking alongside username-based tracking
    """

    def test_ip_tracking_for_failed_logins(self):
        """
        Test that failed login attempts are tracked by IP address.

        After 3 failed attempts from the same IP, CAPTCHA should appear
        regardless of the username used.
        """
        session = TestSession.get_session()

        # Use unique random usernames that definitely don't exist
        for i in range(4):
            unique_username = f"random_user_{random.randint(100000, 999999)}"
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": unique_username,
                    "password": INVALID_PASSWORD,
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        # With IP-based tracking (fixed), CAPTCHA should appear
        has_captcha = TestSession.has_captcha(response.text)

        assert has_captcha, (
            "Failed login attempts should be tracked by IP address. "
            "CAPTCHA should appear after 3 failed attempts from the same IP, "
            "even with different usernames."
        )


class TestIPSpoofingBypass:
    """
    Test IP spoofing bypass vulnerability.

    Vulnerability: X-Forwarded-For and similar headers are trusted without validation,
    allowing attackers to bypass IP-based rate limiting.

    Note: The fix adds IP-based tracking but doesn't fully address header spoofing.
    These tests verify the IP tracking functionality exists.
    """

    def test_consistent_tracking_without_spoofing(self):
        """
        Without IP spoofing, rate limiting should work correctly.

        Multiple failed attempts from same session should be tracked.
        """
        session = TestSession.get_session()

        for i in range(5):
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": f"bruteforce_test_{random.randint(1000, 9999)}",
                    "password": f"attempt_{i}",
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        has_captcha = TestSession.has_captcha(response.text)

        assert has_captcha, (
            "Rate limiting should work for failed login attempts from the same source."
        )

    def test_captcha_with_forwarded_header(self):
        """
        Test that IP tracking considers forwarded headers.

        When using X-Forwarded-For, the tracked IP should be consistent
        within the same session.
        """
        session = TestSession.get_session()
        test_ip = f"10.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(1, 254)}"

        for i in range(4):
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": f"forward_test_{random.randint(1000, 9999)}",
                    "password": f"wrong_{i}",
                    "csrf_token": csrf_token
                },
                headers={
                    "X-Forwarded-For": test_ip
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        has_captcha = TestSession.has_captcha(response.text)

        # In fixed version, IP (even from header) should be tracked
        assert has_captcha, (
            "IP-based tracking should work even when X-Forwarded-For is present. "
            "CAPTCHA should appear after multiple failed attempts."
        )


class TestErrorMessageLeakage:
    """
    Test that error messages don't leak sensitive information.

    Vulnerability: "Invalid captcha" error message reveals CAPTCHA was expected
    Fix: Use generic "Bad username or password" message
    """

    def test_captcha_error_uses_generic_message(self):
        """
        When CAPTCHA validation fails, error should be generic.

        Trigger CAPTCHA, then submit wrong CAPTCHA value and verify
        the error message doesn't specifically mention CAPTCHA.
        """
        session = TestSession.get_session()

        # First, trigger CAPTCHA with failed attempts
        for i in range(4):
            csrf_token = TestSession.get_csrf_token(session)
            response = session.post(
                f"{BASE_URL}/?controller=AuthController&action=check",
                data={
                    "username": VALID_USERNAME,
                    "password": f"wrong_{i}",
                    "csrf_token": csrf_token
                },
                allow_redirects=True
            )
            time.sleep(0.1)

        # CRITICAL: Load the CAPTCHA image to store phrase in session
        # Without this, the session won't have the captcha phrase and
        # the validator will fail silently without showing "Invalid captcha"
        session.get(f"{BASE_URL}/?controller=CaptchaController&action=image")

        # Now CAPTCHA should be present, submit with wrong CAPTCHA
        csrf_token = TestSession.get_csrf_token(session)
        response = session.post(
            f"{BASE_URL}/?controller=AuthController&action=check",
            data={
                "username": VALID_USERNAME,
                "password": INVALID_PASSWORD,
                "captcha": "wrongcaptcha",
                "csrf_token": csrf_token
            },
            allow_redirects=True
        )

        response_lower = response.text.lower()

        # The error should NOT specifically say "Invalid captcha"
        # It should say "Bad username or password" (generic)
        specific_captcha_error = "invalid captcha" in response_lower

        if specific_captcha_error:
            # Check if it's the ONLY error (leak) vs combined with generic
            if "bad username" not in response_lower:
                pytest.fail(
                    "CAPTCHA failure should return generic 'Bad username or password' "
                    "error, not specific 'Invalid captcha' message which leaks information."
                )


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
