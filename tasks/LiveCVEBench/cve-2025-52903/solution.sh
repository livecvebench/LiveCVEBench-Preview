#!/bin/bash
set -e

# Ensure Go is in PATH (golang image has it at /usr/local/go/bin)
export PATH="/usr/local/go/bin:/go/bin:$PATH"
export GOPATH="/go"

# Fix for command allowlist bypass in File Browser (CVE-2025-52903)
# The vulnerability allows arbitrary command execution via tools like find -exec
# even when command allowlists are in place.
#
# The fix approach:
# Modify the CanExecute function to always return false, effectively disabling
# command execution as the defense-in-depth approach from v2.33.10.
# We keep the original import since we're not using any new packages.

echo "=== CVE-2025-52903 Fix Script ==="

USERS_FILE="/app/users/users.go"

# Check if file exists
if [ ! -f "$USERS_FILE" ]; then
    echo "ERROR: $USERS_FILE not found"
    exit 1
fi

# Backup original binary before any changes
echo "Backing up original binary..."
cp /app/filebrowser /app/filebrowser.original 2>/dev/null || true

# Backup original source
cp "$USERS_FILE" "$USERS_FILE.bak"

echo "Applying security fix to users/users.go..."

# Apply the fix using Python - make CanExecute always return false
# Keep the original "regexp" import since we're not using it anyway
# (Go compiler will optimize it out, but we won't change imports to avoid issues)
python3 << 'PYEOF'
import re

users_file = "/app/users/users.go"

with open(users_file, 'r') as f:
    content = f.read()

# We keep the original imports, just modify the function body
# The regexp import stays since changing it might cause issues

# Replace the CanExecute function to ALWAYS return false
# This is the defense-in-depth approach: disable command execution entirely
# Since commands like find can spawn arbitrary subcommands via -exec,
# the only safe approach is to block all command execution.

old_canexecute_pattern = r'''// CanExecute checks if an user can execute a specific command\.
func \(u \*User\) CanExecute\(command string\) bool \{
\s*if !u\.Perm\.Execute \{
\s*return false
\s*\}

\s*for _, cmd := range u\.Commands \{
\s*if regexp\.MustCompile\(cmd\)\.MatchString\(command\) \{
\s*return true
\s*\}
\s*\}

\s*return false
\}'''

# New function that always returns false - command exec is disabled
# Uses _ = command to silence "unused parameter" warning
new_canexecute = '''// CanExecute checks if an user can execute a specific command.
// SECURITY FIX (CVE-2025-52903): Command execution is disabled by default
// because commands like find can execute arbitrary subcommands via -exec.
// This is the defense-in-depth approach from v2.33.10.
func (u *User) CanExecute(command string) bool {
\t_ = command // silence unused parameter warning
\t// Command execution disabled for security (CVE-2025-52903)
\treturn false
}'''

content = re.sub(old_canexecute_pattern, new_canexecute, content, flags=re.MULTILINE)

# Verify the replacement happened
if 'CVE-2025-52903' not in content:
    print("WARNING: Main pattern didn't match, trying alternative approach")
    raise Exception("Need fallback")

with open(users_file, 'w') as f:
    f.write(content)

# Verify fix was applied
with open(users_file, 'r') as f:
    final_content = f.read()

if 'CVE-2025-52903' in final_content:
    print("Security fix applied successfully!")
else:
    raise Exception("Fix verification failed")
PYEOF

# Check if Python fix succeeded
if [ $? -ne 0 ]; then
    echo "Python fix failed, using fallback approach..."
    cp "$USERS_FILE.bak" "$USERS_FILE"

    # Replace the function using line-by-line approach
    python3 << 'PYEOF2'
with open("/app/users/users.go", 'r') as f:
    lines = f.readlines()

output = []
i = 0
while i < len(lines):
    line = lines[i]

    if 'func (u *User) CanExecute(command string) bool {' in line:
        brace_count = 1
        # Write the fixed function that always returns false
        output.append('// CanExecute checks if an user can execute a specific command.\n')
        output.append('// SECURITY FIX (CVE-2025-52903): Command execution is disabled by default\n')
        output.append('// because commands like find can execute arbitrary subcommands via -exec.\n')
        output.append('func (u *User) CanExecute(command string) bool {\n')
        output.append('\t_ = command // silence unused parameter warning\n')
        output.append('\t// Command execution disabled for security (CVE-2025-52903)\n')
        output.append('\treturn false\n')
        output.append('}\n')

        # Skip until we find the closing brace of the original function
        i += 1
        while i < len(lines) and brace_count > 0:
            for c in lines[i]:
                if c == '{':
                    brace_count += 1
                elif c == '}':
                    brace_count -= 1
            i += 1
        continue

    # Skip the comment line before CanExecute if we're about to write it
    if '// CanExecute checks if an user can execute a specific command.' in line:
        i += 1
        continue

    output.append(line)
    i += 1

with open("/app/users/users.go", 'w') as f:
    f.writelines(output)

print("Fallback fix applied!")
PYEOF2
fi

# Now remove the unused "regexp" import since we no longer use it
echo "Removing unused regexp import..."
python3 << 'PYEOF3'
with open("/app/users/users.go", 'r') as f:
    content = f.read()

# Remove the regexp import line
content = content.replace('\t"regexp"\n', '')

with open("/app/users/users.go", 'w') as f:
    f.write(content)

print("Unused import removed!")
PYEOF3

echo "Verifying security fix..."
if grep -q "CVE-2025-52903" "$USERS_FILE" && ! grep -q '"regexp"' "$USERS_FILE"; then
    echo "Security fix verification passed!"
    grep -A6 "func (u \*User) CanExecute" "$USERS_FILE"
else
    echo "WARNING: Fix may not have been applied correctly"
    grep -n "CanExecute\|regexp" "$USERS_FILE" || true
fi

# Install Node.js and pnpm to build the frontend
echo "Installing Node.js for frontend build..."
curl -fsSL https://deb.nodesource.com/setup_20.x | bash - > /dev/null 2>&1
apt-get install -y nodejs > /dev/null 2>&1

echo "Installing pnpm..."
npm install -g pnpm > /dev/null 2>&1

# Build the frontend
echo "Building frontend..."
cd /app/frontend
pnpm install --frozen-lockfile 2>&1 | tail -5
pnpm run build 2>&1 | tail -10

# Verify frontend was built
if [ -f "/app/frontend/dist/index.html" ]; then
    echo "Frontend build successful!"
else
    echo "ERROR: Frontend build failed - dist/index.html not found"
    ls -la /app/frontend/dist/ || true
    exit 1
fi

# Rebuild the Go application with embedded frontend and security fix
echo "Rebuilding File Browser backend with security fix..."
cd /app
go build -o filebrowser . 2>&1

if [ $? -eq 0 ]; then
    echo "Build successful!"
else
    echo "Build failed!"
    exit 1
fi

# Verify the new binary works
echo "Verifying new binary..."
/app/filebrowser version || true

# Kill the running filebrowser process so entrypoint can restart it with fixed binary
echo "Restarting File Browser with security fix..."
pkill -f "filebrowser" || true
sleep 3

echo "=== Fix applied successfully! ==="
echo "Command execution is now disabled (CVE-2025-52903 mitigated)."
