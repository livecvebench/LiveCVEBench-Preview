"""
Functionality tests for bugsink brotli decompression.

These tests verify that brotli decompression works correctly for normal use cases.
Should PASS in both vulnerable and fixed states.
"""

import brotli
import io
import sys
import os
import importlib.util

# Mock the Django and bugsink dependencies BEFORE importing bugsink
class MockSettings:
    def __getitem__(self, key):
        return 10 * 1024 * 1024  # 10MB default

class BadRequest(Exception):
    pass

# Function to do nothing for assert_
def mock_assert(x, msg=None):
    pass

# We need to import bugsink.streams directly without triggering bugsink/__init__.py
# This is done by loading the module file directly using importlib

# First, set up the mock modules that streams.py imports
mock_django = type(sys)('django')
mock_django_core = type(sys)('django.core')
mock_django_core_exceptions = type(sys)('django.core.exceptions')
mock_django_core_exceptions.BadRequest = BadRequest

sys.modules['django'] = mock_django
sys.modules['django.core'] = mock_django_core
sys.modules['django.core.exceptions'] = mock_django_core_exceptions

mock_app_settings = type(sys)('bugsink.app_settings')
mock_app_settings.get_settings = lambda: MockSettings()
sys.modules['bugsink.app_settings'] = mock_app_settings

mock_utils = type(sys)('bugsink.utils')
mock_utils.assert_ = mock_assert
sys.modules['bugsink.utils'] = mock_utils

# Now load streams.py directly using importlib, bypassing bugsink/__init__.py
spec = importlib.util.spec_from_file_location("bugsink.streams", "/app/bugsink/streams.py")
streams_module = importlib.util.module_from_spec(spec)
sys.modules['bugsink.streams'] = streams_module
spec.loader.exec_module(streams_module)

# Extract what we need from the module
brotli_generator = streams_module.brotli_generator
GeneratorReader = streams_module.GeneratorReader
DEFAULT_CHUNK_SIZE = streams_module.DEFAULT_CHUNK_SIZE


class TestBrotliBasicFunctionality:
    """Test basic brotli compression/decompression cycles."""

    def test_basic_decompression(self):
        """Test that basic brotli decompression works correctly."""
        original = b"Hello, World! This is a test message."
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original, f"Expected {original!r}, got {result!r}"

    def test_empty_data(self):
        """Test decompression of empty data."""
        original = b""
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original, f"Expected empty bytes, got {result!r}"

    def test_repeated_pattern(self):
        """Test decompression of data with repeated patterns."""
        original = b"ABCDEFGH" * 1000  # 8KB of repeated pattern
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original
        assert len(result) == 8000

    def test_binary_data(self):
        """Test decompression of binary data."""
        # Generate pseudo-random binary data
        original = bytes(range(256)) * 100  # 25.6KB
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original
        assert len(result) == 25600


class TestChunkedReading:
    """Test reading decompressed data in chunks."""

    def test_read_small_chunks(self):
        """Test reading in small chunks."""
        original = b"A" * 10000
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))

        chunks = []
        while True:
            chunk = reader.read(100)
            if not chunk:
                break
            chunks.append(chunk)

        result = b"".join(chunks)
        assert result == original
        assert len(result) == 10000

    def test_read_exact_size(self):
        """Test reading exact sizes."""
        original = b"0123456789" * 100  # 1000 bytes
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))

        # Read exact amounts
        chunk1 = reader.read(500)
        chunk2 = reader.read(500)
        chunk3 = reader.read(100)  # Should be empty

        assert len(chunk1) == 500
        assert len(chunk2) == 500
        assert chunk3 == b""
        assert chunk1 + chunk2 == original

    def test_read_varying_sizes(self):
        """Test reading with varying chunk sizes."""
        original = b"X" * 5000
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))

        chunks = []
        sizes = [10, 100, 1000, 500, 3390]  # Total = 5000
        for size in sizes:
            chunk = reader.read(size)
            chunks.append(chunk)

        result = b"".join(chunks)
        assert result == original

    def test_read_larger_than_available(self):
        """Test reading more bytes than available."""
        original = b"Short data"
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))

        result = reader.read(1000)  # Request 1000, only 10 available
        assert result == original


class TestModeratePayloads:
    """Test with moderate sized payloads (1-5MB)."""

    def test_1mb_text_data(self):
        """Test decompression of 1MB text data."""
        original = b"Lorem ipsum dolor sit amet. " * 40000  # ~1MB
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original

    def test_2mb_zeros(self):
        """Test decompression of 2MB of zeros (highly compressible)."""
        size = 2 * 1024 * 1024
        original = b'\x00' * size
        compressed = brotli.compress(original, quality=11)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert len(result) == size
        assert result == original

    def test_mixed_content(self):
        """Test decompression of mixed content types."""
        # Mix of text, binary, and repeated patterns
        parts = [
            b"Header: " + b"value" * 100,
            bytes(range(256)),
            b'\x00' * 1000,
            b"Footer: " + b"end" * 50,
        ]
        original = b"".join(parts)
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original


class TestCompressionLevels:
    """Test with different brotli compression levels."""

    def test_quality_0(self):
        """Test with fastest compression (quality=0)."""
        original = b"Test data " * 1000
        compressed = brotli.compress(original, quality=0)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original

    def test_quality_5(self):
        """Test with medium compression (quality=5)."""
        original = b"Test data " * 1000
        compressed = brotli.compress(original, quality=5)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original

    def test_quality_11(self):
        """Test with maximum compression (quality=11)."""
        original = b"Test data " * 1000
        compressed = brotli.compress(original, quality=11)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original


class TestGeneratorReader:
    """Test GeneratorReader specific functionality."""

    def test_generator_yields_correct_data(self):
        """Test that the generator yields correct chunks."""
        original = b"Hello World!"
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        gen = brotli_generator(stream)

        chunks = list(gen)
        result = b"".join(chunks)

        assert result == original

    def test_multiple_chunk_generator(self):
        """Test generator with data larger than chunk size."""
        # Create data larger than DEFAULT_CHUNK_SIZE (8KB)
        original = b"X" * (DEFAULT_CHUNK_SIZE * 3)  # 24KB
        compressed = brotli.compress(original)

        stream = io.BytesIO(compressed)
        reader = GeneratorReader(brotli_generator(stream))
        result = reader.read()

        assert result == original
        assert len(result) == DEFAULT_CHUNK_SIZE * 3
