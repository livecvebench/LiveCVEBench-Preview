"""
Vulnerability tests for JWS crit header validation issue.

These tests demonstrate that the library fails to validate the 'crit'
header parameter according to RFC 7515 Section 4.1.11.

Test behavior:
- FAIL on vulnerable version (vulnerability is exploitable - tokens are wrongly accepted)
- PASS on fixed version (vulnerability is mitigated - tokens are properly rejected)

Each test creates a malformed token that SHOULD be rejected per RFC 7515,
then asserts that the token IS rejected. On vulnerable versions, the token
is wrongly accepted, causing the assertion to FAIL.
"""
import json
import base64
import hmac
import hashlib
import pytest
from authlib.jose import JsonWebSignature


def base64url_encode(data):
    """Base64url encode without padding."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode('utf-8')


def create_token_with_crit(secret, crit_list, extra_headers=None, payload_data=None):
    """Create a JWS token with specified crit headers."""
    header = {"alg": "HS256", "crit": crit_list}
    if extra_headers:
        header.update(extra_headers)

    if payload_data is None:
        payload_data = {"sub": "test"}

    header_b64 = base64url_encode(json.dumps(header))
    payload_b64 = base64url_encode(json.dumps(payload_data))
    signing_input = f"{header_b64}.{payload_b64}"

    signature = hmac.new(
        secret.encode('utf-8'),
        signing_input.encode('utf-8'),
        hashlib.sha256
    ).digest()
    signature_b64 = base64url_encode(signature)

    return f"{signing_input}.{signature_b64}"


class TestUnknownCritHeader:
    """
    Test cases for tokens with unknown critical headers.

    Per RFC 7515 Section 4.1.11, unknown critical headers MUST cause rejection.
    These tests FAIL on vulnerable versions because tokens are wrongly accepted.
    """

    def test_rejects_unknown_crit_header_bork(self):
        """
        Token with unknown critical header 'bork' MUST be rejected.

        Per RFC 7515: If a recipient does not understand a header in crit,
        it MUST reject the token.
        """
        jws = JsonWebSignature()
        secret = "test-secret-key"

        # Create token with unknown critical header "bork"
        token = create_token_with_crit(secret, ["bork"], {"bork": "value"})

        # This SHOULD raise an exception, but vulnerable versions accept it
        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)

    def test_rejects_unknown_crit_header_foobar(self):
        """Token with unknown critical header 'foobar' MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(secret, ["foobar"], {"foobar": "test-value"})

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)

    def test_rejects_multiple_unknown_crit_headers(self):
        """Token with multiple unknown critical headers MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(
            secret,
            ["unknown1", "unknown2", "unknown3"],
            {"unknown1": "v1", "unknown2": "v2", "unknown3": "v3"}
        )

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)


class TestMissingCritParameter:
    """
    Test cases for tokens where crit lists parameters not present in header.

    Per RFC 7515, if crit lists a header that is not present, the token MUST
    be rejected. These tests FAIL on vulnerable versions.
    """

    def test_rejects_crit_with_missing_kid(self):
        """
        Token with crit:["kid"] where kid is NOT present MUST be rejected.

        Pre-computed token: {"alg":"HS256","crit":["kid"]} with payload "hello"
        The "kid" is listed in crit but NOT present in the header.
        """
        jws = JsonWebSignature()

        # Token: {"alg":"HS256","crit":["kid"]} - kid is listed in crit but not present
        token = "eyJhbGciOiJIUzI1NiIsImNyaXQiOlsia2lkIl19.aGVsbG8.RVimhJH2LRGAeHy0ZcbR9xsgKhzhxIBkHs7S_TDgWvc"

        with pytest.raises(Exception):
            jws.deserialize_compact(token, "secret")

    def test_rejects_crit_with_missing_x5t(self):
        """Token with crit:["x5t"] where x5t is NOT present MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        # x5t is a registered header but not present in this token
        token = create_token_with_crit(secret, ["x5t"])

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)

    def test_rejects_crit_with_missing_jku(self):
        """Token with crit:["jku"] where jku is NOT present MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(secret, ["jku"])

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)


class TestUnregisteredCritParameter:
    """
    Test cases for tokens with unregistered parameters in crit.

    Even if the parameter is present in the header, if it's not a registered
    or private header, it MUST be rejected per RFC 7515.
    """

    def test_rejects_unregistered_crit_parameter_invalid(self):
        """
        Token with crit:["invalid"] where "invalid" is unregistered MUST be rejected.

        Pre-computed token: {"alg":"HS256","invalid":"1","crit":["invalid"]}
        Even though "invalid" is present, it's not a registered header parameter.
        """
        jws = JsonWebSignature()

        # Token: {"alg":"HS256","invalid":"1","crit":["invalid"]}
        token = "eyJhbGciOiJIUzI1NiIsImludmFsaWQiOiIxIiwiY3JpdCI6WyJpbnZhbGlkIl19.aGVsbG8.ifW_D1AQWzggrpd8npcnmpiwMD9dp5FTX66lCkYFENM"

        with pytest.raises(Exception):
            jws.deserialize_compact(token, "secret")

    def test_rejects_unregistered_custom_header(self):
        """Token with custom unregistered header in crit MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(
            secret,
            ["x-custom-header"],
            {"x-custom-header": "custom-value"}
        )

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)


class TestJsonSerializationCritBypass:
    """Test cases for JSON serialization format crit bypass."""

    def test_rejects_json_serialization_with_unknown_crit_header(self):
        """JSON serialization with unknown crit header MUST be rejected."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        protected = {"alg": "HS256", "custom_unknown": "value", "crit": ["custom_unknown"]}
        header_obj = {"protected": protected}

        # This SHOULD raise an exception during serialization
        with pytest.raises(Exception):
            jws.serialize_json(header_obj, b"hello", secret)


class TestBypassScenarios:
    """Test realistic bypass scenarios that exploit the vulnerability."""

    def test_rejects_cnf_binding_bypass(self):
        """
        Token binding (cnf) bypass scenario MUST be rejected.

        An attacker could craft a token with crit:["cnf"] but without proper
        confirmation key handling, effectively bypassing token binding.
        """
        jws = JsonWebSignature()
        secret = "shared-secret"

        # Token claiming cnf is critical but cnf is not a registered header
        token = create_token_with_crit(
            secret,
            ["cnf"],
            {"cnf": {"kid": "attacker-key"}},
            payload_data={"sub": "victim", "scope": "admin"}
        )

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)

    def test_rejects_policy_header_bypass(self):
        """
        Policy header bypass scenario MUST be rejected.

        An attacker could add arbitrary policy headers to crit that
        would be ignored by the vulnerable implementation.
        """
        jws = JsonWebSignature()
        secret = "shared-secret"

        token = create_token_with_crit(
            secret,
            ["access_policy", "rate_limit"],
            {"access_policy": "allow_all", "rate_limit": "unlimited"},
            payload_data={"sub": "attacker", "role": "admin"}
        )

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)


class TestDeserializeMethods:
    """Test different deserialization methods for crit validation."""

    def test_rejects_unknown_crit_via_deserialize_method(self):
        """Generic deserialize() method MUST reject unknown crit."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(secret, ["unknown_header"], {"unknown_header": "value"})

        with pytest.raises(Exception):
            jws.deserialize(token, secret)

    def test_rejects_unknown_crit_via_deserialize_compact(self):
        """deserialize_compact() MUST reject tokens with unknown crit."""
        jws = JsonWebSignature()
        secret = "test-secret-key"

        token = create_token_with_crit(secret, ["arbitrary"], {"arbitrary": "data"})

        with pytest.raises(Exception):
            jws.deserialize_compact(token, secret)
