#!/usr/bin/env python3
"""
Functional tests for ImageMagick BMP processing.
These tests verify that normal BMP operations work correctly.
Should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import struct
import tempfile
import pytest


def get_test_env():
    """Get environment with increased resource limits for testing."""
    env = os.environ.copy()
    env["MAGICK_WIDTH_LIMIT"] = "1000000000"
    env["MAGICK_HEIGHT_LIMIT"] = "1000000000"
    env["MAGICK_AREA_LIMIT"] = "1000000000000"
    return env


def create_overflow_bmp(filename, width, height, bits_per_pixel):
    """
    Create a BMP file with specified dimensions that may trigger overflow.
    """
    file_header = struct.pack('<2sIHHI',
        b'BM', 58, 0, 0, 54
    )
    info_header = struct.pack('<IiiHHIIiiII',
        40, width, height, 1, bits_per_pixel, 0, 0, 0, 0, 0, 0
    )
    pixel_data = b'\x00\x00\x00\x00'
    with open(filename, 'wb') as f:
        f.write(file_header + info_header + pixel_data)


class TestBMPBasicOperations:
    """Test basic BMP file operations."""

    def test_create_and_identify_bmp(self):
        """Test that ImageMagick can create and identify BMP files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            bmp_file = os.path.join(tmpdir, "test.bmp")

            # Create a simple BMP file
            result = subprocess.run(
                ["convert", "-size", "100x100", "xc:red", bmp_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0, f"Failed to create BMP: {result.stderr}"
            assert os.path.exists(bmp_file), "BMP file was not created"

            # Verify the file can be identified
            result = subprocess.run(
                ["identify", bmp_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0, f"Failed to identify BMP: {result.stderr}"
            assert "BMP" in result.stdout, f"Expected BMP format in output: {result.stdout}"

    def test_bmp_to_png_conversion(self):
        """Test BMP to PNG format conversion."""
        with tempfile.TemporaryDirectory() as tmpdir:
            bmp_file = os.path.join(tmpdir, "input.bmp")
            png_file = os.path.join(tmpdir, "output.png")

            # Create BMP
            subprocess.run(
                ["convert", "-size", "50x50", "xc:blue", bmp_file],
                check=True, capture_output=True, timeout=30
            )

            # Convert to PNG
            result = subprocess.run(
                ["convert", bmp_file, png_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0, f"Conversion failed: {result.stderr}"

            # Verify PNG was created
            result = subprocess.run(
                ["identify", png_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0
            assert "PNG" in result.stdout

    def test_bmp_with_various_bit_depths(self):
        """Test BMP files with different bit depths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            for depth in [8, 16, 24]:
                bmp_file = os.path.join(tmpdir, f"test_{depth}bit.bmp")

                # Create BMP with specific depth
                result = subprocess.run(
                    ["convert", "-size", "32x32", f"-depth", str(depth),
                     "xc:green", bmp_file],
                    capture_output=True, text=True, timeout=30
                )
                # Some depths may not be supported, but it shouldn't crash
                if result.returncode == 0:
                    # Verify it can be read back
                    result = subprocess.run(
                        ["identify", bmp_file],
                        capture_output=True, text=True, timeout=30
                    )
                    assert result.returncode == 0

    def test_bmp_resize_operation(self):
        """Test resizing a BMP image."""
        with tempfile.TemporaryDirectory() as tmpdir:
            bmp_in = os.path.join(tmpdir, "input.bmp")
            bmp_out = os.path.join(tmpdir, "output.bmp")

            # Create 200x200 BMP
            subprocess.run(
                ["convert", "-size", "200x200", "xc:yellow", bmp_in],
                check=True, capture_output=True, timeout=30
            )

            # Resize to 50x50
            result = subprocess.run(
                ["convert", bmp_in, "-resize", "50x50", bmp_out],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0, f"Resize failed: {result.stderr}"

            # Verify dimensions
            result = subprocess.run(
                ["identify", "-format", "%wx%h", bmp_out],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0
            assert "50x50" in result.stdout


class TestBMPEdgeCases:
    """Test edge cases for BMP processing."""

    def test_small_bmp(self):
        """Test processing a very small BMP (1x1 pixel)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            bmp_file = os.path.join(tmpdir, "tiny.bmp")

            result = subprocess.run(
                ["convert", "-size", "1x1", "xc:white", bmp_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0

            result = subprocess.run(
                ["identify", bmp_file],
                capture_output=True, text=True, timeout=30
            )
            assert result.returncode == 0
            assert "1x1" in result.stdout

    def test_rectangular_bmp(self):
        """Test processing non-square BMP files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            for dims in ["10x100", "100x10", "1x1000", "1000x1"]:
                bmp_file = os.path.join(tmpdir, f"rect_{dims}.bmp")

                result = subprocess.run(
                    ["convert", "-size", dims, "xc:cyan", bmp_file],
                    capture_output=True, text=True, timeout=30
                )
                assert result.returncode == 0, f"Failed to create {dims} BMP"

                result = subprocess.run(
                    ["identify", "-format", "%wx%h", bmp_file],
                    capture_output=True, text=True, timeout=30
                )
                assert result.returncode == 0

    def test_multiple_bmp_operations(self):
        """Test processing multiple BMP files in sequence."""
        with tempfile.TemporaryDirectory() as tmpdir:
            files = []
            for i in range(5):
                bmp_file = os.path.join(tmpdir, f"test_{i}.bmp")
                subprocess.run(
                    ["convert", "-size", f"{20+i*10}x{20+i*10}", "xc:magenta", bmp_file],
                    check=True, capture_output=True, timeout=30
                )
                files.append(bmp_file)

            # Identify all files
            for bmp_file in files:
                result = subprocess.run(
                    ["identify", bmp_file],
                    capture_output=True, text=True, timeout=30
                )
                assert result.returncode == 0


class TestVersionInfo:
    """Test ImageMagick availability."""

    def test_imagemagick_available(self):
        """Test that ImageMagick tools are available."""
        result = subprocess.run(
            ["convert", "--version"],
            capture_output=True, text=True, timeout=30
        )
        assert result.returncode == 0, "convert command not available"
        assert "ImageMagick" in result.stdout, "Not an ImageMagick installation"

    def test_identify_available(self):
        """Test that identify tool is available."""
        result = subprocess.run(
            ["identify", "--version"],
            capture_output=True, text=True, timeout=30
        )
        assert result.returncode == 0, "identify command not available"


class TestBoundaryConditions:
    """Test boundary conditions for BMP processing (should pass in both states)."""

    def test_just_below_overflow_threshold(self):
        """Test width just below overflow (should not crash)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "near_overflow.bmp")

            # Width that doesn't overflow: 134217727 * 32 = 4294967264 (just under 2^32)
            # This might be rejected for being too large, but shouldn't cause crash
            create_overflow_bmp(poc_file, 134217727, 1, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Should not crash (negative return code = signal)
            assert result.returncode >= 0, \
                f"Process crashed with signal {-result.returncode} on near-overflow input"


class TestNoRegressions:
    """Ensure processing doesn't break valid large images (should pass in both states)."""

    def test_large_but_valid_dimensions(self):
        """Test that large but valid BMP dimensions still work."""
        with tempfile.TemporaryDirectory() as tmpdir:
            bmp_file = os.path.join(tmpdir, "large_valid.bmp")

            # Create a larger but valid image (1000x1000)
            result = subprocess.run(
                ["convert", "-size", "1000x1000", "xc:blue", bmp_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )
            assert result.returncode == 0, f"Should create large valid BMP: {result.stderr}"

            # Should be able to identify it
            result = subprocess.run(
                ["identify", bmp_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )
            assert result.returncode == 0, "Should identify large valid BMP"
            assert "1000x1000" in result.stdout

    def test_moderate_dimensions(self):
        """Test moderate image dimensions work correctly."""
        with tempfile.TemporaryDirectory() as tmpdir:
            for size in ["500x500", "1024x768", "1920x1080"]:
                bmp_file = os.path.join(tmpdir, f"mod_{size}.bmp")

                result = subprocess.run(
                    ["convert", "-size", size, "xc:green", bmp_file],
                    capture_output=True, text=True,
                    env=get_test_env(),
                    timeout=60
                )
                if result.returncode != 0:
                    continue  # Skip if can't create (memory constraints)

                result = subprocess.run(
                    ["identify", "-format", "%wx%h", bmp_file],
                    capture_output=True, text=True,
                    env=get_test_env(),
                    timeout=60
                )
                assert result.returncode == 0, f"Should handle {size} images"
