"""
Vulnerability tests for wasm3 out-of-bounds write in MarkSlotAllocated.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable - wasm3 crashes)
- PASS in fixed state (vulnerability is mitigated - no crash)
"""

import subprocess
import os
import tempfile
import pytest

# Path to wasm3 binary (built by run-tests.sh)
WASM3_PATH = "/app/build/wasm3"

# The PoC WebAssembly binary that triggers the vulnerability
# This is a malformed WASM file that causes polymorphic stack conditions
# during compilation, leading to an out-of-bounds array access.
# The crash occurs in MarkSlotAllocated when GetSlotForStackIndex returns
# c_slotUnused (0xffff) during block parameter restoration.
#
# IMPORTANT: The vulnerability is triggered during function COMPILATION,
# not just module loading. We must call the function with --func to crash.
#
# This is the exact PoC from public.md (62 bytes), exports function "fib"
# Hex breakdown:
#   00 61 73 6d - magic ("\0asm")
#   01 00 00 00 - version 1
#   01 06 01 60 01 7c 01 7c - type section: (f64) -> f64
#   03 02 01 00 - function section: 1 function of type 0
#   07 07 01 03 66 69 62 00 00 - export section: "fib"
#   0a 1f 01 1d 00 - code section header
#   20 00 00 00 04 00 30... - malformed code body that triggers the bug
POC_BYTES = bytes([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x06, 0x01, 0x60, 0x01, 0x7c, 0x01, 0x7c,
    0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03,
    0x66, 0x69, 0x62, 0x00, 0x00, 0x0a, 0x1f, 0x01,
    0x1d, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
])


def create_poc_file() -> str:
    """Create a PoC WASM file and return its path."""
    fd, path = tempfile.mkstemp(suffix=".wasm")
    with os.fdopen(fd, 'wb') as f:
        f.write(POC_BYTES)
    return path


def run_wasm3(wasm_path: str, func_name: str = None, args: list = None, timeout: int = 10) -> tuple:
    """
    Run wasm3 with the given WASM file.
    Returns (exit_code, stdout, stderr).

    Note: The vulnerability is triggered during function compilation, not module loading.
    So we need to call a function with --func to trigger the crash.
    """
    # wasm3 command syntax: wasm3 [options] <file> [args...]
    cmd = [WASM3_PATH]
    if func_name:
        cmd.extend(["--func", func_name])
    cmd.append(wasm_path)
    if args:
        cmd.extend([str(a) for a in args])

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Timeout"
    except FileNotFoundError:
        pytest.skip(f"wasm3 binary not found at {WASM3_PATH}")
    except Exception as e:
        return -1, "", str(e)


def check_crash_indicators(stderr: str, exit_code: int) -> bool:
    """
    Check if the output indicates a crash due to the vulnerability.
    Returns True if crash indicators are found.
    """
    crash_indicators = [
        "AddressSanitizer",
        "SEGV",
        "heap-buffer-overflow",
        "MarkSlotAllocated",
        "MarkSlotsAllocated",
        "MarkSlotsAllocatedByType",
        "Segmentation fault",
        "ASAN",
        "ERROR: AddressSanitizer",
        "out-of-bounds",
        "DEADLYSIGNAL",
    ]

    # Check for crash indicators in stderr
    for indicator in crash_indicators:
        if indicator in stderr:
            return True

    # Exit codes indicating crashes (SIGSEGV = 139, SIGABRT = 134, etc.)
    # Also check for generic error exit codes that might indicate memory issues
    if exit_code in [134, 139, -6, -11]:
        return True

    return False


class TestMarkSlotAllocatedOOB:
    """Test suite for the out-of-bounds write vulnerability in MarkSlotAllocated."""

    def test_basic_poc_no_crash(self):
        """
        Test that the basic PoC does not crash wasm3.

        In the vulnerable version, this will crash with SEGV due to
        accessing m3Slots[0xffff] when slot == c_slotUnused.

        After the fix, wasm3 should handle this gracefully (either
        process it or return an error, but not crash).
        """
        poc_path = create_poc_file()
        try:
            # The vulnerability is triggered during function compilation
            # We must call the exported function "fib" to trigger the crash
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["1.0"])

            # The test PASSES if there's NO crash (vulnerability is fixed)
            # The test FAILS if there IS a crash (vulnerability exists)
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash detected - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_polymorphic_stack_handling(self):
        """
        Test handling of WASM with polymorphic stack conditions.
        Uses the same PoC which triggers polymorphic stack during compilation.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["2.0"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash in polymorphic stack handling - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_block_with_params_unreachable(self):
        """
        Test block compilation with parameters in unreachable context.
        The PoC triggers this by having malformed bytecode after an if block.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["0.0"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with unreachable context - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_nested_if_polymorphic(self):
        """
        Test that nested control flow handling doesn't trigger the vulnerability.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["3.14"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with nested if blocks - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_loop_with_unreachable(self):
        """
        Test loop construct handling with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["-1.0"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with loop unreachable - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_br_table_polymorphic(self):
        """
        Test br_table handling with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["99.9"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with br_table - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_return_in_block(self):
        """
        Test return instruction handling with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["0.5"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with return in block - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_multiple_unreachable_paths(self):
        """
        Test multiple code paths with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["100.0"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with multiple unreachable - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)


class TestEdgeCases:
    """Additional edge case tests for the vulnerability."""

    def test_empty_if_branch(self):
        """
        Test edge case handling with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["0.001"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with empty if branch - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)

    def test_deep_block_nesting(self):
        """
        Test deep block nesting handling with the PoC.
        """
        poc_path = create_poc_file()
        try:
            exit_code, stdout, stderr = run_wasm3(poc_path, func_name="fib", args=["1000.0"])
            has_crash = check_crash_indicators(stderr, exit_code)

            assert not has_crash, (
                f"Crash with deep nesting - vulnerability exists!\n"
                f"Exit code: {exit_code}\n"
                f"Stderr: {stderr[:1000]}"
            )
        finally:
            os.unlink(poc_path)
