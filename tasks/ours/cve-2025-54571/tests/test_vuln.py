#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-54571: ModSecurity Improper Error Handling.

These tests detect the vulnerable behavior:
- FAIL when vulnerable (improper error handling allows request to continue,
  causing double content/response in the output)
- PASS when fixed (error is properly handled and request is terminated)

The vulnerability causes Apache/ModSecurity to continue processing after an
error, resulting in extra content being appended after the error response.
"""

import socket
import pytest

# Configuration
HOST = "localhost"
PORT = 80
TIMEOUT = 10


def send_raw_request(request: bytes, timeout: float = TIMEOUT) -> bytes:
    """Send a raw HTTP request and return the response."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((HOST, PORT))
        sock.sendall(request)

        response = b""
        try:
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
        except socket.timeout:
            pass
        return response
    finally:
        sock.close()


def count_html_documents(response: bytes) -> int:
    """Count HTML document markers - vulnerability causes multiple HTML docs."""
    return response.lower().count(b"<html")


def has_error_response(response: bytes) -> bool:
    """Check if response contains an error status code."""
    response_str = response.decode('utf-8', errors='replace')
    return any(f"HTTP/1.1 {code}" in response_str or f"HTTP/1.0 {code}" in response_str
               for code in ["400", "411", "413", "408", "500", "501"])


class TestVulnerabilityDetection:
    """
    Tests that detect CVE-2025-54571 vulnerability.

    The vulnerability occurs when read_request_body() returns -3 (AP_FILTER_ERROR)
    but the switch statement in hook_request_late() doesn't handle this case,
    causing it to fall through to the default case which allows the request to continue.

    In vulnerable state: error response + extra content appended (double HTML)
    In fixed state: only error response, clean termination

    ALL tests in this class should FAIL when vulnerability exists.
    """

    def test_empty_chunked_body_double_content(self):
        """
        Test chunked request with no chunk data causes double content.

        Vulnerable: Returns error page PLUS additional content from continued processing
        Fixed: Returns single clean error response
        """
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n\r\n"
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)

        # Fixed behavior: single HTML document (the error page)
        # Vulnerable behavior: TWO HTML documents (error + index.html content)
        assert html_count == 1, \
            f"Expected single HTML response, got {html_count} HTML documents. " \
            f"Extra content after error indicates CVE-2025-54571 vulnerability. Response: {response_str[:800]}"

    def test_invalid_chunk_size_double_content(self):
        """
        Test chunked request with invalid/negative chunk size causes double content.

        Vulnerable: Continues processing and appends extra content
        Fixed: Returns proper error response only
        """
        request = (
            b"POST / HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Transfer-Encoding: chunked\r\n"
            b"Content-Length: 13\r\n"
            b"\r\n"
            b"-2\r\n"
            b"AA\r\n"
            b"0\r\n"
            b"\r\n"
        )
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)

        # Should get exactly one HTML document without extra content
        assert html_count == 1, \
            f"Double content detected ({html_count} HTML docs). " \
            f"CVE-2025-54571 vulnerability present. Response: {response_str[:800]}"

    def test_conflicting_headers_double_content(self):
        """
        Test conflicting Transfer-Encoding and Content-Length headers.
        """
        request = (
            b"POST / HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Transfer-Encoding: chunked\r\n"
            b"Content-Length: 100\r\n"
            b"Connection: close\r\n"
            b"\r\n"
            b"invalid-chunk\r\n"
        )
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)

        # Should not have multiple HTML documents
        assert html_count == 1, \
            f"Multiple HTML documents ({html_count}) indicates CVE-2025-54571 vulnerability: {response_str[:500]}"

    def test_error_with_test_page_content(self):
        """
        Verify error response doesn't include additional content.

        The vulnerability causes both error AND additional content to appear,
        resulting in multiple HTML documents in a single response.
        """
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n\r\n"
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)

        # Vulnerable: multiple HTML documents (error page + additional content)
        # Fixed: single error page only
        assert html_count == 1, \
            f"Double content detected! {html_count} HTML documents in response. " \
            f"CVE-2025-54571 vulnerability: error followed by additional content. Response: {response_str[:800]}"

    def test_error_terminates_cleanly(self):
        """
        After an error, no additional content should be sent.
        """
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n\r\n"

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            sock.sendall(request)

            response = b""
            try:
                while True:
                    data = sock.recv(4096)
                    if not data:
                        break
                    response += data
            except socket.timeout:
                pass

            response_str = response.decode('utf-8', errors='replace')
            html_count = count_html_documents(response)

            # Should have exactly one HTML document (the error page)
            assert html_count == 1, \
                f"Expected single HTML response after error, got {html_count}. " \
                f"CVE-2025-54571 vulnerability: extra content after error. Response: {response_str[:500]}"

        finally:
            sock.close()

    def test_content_mixing(self):
        """
        Error responses should contain only error content, not mixed content.
        """
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n\r\n"
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)

        # Multiple HTML documents indicate content mixing (vulnerability)
        assert html_count == 1, \
            f"Content mixing detected: {html_count} HTML documents in response. " \
            f"CVE-2025-54571: error and normal content mixed."

    def test_malformed_chunk_extension(self):
        """
        Test with malformed chunk extension causes double content.
        """
        request = (
            b"POST / HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Transfer-Encoding: chunked\r\n"
            b"\r\n"
            b"5;invalid=\x00\r\n"  # NULL byte in extension
            b"hello\r\n"
            b"0\r\n\r\n"
        )
        response = send_raw_request(request, timeout=5)
        response_str = response.decode('utf-8', errors='replace')

        html_count = count_html_documents(response)
        assert html_count == 1, \
            f"Multiple HTML docs ({html_count}): CVE-2025-54571 vulnerability. Response: {response_str[:500]}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
