#!/bin/bash
# Solution script for cel-rust parser panic issue
#
# This script fixes the parser to handle malformed CEL expressions gracefully
# by returning parse errors instead of panicking.
#
# The fix adds error guards to the Visitable implementations for context enums
# in the ANTLR-generated parser code.

set -e

# Source cargo environment
. "$HOME/.cargo/env" 2>/dev/null || true
export PATH="/usr/local/cargo/bin:$PATH"

echo "========================================"
echo "Applying Parser Fix"
echo "========================================"
echo ""

# Target file
FILE="/app/cel/src/parser/gen/celparser.rs"

# Verify file exists
if [ ! -f "$FILE" ]; then
    echo "ERROR: $FILE not found"
    exit 1
fi

echo "Target file: $FILE"
echo "Applying fix..."
echo ""

# Apply fix using Python for reliable regex handling across multiple locations
python3 << 'PYSCRIPT'
import re
import sys

file_path = "/app/cel/src/parser/gen/celparser.rs"

with open(file_path, 'r') as f:
    content = f.read()

original_content = content

# The four context types that need fixing
# These have Visitable implementations that unconditionally call accept()
# on the dereferenced context, which panics for Error variants
contexts = ['MemberContextAll', 'EscapeIdentContextAll', 'LiteralContextAll', 'PrimaryContextAll']

fixed_count = 0

for ctx in contexts:
    # Pattern to match the vulnerable accept implementation
    # This matches: impl<'input, 'a> Visitable<...> for ContextAll { fn accept(...) { self.deref().accept(visitor) }}
    pattern = rf"""(impl<'input, 'a> Visitable<dyn CELVisitor<'input> \+ 'a> for {ctx}<'input> \{{\s*fn accept\(&self, visitor: &mut \(dyn CELVisitor<'input> \+ 'a\)\) \{{\s*)self\.deref\(\)\.accept\(visitor\)"""

    # Replacement with the error guard
    # This prevents the visitor from being invoked on Error variants
    replacement = rf"""\1if !matches!(self, {ctx}::Error(_)) {{
            self.deref().accept(visitor)
        }}"""

    new_content, count = re.subn(pattern, replacement, content, flags=re.DOTALL)

    if count > 0:
        content = new_content
        fixed_count += count
        print(f"  Fixed {ctx}: {count} replacement(s)")
    else:
        print(f"  Warning: Could not find pattern for {ctx}")

if content != original_content:
    with open(file_path, 'w') as f:
        f.write(content)
    print(f"\nTotal fixes applied: {fixed_count}")
else:
    print("\nWARNING: No changes made to the file")
    sys.exit(1)
PYSCRIPT

echo ""
echo "========================================"
echo "Rebuilding cel-rust..."
echo "========================================"
echo ""

cd /app

# Touch the file to ensure rebuild
touch "$FILE"

# Build
cargo build --release

echo ""
echo "========================================"
echo "Fix applied and rebuild complete!"
echo "========================================"
echo ""
echo "The parser now handles malformed expressions gracefully by:"
echo "  - Checking if the context is an Error variant before traversal"
echo "  - Returning parse errors instead of panicking"
echo ""
echo "Verification:"
echo "  Run: /app/target/release/cel-test \"x(1,\""
echo "  Expected: Parse error (not a panic)"
