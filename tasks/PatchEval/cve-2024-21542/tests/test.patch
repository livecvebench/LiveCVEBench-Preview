diff --git a/test/safe_extractor_test.py b/test/safe_extractor_test.py
new file mode 100644
index 0000000000..e14367438e
--- /dev/null
+++ b/test/safe_extractor_test.py
@@ -0,0 +1,125 @@
+# -*- coding: utf-8 -*-
+#
+# Copyright 2012-2015 Spotify AB
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+"""
+Safe Extractor Test
+=============
+
+Tests for the Safe Extractor class in luigi.safe_extractor module.
+"""
+
+import os
+import shutil
+import tarfile
+import tempfile
+import unittest
+
+from luigi.safe_extractor import SafeExtractor
+
+
+class TestSafeExtract(unittest.TestCase):
+    """
+    Unit test class for testing the SafeExtractor module.
+    """
+
+    def setUp(self):
+        """Set up a temporary directory for test files."""
+        self.temp_dir = tempfile.mkdtemp()
+        self.test_file_template = 'test_file_{}.txt'
+        self.tar_file_name = 'test.tar'
+        self.tar_file_name_with_traversal = f'traversal_{self.tar_file_name}'
+
+    def tearDown(self):
+        """Clean up the temporary directory after each test."""
+        shutil.rmtree(self.temp_dir)
+
+    def create_test_tar(self, tar_path, file_count=1, with_traversal=False):
+        """
+        Create a tar file containing test files.
+
+        Args:
+            tar_path (str): Path where the tar file will be created.
+            file_count (int): Number of test files to include.
+            with_traversal (bool): If True, creates a tar file with path traversal vulnerability.
+        """
+        # Default content for the test files
+        file_contents = [f'This is {self.test_file_template.format(i)}' for i in range(file_count)]
+
+        with tarfile.open(tar_path, 'w') as tar:
+            for i in range(file_count):
+                file_name = self.test_file_template.format(i)
+                file_path = os.path.join(self.temp_dir, file_name)
+
+                # Write content to each test file
+                with open(file_path, 'w') as f:
+                    f.write(file_contents[i])
+
+                # If path traversal is enabled, create malicious paths
+                archive_name = f'../../{file_name}' if with_traversal else file_name
+
+                # Add the file to the tar archive
+                tar.add(file_path, arcname=archive_name)
+
+    def verify_extracted_files(self, file_count):
+        """
+        Verify that the correct files were extracted and their contents match expectations.
+
+        Args:
+            file_count (int): Number of files to verify.
+        """
+        for i in range(file_count):
+            file_name = self.test_file_template.format(i)
+            file_path = os.path.join(self.temp_dir, file_name)
+
+            # Check if the file exists
+            self.assertTrue(os.path.exists(file_path), f"File {file_name} does not exist.")
+
+            # Check if the file content is correct
+            with open(file_path, 'r') as f:
+                content = f.read()
+                expected_content = f'This is {file_name}'
+                self.assertEqual(content, expected_content, f"Content mismatch in {file_name}.")
+
+    def test_safe_extract(self):
+        """Test normal safe extraction of tar files."""
+        tar_path = os.path.join(self.temp_dir, self.tar_file_name)
+
+        # Create a tar file with 3 files
+        self.create_test_tar(tar_path, file_count=3)
+
+        # Initialize SafeExtractor and perform extraction
+        extractor = SafeExtractor(self.temp_dir)
+        extractor.safe_extract(tar_path)
+
+        # Verify that all 3 files were extracted correctly
+        self.verify_extracted_files(3)
+
+    def test_safe_extract_with_traversal(self):
+        """Test safe extraction for tar files with path traversal (should raise an error)."""
+        tar_path = os.path.join(self.temp_dir, self.tar_file_name_with_traversal)
+
+        # Create a tar file with a path traversal file
+        self.create_test_tar(tar_path, file_count=1, with_traversal=True)
+
+        # Initialize SafeExtractor and expect RuntimeError due to path traversal
+        extractor = SafeExtractor(self.temp_dir)
+        with self.assertRaises(RuntimeError):
+            extractor.safe_extract(tar_path)
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..9c6f72b
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,108 @@
+import os
+import shutil
+import tarfile
+import tempfile
+import unittest
+
+from luigi.contrib import lsf_runner, sge_runner
+
+
+class TestPatchVerification(unittest.TestCase):
+    """
+    Tests the patch for tarfile extraction vulnerability (Path Traversal).
+
+    This test verifies that the vulnerable functions in lsf_runner and sge_runner
+    are correctly patched to prevent malicious tar archives from writing files
+    outside the intended extraction directory.
+    """
+
+    def setUp(self):
+        """
+        Set up a temporary working directory and prepare paths for the test.
+        """
+        # Create a temporary directory to simulate the 'work_dir'
+        self.work_dir = tempfile.mkdtemp()
+
+        # Define the path for the malicious file we expect to be created by the exploit
+        # It's one level above the work_dir
+        self.malicious_file_path = os.path.join(os.path.dirname(self.work_dir), 'evil.txt')
+        self.tar_path = os.path.join(self.work_dir, 'packages.tar')
+
+        # Ensure the malicious file does not exist before the test run
+        if os.path.exists(self.malicious_file_path):
+            os.remove(self.malicious_file_path)
+
+    def tearDown(self):
+        """
+        Clean up the temporary directory and any files created during the test.
+        """
+        shutil.rmtree(self.work_dir)
+        # Clean up the malicious file if it was created by a vulnerable version
+        if os.path.exists(self.malicious_file_path):
+            os.remove(self.malicious_file_path)
+
+    def create_malicious_tar(self):
+        """
+        Create a tar file with a path traversal entry.
+
+        The archive will contain a file that, when extracted insecurely,
+        would be placed outside of the target directory.
+        """
+        # A dummy file to be included in the tar archive
+        dummy_file_path = os.path.join(self.work_dir, 'dummy.txt')
+        with open(dummy_file_path, 'w') as f:
+            f.write('dummy content')
+
+        # Create the tar file with a malicious arcname
+        with tarfile.open(self.tar_path, 'w') as tar:
+            # The 'arcname' is what matters. '../evil.txt' attempts path traversal.
+            tar.add(dummy_file_path, arcname='../evil.txt')
+
+    def test_lsf_runner_is_patched(self):
+        """
+        Verify that lsf_runner.extract_packages_archive is patched.
+
+        - On patched code, it should use SafeExtractor and raise a RuntimeError.
+        - On vulnerable code, no exception is raised, and this test will fail.
+        """
+        self.create_malicious_tar()
+        original_cwd = os.getcwd()
+        try:
+            # The patched code is expected to raise a RuntimeError due to the path traversal attempt.
+            # The unittest.assertRaises context manager will pass if the expected exception is raised,
+            # and fail the test otherwise (i.e., on the vulnerable code).
+            with self.assertRaises(RuntimeError, msg="Vulnerability not patched in lsf_runner: RuntimeError was not raised."):
+                lsf_runner.extract_packages_archive(self.work_dir)
+        finally:
+            # Ensure we change back to the original directory, even if the function fails to do so.
+            os.chdir(original_cwd)
+
+        # As an additional safeguard, explicitly check that the malicious file was not created.
+        self.assertFalse(os.path.exists(self.malicious_file_path),
+                         "Malicious file was created by lsf_runner, patch is ineffective!")
+
+    def test_sge_runner_is_patched(self):
+        """
+        Verify that sge_runner._extract_packages_archive is patched.
+
+        - On patched code, it should use SafeExtractor and raise a RuntimeError.
+        - On vulnerable code, no exception is raised, and this test will fail.
+        """
+        self.create_malicious_tar()
+        original_cwd = os.getcwd()
+        try:
+            # Similar to the lsf_runner test, we expect a RuntimeError from the patched code.
+            with self.assertRaises(RuntimeError, msg="Vulnerability not patched in sge_runner: RuntimeError was not raised."):
+                # The vulnerable function in sge_runner is named _extract_packages_archive
+                sge_runner._extract_packages_archive(self.work_dir)
+        finally:
+            # Ensure we change back to the original directory.
+            os.chdir(original_cwd)
+
+        # Again, ensure the file was not created.
+        self.assertFalse(os.path.exists(self.malicious_file_path),
+                         "Malicious file was created by sge_runner, patch is ineffective!")
+
+
+if __name__ == '__main__':
+    unittest.main() 
\ No newline at end of file
