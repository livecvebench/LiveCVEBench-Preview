#!/usr/bin/env python3
"""
Functional tests for Erlang/OTP SSH Server

These tests verify that the SSH server is running correctly and responds
to basic SSH protocol operations. They should PASS in both vulnerable
and fixed states.
"""

import socket
import time
import pytest

# SSH server configuration
SSH_HOST = "localhost"
SSH_PORT = 2222
TIMEOUT = 10


class TestSSHServerBasicFunctionality:
    """Tests for basic SSH server functionality."""

    def test_ssh_server_listening(self):
        """Test that SSH server is listening on the expected port."""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        try:
            result = sock.connect_ex((SSH_HOST, SSH_PORT))
            assert result == 0, f"SSH server not listening on {SSH_HOST}:{SSH_PORT}"
        finally:
            sock.close()

    def test_ssh_banner_exchange(self):
        """Test that SSH server returns a valid SSH-2.0 banner."""
        sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        try:
            # Send client banner
            client_banner = b"SSH-2.0-TestClient_1.0\r\n"
            sock.sendall(client_banner)

            # Receive server banner
            banner = sock.recv(256)
            assert banner, "No banner received from SSH server"
            assert b"SSH-2.0" in banner, f"Invalid SSH banner received: {banner}"
        finally:
            sock.close()

    def test_ssh_banner_contains_erlang(self):
        """Test that SSH server banner identifies as Erlang implementation."""
        sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        try:
            client_banner = b"SSH-2.0-TestClient_1.0\r\n"
            sock.sendall(client_banner)

            banner = sock.recv(256)
            # Erlang SSH servers typically include "Erlang" in banner
            assert b"Erlang" in banner or b"SSH-2.0" in banner, \
                f"Unexpected banner format: {banner}"
        finally:
            sock.close()

    def test_multiple_connections(self):
        """Test that server can handle multiple sequential connections."""
        # Test multiple sequential connections (one at a time)
        # This verifies the server can handle repeated connections
        for i in range(3):
            sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
            try:
                sock.sendall(b"SSH-2.0-TestClient_1.0\r\n")
                banner = sock.recv(256)
                assert b"SSH-2.0" in banner, f"Connection {i} failed banner exchange"
            finally:
                sock.close()
            time.sleep(0.2)  # Small delay between connections

    def test_server_sends_kexinit(self):
        """Test that server initiates key exchange after banner exchange."""
        sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        try:
            # Send client banner
            sock.sendall(b"SSH-2.0-TestClient_1.0\r\n")

            # Receive server banner
            banner = sock.recv(256)
            assert b"SSH-2.0" in banner

            # Server should send KEXINIT packet (may be in same recv or next)
            # Give server time to send KEXINIT
            time.sleep(0.5)
            sock.settimeout(2)

            try:
                data = sock.recv(4096)
                # SSH_MSG_KEXINIT is message type 20 (0x14)
                # The packet format includes: length (4) + padding_len (1) + msg_type (1)
                if len(data) > 5:
                    # Check if we received KEXINIT (type 20 / 0x14)
                    msg_type = data[5]
                    assert msg_type == 20, \
                        f"Expected KEXINIT (20), got message type {msg_type}"
            except socket.timeout:
                # Server might wait for client KEXINIT first
                pass
        finally:
            sock.close()


class TestSSHServerReconnection:
    """Tests for server stability and reconnection handling."""

    def test_reconnect_after_disconnect(self):
        """Test that server accepts new connections after client disconnect."""
        # First connection
        sock1 = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        sock1.sendall(b"SSH-2.0-TestClient_1.0\r\n")
        banner1 = sock1.recv(256)
        assert b"SSH-2.0" in banner1
        sock1.close()

        time.sleep(0.5)

        # Second connection after disconnect
        sock2 = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        sock2.sendall(b"SSH-2.0-TestClient_1.0\r\n")
        banner2 = sock2.recv(256)
        assert b"SSH-2.0" in banner2
        sock2.close()

    def test_server_handles_abrupt_disconnect(self):
        """Test that server handles abrupt client disconnection gracefully."""
        sock = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        sock.sendall(b"SSH-2.0-TestClient_1.0\r\n")
        sock.recv(256)

        # Abruptly close without proper SSH disconnect
        sock.close()

        time.sleep(0.5)

        # Server should still accept new connections
        sock2 = socket.create_connection((SSH_HOST, SSH_PORT), timeout=TIMEOUT)
        sock2.sendall(b"SSH-2.0-TestClient_1.0\r\n")
        banner = sock2.recv(256)
        assert b"SSH-2.0" in banner
        sock2.close()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
