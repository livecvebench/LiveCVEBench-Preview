"""
Vulnerability tests for CVE-2025-61919: Rack request body unbounded read.

The vulnerability: In Rack < 2.2.20, request bodies are read fully into memory
using `get_header(RACK_INPUT).read` (no size argument) before any size validation.
This allows memory exhaustion attacks with large POST bodies.

The fix adds:
1. `attr_reader :bytesize_limit` to QueryParser (making limit accessible)
2. Bounded read: `.read(query_parser.bytesize_limit + 2) || ''`

Test expectations:
- VULNERABLE version: bytesize_limit not accessible, read() called without limit
- FIXED version: bytesize_limit accessible, read() called with limit

For reproduction purposes:
- These tests should FAIL in the vulnerable state (v2.2.19)
- These tests should PASS in the fixed state (v2.2.20+)
"""

import subprocess


def run_ruby_test(ruby_code: str, timeout: int = 60) -> tuple[bool, str]:
    """Run a Ruby test script and return (success, output)."""
    result = subprocess.run(
        ["ruby", "-e", ruby_code],
        capture_output=True,
        text=True,
        timeout=timeout,
        cwd="/app"
    )
    output = result.stdout + result.stderr
    return result.returncode == 0, output


class TestBytesizeLimitAccessor:
    """
    Test that bytesize_limit accessor exists on query_parser.

    In vulnerable v2.2.19: @bytesize_limit is private instance variable, no public accessor
    In fixed v2.2.20: attr_reader :bytesize_limit added

    This is the key indicator of vulnerability status.
    """

    def test_bytesize_limit_accessor_exists(self):
        """
        QueryParser should have a public bytesize_limit accessor.
        FAILS in vulnerable version (no accessor)
        PASSES in fixed version (accessor added)
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"

parser = Rack::Utils.default_query_parser

if parser.respond_to?(:bytesize_limit)
  puts "PASS: bytesize_limit accessor exists"
  puts "Value: #{parser.bytesize_limit}"
else
  puts "FAIL: bytesize_limit accessor does not exist"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed - bytesize_limit accessor not found: {output}"
        assert "PASS" in output

    def test_bytesize_limit_default_value(self):
        """
        Default bytesize_limit should be 4194304 (4MB).
        FAILS in vulnerable version (accessor doesn't exist)
        PASSES in fixed version
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"

parser = Rack::Utils.default_query_parser

begin
  limit = parser.bytesize_limit
  if limit == 4194304
    puts "PASS: bytesize_limit is 4194304 (4MB)"
  else
    puts "FAIL: bytesize_limit is #{limit}, expected 4194304"
    exit 1
  end
rescue NoMethodError => e
  puts "FAIL: Cannot access bytesize_limit - #{e.message}"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestBoundedReadBehavior:
    """
    Test that POST body read operation is bounded.

    In vulnerable v2.2.19: get_header(RACK_INPUT).read (no argument, reads everything)
    In fixed v2.2.20: get_header(RACK_INPUT).read(query_parser.bytesize_limit + 2)
    """

    def test_read_called_with_limit_argument(self):
        """
        The read() method should be called with a length argument.

        Uses a TrackedIO object to detect how read() is called:
        - nil argument = unbounded read (VULNERABLE)
        - numeric argument = bounded read (FIXED)
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"

class TrackedIO
  attr_reader :read_arg

  def initialize(data)
    @data = data
    @pos = 0
    @read_arg = :not_called
  end

  def read(length = nil)
    @read_arg = length
    if length.nil?
      result = @data[@pos..-1]
      @pos = @data.length
    else
      result = @data[@pos, length]
      @pos += length if result
    end
    result
  end

  def rewind
    @pos = 0
  end

  def gets
    nil
  end
end

body = "foo=bar"
tracked_input = TrackedIO.new(body)

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => tracked_input
}

request = Rack::Request.new(env)
params = request.POST

if tracked_input.read_arg.nil?
  puts "FAIL: read() called without length argument (unbounded read - vulnerable)"
  exit 1
elsif tracked_input.read_arg == :not_called
  puts "FAIL: read() was never called"
  exit 1
else
  puts "PASS: read() called with length argument: #{tracked_input.read_arg}"
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_read_limit_is_bytesize_limit_plus_2(self):
        """
        The read limit should be exactly bytesize_limit + 2.

        The +2 accounts for:
        - +1 to detect if body exceeds limit
        - +1 in case Safari null-byte cleanup removes last byte
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"

class TrackedIO
  attr_reader :read_arg

  def initialize(data)
    @data = data
    @pos = 0
    @read_arg = :not_called
  end

  def read(length = nil)
    @read_arg = length
    if length.nil?
      result = @data[@pos..-1]
      @pos = @data.length
    else
      result = @data[@pos, length]
      @pos += length if result
    end
    result
  end

  def rewind
    @pos = 0
  end

  def gets
    nil
  end
end

body = "foo=bar"
tracked_input = TrackedIO.new(body)

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => tracked_input
}

request = Rack::Request.new(env)
params = request.POST

expected_limit = 4194304 + 2  # bytesize_limit + 2

if tracked_input.read_arg == expected_limit
  puts "PASS: read() called with correct limit: #{tracked_input.read_arg}"
elsif tracked_input.read_arg.nil?
  puts "FAIL: read() called without limit (unbounded read - vulnerable)"
  exit 1
else
  puts "FAIL: read() called with #{tracked_input.read_arg}, expected #{expected_limit}"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestNilReadHandling:
    """
    Test that nil return from read() is handled gracefully.

    In vulnerable v2.2.19: no || '' fallback, nil causes NoMethodError
    In fixed v2.2.20: read(...) || '' handles nil gracefully
    """

    def test_nil_read_returns_empty_params(self):
        """
        When rack.input.read returns nil, POST should return empty hash.

        In vulnerable version: NoMethodError on nil
        In fixed version: gracefully returns {}
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"

class NilReturningIO
  def read(length = nil)
    nil
  end

  def rewind
  end

  def gets
    nil
  end
end

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => NilReturningIO.new
}

request = Rack::Request.new(env)

begin
  params = request.POST
  if params == {}
    puts "PASS: nil read handled gracefully, returned empty params"
  else
    puts "FAIL: Expected empty hash, got: #{params.inspect}"
    exit 1
  end
rescue NoMethodError => e
  puts "FAIL: nil read caused NoMethodError (vulnerable): #{e.message}"
  exit 1
rescue => e
  puts "FAIL: Unexpected error: #{e.class} - #{e.message}"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestErrorMessageFormat:
    """
    Test the error message format when query size exceeds limit.

    In vulnerable v2.2.19: "total query size (#{qs.bytesize}) exceeds limit (#{@bytesize_limit})"
    In fixed v2.2.20: "total query size exceeds limit (#{@bytesize_limit})"

    The fix removes the actual bytesize from the message (security improvement).
    """

    def test_error_message_does_not_include_actual_size(self):
        """
        Error message should NOT include the actual request size.

        Vulnerable format: "total query size (5000002) exceeds limit (4194304)"
        Fixed format: "total query size exceeds limit (4194304)"
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"
require "rack"
require "stringio"

# Create body larger than 4MB limit
large_body = "x" * 5_000_000 + "=1"

env = {
  "REQUEST_METHOD" => "POST",
  "CONTENT_TYPE" => "application/x-www-form-urlencoded",
  "rack.input" => StringIO.new(large_body)
}

request = Rack::Request.new(env)

begin
  params = request.POST
  puts "FAIL: Should have raised QueryLimitError"
  exit 1
rescue Rack::QueryParser::QueryLimitError => e
  # Check if message includes actual bytesize in parentheses before "exceeds"
  # Vulnerable: "total query size (5000002) exceeds limit"
  # Fixed: "total query size exceeds limit"
  if e.message =~ /total query size \(\d+\) exceeds/
    puts "FAIL: Error message includes actual bytesize (vulnerable format)"
    puts "Message: #{e.message}"
    exit 1
  elsif e.message.include?("exceeds limit")
    puts "PASS: Error message in fixed format (no actual bytesize)"
    puts "Message: #{e.message}"
  else
    puts "FAIL: Unexpected error message format"
    puts "Message: #{e.message}"
    exit 1
  end
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output


class TestSourceCodeVerification:
    """
    Direct verification of source code changes between vulnerable and fixed versions.
    """

    def test_request_rb_uses_bounded_read(self):
        """
        Verify that request.rb uses bounded read with bytesize_limit.

        Vulnerable pattern: form_vars = get_header(RACK_INPUT).read
        Fixed pattern: form_vars = get_header(RACK_INPUT).read(query_parser.bytesize_limit + 2) || ''
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"

# Read the request.rb source file
request_rb = File.read("/app/lib/rack/request.rb")

# Check for the vulnerable pattern (unbounded read)
vulnerable_pattern = /form_vars\s*=\s*get_header\(RACK_INPUT\)\.read\s*$/

# Check for the fixed pattern (bounded read with bytesize_limit)
fixed_pattern = /form_vars\s*=\s*get_header\(RACK_INPUT\)\.read\(query_parser\.bytesize_limit/

if request_rb.match?(fixed_pattern)
  puts "PASS: request.rb uses bounded read with bytesize_limit"
elsif request_rb.match?(vulnerable_pattern)
  puts "FAIL: request.rb uses unbounded read (vulnerable)"
  exit 1
else
  puts "FAIL: Could not find expected read pattern in request.rb"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output

    def test_query_parser_has_bytesize_limit_attr_reader(self):
        """
        Verify that query_parser.rb has attr_reader :bytesize_limit.

        The fix adds: attr_reader :bytesize_limit
        """
        ruby_code = '''
$LOAD_PATH.unshift "/app/lib"

# Read the query_parser.rb source file
query_parser_rb = File.read("/app/lib/rack/query_parser.rb")

# Check for attr_reader :bytesize_limit
if query_parser_rb.include?("attr_reader :bytesize_limit")
  puts "PASS: query_parser.rb has attr_reader :bytesize_limit"
else
  puts "FAIL: query_parser.rb missing attr_reader :bytesize_limit"
  exit 1
end
'''
        success, output = run_ruby_test(ruby_code)
        assert success, f"Test failed: {output}"
        assert "PASS" in output
