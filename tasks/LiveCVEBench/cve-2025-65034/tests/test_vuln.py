"""
Vulnerability tests for Rallly poll management IDOR.

These tests verify that unauthorized users CANNOT manage polls belonging to other users.
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""

import pytest
import requests
import json
import time
import uuid
import os

BASE_URL = "http://localhost:3000"
TRPC_URL = f"{BASE_URL}/api/trpc"

# Database connection - uses environment variable or default
DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://postgres:postgres@rallly-cve-db:5432/rallly")


def get_db_connection():
    """Get a database connection using psycopg2"""
    import psycopg2
    url = DATABASE_URL
    if url.startswith("postgres://"):
        url = url.replace("postgres://", "postgresql://", 1)

    from urllib.parse import urlparse
    parsed = urlparse(url)

    return psycopg2.connect(
        host=parsed.hostname,
        port=parsed.port or 5432,
        user=parsed.username,
        password=parsed.password,
        database=parsed.path.lstrip('/')
    )


def run_db_query(query: str, params=None, fetch: bool = False):
    """Run a query against the PostgreSQL database"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute(query, params)
        if fetch:
            result = cur.fetchone()
            conn.close()
            return result[0] if result else None
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"DB Error: {e}")
        return None


class AuthenticatedSession:
    """Helper class to manage user sessions via anonymous sign-in + DB update"""

    def __init__(self, email_prefix: str, name: str):
        self.session = requests.Session()
        self.email_prefix = email_prefix
        self.name = name
        self.user_id = None
        self.email = None

    def setup_user(self) -> bool:
        """Create an authenticated non-anonymous user"""
        # Step 1: Sign in anonymously to get a valid signed session
        resp = self.session.post(
            f"{BASE_URL}/api/better-auth/sign-in/anonymous",
            json={},
            headers={"Content-Type": "application/json"}
        )

        if resp.status_code != 200:
            print(f"Anonymous sign-in failed: {resp.status_code} - {resp.text}")
            return False

        result = resp.json()
        self.user_id = result.get("user", {}).get("id")
        if not self.user_id:
            print("No user_id returned from anonymous sign-in")
            return False

        # Generate unique email
        self.email = f"{self.email_prefix}_{uuid.uuid4().hex[:8]}@test.local"
        space_id = uuid.uuid4().hex[:26]
        member_id = uuid.uuid4().hex[:26]

        try:
            conn = get_db_connection()
            cur = conn.cursor()

            # Update user to be non-anonymous with verified email
            cur.execute(
                "UPDATE users SET anonymous = false, email = %s, name = %s, email_verified = true WHERE id = %s",
                (self.email, self.name, self.user_id)
            )

            # Create space for user (required for poll operations)
            cur.execute(
                "INSERT INTO spaces (id, name, owner_id, created_at, updated_at, tier) VALUES (%s, %s, %s, NOW(), NOW(), 'hobby')",
                (space_id, "Personal", self.user_id)
            )

            # Add user as space member
            cur.execute(
                "INSERT INTO space_members (id, space_id, user_id, role, created_at, updated_at, last_selected_at) VALUES (%s, %s, %s, 'ADMIN', NOW(), NOW(), NOW())",
                (member_id, space_id, self.user_id)
            )

            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Database setup error: {e}")
            return False

    def create_poll(self, title: str) -> dict:
        """Create a new poll and return its data"""
        poll_data = {
            "json": {
                "title": title,
                "options": [
                    {"startDate": "2025-02-01"},
                    {"startDate": "2025-02-02"}
                ],
                "timeZone": "UTC"
            }
        }

        resp = self.session.post(
            f"{TRPC_URL}/polls.create",
            json=poll_data,
            headers={"Content-Type": "application/json"}
        )

        if resp.status_code == 200:
            result = resp.json()
            if "result" in result and "data" in result["result"]:
                return result["result"]["data"]["json"]
        return None

    def reopen_poll(self, poll_id: str) -> requests.Response:
        """Attempt to reopen a poll"""
        return self.session.post(
            f"{TRPC_URL}/polls.reopen",
            json={"json": {"pollId": poll_id}},
            headers={"Content-Type": "application/json"}
        )

    def pause_poll(self, poll_id: str) -> requests.Response:
        """Attempt to pause a poll"""
        return self.session.post(
            f"{TRPC_URL}/polls.pause",
            json={"json": {"pollId": poll_id}},
            headers={"Content-Type": "application/json"}
        )

    def resume_poll(self, poll_id: str) -> requests.Response:
        """Attempt to resume a poll"""
        return self.session.post(
            f"{TRPC_URL}/polls.resume",
            json={"json": {"pollId": poll_id}},
            headers={"Content-Type": "application/json"}
        )

    def watch_poll(self, poll_id: str) -> requests.Response:
        """Attempt to watch a poll"""
        return self.session.post(
            f"{TRPC_URL}/polls.watch",
            json={"json": {"pollId": poll_id}},
            headers={"Content-Type": "application/json"}
        )


def is_forbidden_response(resp: requests.Response) -> bool:
    """Check if response indicates forbidden/unauthorized access"""
    if resp.status_code == 403:
        return True

    try:
        data = resp.json()
        if isinstance(data, dict):
            if "error" in data:
                error = data["error"]
                if isinstance(error, dict):
                    if error.get("code") == "FORBIDDEN":
                        return True
                    if "data" in error and error["data"].get("code") == "FORBIDDEN":
                        return True
    except (json.JSONDecodeError, KeyError, TypeError):
        pass

    return False


def is_success_response(resp: requests.Response) -> bool:
    """Check if response indicates successful operation"""
    if resp.status_code == 200:
        try:
            data = resp.json()
            if isinstance(data, dict):
                if "error" in data:
                    return False
                if "result" in data:
                    return True
            return True
        except json.JSONDecodeError:
            return True
    return False


@pytest.fixture(scope="module")
def user_a():
    """Create and authenticate User A (victim)"""
    session = AuthenticatedSession("victim", "Victim User")
    if not session.setup_user():
        pytest.skip("Could not setup User A (victim)")
    return session


@pytest.fixture(scope="module")
def user_b():
    """Create and authenticate User B (attacker)"""
    session = AuthenticatedSession("attacker", "Attacker User")
    if not session.setup_user():
        pytest.skip("Could not setup User B (attacker)")
    return session


class TestIDORReopenPoll:
    """Test IDOR vulnerability on poll reopen endpoint"""

    def test_unauthorized_user_cannot_reopen_others_poll(self, user_a, user_b):
        """
        User B should NOT be able to reopen User A's poll.

        Vulnerable: Request succeeds, poll is reopened (this test FAILS)
        Fixed: Request returns 403 FORBIDDEN (this test PASSES)
        """
        unique_title = f"IDOR Reopen Test {uuid.uuid4().hex[:8]}"
        poll = user_a.create_poll(unique_title)

        if not poll or "id" not in poll:
            pytest.skip("Could not create test poll")

        poll_id = poll["id"]
        time.sleep(0.5)

        # User B (attacker) attempts to reopen User A's poll
        resp = user_b.reopen_poll(poll_id)

        # In VULNERABLE state: this assertion FAILS because attacker succeeds
        # In FIXED state: this assertion PASSES because attacker is blocked
        assert is_forbidden_response(resp), \
            f"Expected FORBIDDEN when reopening another user's poll. " \
            f"Status: {resp.status_code}, Response: {resp.text[:500]}"


class TestIDORPausePoll:
    """Test IDOR vulnerability on poll pause endpoint"""

    def test_unauthorized_user_cannot_pause_others_poll(self, user_a, user_b):
        """
        User B should NOT be able to pause User A's poll.

        Vulnerable: Request succeeds (test FAILS)
        Fixed: Request returns 403 FORBIDDEN (test PASSES)
        """
        unique_title = f"IDOR Pause Test {uuid.uuid4().hex[:8]}"
        poll = user_a.create_poll(unique_title)

        if not poll or "id" not in poll:
            pytest.skip("Could not create test poll")

        poll_id = poll["id"]
        time.sleep(0.5)

        resp = user_b.pause_poll(poll_id)

        assert is_forbidden_response(resp), \
            f"Expected FORBIDDEN when pausing another user's poll. " \
            f"Status: {resp.status_code}, Response: {resp.text[:500]}"


class TestIDORResumePoll:
    """Test IDOR vulnerability on poll resume endpoint"""

    def test_unauthorized_user_cannot_resume_others_poll(self, user_a, user_b):
        """
        User B should NOT be able to resume User A's paused poll.

        Vulnerable: Request succeeds (test FAILS)
        Fixed: Request returns 403 FORBIDDEN (test PASSES)
        """
        unique_title = f"IDOR Resume Test {uuid.uuid4().hex[:8]}"
        poll = user_a.create_poll(unique_title)

        if not poll or "id" not in poll:
            pytest.skip("Could not create test poll")

        poll_id = poll["id"]

        # User A pauses their own poll first
        user_a.pause_poll(poll_id)
        time.sleep(0.5)

        resp = user_b.resume_poll(poll_id)

        assert is_forbidden_response(resp), \
            f"Expected FORBIDDEN when resuming another user's poll. " \
            f"Status: {resp.status_code}, Response: {resp.text[:500]}"


class TestIDORWatchPoll:
    """Test IDOR vulnerability on poll watch endpoint"""

    def test_unauthorized_user_cannot_watch_others_poll(self, user_a, user_b):
        """
        User B should NOT be able to watch User A's poll.

        Vulnerable: Request succeeds (test FAILS)
        Fixed: Request returns 403 FORBIDDEN (test PASSES)
        """
        unique_title = f"IDOR Watch Test {uuid.uuid4().hex[:8]}"
        poll = user_a.create_poll(unique_title)

        if not poll or "id" not in poll:
            pytest.skip("Could not create test poll")

        poll_id = poll["id"]
        time.sleep(0.5)

        resp = user_b.watch_poll(poll_id)

        assert is_forbidden_response(resp), \
            f"Expected FORBIDDEN when watching another user's poll. " \
            f"Status: {resp.status_code}, Response: {resp.text[:500]}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
