"""
Vulnerability tests for the MCP database server query validation.
These tests verify that dangerous query patterns are blocked.

Expected behavior:
- FAIL in vulnerable state (dangerous queries are allowed)
- PASS in fixed state (dangerous queries are blocked)
"""

import subprocess
import json
import os
import tempfile
import pytest

APP_DIR = "/app"
DIST_DIR = os.path.join(APP_DIR, "dist", "src")


class TestSemicolonQueryChaining:
    """Test that query chaining with semicolons is blocked."""

    def test_basic_query_chaining_blocked(self):
        """Basic query chaining with semicolon should be blocked."""
        result = run_query_validation("SELECT 1; SELECT 2")
        assert result["blocked"] is True, \
            f"Query chaining should be blocked: {result}"
        assert "Multiple SQL" in result.get("error", "") or "semicolon" in result.get("error", "").lower(), \
            f"Error should mention multiple statements: {result}"

    def test_destructive_query_chaining_blocked(self):
        """Destructive commands after SELECT should be blocked."""
        result = run_query_validation("SELECT 1; DROP TABLE users")
        assert result["blocked"] is True, \
            f"Destructive query chaining should be blocked: {result}"

    def test_delete_after_select_blocked(self):
        """DELETE after SELECT should be blocked."""
        result = run_query_validation("SELECT 1; DELETE FROM users WHERE 1=1")
        assert result["blocked"] is True, \
            f"DELETE after SELECT should be blocked: {result}"

    def test_insert_after_select_blocked(self):
        """INSERT after SELECT should be blocked."""
        result = run_query_validation("SELECT 1; INSERT INTO logs VALUES ('hacked')")
        assert result["blocked"] is True, \
            f"INSERT after SELECT should be blocked: {result}"

    def test_update_after_select_blocked(self):
        """UPDATE after SELECT should be blocked."""
        result = run_query_validation("SELECT 1; UPDATE users SET admin=true")
        assert result["blocked"] is True, \
            f"UPDATE after SELECT should be blocked: {result}"

    def test_multiple_semicolons_blocked(self):
        """Multiple semicolons should be blocked."""
        result = run_query_validation("SELECT 1; SELECT 2; SELECT 3")
        assert result["blocked"] is True, \
            f"Multiple semicolons should be blocked: {result}"

    def test_trailing_semicolon_blocked(self):
        """Trailing semicolon should also be blocked (could allow empty statement injection)."""
        result = run_query_validation("SELECT 1;")
        assert result["blocked"] is True, \
            f"Trailing semicolon should be blocked: {result}"

    def test_semicolon_in_string_literal_should_pass(self):
        """Semicolon inside a string literal is part of data, not a statement separator.
        A proper fix should allow this (false positive if blocked).
        In vulnerable state, this passes through without issue."""
        result = run_query_validation("SELECT 'test;value' AS data")
        # In a properly fixed state, this should be blocked (conservative approach)
        # OR allowed (smart parsing). We test that it IS blocked in fixed state.
        assert result["blocked"] is True, \
            f"Semicolon in string literal should be blocked (conservative security): {result}"


class TestPgSleepBlocked:
    """Test that pg_sleep and related time-based DoS functions are blocked."""

    def test_pg_sleep_simple(self):
        """Simple pg_sleep call should be blocked."""
        result = run_query_validation("SELECT pg_sleep(5)")
        assert result["blocked"] is True, \
            f"pg_sleep should be blocked: {result}"
        assert "pg_sleep" in result.get("error", "").lower() or "not allowed" in result.get("error", "").lower(), \
            f"Error should mention pg_sleep: {result}"

    def test_pg_sleep_with_calculation(self):
        """pg_sleep with calculated value should be blocked."""
        result = run_query_validation("SELECT pg_sleep(1+1)")
        assert result["blocked"] is True, \
            f"pg_sleep with calculation should be blocked: {result}"

    def test_pg_sleep_uppercase(self):
        """pg_sleep in uppercase should be blocked."""
        result = run_query_validation("SELECT PG_SLEEP(5)")
        assert result["blocked"] is True, \
            f"PG_SLEEP (uppercase) should be blocked: {result}"

    def test_pg_sleep_mixed_case(self):
        """pg_sleep in mixed case should be blocked."""
        result = run_query_validation("SELECT Pg_Sleep(5)")
        assert result["blocked"] is True, \
            f"Pg_Sleep (mixed case) should be blocked: {result}"

    def test_pg_sleep_with_whitespace(self):
        """pg_sleep with extra whitespace should be blocked."""
        result = run_query_validation("SELECT  pg_sleep  (  5  )")
        assert result["blocked"] is True, \
            f"pg_sleep with whitespace should be blocked: {result}"

    def test_pg_sleep_in_subquery(self):
        """pg_sleep in subquery should be blocked."""
        result = run_query_validation("SELECT * FROM (SELECT pg_sleep(5)) AS t")
        assert result["blocked"] is True, \
            f"pg_sleep in subquery should be blocked: {result}"


class TestPgTerminateBackendBlocked:
    """Test that pg_terminate_backend and process control functions are blocked."""

    def test_pg_terminate_backend(self):
        """pg_terminate_backend should be blocked."""
        result = run_query_validation("SELECT pg_terminate_backend(12345)")
        assert result["blocked"] is True, \
            f"pg_terminate_backend should be blocked: {result}"

    def test_pg_terminate_backend_uppercase(self):
        """PG_TERMINATE_BACKEND should be blocked."""
        result = run_query_validation("SELECT PG_TERMINATE_BACKEND(12345)")
        assert result["blocked"] is True, \
            f"PG_TERMINATE_BACKEND should be blocked: {result}"

    def test_pg_terminate_backend_from_stat_activity(self):
        """pg_terminate_backend combined with pg_stat_activity query should be blocked."""
        result = run_query_validation(
            "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = 'active'"
        )
        assert result["blocked"] is True, \
            f"pg_terminate_backend from pg_stat_activity should be blocked: {result}"


class TestPgCancelBackendBlocked:
    """Test that pg_cancel_backend is blocked."""

    def test_pg_cancel_backend(self):
        """pg_cancel_backend should be blocked."""
        result = run_query_validation("SELECT pg_cancel_backend(12345)")
        assert result["blocked"] is True, \
            f"pg_cancel_backend should be blocked: {result}"

    def test_pg_cancel_backend_mixed_case(self):
        """Pg_Cancel_Backend should be blocked."""
        result = run_query_validation("SELECT Pg_Cancel_Backend(12345)")
        assert result["blocked"] is True, \
            f"Pg_Cancel_Backend should be blocked: {result}"


class TestAdminFunctionsBlocked:
    """Test that PostgreSQL administrative functions are blocked."""

    def test_pg_reload_conf(self):
        """pg_reload_conf should be blocked."""
        result = run_query_validation("SELECT pg_reload_conf()")
        assert result["blocked"] is True, \
            f"pg_reload_conf should be blocked: {result}"

    def test_pg_rotate_logfile(self):
        """pg_rotate_logfile should be blocked."""
        result = run_query_validation("SELECT pg_rotate_logfile()")
        assert result["blocked"] is True, \
            f"pg_rotate_logfile should be blocked: {result}"


class TestCombinedAttacks:
    """Test combined attack vectors."""

    def test_sleep_with_chaining(self):
        """pg_sleep combined with query chaining should be blocked."""
        result = run_query_validation("SELECT pg_sleep(1); DROP TABLE users")
        assert result["blocked"] is True, \
            f"pg_sleep with chaining should be blocked: {result}"

    def test_terminate_with_chaining(self):
        """pg_terminate_backend combined with chaining should be blocked."""
        result = run_query_validation("SELECT 1; SELECT pg_terminate_backend(123)")
        assert result["blocked"] is True, \
            f"Chained terminate should be blocked: {result}"


class TestEdgeCases:
    """Test edge cases and bypass attempts."""

    def test_function_name_in_column_name(self):
        """Column named 'pg_sleep_time' should be blocked by simple string matching.
        A conservative security approach blocks any mention of dangerous functions."""
        result = run_query_validation("SELECT pg_sleep_time FROM metrics")
        # Simple string matching blocks this - acceptable for security
        assert result["blocked"] is True, \
            f"Column with pg_sleep in name should be blocked (conservative): {result}"

    def test_function_in_quoted_identifier(self):
        """Function name in quoted identifier should be blocked by conservative approach."""
        result = run_query_validation('SELECT "pg_sleep" FROM table1')
        # Simple validation blocks this - acceptable for security
        assert result["blocked"] is True, \
            f"pg_sleep in quoted identifier should be blocked: {result}"

    def test_newline_injection(self):
        """Newline should not bypass semicolon detection."""
        result = run_query_validation("SELECT 1\n; DROP TABLE users")
        assert result["blocked"] is True, \
            f"Newline before semicolon should still be blocked: {result}"

    def test_tab_injection(self):
        """Tab should not bypass detection."""
        result = run_query_validation("SELECT\tpg_sleep(5)")
        assert result["blocked"] is True, \
            f"Tab-separated pg_sleep should be blocked: {result}"

    def test_carriage_return_injection(self):
        """Carriage return should not bypass detection."""
        result = run_query_validation("SELECT 1\r; SELECT 2")
        assert result["blocked"] is True, \
            f"CR before semicolon should be blocked: {result}"


def run_query_validation(query: str) -> dict:
    """
    Test if a query is blocked or allowed by the readQuery validation.
    Returns dict with 'blocked' boolean and 'error' message if applicable.
    """
    # Escape the query for JavaScript
    escaped_query = json.dumps(query)

    test_script = f'''
import {{ initDatabase }} from "{DIST_DIR}/db/index.js";
import {{ readQuery }} from "{DIST_DIR}/tools/queryTools.js";

async function test() {{
    try {{
        // Initialize database connection first
        await initDatabase({{
            host: "postgres",
            database: "testdb",
            user: "testuser",
            password: "testpass",
            port: 5432
        }}, "postgresql");

        await readQuery({escaped_query});
        // If we get here, the query was NOT blocked
        console.log(JSON.stringify({{
            blocked: false,
            error: null
        }}));
    }} catch (error) {{
        const msg = error.message || "";
        // Check if this is a validation block vs database error
        const isBlocked = msg.includes("Multiple SQL") ||
                          msg.includes("not allowed") ||
                          msg.includes("pg_sleep") ||
                          msg.includes("pg_terminate") ||
                          msg.includes("pg_cancel") ||
                          msg.includes("pg_reload") ||
                          msg.includes("pg_rotate") ||
                          msg.includes("semicolon");
        console.log(JSON.stringify({{
            blocked: isBlocked,
            error: msg
        }}));
    }}
    process.exit(0);
}}

test();
'''

    with tempfile.NamedTemporaryFile(mode='w', suffix='.mjs', delete=False) as f:
        f.write(test_script)
        temp_path = f.name

    try:
        result = subprocess.run(
            ['node', temp_path],
            cwd=APP_DIR,
            capture_output=True,
            text=True,
            timeout=15
        )

        # Try to parse JSON output (may have logging before it)
        output = result.stdout.strip()
        lines = output.split('\n')
        for line in reversed(lines):
            line = line.strip()
            if line.startswith('{'):
                try:
                    return json.loads(line)
                except json.JSONDecodeError:
                    pass

        # If script failed to run, query wasn't blocked by validation
        return {
            "blocked": False,
            "error": result.stderr or "Unknown error"
        }
    except subprocess.TimeoutExpired:
        # Timeout likely means query executed (pg_sleep worked) - not blocked
        return {
            "blocked": False,
            "error": "Query timed out (likely pg_sleep executed)"
        }
    except Exception as e:
        return {
            "blocked": False,
            "error": str(e)
        }
    finally:
        os.unlink(temp_path)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
