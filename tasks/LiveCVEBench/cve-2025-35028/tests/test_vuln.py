"""
Vulnerability tests for HexStrike AI MCP Server.

These tests verify that command injection is properly mitigated.
- FAIL in vulnerable state (injection works)
- PASS in fixed state (injection blocked)
"""

import requests
import pytest
import time
import os
import uuid
import subprocess

BASE_URL = "http://localhost:8888"
TIMEOUT = 30


@pytest.fixture(scope="module", autouse=True)
def wait_for_server():
    """Wait for server to be ready before running tests"""
    max_retries = 30
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/health", timeout=5)
            if response.status_code == 200:
                return
        except requests.exceptions.ConnectionError:
            pass
        time.sleep(1)
    pytest.fail(f"Server not ready after {max_retries} seconds")


class TestCommandInjectionSemicolon:
    """Test command injection via semicolon separator"""

    def test_semicolon_injection_in_additional_args(self):
        """Test that semicolon command injection is blocked in additional_args"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        # Attempt injection via additional_args - echo to stdout for detection
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"; echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # Check if marker appears anywhere in output (injection succeeded)
        # Note: marker in stderr as "Failed to resolve" is OK - that's nmap trying to resolve it as hostname
        # We only fail if the marker appears as part of actual command output (not DNS resolution error)
        assert marker not in stdout, f"Semicolon injection output appeared in stdout"
        # Don't check stderr - the marker may appear as a failed hostname resolution which is fine

    def test_semicolon_injection_in_target(self):
        """Test that semicolon injection is blocked in target parameter"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": f"127.0.0.1;echo {marker}",
                "scan_type": "-sn"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # Note: marker in stderr as "Failed to resolve" is OK - that's nmap treating it as hostname
        assert marker not in stdout, "Semicolon injection in target appeared in stdout"
        # Don't check stderr - the marker may appear as a failed hostname resolution which is fine

    def test_semicolon_injection_in_scan_type(self):
        """Test that semicolon injection is blocked in scan_type parameter"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": f"-sn;echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "Semicolon injection in scan_type succeeded"


class TestCommandInjectionPipe:
    """Test command injection via pipe operator"""

    def test_pipe_injection_in_additional_args(self):
        """Test that pipe command injection is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"| echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "Pipe injection succeeded - marker in stdout"

    def test_pipe_injection_reading_file(self):
        """Test that pipe injection cannot read files"""
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": "| cat /etc/passwd"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        # /etc/passwd should not appear in output
        assert "root:" not in stdout, "Pipe injection leaked /etc/passwd content"


class TestCommandInjectionBacktick:
    """Test command injection via backtick command substitution"""

    def test_backtick_injection_in_additional_args(self):
        """Test that backtick command substitution is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"`echo {marker}`"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")
        combined = stdout + stderr

        # When vulnerable (shell=True): shell expands `echo MARKER` to just MARKER
        # nmap shows: Failed to resolve "MARKER".
        # When fixed (shell=False): backticks are passed literally
        # nmap may show: Failed to resolve "`echo". and Failed to resolve "MARKER`".
        #
        # Detection: If marker appears as CLEAN word (followed by " or . or space),
        # the shell executed the substitution. If marker appears with ` attached,
        # then backticks were passed literally (fixed).
        #
        # Check for "MARKER" or "MARKER". pattern - clean marker in quotes
        import re
        # Match marker as a clean value (not attached to backtick)
        clean_marker = re.search(rf'"{re.escape(marker)}"', combined) or \
                       re.search(rf'"{re.escape(marker)}\."', combined) or \
                       re.search(rf"'{re.escape(marker)}'", combined)
        assert clean_marker is None, f"Backtick injection executed - marker appeared as clean value in output"

    def test_backtick_injection_in_target(self):
        """Test that backtick injection in target is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": f"`echo {marker}`",
                "scan_type": "-sn"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")
        combined = stdout + stderr

        # Same logic - check for clean marker
        import re
        clean_marker = re.search(rf'"{re.escape(marker)}"', combined) or \
                       re.search(rf'"{re.escape(marker)}\."', combined) or \
                       re.search(rf"'{re.escape(marker)}'", combined)
        assert clean_marker is None, f"Backtick injection in target executed - marker appeared as clean value"


class TestCommandInjectionSubshell:
    """Test command injection via $() subshell substitution"""

    def test_subshell_injection_in_additional_args(self):
        """Test that $() subshell substitution is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"$(echo {marker})"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")
        combined = stdout + stderr

        # When vulnerable (shell=True): shell expands $(echo MARKER) to MARKER
        # nmap shows: Failed to resolve "MARKER".
        # When fixed (shell=False): shlex.split tokenizes as ["$(echo", "MARKER)"]
        # nmap may show: Failed to resolve "$(echo". and Failed to resolve "MARKER)".
        #
        # Detection: If marker appears as CLEAN value in quotes, injection worked
        import re
        clean_marker = re.search(rf'"{re.escape(marker)}"', combined) or \
                       re.search(rf'"{re.escape(marker)}\."', combined) or \
                       re.search(rf"'{re.escape(marker)}'", combined)
        assert clean_marker is None, f"Subshell injection executed - marker appeared as clean value in output"

    def test_subshell_injection_in_target(self):
        """Test that $() injection in target is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": f"$(echo {marker})",
                "scan_type": "-sn"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")
        combined = stdout + stderr

        # Same logic
        import re
        clean_marker = re.search(rf'"{re.escape(marker)}"', combined) or \
                       re.search(rf'"{re.escape(marker)}\."', combined) or \
                       re.search(rf"'{re.escape(marker)}'", combined)
        assert clean_marker is None, f"Subshell injection in target executed - marker appeared as clean value"

    def test_nested_subshell_injection(self):
        """Test that nested subshell injection is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"$(echo $(echo {marker}))"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")
        combined = stdout + stderr

        # Same logic
        import re
        clean_marker = re.search(rf'"{re.escape(marker)}"', combined) or \
                       re.search(rf'"{re.escape(marker)}\."', combined) or \
                       re.search(rf"'{re.escape(marker)}'", combined)
        assert clean_marker is None, f"Nested subshell injection executed - marker appeared as clean value"


class TestCommandInjectionAmpersand:
    """Test command injection via && and & operators"""

    def test_and_operator_injection(self):
        """Test that && command chaining is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"&& echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "&& operator injection succeeded"

    def test_background_operator_injection(self):
        """Test that & background operator is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        # Use echo to stdout instead of file-based detection
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"& echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # Note: marker in stderr as "Failed to resolve" is OK - that's nmap treating it as hostname
        assert marker not in stdout, "Background & operator injection appeared in stdout"
        # Don't check stderr - the marker may appear as a failed hostname resolution which is fine


class TestCommandInjectionNewline:
    """Test command injection via newline characters"""

    def test_newline_injection(self):
        """Test that newline character injection is blocked"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "additional_args": f"-sn\necho {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "Newline injection succeeded"


class TestCommandInjectionPorts:
    """Test command injection via ports parameter"""

    def test_injection_in_ports_semicolon(self):
        """Test that semicolon injection is blocked in ports parameter"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "ports": f"80;echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "Semicolon injection in ports succeeded"

    def test_injection_in_ports_subshell(self):
        """Test that subshell injection is blocked in ports parameter"""
        # Use a specific port that wouldn't normally be scanned
        # If subshell expands, this port will be scanned
        test_port = "31337"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "ports": f"$(echo {test_port})",
                "scan_type": "-sS",  # SYN scan allows port specification
                "additional_args": "-Pn"  # Skip host discovery
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # If subshell executed, nmap would scan the expanded port (31337)
        # In a fixed version, the literal "$(echo 31337)" would cause an error
        # Check if the port was actually scanned (subshell executed)
        port_scanned = test_port in stdout or f"[{test_port} port" in stdout.lower()
        assert not port_scanned, f"Subshell injection in ports succeeded - port {test_port} was scanned"


class TestFileSystemAccess:
    """Test that command injection cannot access the filesystem"""

    def test_cannot_read_passwd(self):
        """Test that /etc/passwd cannot be read via injection"""
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": ";cat /etc/passwd"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert "root:x:" not in stdout, "Command injection leaked /etc/passwd"
        assert "nobody:" not in stdout, "Command injection leaked /etc/passwd"

    def test_cannot_create_files(self):
        """Test that files cannot be created via injection"""
        marker = f"PWNED_{uuid.uuid4().hex[:8]}"
        marker_file = f"/tmp/hexstrike_vuln_test_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f";touch {marker_file}"
            },
            timeout=TIMEOUT
        )

        time.sleep(1)

        file_exists = os.path.exists(marker_file)
        if file_exists:
            os.remove(marker_file)
            pytest.fail("Command injection created a file")

    def test_cannot_execute_id(self):
        """Test that 'id' command cannot be executed via injection"""
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": ";id"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # 'id' command output patterns - check both stdout and stderr
        # When id runs with '127.0.0.1' as argument, it shows "id: '127.0.0.1': no such user"
        assert "uid=" not in stdout, "Command injection executed 'id' command (uid in stdout)"
        assert "gid=" not in stdout, "Command injection executed 'id' command (gid in stdout)"
        # Check if id command was executed (shows error about invalid user)
        assert not ("id:" in stderr and "no such user" in stderr), "Command injection executed 'id' command (id error in stderr)"


class TestComplexInjectionPatterns:
    """Test complex and obfuscated injection patterns"""

    def test_encoded_semicolon(self):
        """Test various forms of semicolon encoding"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        # URL-encoded semicolon won't work in JSON but test literal semicolon
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "-sn",
                "additional_args": f"; echo {marker}"  # With space
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert marker not in stdout, "Semicolon with space injection succeeded"

    def test_multiple_injection_attempts(self):
        """Test multiple injection patterns in one request"""
        marker = f"MULTI_{uuid.uuid4().hex[:8]}"

        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": f"-sn;echo {marker}1",
                "ports": f"80;echo {marker}2",
                "additional_args": f"-v;echo {marker}3"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")

        assert f"{marker}1" not in stdout, "Injection in scan_type succeeded"
        assert f"{marker}2" not in stdout, "Injection in ports succeeded"
        assert f"{marker}3" not in stdout, "Injection in additional_args succeeded"

    def test_or_operator_injection(self):
        """Test || operator injection - force failure with invalid nmap option"""
        marker = f"INJECTED_{uuid.uuid4().hex[:8]}"

        # Use invalid scan type to make nmap fail, so || branch executes
        response = requests.post(
            f"{BASE_URL}/api/tools/nmap",
            json={
                "target": "127.0.0.1",
                "scan_type": "--invalid-option-xyz",
                "additional_args": f"|| echo {marker}"
            },
            timeout=TIMEOUT
        )

        data = response.json()
        stdout = data.get("stdout", "")
        stderr = data.get("stderr", "")

        # If || works, marker should appear when nmap fails
        assert marker not in stdout, "|| operator injection succeeded (stdout)"
        assert marker not in stderr, "|| operator injection succeeded (stderr)"
