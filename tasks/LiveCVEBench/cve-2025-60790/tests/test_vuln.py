"""
Vulnerability tests for ZIP extraction resource exhaustion.

These tests verify that the vulnerability EXISTS in the vulnerable state:
- FAIL in vulnerable state (ZIP bomb is extracted, causing resource exhaustion)
- PASS in fixed state (ZIP bomb is rejected before extraction)

The vulnerability allows attackers to upload malicious ZIP files that expand
to extremely large sizes during extraction, causing denial of service.
"""

import subprocess
import os
import tempfile
import zipfile
import shutil
import time
import pytest


# Path to the PHP test helper script
PHP_TEST_SCRIPT = "/tests/test_helper.php"
APP_DIR = "/var/www/html"
POC_BOMB_PATH = "/tests/poc_bomb.zip"


def create_many_files_zip(num_files: int, file_size: int, dest_path: str) -> str:
    """Create a ZIP file with many files to test file count limits."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        for i in range(num_files):
            # Use highly compressible content
            content = "A" * file_size
            zf.writestr(f"file_{i:06d}.txt", content)
    return dest_path


def create_large_uncompressed_zip(total_mb: int, dest_path: str) -> str:
    """Create a ZIP file that expands to a large size when uncompressed."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        # Create files that compress well but expand to target size
        file_size = 1024 * 1024  # 1 MB per file
        num_files = total_mb

        for i in range(num_files):
            # Highly compressible: repeated pattern
            content = ("AAAAAAAAAA" * 102400) + f"_{i:06d}"  # ~1MB
            content = content[:file_size]
            zf.writestr(f"large_{i:04d}.txt", content)

    return dest_path


def create_deep_nested_zip(depth: int, dest_path: str) -> str:
    """Create a ZIP with deeply nested directory structure."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        path = ""
        for i in range(depth):
            path += f"dir_{i}/"
            zf.writestr(path + "file.txt", f"Content at depth {i}")
    return dest_path


def run_unzip_test(zip_path: str, timeout: int = 30) -> dict:
    """
    Run the PHP unzip test and return the result.
    Returns dict with 'success', 'output', 'error', 'timed_out' keys.
    """
    try:
        result = subprocess.run(
            ["php", PHP_TEST_SCRIPT, "unzip", zip_path],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=APP_DIR
        )
        return {
            "success": result.returncode == 0,
            "output": result.stdout,
            "error": result.stderr,
            "returncode": result.returncode,
            "timed_out": False
        }
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "output": "",
            "error": "Process timed out - likely extracting too many files",
            "returncode": -1,
            "timed_out": True
        }


def get_disk_usage(path: str) -> int:
    """Get disk usage in bytes for a path."""
    total = 0
    if os.path.isdir(path):
        for dirpath, dirnames, filenames in os.walk(path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                if os.path.isfile(fp):
                    total += os.path.getsize(fp)
    return total


class TestExcessiveFileCount:
    """Test that ZIPs with excessive file counts are rejected."""

    def test_zip_with_2000_files_rejected(self, tmp_path):
        """
        ZIP with 2000 files should be rejected if fix is in place.
        Default maxFiles limit is 1000 or 1500.
        """
        zip_path = str(tmp_path / "many_files.zip")
        create_many_files_zip(num_files=2000, file_size=100, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=60)

        # In fixed state: should fail with error about too many files
        # In vulnerable state: will succeed (or timeout trying to extract)
        assert not result["success"], (
            f"ZIP with 2000 files was accepted but should be rejected. "
            f"Output: {result['output']}"
        )

        # Verify error message indicates file count issue
        error_output = (result["error"] + result["output"]).lower()
        assert "too many" in error_output or "files" in error_output or "limit" in error_output, (
            f"Error message should mention file count limit. Got: {result['error']} {result['output']}"
        )

    def test_zip_with_5000_files_rejected(self, tmp_path):
        """ZIP with 5000 files should definitely be rejected."""
        zip_path = str(tmp_path / "very_many_files.zip")
        create_many_files_zip(num_files=5000, file_size=50, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=60)

        assert not result["success"], (
            f"ZIP with 5000 files was accepted but should be rejected. "
            f"Timeout: {result['timed_out']}"
        )


class TestExcessiveUncompressedSize:
    """Test that ZIPs with excessive uncompressed size are rejected."""

    def test_zip_expanding_to_200mb_rejected(self, tmp_path):
        """
        ZIP expanding to 200MB should be rejected.
        Default maxTotalMegabytes is 100.
        """
        zip_path = str(tmp_path / "large_uncompressed.zip")
        create_large_uncompressed_zip(total_mb=200, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=120)

        # In fixed state: should fail with size error
        # In vulnerable state: will try to extract (and possibly succeed or timeout)
        assert not result["success"], (
            f"ZIP expanding to 200MB was accepted but should be rejected. "
            f"Output: {result['output']}"
        )

        error_output = (result["error"] + result["output"]).lower()
        assert "size" in error_output or "megabytes" in error_output or "mb" in error_output or "limit" in error_output, (
            f"Error message should mention size limit. Got: {result['error']} {result['output']}"
        )

    def test_zip_expanding_to_500mb_rejected(self, tmp_path):
        """ZIP expanding to 500MB should definitely be rejected."""
        zip_path = str(tmp_path / "very_large.zip")
        create_large_uncompressed_zip(total_mb=500, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=120)

        assert not result["success"], (
            f"ZIP expanding to 500MB was accepted but should be rejected"
        )


class TestZipBomb:
    """Test that the PoC zip bomb is rejected."""

    @pytest.mark.skipif(
        not os.path.exists(POC_BOMB_PATH),
        reason="PoC zip bomb file not found"
    )
    def test_poc_zip_bomb_rejected(self):
        """
        The PoC zip bomb (~7MB compressed, ~6GB uncompressed) should be rejected.
        This is the primary test for the CVE fix.
        """
        result = run_unzip_test(POC_BOMB_PATH, timeout=30)

        # In fixed state: should fail immediately with validation error
        # In vulnerable state: will try to extract 6GB of data
        assert not result["success"], (
            f"PoC zip bomb was accepted but should be rejected! "
            f"This indicates the vulnerability is still present. "
            f"Output: {result['output']}"
        )

    @pytest.mark.skipif(
        not os.path.exists(POC_BOMB_PATH),
        reason="PoC zip bomb file not found"
    )
    def test_poc_zip_bomb_no_disk_usage(self, tmp_path):
        """
        Verify that rejecting the zip bomb doesn't cause significant disk usage.
        In vulnerable state, extraction would create gigabytes of data.
        """
        # Get initial disk usage of temp directory
        initial_usage = get_disk_usage(str(tmp_path))

        # Run the test
        result = run_unzip_test(POC_BOMB_PATH, timeout=30)

        # Check disk usage didn't increase significantly (< 10 MB)
        final_usage = get_disk_usage(str(tmp_path))
        usage_increase_mb = (final_usage - initial_usage) / (1024 * 1024)

        assert not result["success"], "Zip bomb should be rejected"
        assert usage_increase_mb < 10, (
            f"Disk usage increased by {usage_increase_mb:.2f} MB during rejection. "
            f"This suggests partial extraction occurred before validation."
        )


class TestDeepDirectoryNesting:
    """Test that deeply nested directories are handled properly."""

    def test_excessive_depth_rejected(self, tmp_path):
        """ZIP with excessive directory depth should be rejected."""
        zip_path = str(tmp_path / "deep_nested.zip")
        # Create ZIP with 20 levels of nesting (default maxDepth is 8-10)
        create_deep_nested_zip(depth=20, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=30)

        assert not result["success"], (
            f"ZIP with 20 levels of nesting should be rejected. "
            f"Output: {result['output']}"
        )

        error_output = (result["error"] + result["output"]).lower()
        assert "depth" in error_output or "nested" in error_output or "level" in error_output, (
            f"Error message should mention depth limit. Got: {result['error']} {result['output']}"
        )


class TestValidationBeforeExtraction:
    """Test that validation happens before any extraction."""

    def test_validation_is_preemptive(self, tmp_path):
        """
        Verify that validation errors are returned quickly,
        indicating validation happens before extraction.
        """
        zip_path = str(tmp_path / "large_file_count.zip")
        create_many_files_zip(num_files=3000, file_size=100, dest_path=zip_path)

        start_time = time.time()
        result = run_unzip_test(zip_path, timeout=60)
        elapsed_time = time.time() - start_time

        assert not result["success"], "ZIP with 3000 files should be rejected"

        # If validation is pre-emptive, it should complete quickly (< 5 seconds)
        # If it's extracting first, it would take much longer
        assert elapsed_time < 10, (
            f"Validation took {elapsed_time:.2f} seconds. "
            f"This suggests files are being extracted before validation, "
            f"which indicates the vulnerability may still exist."
        )


class TestErrorMessages:
    """Test that appropriate error messages are returned."""

    def test_file_count_error_message(self, tmp_path):
        """Verify error message for file count violation is informative."""
        zip_path = str(tmp_path / "many_files.zip")
        create_many_files_zip(num_files=2000, file_size=50, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=60)

        assert not result["success"]
        # Error should mention the issue
        combined_output = result["output"] + result["error"]
        assert len(combined_output) > 0, "Should provide error message when rejecting ZIP"

    def test_size_limit_error_message(self, tmp_path):
        """Verify error message for size violation is informative."""
        zip_path = str(tmp_path / "large.zip")
        create_large_uncompressed_zip(total_mb=200, dest_path=zip_path)

        result = run_unzip_test(zip_path, timeout=120)

        assert not result["success"]
        combined_output = result["output"] + result["error"]
        assert len(combined_output) > 0, "Should provide error message when rejecting ZIP"
