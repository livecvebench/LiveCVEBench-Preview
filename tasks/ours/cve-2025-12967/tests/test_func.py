"""
Functionality tests for the database wrapper application.
These tests verify that the application works correctly in both vulnerable and fixed states.
"""
import pytest
import psycopg2
import os
import time

# Database connection parameters
DB_HOST = os.environ.get('DB_HOST', 'localhost')
DB_PORT = os.environ.get('DB_PORT', '5432')
DB_NAME = os.environ.get('DB_NAME', 'testdb')
DB_USER = os.environ.get('DB_USER', 'postgres')
DB_PASS = os.environ.get('DB_PASS', 'postgres')


def get_connection(user=None, password=None):
    """Get a database connection."""
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        dbname=DB_NAME,
        user=user or DB_USER,
        password=password or DB_PASS
    )


def wait_for_db(max_retries=30, delay=1):
    """Wait for database to be ready."""
    for i in range(max_retries):
        try:
            conn = get_connection()
            conn.close()
            return True
        except psycopg2.OperationalError:
            time.sleep(delay)
    return False


class TestDatabaseConnectivity:
    """Test basic database connectivity."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Wait for database to be ready."""
        assert wait_for_db(), "Database is not ready"

    def test_can_connect_to_database(self):
        """Verify we can connect to the PostgreSQL database."""
        conn = get_connection()
        assert conn is not None
        conn.close()

    def test_can_execute_simple_query(self):
        """Verify we can execute a simple query."""
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        result = cursor.fetchone()
        assert result[0] == 1
        cursor.close()
        conn.close()


class TestBuiltinFunctions:
    """Test that PostgreSQL built-in functions work correctly."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Wait for database to be ready."""
        assert wait_for_db(), "Database is not ready"

    def test_version_function_returns_valid_string(self):
        """Verify version() returns a valid PostgreSQL version string."""
        conn = get_connection()
        cursor = conn.cursor()
        # Use qualified name to ensure we get real version
        cursor.execute("SELECT pg_catalog.version()")
        result = cursor.fetchone()[0]
        assert "PostgreSQL" in result
        cursor.close()
        conn.close()

    def test_current_database_returns_correct_name(self):
        """Verify current_database() returns the expected database name."""
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT pg_catalog.current_database()")
        result = cursor.fetchone()[0]
        assert result == DB_NAME
        cursor.close()
        conn.close()

    def test_current_user_returns_valid_user(self):
        """Verify current_user returns a valid username."""
        conn = get_connection()
        cursor = conn.cursor()
        # current_user is a SQL keyword, not a function, so no schema prefix needed
        cursor.execute("SELECT current_user")
        result = cursor.fetchone()[0]
        assert result is not None
        assert len(result) > 0
        cursor.close()
        conn.close()

    def test_now_returns_valid_timestamp(self):
        """Verify now() returns a valid timestamp."""
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT pg_catalog.now()")
        result = cursor.fetchone()[0]
        assert result is not None
        cursor.close()
        conn.close()

    def test_pg_is_in_recovery_returns_boolean(self):
        """Verify pg_is_in_recovery() returns a boolean value."""
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT pg_catalog.pg_is_in_recovery()")
        result = cursor.fetchone()[0]
        assert isinstance(result, bool)
        cursor.close()
        conn.close()


class TestQualifiedFunctionCalls:
    """Test that qualified function calls bypass search_path."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Wait for database to be ready."""
        assert wait_for_db(), "Database is not ready"

    def test_qualified_version_always_returns_postgres_version(self):
        """Verify pg_catalog.version() always returns real PostgreSQL version."""
        conn = get_connection()
        cursor = conn.cursor()

        # Even if there's a shadowing function, qualified call should work
        cursor.execute("SELECT pg_catalog.version()")
        result = cursor.fetchone()[0]

        # Must contain PostgreSQL - not any attacker-injected value
        assert "PostgreSQL" in result
        assert "HIJACKED" not in result

        cursor.close()
        conn.close()

    def test_qualified_current_database_returns_real_db(self):
        """Verify pg_catalog.current_database() returns real database name."""
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT pg_catalog.current_database()")
        result = cursor.fetchone()[0]

        # Must be the actual database name
        assert result == DB_NAME
        assert "HIJACKED" not in result

        cursor.close()
        conn.close()

    def test_qualified_now_returns_valid_time(self):
        """Verify pg_catalog.now() returns a real timestamp."""
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT pg_catalog.now()")
        result = cursor.fetchone()[0]

        # Must be a real timestamp
        assert result is not None
        # Should be within reasonable range (not year 1970 or 9999)
        assert result.year >= 2020
        assert result.year <= 2100

        cursor.close()
        conn.close()
