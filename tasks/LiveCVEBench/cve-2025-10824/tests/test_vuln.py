"""
Vulnerability tests for CVE-2025-10824: Use-after-free in fio job parser.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerability is triggered by malformed include directives in job files.
When parsing such files, the opts array is freed prematurely but subsequently
accessed, causing a heap-use-after-free.
"""

import subprocess
import tempfile
import os
import pytest


FIO_PATH = '/app/fio'


def check_memory_errors(stderr: str) -> tuple[bool, str]:
    """
    Check stderr for memory error indicators.

    Returns:
        (has_error, indicator): Tuple of whether error was found and what indicator matched
    """
    stderr_lower = stderr.lower()

    memory_error_indicators = [
        'heap-use-after-free',
        'addresssanitizer',
        'use-after-free',
        'segmentation fault',
        'segfault',
        'asan',
        'stack-buffer-overflow',
        'heap-buffer-overflow',
        'memory error',
        'double-free',
        'alloc-dealloc-mismatch',
    ]

    for indicator in memory_error_indicators:
        if indicator in stderr_lower:
            return True, indicator

    return False, ''


def run_fio_with_poc(poc_content: str, timeout: int = 30) -> subprocess.CompletedProcess:
    """Run fio --parse-only with given PoC content."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
        f.write(poc_content)
        poc_file = f.name

    try:
        result = subprocess.run(
            ['./fio', '--parse-only', poc_file],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=FIO_PATH
        )
        return result
    finally:
        if os.path.exists(poc_file):
            os.unlink(poc_file)


class TestUseAfterFreeVulnerability:
    """Tests for the use-after-free vulnerability in job file parser."""

    def test_basic_malformed_include(self):
        """
        Test basic malformed include directive without filename.

        This is the primary trigger for the UAF - an include statement
        on its own line without any filename argument.
        """
        poc_content = """[global]
runtime=300

[hdfs]
filename=dfs-perftest-base.dfs-perftest-base,9000
ioengine=external
rw=read
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out (possible hang due to memory corruption)")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        # Check for crash via signal
        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_alone_on_line(self):
        """
        Test include directive alone on its own line (no filename).

        The word 'include' by itself triggers the UAF when parsing.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_with_whitespace_only(self):
        """
        Test include directive followed by only whitespace.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_after_options(self):
        """
        Test include directive after several options in a job.

        The UAF is triggered regardless of where include appears in the section.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
bs=4k
numjobs=2
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_multiple_malformed_includes(self):
        """
        Test multiple malformed include directives in same file.

        Tests that repeated triggering doesn't cause additional issues.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
include

[job2]
rw=write
include

[job3]
rw=randread
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_at_start_of_section(self):
        """
        Test include directive at the start of a section.
        """
        poc_content = """[global]
runtime=10

[job1]
include
rw=read

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_in_global_section(self):
        """
        Test malformed include in global section.
        """
        poc_content = """[global]
runtime=10
include

[job1]
rw=read

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_as_last_line(self):
        """
        Test include directive as the last line of a job section.

        This is a common pattern in the original PoC.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
size=1M
include
"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_complex_job_with_malformed_include(self):
        """
        Test complex job file configuration with malformed include.

        This tests the vulnerability with more options to ensure
        the opts array has more entries when freed.
        """
        poc_content = """[global]
runtime=300
time_based=1
group_reporting=1
direct=1

[hdfs]
filename=dfs-perftest-base.dfs-perftest-base,9000
ioengine=external
rw=read
bs=4k
numjobs=4
iodepth=32
size=1G
include

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")


class TestEdgeCaseVulnerability:
    """Additional edge case tests for the vulnerability."""

    def test_include_followed_by_equals(self):
        """
        Test include= syntax (might be parsed differently).
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
include=

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_include_in_middle_of_job(self):
        """
        Test include directive in the middle of job options.

        Tests that options after the malformed include don't change behavior.
        """
        poc_content = """[global]
runtime=10

[job1]
rw=read
include
bs=4k

"""
        try:
            result = run_fio_with_poc(poc_content)
        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        has_error, indicator = check_memory_errors(result.stderr)
        assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

        if result.returncode < 0:
            pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

    def test_nested_job_with_include_error(self):
        """
        Test job file that creates nested parsing with include errors.
        """
        # Create an include file that itself has malformed includes
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write("size=1M\ninclude\n")
            nested_file = f.name

        poc_content = f"""[global]
runtime=10

[job1]
rw=read
include {nested_file}

"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write(poc_content)
            poc_file = f.name

        try:
            result = subprocess.run(
                ['./fio', '--parse-only', poc_file],
                capture_output=True,
                text=True,
                timeout=30,
                cwd=FIO_PATH
            )

            has_error, indicator = check_memory_errors(result.stderr)
            assert not has_error, f"VULNERABLE: Memory error detected: {indicator}"

            if result.returncode < 0:
                pytest.fail(f"VULNERABLE: Process crashed with signal {-result.returncode}")

        except subprocess.TimeoutExpired:
            pytest.fail("VULNERABLE: Process timed out")

        finally:
            for path in [poc_file, nested_file]:
                if os.path.exists(path):
                    os.unlink(path)


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
