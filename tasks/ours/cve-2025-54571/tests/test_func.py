#!/usr/bin/env python3
"""
Functional tests for ModSecurity + Apache.
These tests verify that the web server and ModSecurity are functioning correctly.
Should PASS in both vulnerable and fixed states.
"""

import socket
import time
import pytest

# Configuration
HOST = "localhost"
PORT = 80
TIMEOUT = 10


def send_raw_request(request: bytes, timeout: float = TIMEOUT) -> bytes:
    """Send a raw HTTP request and return the response."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((HOST, PORT))
        sock.sendall(request)

        response = b""
        try:
            while True:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
        except socket.timeout:
            pass
        return response
    finally:
        sock.close()


class TestBasicFunctionality:
    """Basic server functionality tests."""

    def test_server_responds_to_valid_get(self):
        """Test that server responds to a valid GET request."""
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
        response = send_raw_request(request)

        assert b"HTTP/1.1" in response, "Server should return HTTP response"
        # Accept any valid HTTP response (200, 403, 404, etc.)
        assert any(status in response for status in [b"200", b"301", b"302", b"403", b"404"]), \
            "Server should return a valid HTTP status code"

    def test_server_handles_post_request(self):
        """Test that server handles POST requests correctly."""
        body = b"test=data&foo=bar"
        request = (
            b"POST / HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Content-Type: application/x-www-form-urlencoded\r\n"
            b"Content-Length: " + str(len(body)).encode() + b"\r\n"
            b"Connection: close\r\n"
            b"\r\n" + body
        )
        response = send_raw_request(request)

        assert b"HTTP/1.1" in response, "Server should return HTTP response for POST"

    def test_server_returns_headers(self):
        """Test that server returns proper HTTP headers."""
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
        response = send_raw_request(request)
        response_str = response.decode('utf-8', errors='replace')

        # Should have header section ending with double CRLF
        assert "\r\n\r\n" in response_str or "\n\n" in response_str, \
            "Response should have header/body separator"


class TestModSecurityEnabled:
    """Tests to verify ModSecurity is active and processing requests."""

    def test_modsecurity_processes_request(self):
        """Test that ModSecurity is processing requests (doesn't block normal traffic)."""
        request = b"GET /index.html HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
        response = send_raw_request(request)

        # A normal request should not be blocked
        assert b"HTTP/1.1" in response, "ModSecurity should allow normal requests"
        # Should not get 500 error (which would indicate ModSecurity misconfiguration)
        assert b"500 Internal Server Error" not in response, \
            "Server should not return 500 for normal requests"

    def test_modsecurity_handles_body(self):
        """Test that ModSecurity properly inspects request bodies."""
        body = b"username=testuser&password=testpass"
        request = (
            b"POST /login HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Content-Type: application/x-www-form-urlencoded\r\n"
            b"Content-Length: " + str(len(body)).encode() + b"\r\n"
            b"Connection: close\r\n"
            b"\r\n" + body
        )
        response = send_raw_request(request)

        # Request should be processed (not 500)
        assert b"HTTP/1.1" in response
        assert b"500 Internal Server Error" not in response


class TestValidChunkedEncoding:
    """Test that valid chunked encoding still works correctly."""

    def test_valid_chunked_request(self):
        """Test that properly formatted chunked requests work."""
        # Valid chunked encoding: chunk-size (hex) + CRLF + data + CRLF, ending with 0 CRLF CRLF
        request = (
            b"POST / HTTP/1.1\r\n"
            b"Host: localhost\r\n"
            b"Transfer-Encoding: chunked\r\n"
            b"Content-Type: text/plain\r\n"
            b"Connection: close\r\n"
            b"\r\n"
            b"5\r\n"
            b"hello\r\n"
            b"0\r\n"
            b"\r\n"
        )
        response = send_raw_request(request)

        assert b"HTTP/1.1" in response, "Server should respond to valid chunked request"
        # Should get either success or method not allowed - not internal error
        assert b"500 Internal Server Error" not in response, \
            "Valid chunked request should not cause server error"


class TestConnectionHandling:
    """Test connection handling behavior."""

    def test_connection_close_honored(self):
        """Test that Connection: close is honored."""
        request = b"GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
        response = send_raw_request(request, timeout=5)

        # Response should complete and connection should close
        assert len(response) > 0, "Should receive response before connection closes"

    def test_multiple_sequential_requests(self):
        """Test that multiple sequential requests work correctly."""
        for i in range(3):
            request = b"GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n"
            response = send_raw_request(request)

            assert b"HTTP/1.1" in response, f"Request {i+1} should receive valid response"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
