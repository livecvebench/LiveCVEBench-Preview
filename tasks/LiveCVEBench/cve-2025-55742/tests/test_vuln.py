"""
Vulnerability tests for UnoPim SVG MIME/extension bypass.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""

import pytest
import requests
import os
import io
import time
import re
import base64


BASE_URL = os.environ.get("APP_URL", "http://localhost:8000")
ADMIN_EMAIL = os.environ.get("ADMIN_EMAIL", "admin@example.com")
ADMIN_PASSWORD = os.environ.get("ADMIN_PASSWORD", "admin123")


class TestSession:
    """Helper class to manage authenticated sessions"""

    def __init__(self):
        self.session = requests.Session()
        self.csrf_token = None
        self._logged_in = False

    def get_csrf_token(self):
        """Get CSRF token from login page"""
        response = self.session.get(f"{BASE_URL}/admin/login", timeout=30)
        assert response.status_code == 200, f"Failed to get login page: {response.status_code}"

        # Extract CSRF token from the page
        match = re.search(r'name="csrf-token"\s+content="([^"]+)"', response.text)
        if match:
            self.csrf_token = match.group(1)
        else:
            # Try alternative patterns
            match = re.search(r'name="_token"\s+value="([^"]+)"', response.text)
            if match:
                self.csrf_token = match.group(1)
            else:
                match = re.search(r'"csrfToken":\s*"([^"]+)"', response.text)
                if match:
                    self.csrf_token = match.group(1)

        return self.csrf_token

    def login(self):
        """Authenticate with the admin panel"""
        if self._logged_in:
            return True

        self.get_csrf_token()

        login_data = {
            "_token": self.csrf_token,
            "email": ADMIN_EMAIL,
            "password": ADMIN_PASSWORD,
        }

        response = self.session.post(
            f"{BASE_URL}/admin/login",
            data=login_data,
            allow_redirects=True,
            timeout=30
        )

        if response.status_code == 200:
            self._logged_in = True
            self.get_csrf_token()
            return True

        return False

    def upload_user_image(self, file_content, filename, mime_type=None):
        """
        Upload a file as user profile image.
        Returns the response from the server.
        """
        if not self._logged_in:
            self.login()

        self.get_csrf_token()

        # First get the users page to ensure session is active
        self.session.get(f"{BASE_URL}/admin/settings/users", timeout=30)

        # Prepare user data with required fields
        user_data = {
            "name": "Test Vuln User",
            "email": f"vuln_test_{int(time.time())}@example.com",
            "password": "password123",
            "password_confirmation": "password123",
            "status": "1",
            "timezone": "UTC",
            "role_id": "1",
            "ui_locale_id": "1",
        }

        files = {
            "image[]": (filename, io.BytesIO(file_content), mime_type or "application/octet-stream")
        }

        headers = {
            "X-CSRF-TOKEN": self.csrf_token,
            "Accept": "application/json",
            "X-Requested-With": "XMLHttpRequest",
        }

        response = self.session.post(
            f"{BASE_URL}/admin/settings/users/create",
            data=user_data,
            files=files,
            headers=headers,
            timeout=30
        )

        return response


@pytest.fixture(scope="module")
def auth_session():
    """Fixture to provide authenticated session"""
    session = TestSession()
    max_retries = 5

    for attempt in range(max_retries):
        try:
            if session.login():
                return session
        except requests.exceptions.ConnectionError:
            if attempt < max_retries - 1:
                time.sleep(5)
                continue
            raise

    pytest.skip("Could not authenticate with admin panel")


def create_svg_with_gif_magic_bytes(payload_type="basic"):
    """
    Create a malicious SVG file with GIF89a magic bytes prepended.
    This bypasses MIME type detection which uses magic bytes.
    """
    svg_templates = {
        "basic": '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200" onload="alert(document.cookie)">
  <rect width="200" height="200" fill="#3498db"/>
</svg>''',
        "onerror": '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
  <image href="x" onerror="alert('xss')"/>
</svg>''',
        "script": '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
  <script type="text/javascript">alert('xss')</script>
  <rect width="100" height="100" fill="red"/>
</svg>''',
        "event_handler": '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
  <rect width="100" height="100" fill="blue" onclick="alert('xss')"/>
</svg>''',
        "animate": '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
  <set attributeName="onmouseover" to="alert('xss')"/>
  <rect width="100" height="100" fill="green"/>
</svg>''',
    }

    svg_content = svg_templates.get(payload_type, svg_templates["basic"])

    # Prepend GIF89a magic bytes to bypass MIME detection
    # MIME type detection sees GIF89a -> returns "image/gif"
    # Browser sees .svg extension -> renders as SVG
    malicious_content = b"GIF89a\n" + svg_content.encode('utf-8')

    return malicious_content


def create_svg_with_png_magic_bytes():
    """
    Create SVG with PNG magic bytes prepended.
    Another bypass technique using different magic bytes.
    """
    svg_content = '''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" onload="alert('xss')">
  <rect width="100" height="100" fill="#e74c3c"/>
</svg>'''

    # PNG magic bytes
    png_magic = bytes([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])
    malicious_content = png_magic + b"\n" + svg_content.encode('utf-8')

    return malicious_content


def create_gif_with_svg_extension():
    """
    Create a real GIF file but save with .svg extension.
    Tests extension/content mismatch validation.
    """
    # Minimal valid GIF
    gif_bytes = base64.b64decode(
        "R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
    )
    return gif_bytes


def create_png_with_svg_extension():
    """
    Create a real PNG file but intended to be saved with .svg extension.
    Tests extension/content mismatch validation.
    """
    png_bytes = base64.b64decode(
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="
    )
    return png_bytes


def create_jpeg_with_svg_extension():
    """
    Create a real JPEG file but intended to be saved with .svg extension.
    Tests extension/content mismatch validation.
    """
    jpeg_bytes = base64.b64decode(
        "/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0a"
        "HBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIy"
        "MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAAEDASIA"
        "AhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEB"
        "AQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCwAB//2Q=="
    )
    return jpeg_bytes


def is_upload_rejected_for_mime_mismatch(response):
    """
    Check if the upload was rejected specifically for MIME/extension mismatch.
    Returns True if rejected for the right reason, False otherwise.
    """
    if response.status_code == 422:
        try:
            response_text = response.text.lower()
            # Check for mime/extension mismatch error message
            if "mime" in response_text and "extension" in response_text:
                return True
            if "file extension and mime type do not match" in response_text:
                return True
            if "mismatch" in response_text:
                return True
        except:
            pass
    return False


def is_upload_successful(response):
    """
    Check if the upload was successful (vulnerability exists).
    """
    if response.status_code in [200, 201]:
        try:
            json_response = response.json()
            if "message" in json_response and "success" in json_response.get("message", "").lower():
                return True
            if "error" not in str(json_response).lower():
                return True
        except:
            pass
        # Check if response body indicates success
        if "success" in response.text.lower():
            return True
    return False


class TestMIMEExtensionBypass:
    """
    Test that MIME/extension mismatch files are properly rejected.

    In vulnerable version: These uploads succeed (FAIL)
    In fixed version: These uploads are rejected with validation error (PASS)
    """

    def test_svg_with_gif_magic_bytes_basic(self, auth_session):
        """
        Test uploading SVG with GIF89a magic bytes prepended.
        Primary attack vector: file extension is .svg but MIME detected as image/gif.
        """
        malicious_content = create_svg_with_gif_magic_bytes("basic")
        response = auth_session.upload_user_image(
            malicious_content,
            "malicious.svg",
            "image/svg+xml"
        )

        # In fixed version, this should be rejected
        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of SVG with GIF magic bytes should be rejected. "
            f"Status: {response.status_code}, Response: {response.text[:500]}"
        )

    def test_svg_with_gif_magic_bytes_onerror(self, auth_session):
        """
        Test SVG with onerror event handler and GIF magic bytes.
        """
        malicious_content = create_svg_with_gif_magic_bytes("onerror")
        response = auth_session.upload_user_image(
            malicious_content,
            "image_onerror.svg",
            "image/svg+xml"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of SVG with GIF magic bytes (onerror payload) should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_svg_with_gif_magic_bytes_script(self, auth_session):
        """
        Test SVG with embedded script tag and GIF magic bytes.
        """
        malicious_content = create_svg_with_gif_magic_bytes("script")
        response = auth_session.upload_user_image(
            malicious_content,
            "scripted.svg",
            "image/svg+xml"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of SVG with GIF magic bytes (script tag) should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_svg_with_gif_magic_bytes_event_handler(self, auth_session):
        """
        Test SVG with onclick event handler and GIF magic bytes.
        """
        malicious_content = create_svg_with_gif_magic_bytes("event_handler")
        response = auth_session.upload_user_image(
            malicious_content,
            "clickable.svg",
            "image/svg+xml"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of SVG with GIF magic bytes (onclick) should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_svg_with_png_magic_bytes(self, auth_session):
        """
        Test uploading SVG with PNG magic bytes prepended.
        Alternative bypass: MIME detected as image/png.
        """
        malicious_content = create_svg_with_png_magic_bytes()
        response = auth_session.upload_user_image(
            malicious_content,
            "disguised_png.svg",
            "image/svg+xml"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of SVG with PNG magic bytes should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_gif_content_with_svg_extension(self, auth_session):
        """
        Test uploading real GIF content with .svg extension.
        The file is a valid GIF but named as .svg.
        """
        gif_content = create_gif_with_svg_extension()
        response = auth_session.upload_user_image(
            gif_content,
            "fake.svg",
            "image/gif"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of GIF content with .svg extension should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_png_content_with_svg_extension(self, auth_session):
        """
        Test uploading real PNG content with .svg extension.
        """
        png_content = create_png_with_svg_extension()
        response = auth_session.upload_user_image(
            png_content,
            "disguised.svg",
            "image/png"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of PNG content with .svg extension should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_jpeg_content_with_svg_extension(self, auth_session):
        """
        Test uploading real JPEG content with .svg extension.
        """
        jpeg_content = create_jpeg_with_svg_extension()
        response = auth_session.upload_user_image(
            jpeg_content,
            "photo.svg",
            "image/jpeg"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of JPEG content with .svg extension should be rejected. "
            f"Status: {response.status_code}"
        )


class TestAlternativeExtensions:
    """
    Test MIME/extension mismatch with various other extension combinations.
    """

    def test_gif_content_with_png_extension(self, auth_session):
        """
        Test uploading GIF content with .png extension.
        """
        gif_content = create_gif_with_svg_extension()
        response = auth_session.upload_user_image(
            gif_content,
            "fake.png",
            "image/gif"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of GIF content with .png extension should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_png_content_with_gif_extension(self, auth_session):
        """
        Test uploading PNG content with .gif extension.
        """
        png_content = create_png_with_svg_extension()
        response = auth_session.upload_user_image(
            png_content,
            "fake.gif",
            "image/png"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload of PNG content with .gif extension should be rejected. "
            f"Status: {response.status_code}"
        )

    def test_svg_with_gif_magic_uppercase_extension(self, auth_session):
        """
        Test with uppercase .SVG extension.
        """
        malicious_content = create_svg_with_gif_magic_bytes("basic")
        response = auth_session.upload_user_image(
            malicious_content,
            "MALICIOUS.SVG",
            "image/svg+xml"
        )

        # Should still be rejected regardless of case
        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload with uppercase .SVG extension should be rejected. "
            f"Status: {response.status_code}"
        )


class TestMixedCaseSensitivity:
    """
    Test that validation handles various case permutations.
    """

    def test_mixed_case_svg_extension(self, auth_session):
        """
        Test with mixed case .SvG extension.
        """
        malicious_content = create_svg_with_gif_magic_bytes("basic")
        response = auth_session.upload_user_image(
            malicious_content,
            "file.SvG",
            "image/svg+xml"
        )

        assert is_upload_rejected_for_mime_mismatch(response), (
            f"Upload with mixed case extension should be rejected. "
            f"Status: {response.status_code}"
        )
