"""
Vulnerability tests for pyLoad's add_package endpoint.
These tests verify that path traversal in filenames allows writing files
outside the intended storage directory.

Test behavior:
- FAIL on vulnerable version (path traversal succeeds, files written outside storage)
- PASS on fixed version (path traversal blocked, files stay in storage folder)

Note: pyLoad prepends 'tmp_' to uploaded filenames, so we need sufficient ../
sequences to escape from /tmp/pyload-downloads/tmp_../../../...
"""
import pytest
import requests
import os
import time
import uuid
from io import BytesIO

BASE_URL = os.environ.get("PYLOAD_URL", "http://localhost:8000")
TIMEOUT = 30


@pytest.fixture(scope="module")
def wait_for_service():
    """Wait for pyLoad service to be ready"""
    for i in range(TIMEOUT):
        try:
            response = requests.get(f"{BASE_URL}/api/login", timeout=5)
            # 401 (Unauthorized) means service is up but requires auth
            if response.status_code in (200, 401, 404, 405):
                time.sleep(2)
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(1)
    pytest.fail(f"pyLoad service not available at {BASE_URL} after {TIMEOUT} seconds")


@pytest.fixture
def authenticated_session(wait_for_service):
    """Create an authenticated session"""
    session = requests.Session()
    response = session.post(
        f"{BASE_URL}/api/login",
        data={"username": "pyload", "password": "pyload"},
        timeout=10
    )
    assert response.status_code == 200, f"Login failed: {response.text}"
    return session


def cleanup_test_files(paths):
    """Remove test files that might have been created"""
    for path in paths:
        try:
            if os.path.exists(path):
                os.remove(path)
        except (OSError, PermissionError):
            pass


class TestPathTraversal:
    """Test path traversal vulnerability - all tests should FAIL on vulnerable version"""

    def test_traversal_to_tmp(self, authenticated_session):
        """
        Test path traversal to write file to /tmp directory.

        Vulnerable: File created at /tmp/traversal_test_XXX.txt
        Fixed: File stays in storage folder as sanitized filename
        """
        test_id = uuid.uuid4().hex[:8]
        target_file = f"/tmp/traversal_test_{test_id}.txt"
        # Need enough ../ to escape: storage is /tmp/pyload-downloads, with tmp_ prefix
        malicious_filename = f"../../../../../../../tmp/traversal_test_{test_id}.txt"
        marker_content = f"PATH_TRAVERSAL_{test_id}"

        cleanup_test_files([target_file])

        files = {'add_file': (malicious_filename, BytesIO(marker_content.encode()), 'text/plain')}
        data = {
            'add_name': 'TraversalTest',
            'add_dest': '1',
            'add_links': '',
            'add_password': ''
        }

        response = authenticated_session.post(
            f"{BASE_URL}/json/add_package",
            files=files,
            data=data,
            timeout=10
        )
        assert response.status_code == 200

        time.sleep(0.5)

        file_exists = os.path.exists(target_file)
        cleanup_test_files([target_file])

        assert not file_exists, \
            f"Path traversal vulnerability! File was written to {target_file}"

    def test_deep_traversal(self, authenticated_session):
        """
        Test deep directory traversal with many ../ sequences.
        """
        test_id = uuid.uuid4().hex[:8]
        target_file = f"/tmp/deep_traversal_{test_id}.txt"
        malicious_filename = f"../../../../../../../../../../tmp/deep_traversal_{test_id}.txt"
        marker_content = f"DEEP_TRAVERSAL_{test_id}"

        cleanup_test_files([target_file])

        files = {'add_file': (malicious_filename, BytesIO(marker_content.encode()), 'text/plain')}
        data = {
            'add_name': 'DeepTraversalTest',
            'add_dest': '1',
            'add_links': '',
            'add_password': ''
        }

        response = authenticated_session.post(
            f"{BASE_URL}/json/add_package",
            files=files,
            data=data,
            timeout=10
        )
        assert response.status_code == 200

        time.sleep(0.5)

        file_exists = os.path.exists(target_file)
        cleanup_test_files([target_file])

        assert not file_exists, \
            f"Deep path traversal vulnerability! File was written to {target_file}"

    def test_traversal_write_shell_script(self, authenticated_session):
        """
        Test that malicious shell script can be written outside storage.
        """
        test_id = uuid.uuid4().hex[:8]
        target_file = f"/tmp/malicious_{test_id}.sh"
        malicious_filename = f"../../../../../../../tmp/malicious_{test_id}.sh"
        malicious_content = b"#!/bin/bash\necho 'Exploited!'\n"

        cleanup_test_files([target_file])

        files = {'add_file': (malicious_filename, BytesIO(malicious_content), 'application/x-sh')}
        data = {'add_name': 'ShellTest', 'add_dest': '1', 'add_links': '', 'add_password': ''}

        response = authenticated_session.post(
            f"{BASE_URL}/json/add_package",
            files=files,
            data=data,
            timeout=10
        )
        assert response.status_code == 200

        time.sleep(0.5)

        file_exists = os.path.exists(target_file)
        cleanup_test_files([target_file])

        assert not file_exists, \
            f"Shell script traversal vulnerability! File was written to {target_file}"

    def test_traversal_to_var_tmp(self, authenticated_session):
        """
        Test that files can be written to /var/tmp directory via traversal.
        """
        test_id = uuid.uuid4().hex[:8]
        target_file = f"/var/tmp/traversal_test_{test_id}.txt"
        malicious_filename = f"../../../../../../../var/tmp/traversal_test_{test_id}.txt"

        cleanup_test_files([target_file])

        files = {'add_file': (malicious_filename, BytesIO(f"VARTMP_{test_id}".encode()), 'text/plain')}
        data = {'add_name': 'VarTmpTest', 'add_dest': '1', 'add_links': '', 'add_password': ''}

        response = authenticated_session.post(
            f"{BASE_URL}/json/add_package",
            files=files,
            data=data,
            timeout=10
        )
        assert response.status_code == 200

        time.sleep(0.5)

        file_exists = os.path.exists(target_file)
        cleanup_test_files([target_file])

        assert not file_exists, \
            f"Var/tmp traversal vulnerability! File was written to {target_file}"

    def test_traversal_cron_payload(self, authenticated_session):
        """
        Test that cron-style payload file can be written via traversal.
        """
        test_id = uuid.uuid4().hex[:8]
        target_file = f"/tmp/cron_test_{test_id}"
        malicious_filename = f"../../../../../../../tmp/cron_test_{test_id}"
        cron_content = b"* * * * * root /bin/echo 'pwned'\n"

        cleanup_test_files([target_file])

        files = {'add_file': (malicious_filename, BytesIO(cron_content), 'text/plain')}
        data = {'add_name': 'CronTest', 'add_dest': '1', 'add_links': '', 'add_password': ''}

        response = authenticated_session.post(
            f"{BASE_URL}/json/add_package",
            files=files,
            data=data,
            timeout=10
        )
        assert response.status_code == 200

        time.sleep(0.5)

        file_exists = os.path.exists(target_file)
        cleanup_test_files([target_file])

        assert not file_exists, \
            f"Cron traversal vulnerability! File was written to {target_file}"
