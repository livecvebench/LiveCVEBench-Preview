#!/bin/bash
#
# Solution script for ModSecurity error handling vulnerability (CVE-2025-54571)
#
# This script patches the error handling in ModSecurity's request body processing
# to properly handle all error codes returned by read_request_body().
#
set -e

echo "=== Applying ModSecurity error handling fix ==="

# Determine ModSecurity source location
# Common locations to check
MODSEC_DIRS=(
    "/app"
    "/app/modsecurity"
    "/app/ModSecurity"
    "/usr/src/modsecurity"
    "/usr/src/ModSecurity"
    "/opt/modsecurity"
    "/var/www/modsecurity"
)

MODSEC_DIR=""
for dir in "${MODSEC_DIRS[@]}"; do
    if [ -f "$dir/apache2/mod_security2.c" ]; then
        MODSEC_DIR="$dir"
        break
    fi
done

if [ -z "$MODSEC_DIR" ]; then
    # Try to find it
    MODSEC_DIR=$(find /app /usr/src /opt -name "mod_security2.c" -path "*/apache2/*" 2>/dev/null | head -1 | xargs dirname 2>/dev/null | xargs dirname 2>/dev/null || true)
fi

if [ -z "$MODSEC_DIR" ] || [ ! -d "$MODSEC_DIR" ]; then
    echo "ERROR: Cannot find ModSecurity source directory"
    echo "Checked: ${MODSEC_DIRS[*]}"
    exit 1
fi

echo "Found ModSecurity source at: $MODSEC_DIR"

cd "$MODSEC_DIR"


if [ -f "$PATCH_FILE" ]; then
    echo "Applying patch from: $PATCH_FILE"
    patch -p1 --forward < "$PATCH_FILE" || {
        echo "Patch may have already been applied, continuing..."
    }
else
    echo "Patch file not found, applying changes manually..."

    # =========================================================================
    # Fix apache2/apache2_io.c
    # =========================================================================
    echo "Patching apache2/apache2_io.c..."

    IO_FILE="apache2/apache2_io.c"

    if [ ! -f "$IO_FILE" ]; then
        echo "ERROR: $IO_FILE not found"
        exit 1
    fi

    # Replace 'return 0;' with 'return APR_SUCCESS;' in read_request_body
    sed -i 's/return 0;/return APR_SUCCESS;/g' "$IO_FILE"

    # Replace 'return -1;' with 'return HTTP_INTERNAL_SERVER_ERROR;'
    sed -i 's/return -1;/return HTTP_INTERNAL_SERVER_ERROR;/g' "$IO_FILE"

    # Replace 'return -5;' with 'return HTTP_REQUEST_ENTITY_TOO_LARGE;'
    sed -i 's/return -5;/return HTTP_REQUEST_ENTITY_TOO_LARGE;/g' "$IO_FILE"

    # Fix the switch statement for ap_get_brigade errors
    # Replace the entire error switch with unified handling using ap_map_http_request_error
    # This is complex with sed, so we use a more targeted approach

    # Replace the -3 return with proper handling
    sed -i 's/return -3;/return ap_map_http_request_error(rc, HTTP_BAD_REQUEST);/g' "$IO_FILE"

    # Replace -2, -4, -6, -7 returns
    sed -i 's/return -2;/return ap_map_http_request_error(rc, HTTP_BAD_REQUEST);/g' "$IO_FILE"
    sed -i 's/return -4;/return ap_map_http_request_error(rc, HTTP_BAD_REQUEST);/g' "$IO_FILE"
    sed -i 's/return -6;/return ap_map_http_request_error(rc, HTTP_BAD_REQUEST);/g' "$IO_FILE"
    sed -i 's/return -7;/return ap_map_http_request_error(rc, HTTP_BAD_REQUEST);/g' "$IO_FILE"

    # Fix the rcbe return at end of function
    sed -i 's/return rcbe;/if (rcbe == -5) { return HTTP_REQUEST_ENTITY_TOO_LARGE; } if (rcbe < 0) { return HTTP_INTERNAL_SERVER_ERROR; } return APR_SUCCESS;/g' "$IO_FILE"

    # =========================================================================
    # Fix apache2/mod_security2.c
    # =========================================================================
    echo "Patching apache2/mod_security2.c..."

    MOD_FILE="apache2/mod_security2.c"

    if [ ! -f "$MOD_FILE" ]; then
        echo "ERROR: $MOD_FILE not found"
        exit 1
    fi

    # Create a temporary file with the fixed code
    # We need to replace the switch statement with proper error handling

    # Use awk to do a more precise replacement
    awk '
    /rc = read_request_body\(msr, &my_error_msg\);/ {
        print $0
        # Skip until we find the closing of the old error handling block
        in_block = 1
        brace_count = 0
        while ((getline line) > 0) {
            if (in_block && line ~ /if \(rc < 0 && msr->txcfg->is_enabled == MODSEC_ENABLED\)/) {
                # Found the start of the old block, skip it
                brace_count = 1
                while (brace_count > 0 && (getline line) > 0) {
                    if (line ~ /{/) brace_count++
                    if (line ~ /}/) brace_count--
                }
                # Print the new error handling
                print "    if (rc != OK) {"
                print "        if (my_error_msg != NULL) {"
                print "            msr_log(msr, 1, \"%s\", my_error_msg);"
                print "        }"
                print "        if (rc == HTTP_REQUEST_ENTITY_TOO_LARGE) {"
                print "            msr->inbound_error = 1;"
                print "        }"
                print "        r->connection->keepalive = AP_CONN_CLOSE;"
                print "        return rc;"
                print "    }"
                in_block = 0
            } else if (!in_block) {
                print line
                break
            }
        }
        next
    }
    { print }
    ' "$MOD_FILE" > "${MOD_FILE}.new"

    # If awk produced valid output, use it
    if [ -s "${MOD_FILE}.new" ]; then
        mv "${MOD_FILE}.new" "$MOD_FILE"
    else
        rm -f "${MOD_FILE}.new"
        echo "WARNING: awk replacement may not have worked, using sed fallback"

        # Fallback: Use sed to at least add the -3 case to the switch
        # Add case -3 handling before the default case
        sed -i '/default :/i\            case -3 : /* AP_FILTER_ERROR */\n                if (my_error_msg != NULL) {\n                    msr_log(msr, 1, "%s", my_error_msg);\n                }\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_BAD_REQUEST;\n                break;' "$MOD_FILE"
    fi
fi

echo "Source files patched."

# =========================================================================
# Rebuild ModSecurity
# =========================================================================
echo ""
echo "=== Rebuilding ModSecurity ==="

# Check if we need to rebuild
if [ -f "Makefile" ]; then
    echo "Running make..."
    make clean 2>/dev/null || true
    make -j$(nproc) 2>&1 || {
        echo "Make failed, trying autoreconf first..."
        autoreconf -fiv 2>/dev/null || true
        ./configure --with-apxs=/usr/bin/apxs 2>&1 || ./configure 2>&1
        make -j$(nproc) 2>&1
    }

    echo "Installing module..."
    make install 2>&1

elif [ -f "configure" ]; then
    echo "Running configure and make..."
    ./configure --with-apxs=/usr/bin/apxs 2>&1 || ./configure 2>&1
    make -j$(nproc) 2>&1
    make install 2>&1
else
    echo "WARNING: No Makefile or configure script found. Module may need manual rebuild."
fi

# =========================================================================
# Restart Apache to load the fixed module
# =========================================================================
echo ""
echo "=== Restarting Apache ==="

# Stop Apache gracefully
if command -v apachectl &> /dev/null; then
    apachectl graceful 2>/dev/null || apachectl restart 2>/dev/null || true
elif command -v apache2ctl &> /dev/null; then
    apache2ctl graceful 2>/dev/null || apache2ctl restart 2>/dev/null || true
else
    # Try to restart using systemctl or service
    systemctl restart apache2 2>/dev/null || \
    systemctl restart httpd 2>/dev/null || \
    service apache2 restart 2>/dev/null || \
    service httpd restart 2>/dev/null || \
    {
        # Last resort: kill and let supervisor restart
        pkill -f "apache2|httpd" 2>/dev/null || true
        sleep 2
    }
fi

# Wait for Apache to come back up
echo "Waiting for Apache to restart..."
max_wait=30
waited=0
while ! nc -z localhost 80 2>/dev/null; do
    sleep 1
    waited=$((waited + 1))
    if [ $waited -ge $max_wait ]; then
        echo "WARNING: Apache may not have restarted properly"
        break
    fi
done

echo ""
echo "=== Fix applied successfully ==="
echo "ModSecurity error handling has been patched to properly handle all error codes."
