"""
Vulnerability tests for the Null Pathname DoS issue (CVE-2025-58047).

These tests verify whether the vulnerability is present or fixed:
- FAIL in vulnerable state (malformed URLs with @ symbol cause server crash)
- PASS in fixed state (malformed URLs are handled gracefully)

The vulnerability is triggered by URLs containing //:...@... pattern which causes
url.parse() to return null for pathname, crashing the server when .startsWith() is called.
"""

import http.client
import time
import pytest
import socket

BASE_HOST = "localhost"
BASE_PORT = 3000
TIMEOUT = 10


def wait_for_server_ready(max_wait=120, interval=2):
    """Wait for server to become ready using raw HTTP."""
    elapsed = 0
    while elapsed < max_wait:
        try:
            conn = http.client.HTTPConnection(BASE_HOST, BASE_PORT, timeout=5)
            conn.request('GET', '/')
            response = conn.getresponse()
            conn.close()
            if response.status:
                return True
        except Exception:
            pass
        time.sleep(interval)
        elapsed += interval
    return False


def send_malformed_request(url_path):
    """
    Send a malformed request using raw http.client to avoid URL processing.

    Returns:
        dict with 'success' (bool) and either 'status' or 'error'
    """
    try:
        conn = http.client.HTTPConnection(BASE_HOST, BASE_PORT, timeout=TIMEOUT)
        conn.request('GET', url_path)
        response = conn.getresponse()
        status = response.status
        conn.close()
        # Got a valid HTTP response - server handled it gracefully
        return {"success": True, "status": status}
    except http.client.RemoteDisconnected:
        # Server crashed - connection closed without response
        return {"success": False, "error": "RemoteDisconnected"}
    except ConnectionResetError:
        # Server crashed - connection reset
        return {"success": False, "error": "ConnectionReset"}
    except ConnectionRefusedError:
        # Server is down
        return {"success": False, "error": "ConnectionRefused"}
    except socket.timeout:
        # Timeout - server may be slow but not crashed
        return {"success": True, "status": 0}
    except Exception as e:
        return {"success": False, "error": str(e)}


class TestNullPathnameVulnerability:
    """
    Test suite for the null pathname vulnerability.

    The vulnerability occurs when malformed URLs with //:...@... pattern cause
    the URL parser to return null for the pathname, which then crashes the server
    when .startsWith() is called on null.

    These tests PASS when the server handles the malformed URL gracefully (fixed state).
    These tests FAIL when the server crashes from the malformed URL (vulnerable state).
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is running before test."""
        assert wait_for_server_ready(max_wait=120), \
            "Server not ready - cannot run vulnerability tests"

    def test_double_slash_with_auth_pattern(self):
        """
        Test with //:user@host pattern - the primary attack vector.

        This URL pattern causes url.parse() to interpret the URL as a protocol-relative
        URL with credentials, resulting in a null pathname which crashes the vulnerable server.
        """
        result = send_malformed_request("//:test@example.com")
        assert result["success"], \
            f"Server crashed after malformed URL //:test@example.com - vulnerability is present. Error: {result.get('error')}"

    def test_double_slash_with_empty_user_at_localhost(self):
        """
        Test with //:@localhost pattern - empty credentials still triggers the bug.
        """
        result = send_malformed_request("//:@localhost")
        assert result["success"], \
            f"Server crashed after //:@localhost - vulnerability is present. Error: {result.get('error')}"

    def test_double_slash_with_user_pass_at_host(self):
        """
        Test with //user:pass@host.com pattern - full credentials format.
        """
        result = send_malformed_request("//user:pass@host.com")
        assert result["success"], \
            f"Server crashed after //user:pass@host.com - vulnerability is present. Error: {result.get('error')}"

    def test_double_slash_admin_internal(self):
        """
        Test with //:admin@internal pattern.
        """
        result = send_malformed_request("//:admin@internal")
        assert result["success"], \
            f"Server crashed after //:admin@internal - vulnerability is present. Error: {result.get('error')}"

    def test_double_slash_complex_credentials(self):
        """
        Test with //:x:y@attacker.com pattern - complex credentials.
        """
        result = send_malformed_request("//:x:y@attacker.com")
        assert result["success"], \
            f"Server crashed after //:x:y@attacker.com - vulnerability is present. Error: {result.get('error')}"

    def test_double_slash_admin_password_port(self):
        """
        Test with //admin:password@localhost:8080 pattern - full URL with port.
        """
        result = send_malformed_request("//admin:password@localhost:8080")
        assert result["success"], \
            f"Server crashed after //admin:password@localhost:8080 - vulnerability is present. Error: {result.get('error')}"

    def test_rapid_fire_attack(self):
        """
        Test rapid succession of malformed requests with @ symbol.
        All requests should be handled without crashing.
        """
        crashed_count = 0
        for i in range(5):
            wait_for_server_ready(max_wait=10)
            result = send_malformed_request(f"//:test{i}@attacker.com")
            if not result["success"]:
                crashed_count += 1

        assert crashed_count == 0, \
            f"Server crashed {crashed_count} times under rapid malformed request attack - vulnerability is present"

    def test_server_stability_after_attack(self):
        """
        Comprehensive test: send attack, verify server handles it gracefully.
        """
        wait_for_server_ready(max_wait=30)
        result = send_malformed_request("//:test@example.com")

        assert result["success"], \
            f"Server crashed on malformed URL - vulnerability is present. Error: {result.get('error')}"

        # Immediately check if server is still responding (no restart needed)
        result2 = send_malformed_request("/")
        assert result2["success"], \
            "Server not responding immediately after handling malformed URL"
