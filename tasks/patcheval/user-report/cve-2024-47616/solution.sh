cat <<'EOF' > fix.patch
diff --git a/pkg/grpcutil/options.go b/pkg/grpcutil/options.go
index d3329251e0b..5e1a4255b57 100644
--- a/pkg/grpcutil/options.go
+++ b/pkg/grpcutil/options.go
@@ -3,10 +3,12 @@ package grpcutil
 import (
 	"context"
 	"encoding/base64"
+	"fmt"
 	"time"
 
 	"github.com/go-jose/go-jose/v3"
 	"github.com/go-jose/go-jose/v3/jwt"
+	"github.com/pomerium/pomerium/internal/log"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
@@ -92,22 +94,30 @@ func RequireSignedJWT(ctx context.Context, key []byte) error {
 			return status.Error(codes.Unauthenticated, "unauthenticated")
 		}
 
-		tok, err := jwt.ParseSigned(rawjwt)
-		if err != nil {
-			return status.Errorf(codes.Unauthenticated, "invalid JWT: %v", err)
+		if err := validateJWT(rawjwt, key); err != nil {
+			log.Ctx(ctx).Debug().Err(err).Msg("rejected gRPC request due to invalid JWT")
+			return status.Error(codes.Unauthenticated, "invalid JWT")
 		}
+	}
+	return nil
+}
 
-		var claims struct {
-			Expiry *jwt.NumericDate `json:"exp,omitempty"`
-		}
-		err = tok.Claims(key, &claims)
-		if err != nil {
-			return status.Errorf(codes.Unauthenticated, "invalid JWT: %v", err)
-		}
+func validateJWT(rawjwt string, key []byte) error {
+	tok, err := jwt.ParseSigned(rawjwt)
+	if err != nil {
+		return err
+	}
 
-		if claims.Expiry == nil || time.Now().After(claims.Expiry.Time()) {
-			return status.Errorf(codes.Unauthenticated, "expired JWT: %v", err)
-		}
+	var claims map[string]*jwt.NumericDate
+	err = tok.Claims(key, &claims)
+	if err != nil {
+		return err
+	} else if len(claims) != 1 || claims["exp"] == nil {
+		return fmt.Errorf("expected exactly one claim (exp)")
+	}
+
+	if t := claims["exp"].Time(); time.Now().After(t) {
+		return fmt.Errorf("JWT expired at %s", t.Format(time.DateTime))
 	}
 	return nil
 }


EOF

cd /app/pomerium
git apply --whitespace=nowarn  /app/fix.patch