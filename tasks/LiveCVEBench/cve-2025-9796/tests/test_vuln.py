"""
Vulnerability Tests for EncodeUtils.xssFilter - Data Protocol Bypass

These tests verify that the data: protocol is properly blocked in href and src
attributes. The vulnerability allows attackers to bypass the XSS filter by using
data: protocol URIs which can embed HTML/JavaScript content.

- FAIL in vulnerable state (data: protocol passes through unfiltered)
- PASS in fixed state (data: protocol is blocked like javascript: and vbscript:)
"""

import subprocess
import os
import tempfile
import shutil
import pytest


class TestDataProtocolVulnerability:
    """Test that the data: protocol is properly filtered in href/src attributes"""

    @classmethod
    def setup_class(cls):
        """Set up the test environment - compile the Java test harness"""
        cls.test_dir = tempfile.mkdtemp()
        cls.java_file = os.path.join(cls.test_dir, "DataProtocolVulnTest.java")

        java_code = r'''
import java.util.*;
import java.util.regex.*;
import java.io.*;

public class DataProtocolVulnTest {

    private static List<Pattern> xssPatterns = new ArrayList<>();

    static {
        try {
            loadPatternsFromSource();
        } catch (Exception e) {
            System.err.println("Failed to load patterns: " + e.getMessage());
            loadDefaultPatterns();
        }
    }

    private static void loadPatternsFromSource() throws Exception {
        File file = new File("/app/common/src/main/java/com/jeesite/common/codec/EncodeUtils.java");
        Scanner scanner = new Scanner(file);
        StringBuilder content = new StringBuilder();
        while (scanner.hasNextLine()) {
            content.append(scanner.nextLine()).append("\n");
        }
        scanner.close();

        String src = content.toString();

        // Pattern 1: script/link/style/iframe tags
        xssPatterns.add(Pattern.compile("(<\\s*(script|link|style|iframe)([\\s\\S]*?)(>|</\\s*\\1\\s*>))|(</\\s*(script|link|style|iframe)\\s*>)", Pattern.CASE_INSENSITIVE));

        // Pattern 2: href/src with dangerous protocols - extract from source
        String hrefSrcPattern = extractHrefSrcPattern(src);
        xssPatterns.add(Pattern.compile(hrefSrcPattern, Pattern.CASE_INSENSITIVE));

        // Pattern 3: event handlers
        xssPatterns.add(Pattern.compile("\\s*/?\\s*on[a-zA-Z]+\\s*=\\s*(['\"]?)(.*?)\\1(?=\\s|>|/>)", Pattern.CASE_INSENSITIVE));

        // Pattern 4: eval/expression
        xssPatterns.add(Pattern.compile("(eval\\((.*?)\\)|expression\\((.*?)\\))", Pattern.CASE_INSENSITIVE));

        // Pattern 5: standalone javascript:/vbscript:
        xssPatterns.add(Pattern.compile("^(javascript:|vbscript:)", Pattern.CASE_INSENSITIVE));
    }

    private static String extractHrefSrcPattern(String src) {
        String[] lines = src.split("\n");
        for (String line : lines) {
            if (line.contains("href|src") && line.contains("Pattern.compile")) {
                int compileIdx = line.indexOf("Pattern.compile(\"");
                if (compileIdx >= 0) {
                    int start = compileIdx + "Pattern.compile(\"".length();
                    int end = line.indexOf("\", Pattern");
                    if (end > start) {
                        // Convert Java source escaping to actual regex
                        // In Java source: \\s means regex \s, so we need to unescape
                        String pattern = line.substring(start, end);
                        return pattern.replace("\\\\", "\\");
                    }
                }
            }
        }
        // Default vulnerable pattern (does not include data:)
        return "\\s*(href|src)\\s*=\\s*(\"\\s*(javascript|vbscript):[^\"]+\"|'\\s*(javascript|vbscript):[^']+'|(javascript|vbscript):[^\\s]+)\\s*(?=>)";
    }

    private static void loadDefaultPatterns() {
        xssPatterns.add(Pattern.compile("(<\\s*(script|link|style|iframe)([\\s\\S]*?)(>|</\\s*\\1\\s*>))|(</\\s*(script|link|style|iframe)\\s*>)", Pattern.CASE_INSENSITIVE));
        xssPatterns.add(Pattern.compile("\\s*(href|src)\\s*=\\s*(\"\\s*(javascript|vbscript):[^\"]+\"|'\\s*(javascript|vbscript):[^']+'|(javascript|vbscript):[^\\s]+)\\s*(?=>)", Pattern.CASE_INSENSITIVE));
        xssPatterns.add(Pattern.compile("\\s*/?\\s*on[a-zA-Z]+\\s*=\\s*(['\"]?)(.*?)\\1(?=\\s|>|/>)", Pattern.CASE_INSENSITIVE));
        xssPatterns.add(Pattern.compile("(eval\\((.*?)\\)|expression\\((.*?)\\))", Pattern.CASE_INSENSITIVE));
        xssPatterns.add(Pattern.compile("^(javascript:|vbscript:)", Pattern.CASE_INSENSITIVE));
    }

    public static String xssFilter(String text) {
        if (text == null) return null;

        String value = text.trim();
        for (Pattern pattern : xssPatterns) {
            Matcher matcher = pattern.matcher(value);
            if (matcher.find()) {
                value = matcher.replaceAll("");
            }
        }

        // Character encoding for non-HTML content
        if (!value.toLowerCase().startsWith("<!--html-->")
            && !value.toLowerCase().startsWith("<?xml ")
            && !(value.startsWith("{") && value.endsWith("}"))
            && !(value.startsWith("[") && value.endsWith("]"))) {
            StringBuilder sb = new StringBuilder();
            for (char c : value.toCharArray()) {
                switch (c) {
                    case '>': sb.append('\uff1e'); break;
                    case '<': sb.append('\uff1c'); break;
                    case '\'': sb.append('\uff07'); break;
                    case '"': sb.append('\uff02'); break;
                    default: sb.append(c);
                }
            }
            value = sb.toString();
        }
        return value;
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Usage: java DataProtocolVulnTest <test_name>");
            System.exit(1);
        }

        String testName = args[0];
        String result;

        try {
            switch (testName) {
                case "data_src_base64":
                    // Base64 encoded script in data: URI (original PoC)
                    result = xssFilter("<!--HTML-->XSS<embed src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCg5KTwvc2NyaXB0Pgo=\">");
                    System.out.println(!result.contains("src=\"data:") ? "PASS" : "FAIL:data_src_not_filtered");
                    break;

                case "data_href":
                    // data: protocol in href attribute
                    result = xssFilter("<!--HTML--><a href=\"data:text/html,<script>alert(1)</script>\">click</a>");
                    System.out.println(!result.contains("href=\"data:") ? "PASS" : "FAIL:data_href_not_filtered");
                    break;

                case "data_src_img":
                    // data: protocol in img src
                    result = xssFilter("<!--HTML--><img src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\">");
                    System.out.println(!result.contains("src=\"data:") ? "PASS" : "FAIL:data_img_src_not_filtered");
                    break;

                case "data_uppercase":
                    // Case insensitive - DATA: should also be blocked
                    result = xssFilter("<!--HTML--><embed src=\"DATA:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\">");
                    System.out.println(!result.toLowerCase().contains("src=\"data:") ? "PASS" : "FAIL:DATA_uppercase_not_filtered");
                    break;

                case "data_mixed_case":
                    // Mixed case - DaTa: should also be blocked
                    result = xssFilter("<!--HTML--><a href=\"DaTa:text/html,<script>alert(1)</script>\">click</a>");
                    System.out.println(!result.toLowerCase().contains("href=\"data:") ? "PASS" : "FAIL:DaTa_mixed_not_filtered");
                    break;

                case "data_javascript_content":
                    // data: with javascript content type
                    result = xssFilter("<!--HTML--><embed src=\"data:text/javascript,alert(1)\">");
                    System.out.println(!result.contains("src=\"data:") ? "PASS" : "FAIL:data_js_content_not_filtered");
                    break;

                case "data_single_quote":
                    // data: with single quotes
                    result = xssFilter("<!--HTML--><a href='data:text/html,<script>alert(1)</script>'>click</a>");
                    System.out.println(!result.contains("href='data:") ? "PASS" : "FAIL:data_single_quote_not_filtered");
                    break;

                case "data_charset":
                    // data: with charset specification
                    result = xssFilter("<!--HTML--><embed src=\"data:text/html;charset=utf-8,<script>alert(document.domain)</script>\">");
                    System.out.println(!result.contains("src=\"data:") ? "PASS" : "FAIL:data_charset_not_filtered");
                    break;

                case "data_svg":
                    // data: with SVG content
                    result = xssFilter("<!--HTML--><embed src=\"data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+\">");
                    System.out.println(!result.contains("src=\"data:") ? "PASS" : "FAIL:data_svg_not_filtered");
                    break;

                case "data_no_space":
                    // data: without spaces around equals
                    result = xssFilter("<!--HTML--><embed src=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==>");
                    System.out.println(!result.contains("src=data:") ? "PASS" : "FAIL:data_no_space_not_filtered");
                    break;

                default:
                    System.out.println("FAIL:unknown_test:" + testName);
            }
        } catch (Exception e) {
            System.out.println("FAIL:exception:" + e.getMessage());
            e.printStackTrace(System.err);
        }
    }
}
'''

        with open(cls.java_file, 'w') as f:
            f.write(java_code)

        # Compile the Java test
        result = subprocess.run(
            ['javac', cls.java_file],
            cwd=cls.test_dir,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            raise RuntimeError(f"Failed to compile Java test: {result.stderr}")

    @classmethod
    def teardown_class(cls):
        """Clean up the test environment"""
        shutil.rmtree(cls.test_dir, ignore_errors=True)

    def run_java_test(self, test_type):
        """Run a specific Java test and return (passed, output)"""
        result = subprocess.run(
            ['java', 'DataProtocolVulnTest', test_type],
            cwd=self.test_dir,
            capture_output=True,
            text=True
        )
        output = result.stdout.strip()
        return output.startswith('PASS'), output

    def test_data_src_base64_blocked(self):
        """
        data:text/html;base64,... in src attribute should be blocked.

        This is the original PoC payload that bypasses the XSS filter.
        The base64 content decodes to <script>alert(9)</script>
        """
        passed, output = self.run_java_test('data_src_base64')
        assert passed, f"data: protocol with base64 in src should be blocked: {output}"

    def test_data_href_blocked(self):
        """
        data:text/html,... in href attribute should be blocked.

        Direct HTML content in data: URI can execute scripts.
        """
        passed, output = self.run_java_test('data_href')
        assert passed, f"data: protocol in href should be blocked: {output}"

    def test_data_src_img_blocked(self):
        """
        data: protocol in img src should be blocked.

        While img src=data:image/* is commonly used for inline images,
        data:text/html can still be dangerous.
        """
        passed, output = self.run_java_test('data_src_img')
        assert passed, f"data: protocol in img src should be blocked: {output}"

    def test_data_uppercase_blocked(self):
        """
        DATA: (uppercase) should also be blocked (case insensitive).

        Protocol matching should be case insensitive to prevent bypasses.
        """
        passed, output = self.run_java_test('data_uppercase')
        assert passed, f"DATA: uppercase should be blocked: {output}"

    def test_data_mixed_case_blocked(self):
        """
        DaTa: (mixed case) should also be blocked.

        Mixed case variations should not bypass the filter.
        """
        passed, output = self.run_java_test('data_mixed_case')
        assert passed, f"DaTa: mixed case should be blocked: {output}"

    def test_data_javascript_content_blocked(self):
        """
        data:text/javascript,... should be blocked.

        JavaScript content type in data: URI is especially dangerous.
        """
        passed, output = self.run_java_test('data_javascript_content')
        assert passed, f"data:text/javascript should be blocked: {output}"

    def test_data_single_quote_blocked(self):
        """
        data: with single quotes should be blocked.

        Both single and double quote variants should be handled.
        """
        passed, output = self.run_java_test('data_single_quote')
        assert passed, f"data: with single quotes should be blocked: {output}"

    def test_data_charset_blocked(self):
        """
        data: with charset specification should be blocked.

        Various charset specifications should not bypass the filter.
        """
        passed, output = self.run_java_test('data_charset')
        assert passed, f"data: with charset should be blocked: {output}"

    def test_data_svg_content_blocked(self):
        """
        data:image/svg+xml with embedded script should be blocked.

        SVG files can contain JavaScript via onload handlers.
        """
        passed, output = self.run_java_test('data_svg')
        assert passed, f"data:image/svg+xml should be blocked: {output}"

    def test_data_no_space_blocked(self):
        """
        data: without spaces (src=data:...) should be blocked.

        Compact notation without spaces should also be filtered.
        """
        passed, output = self.run_java_test('data_no_space')
        assert passed, f"data: without spaces should be blocked: {output}"
