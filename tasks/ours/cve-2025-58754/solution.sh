#!/bin/bash
set -e

cd /app

# Part 1: Create the new helper file for estimating data URL decoded size
cat > /app/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js << 'HELPER_EOF'
/**
 * Estimate decoded byte length of a data:// URL *without* allocating large buffers.
 * - For base64: compute exact decoded size using length and padding;
 *               handle %XX at the character-count level (no string allocation).
 * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.
 *
 * @param {string} url
 * @returns {number}
 */
export default function estimateDataURLDecodedBytes(url) {
  if (!url || typeof url !== 'string') return 0;
  if (!url.startsWith('data:')) return 0;

  const comma = url.indexOf(',');
  if (comma < 0) return 0;

  const meta = url.slice(5, comma);
  const body = url.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);

  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length; // cache length

    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex =
          ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) &&
          ((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));

        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }

    let pad = 0;
    let idx = len - 1;

    const tailIsPct3D = (j) =>
      j >= 2 &&
      body.charCodeAt(j - 2) === 37 && // '%'
      body.charCodeAt(j - 1) === 51 && // '3'
      (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'

    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61 /* '=' */) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }

    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61 /* '=' */) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }

    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }

  return Buffer.byteLength(body, 'utf8');
}
HELPER_EOF

# Part 2: Patch http.js to add import and size validation
# Use Node.js for reliable patching since sed can be tricky with complex multi-line edits

node --input-type=module << 'PATCH_EOF'
import fs from 'fs';

const httpPath = '/app/node_modules/axios/lib/adapters/http.js';
let content = fs.readFileSync(httpPath, 'utf8');

// Check if already patched
if (content.includes('estimateDataURLDecodedBytes')) {
    console.log('http.js already patched');
    process.exit(0);
}

// Add import after the progressEventReducer import
const importTarget = 'import {progressEventReducer, progressEventDecorator, asyncDecorator} from "../helpers/progressEventReducer.js";';
const newImport = `${importTarget}\nimport estimateDataURLDecodedBytes from '../helpers/estimateDataURLDecodedBytes.js';`;
content = content.replace(importTarget, newImport);

// Add size validation block inside the data: protocol handler
// Find: if (protocol === 'data:') { let convertedData;
// Replace with: if (protocol === 'data:') { [validation block] let convertedData;
const dataBlockTarget = `if (protocol === 'data:') {
      let convertedData;`;

const dataBlockReplacement = `if (protocol === 'data:') {
      // Apply the same semantics as HTTP: only enforce if a finite, non-negative cap is set.
      if (config.maxContentLength > -1) {
        // Use the exact string passed to fromDataURI (config.url); fall back to fullPath if needed.
        const dataUrl = String(config.url || fullPath || '');
        const estimated = estimateDataURLDecodedBytes(dataUrl);

        if (estimated > config.maxContentLength) {
          return reject(new AxiosError(
            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
            AxiosError.ERR_BAD_RESPONSE,
            config
          ));
        }
      }

      let convertedData;`;

content = content.replace(dataBlockTarget, dataBlockReplacement);

fs.writeFileSync(httpPath, content);
console.log('Successfully patched http.js');
PATCH_EOF

echo "Fix applied successfully"
