"""
Functionality tests for filestream_vscanf.
These tests verify that the function works correctly for normal input.
Should PASS in both vulnerable and fixed states.
"""

import subprocess
import pytest
import os


# Path to the compiled test harness
TEST_HARNESS = "/tests/test_harness"
TEST_HARNESS_ASAN = "/tests/test_harness_asan"


def get_harness():
    """Get the path to an available test harness"""
    if os.path.exists(TEST_HARNESS):
        return TEST_HARNESS
    if os.path.exists(TEST_HARNESS_ASAN):
        return TEST_HARNESS_ASAN
    # Check if we need to compile
    pytest.fail("Test harness not found. Run compile_harness.sh first.")


class TestFunctionalityIntegerParsing:
    """Test normal integer parsing functionality"""

    def test_single_integer_parse(self):
        """Test parsing a single integer from a file"""
        harness = get_harness()
        result = subprocess.run(
            [harness, "func_int"],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode == 0, f"Test failed: {result.stdout}\n{result.stderr}"
        assert "PASS" in result.stdout, f"Expected PASS in output: {result.stdout}"

    def test_multiple_values_parse(self):
        """Test parsing multiple values (int and string) from a file"""
        harness = get_harness()
        result = subprocess.run(
            [harness, "func_multi"],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode == 0, f"Test failed: {result.stdout}\n{result.stderr}"
        assert "PASS" in result.stdout, f"Expected PASS in output: {result.stdout}"

    def test_all_functionality_tests(self):
        """Run all functionality tests in sequence"""
        harness = get_harness()
        result = subprocess.run(
            [harness, "all_func"],
            capture_output=True,
            text=True,
            timeout=60
        )

        assert result.returncode == 0, f"Functionality tests failed: {result.stdout}\n{result.stderr}"


class TestFunctionalityEdgeCases:
    """Test edge cases for functionality"""

    def test_file_position_after_successful_parse(self):
        """Verify file position is correctly updated after successful parse"""
        # This test creates a file and verifies position tracking
        import tempfile

        # Create test file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write("999\n")
            testfile = f.name

        try:
            # The harness already tests position, but we verify basic file I/O works
            with open(testfile, 'r') as f:
                content = f.read()
                assert content == "999\n", "Test file creation failed"
        finally:
            os.unlink(testfile)

    def test_whitespace_handling(self):
        """Test that whitespace is handled correctly in format strings"""
        import tempfile

        # Create test file with whitespace
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write("  123  \n")
            testfile = f.name

        try:
            # Verify file was created correctly
            with open(testfile, 'r') as f:
                content = f.read()
                assert "123" in content
        finally:
            os.unlink(testfile)


class TestFunctionalityRobustness:
    """Robustness tests for functionality"""

    def test_repeated_normal_operations(self):
        """Test that repeated normal operations work consistently"""
        harness = get_harness()

        for i in range(5):
            result = subprocess.run(
                [harness, "func_int"],
                capture_output=True,
                text=True,
                timeout=30
            )
            assert result.returncode == 0, f"Iteration {i} failed: {result.stdout}\n{result.stderr}"

    def test_no_memory_errors_in_normal_operation(self):
        """Verify no memory errors during normal operation (if ASan build available)"""
        if os.path.exists(TEST_HARNESS_ASAN):
            result = subprocess.run(
                [TEST_HARNESS_ASAN, "all_func"],
                capture_output=True,
                text=True,
                timeout=60,
                env={**os.environ, "ASAN_OPTIONS": "detect_leaks=0"}
            )

            # Check for ASan errors in stderr
            asan_error = "AddressSanitizer" in result.stderr or "ASAN" in result.stderr
            assert not asan_error, f"Memory error detected: {result.stderr}"
            assert result.returncode == 0, f"Test failed: {result.stdout}\n{result.stderr}"
        else:
            # Skip if ASan build not available
            pytest.skip("ASan build not available")
