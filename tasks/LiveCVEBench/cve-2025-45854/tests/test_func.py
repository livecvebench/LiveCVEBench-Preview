"""
Functionality Tests for JEHC-BPM Application

These tests verify that the application works correctly regardless of the fix state.
They should PASS in both vulnerable and fixed states.

The tests check:
1. Application is running and responsive
2. Basic API endpoints are accessible
3. Other actuator endpoints work correctly
"""

import pytest
import requests
import time
import os

# Configuration
BASE_URL = os.environ.get("APP_URL", "http://localhost:8082")
TIMEOUT = 10


class TestApplicationHealth:
    """
    Test that the application is running and basic endpoints are accessible.
    """

    def test_application_is_running(self):
        """Verify the application is responding to HTTP requests"""
        try:
            # Try to access the root or any endpoint to verify the server is running
            response = requests.get(f"{BASE_URL}/", timeout=TIMEOUT, allow_redirects=True)
            # Any response (even 404 or redirects) indicates the server is running
            assert response.status_code is not None, "No response from application"
        except requests.exceptions.ConnectionError:
            pytest.fail(f"Application is not running at {BASE_URL}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Application timeout at {BASE_URL}")

    def test_actuator_endpoints_exist(self):
        """Verify that actuator info endpoints are defined"""
        # Test the thread endpoint which should exist
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/thread", timeout=TIMEOUT)
            # Endpoint should exist (200 or auth required 401/403)
            assert response.status_code in [200, 401, 403, 500], \
                f"Unexpected status code: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to access actuator endpoint: {e}")


class TestActuatorInfoEndpoints:
    """
    Test that other actuator info endpoints work correctly.
    These endpoints don't execute commands and should remain functional.
    """

    def test_thread_info_endpoint(self):
        """Test thread information endpoint"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/thread", timeout=TIMEOUT)
            # Should return data or require auth (depending on fix state for other endpoints)
            assert response.status_code in [200, 401, 403, 500], \
                f"Thread endpoint returned unexpected status: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Thread endpoint not accessible: {e}")

    def test_gc_info_endpoint(self):
        """Test garbage collection info endpoint"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/gc", timeout=TIMEOUT)
            # Should return data or require auth
            assert response.status_code in [200, 401, 403, 500], \
                f"GC endpoint returned unexpected status: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"GC endpoint not accessible: {e}")

    def test_classload_info_endpoint(self):
        """Test class loading info endpoint"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/classLoad", timeout=TIMEOUT)
            # Should return data or require auth
            assert response.status_code in [200, 401, 403, 500], \
                f"ClassLoad endpoint returned unexpected status: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"ClassLoad endpoint not accessible: {e}")

    def test_system_info_endpoint(self):
        """Test system info endpoint"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/systemInfo", timeout=TIMEOUT)
            # Should return data or require auth
            assert response.status_code in [200, 401, 403, 500], \
                f"SystemInfo endpoint returned unexpected status: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"SystemInfo endpoint not accessible: {e}")


class TestActuatorServerEndpoints:
    """
    Test that actuator server endpoints are defined.
    """

    def test_server_list_endpoint(self):
        """Test server list endpoint"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/server/list", timeout=TIMEOUT)
            # Should return data or require auth
            assert response.status_code in [200, 401, 403], \
                f"Server list endpoint returned unexpected status: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Server list endpoint not accessible: {e}")


class TestAPIResponseFormat:
    """
    Test that API responses follow the expected format.
    """

    def test_response_is_json(self):
        """Test that API responses are valid JSON"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/thread", timeout=TIMEOUT)
            if response.status_code == 200:
                # Should be valid JSON
                data = response.json()
                assert isinstance(data, dict), "Response should be a JSON object"
        except requests.exceptions.JSONDecodeError:
            # Some error responses might not be JSON, which is acceptable
            pass
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Endpoint not accessible: {e}")

    def test_success_response_structure(self):
        """Test that successful responses have expected structure"""
        try:
            response = requests.get(f"{BASE_URL}/actuator/info/thread", timeout=TIMEOUT)
            if response.status_code == 200:
                data = response.json()
                # JEHC responses typically have 'success', 'data', and 'message' fields
                # At minimum, check it's a dictionary
                assert isinstance(data, dict), "Response should be a JSON object"
        except requests.exceptions.JSONDecodeError:
            pass
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Endpoint not accessible: {e}")


class TestEndpointExistence:
    """
    Test that the executeExec endpoint exists (it should be there, just protected).
    """

    def test_execute_exec_endpoint_exists(self):
        """Test that executeExec endpoint is defined (responds with something)"""
        try:
            # Send a POST request - any response indicates the endpoint exists
            response = requests.post(
                f"{BASE_URL}/actuator/info/executeExec",
                json={"0": "echo"},
                timeout=TIMEOUT
            )
            # The endpoint should respond (not 404 Method Not Allowed)
            # After fix: 401/403, Before fix: 200
            # 405 would indicate POST not allowed, 404 would indicate endpoint doesn't exist
            assert response.status_code != 404, "executeExec endpoint should exist"
            assert response.status_code != 405, "executeExec should accept POST requests"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not test endpoint existence: {e}")


class TestContentTypes:
    """
    Test that endpoints accept proper content types.
    """

    def test_accepts_json_content_type(self):
        """Test that POST endpoint accepts application/json"""
        try:
            response = requests.post(
                f"{BASE_URL}/actuator/info/executeExec",
                json={"0": "test"},
                headers={"Content-Type": "application/json"},
                timeout=TIMEOUT
            )
            # Should not return 415 Unsupported Media Type
            assert response.status_code != 415, "Endpoint should accept application/json"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not test content type: {e}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
