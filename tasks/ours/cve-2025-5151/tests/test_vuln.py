"""
Vulnerability tests to verify that dangerous operations are blocked.
These tests should:
- FAIL in vulnerable state (dangerous operations succeed)
- PASS in fixed state (dangerous operations are blocked)
"""
import pytest
import asyncio
import sys
import os

# Add backend to path for imports
sys.path.insert(0, '/app/backend')


@pytest.mark.asyncio
async def test_etc_passwd_access_via_pandas_blocked():
    """
    Test that reading /etc/passwd via pandas is blocked.

    In the vulnerable version, pandas can read any file including sensitive system files.
    The fix should block access to /etc/ directory paths.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    malicious_code = '''
import pandas as pd
try:
    data = pd.read_csv('/etc/passwd', sep=':', header=None)
    final_result = f"SUCCESS: Read {len(data)} lines from sensitive file"
except Exception as e:
    final_result = f"BLOCKED: {str(e)}"
'''
    result, error = await execute_analysis_code_safely(malicious_code, "[]")

    # After fix: the code should be rejected before execution due to /etc/ path detection
    # or the error should indicate the operation is not permitted
    assert "SUCCESS" not in result, \
        f"Security vulnerability: able to read /etc/passwd! Result: {result}"

    # Verify that some form of blocking occurred
    blocked = (
        "not permitted" in result.lower() or
        "not permitted" in error.lower() or
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        error != ""
    )
    assert blocked, f"Expected operation to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_eval_function_blocked():
    """
    Test that eval() calls are blocked.

    In the vulnerable version, eval can be used to execute arbitrary code.
    The fix should detect and block eval() calls via AST analysis.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
result = eval("1 + 1")
final_result = f"eval returned: {result}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: eval should be blocked
    assert "eval returned: 2" not in result, \
        f"Security vulnerability: eval() was executed! Result: {result}"

    blocked = (
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        "not permitted" in result.lower() or
        "not permitted" in error.lower() or
        error != ""
    )
    assert blocked, f"Expected eval to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_exec_function_blocked():
    """
    Test that exec() calls are blocked.

    In the vulnerable version, exec can run arbitrary code strings.
    The fix should detect and block exec() calls.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
exec("x = 42")
final_result = f"exec worked, x = {x}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: exec should be blocked
    assert "exec worked" not in result, \
        f"Security vulnerability: exec() was executed! Result: {result}"

    blocked = (
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        error != ""
    )
    assert blocked, f"Expected exec to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_open_function_blocked():
    """
    Test that open() function is blocked.

    In the vulnerable version, open() has full access to the filesystem.
    The fix should replace open with a safe version that blocks file operations.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
try:
    with open('/etc/passwd', 'r') as f:
        content = f.read()
    final_result = f"SUCCESS: Read {len(content)} bytes"
except Exception as e:
    final_result = f"BLOCKED: {str(e)}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: open() should be blocked either by AST or by safe_open
    assert "SUCCESS" not in result, \
        f"Security vulnerability: open() read a file! Result: {result}"

    blocked = (
        "not permitted" in result.lower() or
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        "BLOCKED" in result or
        error != ""
    )
    assert blocked, f"Expected open to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_dunder_import_blocked():
    """
    Test that __import__() is blocked.

    In the vulnerable version, __import__ can import any module.
    The fix should restrict imports to allowed libraries only.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
try:
    os = __import__('os')
    result = os.getcwd()
    final_result = f"SUCCESS: Imported os, cwd = {result}"
except Exception as e:
    final_result = f"BLOCKED: {str(e)}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: importing os should be blocked
    assert "SUCCESS" not in result, \
        f"Security vulnerability: __import__('os') succeeded! Result: {result}"

    blocked = (
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        "BLOCKED" in result or
        error != ""
    )
    assert blocked, f"Expected __import__ of os to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_arbitrary_file_read_via_pandas_blocked():
    """
    Test that reading arbitrary files via pandas methods is blocked.

    Even if direct open() is blocked, pandas has various file reading methods.
    The fix should block paths to sensitive directories.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
import pandas as pd
try:
    # Try to read /etc/passwd using pandas read_table which is more flexible
    df = pd.read_table('/etc/passwd', sep=':', header=None)
    final_result = f"SUCCESS: Read {len(df)} lines from /etc/passwd via read_table"
except Exception as e:
    final_result = f"BLOCKED: {str(e)}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: accessing /etc/ should be blocked
    assert "SUCCESS" not in result, \
        f"Security vulnerability: read /etc/passwd via pandas! Result: {result}"

    # In vulnerable state, should succeed; in fixed state, should be blocked
    blocked = (
        "not permitted" in result.lower() or
        "not allowed" in result.lower() or
        "not allowed" in error.lower() or
        error != ""
    )
    assert blocked, f"Expected operation to be blocked. Result: {result}, Error: {error}"


@pytest.mark.asyncio
async def test_subprocess_import_blocked():
    """
    Test that importing subprocess module is blocked.

    The fix should only allow whitelisted module imports.
    """
    from tools.analysis_tools import execute_analysis_code_safely

    code = '''
try:
    import subprocess
    result = subprocess.run(['echo', 'test'], capture_output=True, text=True)
    final_result = f"SUCCESS: subprocess worked, output = {result.stdout}"
except Exception as e:
    final_result = f"BLOCKED: {str(e)}"
'''
    result, error = await execute_analysis_code_safely(code, "[]")

    # After fix: subprocess should not be importable
    assert "SUCCESS" not in result, \
        f"Security vulnerability: subprocess was imported! Result: {result}"