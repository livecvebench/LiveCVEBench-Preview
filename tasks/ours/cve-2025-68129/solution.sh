#!/bin/bash
set -e
cd /app

echo "Applying fix for token validation..."

# Create a PHP script to apply the fix
cat > /tmp/apply_fix.php << 'EOFPHP'
<?php
/**
 * Apply fix to Token.php and InvalidTokenException.php
 *
 * This fix:
 * 1. Adds detection of ID tokens being used as access tokens (nonce check)
 * 2. Changes audience handling so clientId is only added for non-access tokens,
 *    or as a fallback when no API audience is configured
 */

// Fix Token.php
$tokenFile = '/app/src/Token.php';
$content = file_get_contents($tokenFile);

if ($content === false) {
    echo "ERROR: Could not read $tokenFile\n";
    exit(1);
}

// Replace the vulnerable pattern with the fixed version
$vulnerable_pattern = '$tokenAudience[] = (string) $this->configuration->getClientId();
        $tokenAudience = array_unique($tokenAudience);';

$fixed_code = 'if (self::TYPE_ACCESS_TOKEN === $this->type) {
            if (null !== $this->getParser()->getClaim(\'nonce\')) {
                throw InvalidTokenException::idTokenUsedAsAccessToken();
            }
            if ([] === $tokenAudience) {
                $tokenAudience[] = (string) $this->configuration->getClientId();
            }
        } else {
            $tokenAudience[] = (string) $this->configuration->getClientId();
        }
        $tokenAudience = array_unique($tokenAudience);';

if (strpos($content, $vulnerable_pattern) === false) {
    echo "NOTE: Vulnerable pattern not found in Token.php - may already be fixed\n";
} else {
    $content = str_replace($vulnerable_pattern, $fixed_code, $content);
    file_put_contents($tokenFile, $content);
    echo "Fixed Token.php\n";
}

// Fix InvalidTokenException.php - Add constant and method
$exceptionFile = '/app/src/Exception/InvalidTokenException.php';
$content = file_get_contents($exceptionFile);

if ($content === false) {
    echo "ERROR: Could not read $exceptionFile\n";
    exit(1);
}

// Check if already fixed
if (strpos($content, 'MSG_ID_TOKEN_USED_AS_ACCESS_TOKEN') !== false) {
    echo "NOTE: InvalidTokenException.php already contains the fix\n";
} else {
    // Add the constant after MSG_BAD_SIGNATURE_MISSING_KID
    $constMarker = "public const MSG_BAD_SIGNATURE_MISSING_KID = 'Cannot verify signature: JWKS did not contain the key specified by the token';";
    $constNew = $constMarker . "

    /**
     * @var string
     */
    public const MSG_ID_TOKEN_USED_AS_ACCESS_TOKEN = 'ID token cannot be validated as an access token (detected nonce claim)';";

    $content = str_replace($constMarker, $constNew, $content);

    // Add the static method before the closing brace of the class
    $methodToAdd = "
    public static function idTokenUsedAsAccessToken(
        ?\\Throwable \$previous = null,
    ): self {
        return new self(self::MSG_ID_TOKEN_USED_AS_ACCESS_TOKEN, 0, \$previous);
    }
";

    // Find the last closing brace of the class
    $lastBrace = strrpos($content, '}');
    if ($lastBrace !== false) {
        $content = substr($content, 0, $lastBrace) . $methodToAdd . '}' . "\n";
    }

    file_put_contents($exceptionFile, $content);
    echo "Fixed InvalidTokenException.php\n";
}

echo "Fix applied successfully\n";
EOFPHP

php /tmp/apply_fix.php

# Clean up
rm -f /tmp/apply_fix.php

echo "Done!"
