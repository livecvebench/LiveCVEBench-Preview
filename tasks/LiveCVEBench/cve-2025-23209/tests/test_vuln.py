"""
Vulnerability tests for CVE-2025-23209: Craft CMS Path Traversal RCE

These tests send real HTTP requests to the Craft CMS service to verify:
- FAIL when vulnerable (path traversal attack succeeds)
- PASS when fixed (path traversal attack is blocked)
"""

import hashlib
import hmac
import json
import requests
import time


class TestCVE202523209:
    """Dynamic tests for CVE-2025-23209 path traversal vulnerability."""

    # Craft CMS service URL (inside container network)
    BASE_URL = "http://localhost:80"

    # Known security key (same as in docker-compose.yaml)
    SECURITY_KEY = "testkey123456789012345678901234"

    # Endpoint for the vulnerable action
    RESTORE_DB_ENDPOINT = "/admin/actions/updater/restore-db"

    def hash_data(self, data: str) -> str:
        """
        Sign data using HMAC-SHA256, matching Craft CMS Security::hashData().

        Craft CMS prepends the HMAC hash to the data.
        """
        key = self.SECURITY_KEY.encode('utf-8')
        data_bytes = data.encode('utf-8')
        hash_hex = hmac.new(key, data_bytes, hashlib.sha256).hexdigest()
        return hash_hex + data

    def create_signed_payload(self, db_backup_path: str) -> str:
        """Create a signed payload with the given dbBackupPath.

        Uses PHP-compatible JSON encoding:
        - No spaces after separators
        - Escape forward slashes (PHP's default behavior)
        """
        # Generate PHP-compatible JSON
        payload = json.dumps({"dbBackupPath": db_backup_path}, separators=(',', ':'))
        # PHP escapes forward slashes by default
        payload = payload.replace('/', '\\/')
        return self.hash_data(payload)

    def send_restore_request(self, signed_data: str) -> requests.Response:
        """Send a POST request to the restore-db endpoint."""
        url = f"{self.BASE_URL}{self.RESTORE_DB_ENDPOINT}"

        # Craft CMS expects the data as a form parameter
        data = {"data": signed_data}

        # Headers to simulate a control panel request
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "X-Requested-With": "XMLHttpRequest",
        }

        return requests.post(url, data=data, headers=headers, timeout=10)

    def test_path_traversal_blocked(self):
        """
        Test that path traversal attacks are blocked after fix.

        When VULNERABLE:
        - Returns 200 with "Couldn't restore" (tried to use path as backup)
        - This SHOULD FAIL the test

        When FIXED:
        - Returns 400 Bad Request with "Invalid backup path"
        - This SHOULD PASS the test
        """
        # Malicious path with path traversal
        malicious_path = "/var/www/html/storage/backups/../../../etc/passwd"
        signed_payload = self.create_signed_payload(malicious_path)

        response = self.send_restore_request(signed_payload)

        # VULNERABLE state: status 200 with "Couldn't restore" means path was used
        # FIXED state: status 400 with "Invalid backup path"
        if response.status_code == 200:
            # Check if the vulnerable behavior occurred
            response_json = response.json() if response.headers.get('content-type', '').startswith('application/json') else {}
            if "error" in response_json and "Couldn't restore" in response_json.get("error", ""):
                # This is the VULNERABLE state - the path traversal was attempted
                assert False, \
                    "VULNERABLE: Path traversal attack succeeded. " \
                    "The system attempted to restore from a path outside backups directory. " \
                    f"Response: {response.text[:500]}"

        # After fix: should get 400 Bad Request
        assert response.status_code == 400, \
            f"Path traversal should be blocked with 400 status. Got {response.status_code}. " \
            f"Response: {response.text[:500]}"

    def test_nonexistent_path_blocked(self):
        """
        Test that non-existent backup paths are blocked after fix.

        The fix checks file_exists() before proceeding.

        When VULNERABLE:
        - Returns 200 with "Couldn't restore" (tried to read non-existent file)

        When FIXED:
        - Returns 400 Bad Request because file doesn't exist
        """
        # Path that doesn't exist
        fake_path = "/var/www/html/storage/backups/nonexistent_backup_12345.sql"
        signed_payload = self.create_signed_payload(fake_path)

        response = self.send_restore_request(signed_payload)

        # VULNERABLE state: status 200 with "Couldn't restore"
        if response.status_code == 200:
            response_json = response.json() if response.headers.get('content-type', '').startswith('application/json') else {}
            if "error" in response_json and "Couldn't restore" in response_json.get("error", ""):
                assert False, \
                    "VULNERABLE: Non-existent path was attempted. " \
                    f"Response: {response.text[:500]}"

        # After fix: should get 400 Bad Request because file doesn't exist
        assert response.status_code == 400, \
            f"Non-existent path should be blocked with 400 status. Got {response.status_code}. " \
            f"Response: {response.text[:500]}"

    def test_outside_backup_dir_blocked(self):
        """
        Test that paths outside the backup directory are blocked.

        The fix uses FileHelper::isWithin() to validate path containment.

        When VULNERABLE:
        - Returns 200 with "Couldn't restore" (tried to read outside backup dir)

        When FIXED:
        - Returns 400 Bad Request
        """
        # Path outside backup directory (but exists)
        outside_path = "/var/www/html/config/general.php"
        signed_payload = self.create_signed_payload(outside_path)

        response = self.send_restore_request(signed_payload)

        # VULNERABLE state: status 200 with "Couldn't restore"
        if response.status_code == 200:
            response_json = response.json() if response.headers.get('content-type', '').startswith('application/json') else {}
            if "error" in response_json and "Couldn't restore" in response_json.get("error", ""):
                assert False, \
                    "VULNERABLE: Path outside backup directory was attempted. " \
                    f"Response: {response.text[:500]}"

        # After fix: should get 400 Bad Request
        assert response.status_code == 400, \
            f"Path outside backup dir should be blocked. Got {response.status_code}. " \
            f"Response: {response.text[:500]}"

