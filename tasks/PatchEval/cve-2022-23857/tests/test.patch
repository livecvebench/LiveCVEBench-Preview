diff --git a/model/criteria/criteria_test.go b/model/criteria/criteria_test.go
new file mode 100644
index 0000000..766d7a7
--- /dev/null
+++ b/model/criteria/criteria_test.go
@@ -0,0 +1,173 @@
+package criteria
+
+import (
+	"bytes"
+	"encoding/json"
+
+	"strings"
+	"testing"
+
+	. "github.com/onsi/ginkgo"
+	"github.com/onsi/gomega"
+
+	"github.com/stretchr/testify/assert"
+)
+
+// In real code, this map should be placed in an appropriate location. This test is just an example.
+type fieldDef struct {
+	field string
+	order string
+}
+
+var _ = Describe("Criteria", func() {
+	var goObj Criteria
+	var jsonObj string
+	BeforeEach(func() {
+		goObj = Criteria{
+			Expression: All{
+				Contains{"title": "love"},
+				NotContains{"title": "hate"},
+				Any{
+					IsNot{"artist": "u2"},
+					Is{"album": "best of"},
+				},
+				All{
+					StartsWith{"comment": "this"},
+					InTheRange{"year": []int{1980, 1990}},
+				},
+			},
+			Sort:   "title",
+			Order:  "asc",
+			Limit:  20,
+			Offset: 10,
+		}
+		var b bytes.Buffer
+		err := json.Compact(&b, []byte(`
+{
+	"all": [
+		{ "contains": {"title": "love"} },
+		{ "notContains": {"title": "hate"} },
+		{ "any": [
+				{ "isNot": {"artist": "u2"} },
+				{ "is": {"album": "best of"} }
+			]
+		},
+		{ "all": [
+				{ "startsWith": {"comment": "this"} },
+				{ "inTheRange": {"year":[1980,1990]} }
+			]
+		}
+	],
+	"sort": "title",
+	"order": "asc",
+	"limit": 20,
+	"offset": 10
+}
+`))
+		if err != nil {
+			panic(err)
+		}
+		jsonObj = b.String()
+	})
+
+	It("generates valid SQL", func() {
+		sql, args, err := goObj.ToSql()
+		gomega.Expect(err).ToNot(gomega.HaveOccurred())
+		gomega.Expect(sql).To(gomega.Equal("(media_file.title LIKE ? AND media_file.title NOT LIKE ? AND (media_file.artist <> ? OR media_file.album = ?) AND (media_file.comment LIKE ? AND (media_file.year >= ? AND media_file.year <= ?)))"))
+		gomega.Expect(args).To(gomega.ConsistOf("%love%", "%hate%", "u2", "best of", "this%", 1980, 1990))
+	})
+
+	It("marshals to JSON", func() {
+		j, err := json.Marshal(goObj)
+		gomega.Expect(err).ToNot(gomega.HaveOccurred())
+		gomega.Expect(string(j)).To(gomega.Equal(jsonObj))
+	})
+
+	It("is reversible to/from JSON", func() {
+		var newObj Criteria
+		err := json.Unmarshal([]byte(jsonObj), &newObj)
+		gomega.Expect(err).ToNot(gomega.HaveOccurred())
+		j, err := json.Marshal(newObj)
+		gomega.Expect(err).ToNot(gomega.HaveOccurred())
+		gomega.Expect(string(j)).To(gomega.Equal(jsonObj))
+	})
+
+})
+
+// TestCriteriaOrderBy tests whether the fixed OrderBy correctly handles SQL injection or invalid input
+func TestCriteriaOrderBy(t *testing.T) {
+
+	tests := []struct {
+		name     string
+		sort     string
+		order    string
+		want     string
+		logCheck string // Expected substring in logs, used for additional verification
+	}{
+		{
+			name:  "Empty sort => defaults to 'title'",
+			sort:  "",
+			order: "",
+			want:  "media_file.title",
+		},
+		{
+			name:  "Valid sort => 'artist asc'",
+			sort:  "artist",
+			order: "asc",
+			want:  "media_file.artist asc",
+		},
+		{
+			name:  "Valid sort => 'artist desc'",
+			sort:  "artist",
+			order: "desc",
+			want:  "media_file.artist desc",
+		},
+		{
+			name:  "Invalid sort => fallback to 'title'",
+			sort:  "invalid_column",
+			order: "asc",
+			want:  "media_file.title asc",
+		},
+		{
+			name:  "Injection attempt in sort => fallback to 'title'",
+			sort:  "artist; drop table user;--",
+			order: "asc",
+			want:  "media_file.title asc",
+		},
+		{
+			name:  "Invalid order => ignore order, keep field",
+			sort:  "artist",
+			order: "something malicious",
+			want:  "media_file.artist", // Do not append "desc" or "asc"
+
+		},
+	}
+
+	// Optional: mock log output to check if warnings appear
+
+	var capturedLogs strings.Builder
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			c := Criteria{
+				Sort:  tt.sort,
+				Order: tt.order,
+			}
+			got := c.OrderBy()
+			assert.Equal(t, tt.want, got, "OrderBy() mismatch")
+
+			if tt.logCheck != "" {
+				assert.Contains(t, capturedLogs.String(), tt.logCheck,
+					"Expected log message %q not found in:\n%s", tt.logCheck, capturedLogs.String())
+			} else {
+				assert.NotContains(t, capturedLogs.String(), "Invalid field in 'sort' field",
+					"Log should not contain invalid sort error for this case")
+				assert.NotContains(t, capturedLogs.String(), "Invalid value in 'order' field",
+					"Log should not contain invalid order error for this case")
+			}
+
+			// Reset log capture
+			capturedLogs.Reset()
+		})
+	}
+}
