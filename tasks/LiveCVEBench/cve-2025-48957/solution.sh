#!/bin/bash
# Solution script for AstrBot path traversal vulnerability fix
# This script applies the fix to prevent directory traversal in the get_file endpoint

set -e
cd /app

echo "[solution.sh] Applying path traversal fix to astrbot/dashboard/routes/chat.py..."

# Use Python to perform the multiline string replacement
python3 << 'PYTHON_SCRIPT'
import os

chat_py_path = 'astrbot/dashboard/routes/chat.py'

with open(chat_py_path, 'r') as f:
    content = f.read()

# Check if already fixed (idempotency check)
if 'os.path.basename(filename)' in content and 'real_file_path.startswith(real_imgs_dir)' in content:
    print("[solution.sh] Fix already applied, skipping...")
    exit(0)

# The vulnerable code pattern to find
vulnerable_code = '''    async def get_file(self):
        filename = request.args.get("filename")
        if not filename:
            return Response().error("Missing key: filename").__dict__

        try:
            with open(os.path.join(self.imgs_dir, filename), "rb") as f:
                if filename.endswith(".wav"):
                    return QuartResponse(f.read(), mimetype="audio/wav")
                elif filename.split(".")[-1] in self.supported_imgs:
                    return QuartResponse(f.read(), mimetype="image/jpeg")
                else:
                    return QuartResponse(f.read())

        except FileNotFoundError:
            return Response().error("File not found").__dict__'''

# The fixed code
fixed_code = '''    async def get_file(self):
        filename = request.args.get("filename")
        if not filename:
            return Response().error("Missing key: filename").__dict__

        try:
            file_path = os.path.join(self.imgs_dir, os.path.basename(filename))
            real_file_path = os.path.realpath(file_path)
            real_imgs_dir = os.path.realpath(self.imgs_dir)

            if not real_file_path.startswith(real_imgs_dir):
                return Response().error("Invalid file path").__dict__

            with open(real_file_path, "rb") as f:
                filename_ext = os.path.splitext(filename)[1].lower()

                if filename_ext == ".wav":
                    return QuartResponse(f.read(), mimetype="audio/wav")
                elif filename_ext[1:] in self.supported_imgs:
                    return QuartResponse(f.read(), mimetype="image/jpeg")
                else:
                    return QuartResponse(f.read())

        except (FileNotFoundError, OSError):
            return Response().error("File access error").__dict__'''

if vulnerable_code in content:
    content = content.replace(vulnerable_code, fixed_code)
    with open(chat_py_path, 'w') as f:
        f.write(content)
    print("[solution.sh] Fix applied successfully!")
else:
    # Try more flexible matching if exact match fails
    print("[solution.sh] Exact match not found, trying flexible replacement...")

    import re

    # Pattern to match the vulnerable function
    pattern = r'(    async def get_file\(self\):.*?except FileNotFoundError:.*?return Response\(\)\.error\("File not found"\)\.__dict__)'

    match = re.search(pattern, content, re.DOTALL)
    if match:
        content = content.replace(match.group(0), fixed_code)
        with open(chat_py_path, 'w') as f:
            f.write(content)
        print("[solution.sh] Fix applied with flexible matching!")
    else:
        print("[solution.sh] ERROR: Could not find vulnerable code pattern")
        print("[solution.sh] Current get_file function content:")
        # Print the get_file function for debugging
        start = content.find('async def get_file(self):')
        if start != -1:
            end = content.find('\n    async def', start + 1)
            if end == -1:
                end = content.find('\n    def ', start + 1)
            if end == -1:
                end = start + 1500
            print(content[start:end])
        exit(1)

PYTHON_SCRIPT

echo "[solution.sh] Restarting application to apply changes..."

# Kill the running Python process to trigger restart via entrypoint
pkill -f "python.*main.py" || true

# Wait for the application to restart
echo "[solution.sh] Waiting for application to restart..."
sleep 5

echo "[solution.sh] Fix complete!"
