"""
Vulnerability tests for CVE-2025-62162: cel-rust parser panic DoS.

These tests verify that the specific parser panic vulnerability is present
in the vulnerable version and fixed in the patched version.

CVE-2025-62162 affects expressions containing standalone dots (`.`) that
create Error variants in certain parser context types (PrimaryContextAll,
MemberContextAll, etc.).

VULNERABLE behavior: Process panics with "unreachable code" error
FIXED behavior: Process returns a parse error gracefully

The tests should:
- FAIL when vulnerability is present (parser panics)
- PASS when vulnerability is fixed (parser returns errors)
"""

import subprocess
import pytest

# The cel-test binary is compiled in /app
APP_DIR = "/app"
TEST_BINARY = "/app/target/release/cel-test"


def run_cel_expression(expr: str, timeout: int = 30) -> subprocess.CompletedProcess:
    """Helper to run a CEL expression through the test harness."""
    return subprocess.run(
        [TEST_BINARY, expr],
        capture_output=True,
        text=True,
        cwd=APP_DIR,
        timeout=timeout
    )


def is_panic(result: subprocess.CompletedProcess) -> bool:
    """Check if the process panicked with the specific CVE-2025-62162 error."""
    stderr_lower = result.stderr.lower()
    # Check for the specific panic indicators from CVE-2025-62162
    return (
        "panic" in stderr_lower and
        ("unreachable code" in stderr_lower or
         "internal error" in stderr_lower or
         "should have been properly implemented" in stderr_lower)
    )


class TestStandaloneDotPanic:
    """Tests for standalone dot expressions that trigger PrimaryContextAll::Error panic."""

    def test_standalone_dot(self):
        """Test standalone dot: ."""
        result = run_cel_expression(".")
        assert not is_panic(result), (
            f"Parser panicked on '.'. This is the primary vulnerability trigger. "
            f"Stderr: {result.stderr}"
        )

    def test_dot_in_parentheses(self):
        """Test dot in parentheses: (.)"""
        result = run_cel_expression("(.)")
        assert not is_panic(result), (
            f"Parser panicked on '(.)'. "
            f"Stderr: {result.stderr}"
        )

    def test_double_dot_at_start(self):
        """Test double dot at start: ..a"""
        result = run_cel_expression("..a")
        assert not is_panic(result), (
            f"Parser panicked on '..a'. "
            f"Stderr: {result.stderr}"
        )


class TestDotAfterOperator:
    """Tests where dot appears after an operator, triggering the parser panic."""

    def test_addition_then_dot(self):
        """Test addition followed by dot: 1+."""
        result = run_cel_expression("1+.")
        assert not is_panic(result), (
            f"Parser panicked on '1+.'. "
            f"Stderr: {result.stderr}"
        )

    def test_subtraction_then_dot(self):
        """Test subtraction followed by dot: 1-."""
        result = run_cel_expression("1-.")
        assert not is_panic(result), (
            f"Parser panicked on '1-.'. "
            f"Stderr: {result.stderr}"
        )

    def test_dot_then_addition(self):
        """Test dot followed by addition: .+1"""
        result = run_cel_expression(".+1")
        assert not is_panic(result), (
            f"Parser panicked on '.+1'. "
            f"Stderr: {result.stderr}"
        )

    def test_chained_operation_ending_dot(self):
        """Test chained operation ending in dot: a+b+c+."""
        result = run_cel_expression("a+b+c+.")
        assert not is_panic(result), (
            f"Parser panicked on 'a+b+c+.'. "
            f"Stderr: {result.stderr}"
        )


class TestDotInCollection:
    """Tests where dot appears inside collection constructs."""

    def test_dot_in_list(self):
        """Test dot in list: [.]"""
        result = run_cel_expression("[.]")
        assert not is_panic(result), (
            f"Parser panicked on '[.]'. "
            f"Stderr: {result.stderr}"
        )

    def test_dot_in_map(self):
        """Test dot in map: {{.}}"""
        # Using {.} - a map with just a dot as key expression
        result = run_cel_expression("{.}")
        assert not is_panic(result), (
            f"Parser panicked on '{{.}}'. "
            f"Stderr: {result.stderr}"
        )

    def test_list_with_dot_element(self):
        """Test list with dot as element: [1,.]"""
        result = run_cel_expression("[1,.]+2")
        assert not is_panic(result), (
            f"Parser panicked on '[1,.]+2'. "
            f"Stderr: {result.stderr}"
        )

    def test_dot_in_index(self):
        """Test dot in index access: x[.]"""
        result = run_cel_expression("x[.]")
        assert not is_panic(result), (
            f"Parser panicked on 'x[.]'. "
            f"Stderr: {result.stderr}"
        )


class TestDotInLogicalOps:
    """Tests where dot appears in logical operations."""

    def test_and_then_dot(self):
        """Test logical AND followed by dot: a&&."""
        result = run_cel_expression("a&&.")
        assert not is_panic(result), (
            f"Parser panicked on 'a&&.'. "
            f"Stderr: {result.stderr}"
        )

    def test_or_then_dot(self):
        """Test logical OR followed by dot: a||."""
        result = run_cel_expression("a||.")
        assert not is_panic(result), (
            f"Parser panicked on 'a||.'. "
            f"Stderr: {result.stderr}"
        )

    def test_not_dot(self):
        """Test logical NOT dot: !."""
        result = run_cel_expression("!.")
        assert not is_panic(result), (
            f"Parser panicked on '!.'. "
            f"Stderr: {result.stderr}"
        )

    def test_negation_dot(self):
        """Test negation dot: -."""
        result = run_cel_expression("-.")
        assert not is_panic(result), (
            f"Parser panicked on '-.'. "
            f"Stderr: {result.stderr}"
        )


class TestDotInComparison:
    """Tests where dot appears in comparison expressions."""

    def test_equality_dot(self):
        """Test equality with dot: a==."""
        result = run_cel_expression("a==.")
        assert not is_panic(result), (
            f"Parser panicked on 'a==.'. "
            f"Stderr: {result.stderr}"
        )

    def test_inequality_dot(self):
        """Test inequality with dot: a!=."""
        result = run_cel_expression("a!=.")
        assert not is_panic(result), (
            f"Parser panicked on 'a!=.'. "
            f"Stderr: {result.stderr}"
        )


class TestDotInTernary:
    """Tests where dot appears in ternary expressions."""

    def test_ternary_with_dot_result(self):
        """Test ternary with dot in result: true?.:0"""
        result = run_cel_expression("true?.:0")
        assert not is_panic(result), (
            f"Parser panicked on 'true?.:0'. "
            f"Stderr: {result.stderr}"
        )


class TestDotInFunctionCall:
    """Tests where dot appears in function calls."""

    def test_dot_as_function_arg(self):
        """Test dot as function argument: func(.)"""
        result = run_cel_expression("func(.)")
        assert not is_panic(result), (
            f"Parser panicked on 'func(.)'. "
            f"Stderr: {result.stderr}"
        )

    def test_dot_in_nested_call(self):
        """Test dot in nested function call: a(b,c+.)"""
        result = run_cel_expression("a(b,c+.)")
        assert not is_panic(result), (
            f"Parser panicked on 'a(b,c+.)'. "
            f"Stderr: {result.stderr}"
        )


class TestDotAfterMethodAccess:
    """Tests where dot appears after member access."""

    def test_member_chain_then_operator_dot(self):
        """Test member chain followed by operator and dot: a.b.c+."""
        result = run_cel_expression("a.b.c+.")
        assert not is_panic(result), (
            f"Parser panicked on 'a.b.c+.'. "
            f"Stderr: {result.stderr}"
        )

    def test_index_then_operator_dot(self):
        """Test index access followed by operator and dot: x[0]+."""
        result = run_cel_expression("x[0]+.")
        assert not is_panic(result), (
            f"Parser panicked on 'x[0]+.'. "
            f"Stderr: {result.stderr}"
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
