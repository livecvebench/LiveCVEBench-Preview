#!/usr/bin/env python3
"""
Functionality tests for CUPS IPv6 address parsing.
These tests verify that normal, valid IPv6 and IPv4 addresses are parsed correctly.
Should PASS in both vulnerable and fixed states.
"""

import os
import signal
import subprocess
import tempfile
import time
import pytest
from typing import Tuple, Optional


# Find the cupsd binary
def find_cupsd_binary() -> str:
    """Find the cupsd binary in the container."""
    possible_paths = [
        "/app/cups-2.4.14/scheduler/cupsd",
        "/app/cups/scheduler/cupsd",
        "/usr/sbin/cupsd",
    ]
    for path in possible_paths:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path
    raise FileNotFoundError("cupsd binary not found in expected locations")


def run_cupsd_with_config(config_content: str, timeout: float = 3.0) -> Tuple[int, str, str]:
    """
    Run cupsd with a given configuration and return results.

    Returns:
        Tuple of (exit_code, stdout, stderr)
    """
    cupsd_path = find_cupsd_binary()

    # Create temporary config file
    fd, config_path = tempfile.mkstemp(suffix=".conf", prefix="cupsd_test_")
    with os.fdopen(fd, "w") as f:
        f.write(config_content)

    try:
        # Set library path for CUPS libraries
        env = os.environ.copy()
        cups_lib_dir = os.path.dirname(os.path.dirname(cupsd_path)) + "/cups"
        env["LD_LIBRARY_PATH"] = f"{cups_lib_dir}:{env.get('LD_LIBRARY_PATH', '')}"

        process = subprocess.Popen(
            [cupsd_path, "-f", "-c", config_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env,
            preexec_fn=os.setsid
        )

        try:
            stdout, stderr = process.communicate(timeout=timeout)
            exit_code = process.returncode
        except subprocess.TimeoutExpired:
            # Process is still running - this is expected for valid configs
            os.killpg(os.getpgid(process.pid), signal.SIGTERM)
            time.sleep(0.1)
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGKILL)
            except ProcessLookupError:
                pass
            stdout, stderr = process.communicate()
            # Exit code 0 for timeout means it was running successfully
            exit_code = 0

        return exit_code, stdout.decode('utf-8', errors='replace'), stderr.decode('utf-8', errors='replace')
    finally:
        try:
            os.unlink(config_path)
        except OSError:
            pass


def is_crash_exit_code(exit_code: int) -> bool:
    """Check if the exit code indicates a crash (segfault, etc.)."""
    # Python subprocess returns negative signal numbers for signal deaths
    # SIGSEGV (11): Python returns -11, shell returns 139 (128 + 11)
    # SIGABRT (6): Python returns -6, shell returns 134 (128 + 6)
    # SIGBUS (7): Python returns -7, shell returns 135 (128 + 7)

    # Handle Python's negative signal convention
    if exit_code < 0:
        signal_num = -exit_code
        # SIGSEGV=11, SIGABRT=6, SIGBUS=7, SIGFPE=8, SIGILL=4
        crash_signals = [4, 6, 7, 8, 11]
        return signal_num in crash_signals

    # Handle shell convention (128 + signal)
    crash_codes = [134, 135, 139]  # SIGABRT, SIGBUS, SIGSEGV
    return exit_code in crash_codes or (exit_code > 128 and exit_code < 192)


class TestValidIPv6Parsing:
    """Test that valid IPv6 addresses are parsed correctly."""

    def test_loopback_ipv6(self):
        """Test IPv6 loopback address [::1]."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [::1]
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_full_ipv6_address(self):
        """Test full IPv6 address [2001:db8::1]."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [2001:db8::1]
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_link_local_ipv6(self):
        """Test link-local IPv6 address [fe80::1]."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [fe80::1]
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_ipv6_with_cidr_mask(self):
        """Test IPv6 address with CIDR mask [2001:db8::1]/128."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [2001:db8::1]/128
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_ipv6_with_prefix(self):
        """Test IPv6 address with /64 prefix."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [fe80::]/64
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_ipv4_mapped_ipv6(self):
        """Test IPv4-mapped IPv6 address [::ffff:192.168.1.1]."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [::ffff:192.168.1.1]
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"


class TestValidIPv4Parsing:
    """Test that valid IPv4 addresses are parsed correctly."""

    def test_loopback_ipv4(self):
        """Test IPv4 loopback address 127.0.0.1."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from 127.0.0.1
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_ipv4_subnet(self):
        """Test IPv4 subnet 192.168.1.0/24."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from 192.168.1.0/24
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_ipv4_any(self):
        """Test IPv4 wildcard 0.0.0.0/0."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from 0.0.0.0/0
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"


class TestMixedAddressRules:
    """Test configurations with multiple address rules."""

    def test_multiple_valid_addresses(self):
        """Test configuration with multiple valid IPv4 and IPv6 addresses."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from [::1]
  Allow from 127.0.0.1
  Allow from [2001:db8::1]/128
  Allow from 192.168.1.0/24
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"

    def test_localhost_only(self):
        """Test simple localhost-only configuration."""
        config = """
LogLevel debug
Listen localhost:8631
<Location />
  Order allow,deny
  Allow from localhost
</Location>
"""
        exit_code, stdout, stderr = run_cupsd_with_config(config)
        assert not is_crash_exit_code(exit_code), f"cupsd crashed with exit code {exit_code}"
