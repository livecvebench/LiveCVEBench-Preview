#!/bin/bash
set -e

# Solution for workflow ID path traversal vulnerability
# Adds validation to workflow IDs in FileWorkflowStorage.save_workflow()

TARGET_FILE="/app/python_a2a/agent_flow/storage/workflow_storage.py"

# Check if the fix is already applied (idempotency)
if grep -q "Invalid workflow ID" "$TARGET_FILE" 2>/dev/null; then
    echo "Fix already applied"
    exit 0
fi

# Apply the fix using Python for reliable string handling
python3 << 'EOF'
import re

filepath = "/app/python_a2a/agent_flow/storage/workflow_storage.py"

with open(filepath, 'r') as f:
    content = f.read()

# Add 're' import if not present
if 'import re' not in content:
    # Add after the first import
    content = content.replace('import os', 'import re\nimport os', 1)

# Find the save_workflow method and add validation after workflow_id = workflow.id
old_pattern = 'workflow_id = workflow.id'
new_code = '''workflow_id = workflow.id

        # Validate workflow_id to prevent path traversal
        if not re.match(r'^[a-zA-Z0-9_-]+$', workflow_id):
            raise ValueError(f"Invalid workflow ID: {workflow_id}")

        # Additional check: ensure resolved path is within storage directory
        temp_path = os.path.join(self.storage_dir, f"{workflow_id}.json")
        if not os.path.realpath(temp_path).startswith(os.path.realpath(self.storage_dir) + os.sep):
            raise ValueError(f"Path traversal detected in workflow ID: {workflow_id}")'''

# Only replace the first occurrence (in FileWorkflowStorage.save_workflow)
content = content.replace(old_pattern, new_code, 1)

with open(filepath, 'w') as f:
    f.write(content)

print("Patch applied successfully to workflow_storage.py")
EOF

# Verify the patch was applied
if grep -q "Invalid workflow ID" "$TARGET_FILE"; then
    echo "Patch verification: SUCCESS"
else
    echo "Patch verification: FAILED"
    exit 1
fi

# Restart the Flask server to pick up the code changes
# The entrypoint has a while loop that restarts the server after it exits
# We need to kill just the python process (not bash entrypoint)

# Use pidof to find python process and bash builtin kill
PYTHON_PID=$(pidof python 2>/dev/null || pidof python3 2>/dev/null || echo "")

if [ -n "$PYTHON_PID" ]; then
    echo "Killing Python server (PID: $PYTHON_PID) to restart with patched code..."
    kill $PYTHON_PID 2>/dev/null || true

    # Wait for process to terminate
    sleep 2

    # Wait for the server to come back up (entrypoint will restart it)
    for i in $(seq 1 10); do
        if curl -s http://localhost:8080/ >/dev/null 2>&1; then
            echo "Server restarted successfully"
            break
        fi
        sleep 1
    done
else
    echo "Warning: Could not find Python process to restart"
fi

echo "Fix applied successfully."
