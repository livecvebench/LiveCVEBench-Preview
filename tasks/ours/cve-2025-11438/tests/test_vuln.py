"""
Vulnerability tests for OpnForm workspace authorization bypass.

These tests verify that proper authorization is enforced:
- Non-admin users should NOT be able to modify workspace settings
- Only admin users should be able to modify custom domains and email settings

These tests should:
- FAIL in vulnerable state (non-admin can modify settings)
- PASS in fixed state (non-admin gets 403 Forbidden)
"""

import pytest
import requests
import os
import time
import json

BASE_URL = os.environ.get("APP_URL", "http://localhost")

# Test users - admin owns the workspace, viewer has read-only access
ADMIN_EMAIL = "admin@test.com"
ADMIN_PASSWORD = "password123"
VIEWER_EMAIL = "viewer@test.com"
VIEWER_PASSWORD = "password123"


class TestSetup:
    """Helper class for test setup and utilities."""

    @staticmethod
    def get_auth_token(email, password):
        """Get authentication token for a user."""
        response = requests.post(
            f"{BASE_URL}/login",
            json={"email": email, "password": password},
            headers={"Content-Type": "application/json", "Accept": "application/json"},
            timeout=30
        )
        if response.status_code == 200:
            return response.json().get("token")
        return None

    @staticmethod
    def get_workspaces(token):
        """Get list of workspaces for authenticated user."""
        response = requests.get(
            f"{BASE_URL}/open/workspaces",
            headers={
                "Authorization": f"Bearer {token}",
                "Accept": "application/json"
            },
            timeout=30
        )
        if response.status_code == 200:
            data = response.json()
            # Response is a list, not {"data": [...]}
            if isinstance(data, list):
                return data
            return data.get("data", [])
        return []

    @staticmethod
    def wait_for_app():
        """Wait for the application to be ready."""
        for _ in range(30):
            try:
                # Check if the API responds to any request
                response = requests.get(f"{BASE_URL}/healthcheck", timeout=5)
                # Accept any HTTP response as sign that app is running
                return True
            except requests.exceptions.RequestException:
                pass
            time.sleep(1)
        return False


class TestCustomDomainAuthorizationBypass:
    """Test authorization enforcement on custom domains endpoint."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        assert TestSetup.wait_for_app(), "Application is not ready"

        # Get tokens for both users
        self.admin_token = TestSetup.get_auth_token(ADMIN_EMAIL, ADMIN_PASSWORD)
        self.viewer_token = TestSetup.get_auth_token(VIEWER_EMAIL, VIEWER_PASSWORD)

        assert self.admin_token, f"Failed to authenticate as admin user {ADMIN_EMAIL}"
        assert self.viewer_token, f"Failed to authenticate as viewer user {VIEWER_EMAIL}"

        # Get workspace ID (viewer should have access to admin's workspace)
        workspaces = TestSetup.get_workspaces(self.viewer_token)
        assert len(workspaces) > 0, "Viewer should have access to at least one workspace"
        self.workspace_id = workspaces[0]["id"]

    def test_nonadmin_cannot_modify_custom_domains(self):
        """
        Test that non-admin user cannot modify custom domains.

        This is the primary vulnerability test. In the vulnerable state,
        this request will succeed (200 OK). After the fix, it should
        return 403 Forbidden.
        """
        attacker_domain = "attacker-controlled-domain.com"

        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={"custom_domains": [attacker_domain]},
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        # Should get 403 Forbidden - non-admin cannot modify settings
        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to modify custom domains. " \
            f"Expected 403, got {response.status_code}. Response: {response.text}"

    def test_nonadmin_cannot_inject_multiple_domains(self):
        """
        Test that non-admin user cannot inject multiple custom domains.
        """
        malicious_domains = [
            "evil1.com",
            "evil2.com",
            "phishing-site.com"
        ]

        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={"custom_domains": malicious_domains},
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to inject multiple domains. " \
            f"Expected 403, got {response.status_code}."

    def test_nonadmin_cannot_clear_custom_domains(self):
        """
        Test that non-admin user cannot clear/remove custom domains.
        """
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={"custom_domains": []},
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to clear custom domains. " \
            f"Expected 403, got {response.status_code}."

    def test_nonadmin_cannot_modify_with_special_characters(self):
        """
        Test that non-admin user cannot inject subdomains.
        Using valid domain format to ensure authorization is checked.
        """
        # Use valid domain formats that will pass validation
        subdomains = [
            "subdomain.attacker.com",
            "another.evil.com"
        ]

        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={"custom_domains": subdomains},
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        # Should get 403 Forbidden - non-admin cannot modify settings
        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to inject subdomains. " \
            f"Expected 403, got {response.status_code}."


class TestEmailSettingsAuthorizationBypass:
    """Test authorization enforcement on email settings endpoint."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        assert TestSetup.wait_for_app(), "Application is not ready"

        # Get tokens for both users
        self.admin_token = TestSetup.get_auth_token(ADMIN_EMAIL, ADMIN_PASSWORD)
        self.viewer_token = TestSetup.get_auth_token(VIEWER_EMAIL, VIEWER_PASSWORD)

        assert self.admin_token, f"Failed to authenticate as admin user {ADMIN_EMAIL}"
        assert self.viewer_token, f"Failed to authenticate as viewer user {VIEWER_EMAIL}"

        # Get workspace ID
        workspaces = TestSetup.get_workspaces(self.viewer_token)
        assert len(workspaces) > 0, "Viewer should have access to at least one workspace"
        self.workspace_id = workspaces[0]["id"]

    def test_nonadmin_cannot_modify_email_settings(self):
        """
        Test that non-admin user cannot modify email settings.

        This is the secondary vulnerability. In the vulnerable state,
        this request will succeed. After the fix, it should return 403.
        """
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/email-settings",
            json={
                "smtp_host": "attacker-smtp.com",
                "smtp_port": 587
            },
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to modify email settings. " \
            f"Expected 403, got {response.status_code}. Response: {response.text}"

    def test_nonadmin_cannot_inject_malicious_smtp(self):
        """
        Test that non-admin user cannot inject malicious SMTP server.
        """
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/email-settings",
            json={
                "smtp_host": "evil-smtp-intercept.com",
                "smtp_port": 25,
                "smtp_username": "attacker",
                "smtp_password": "password"
            },
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to inject SMTP settings. " \
            f"Expected 403, got {response.status_code}."

    def test_nonadmin_cannot_modify_sender_email(self):
        """
        Test that non-admin user cannot modify sender email address.
        """
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/email-settings",
            json={
                "sender_email": "phishing@attacker.com",
                "sender_name": "Legitimate Company"
            },
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin user should NOT be able to modify sender email. " \
            f"Expected 403, got {response.status_code}."


class TestAuthorizationEdgeCases:
    """Test edge cases in authorization enforcement."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures."""
        assert TestSetup.wait_for_app(), "Application is not ready"

        self.admin_token = TestSetup.get_auth_token(ADMIN_EMAIL, ADMIN_PASSWORD)
        self.viewer_token = TestSetup.get_auth_token(VIEWER_EMAIL, VIEWER_PASSWORD)

        assert self.admin_token, f"Failed to authenticate as admin"
        assert self.viewer_token, f"Failed to authenticate as viewer"

        workspaces = TestSetup.get_workspaces(self.viewer_token)
        assert len(workspaces) > 0, "Viewer should have access to workspace"
        self.workspace_id = workspaces[0]["id"]

    def test_nonadmin_blocked_with_different_content_types(self):
        """
        Test that non-admin is blocked regardless of Content-Type variations.
        """
        # Try with different content type
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            data='{"custom_domains":["attacker.com"]}',
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json; charset=utf-8",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin should be blocked regardless of content-type variation. " \
            f"Got {response.status_code}."

    def test_nonadmin_blocked_with_extra_fields(self):
        """
        Test that non-admin cannot bypass by adding extra fields.
        """
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={
                "custom_domains": ["attacker.com"],
                "bypass_auth": True,
                "role": "admin",
                "is_admin": True
            },
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        assert response.status_code == 403, \
            f"Non-admin should be blocked even with extra fields. " \
            f"Got {response.status_code}."

    def test_repeated_requests_all_blocked(self):
        """
        Test that repeated requests from non-admin are all blocked.
        Ensures there's no race condition or caching issue.
        """
        domains_to_try = [
            ["attempt1.com"],
            ["attempt2.com"],
            ["attempt3.com"]
        ]

        for domains in domains_to_try:
            response = requests.put(
                f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
                json={"custom_domains": domains},
                headers={
                    "Authorization": f"Bearer {self.viewer_token}",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                timeout=30
            )

            assert response.status_code == 403, \
                f"Non-admin should be blocked on all attempts. " \
                f"Failed on {domains}. Got {response.status_code}."

    def test_cross_workspace_access_blocked(self):
        """
        Test that non-admin user cannot modify their own workspace's settings.
        This is the core authorization bypass test - user has access to workspace
        but should not be able to modify settings without admin role.
        """
        # Attempt to modify custom domains in a workspace where user is a member
        # but not an admin - this tests the actual authorization bypass
        response = requests.put(
            f"{BASE_URL}/open/workspaces/{self.workspace_id}/custom-domains",
            json={"custom_domains": ["cross-workspace-test.com"]},
            headers={
                "Authorization": f"Bearer {self.viewer_token}",
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            timeout=30
        )

        # Should get 403 - user is in workspace but not admin
        assert response.status_code == 403, \
            f"Non-admin member should be blocked from modifying workspace settings. " \
            f"Got {response.status_code}."
