"""
Vulnerability tests for Bagisto SSTI in product descriptions.

These tests verify that the Server-Side Template Injection vulnerability
is properly mitigated. The tests should:
- FAIL when the vulnerability exists (Blade template syntax gets executed)
- PASS when the vulnerability is fixed (Blade template syntax is escaped/stripped)

Note: Due to Bagisto 2.x's complex Vue.js-based product creation UI,
these tests use a simplified approach that verifies SSTI behavior by
testing Blade compilation directly.
"""

import pytest
import subprocess
import os
import time
import uuid

# Path to artisan - tests run inside the container at /tests
# The app is at /var/www/html
ARTISAN_PATH = "/var/www/html/artisan"


def run_php_code(code):
    """Run PHP code directly inside the container using artisan tinker."""
    # Create a temporary PHP file to execute
    temp_file = f"/tmp/test_ssti_{uuid.uuid4().hex[:8]}.php"

    # Write the PHP code to a temp file
    php_script = f'''<?php
require_once '/var/www/html/vendor/autoload.php';
$app = require_once '/var/www/html/bootstrap/app.php';
$kernel = $app->make(Illuminate\\Contracts\\Console\\Kernel::class);
$kernel->bootstrap();

{code}
'''

    with open(temp_file, 'w') as f:
        f.write(php_script)

    try:
        result = subprocess.run(
            ['php', temp_file],
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.stdout, result.stderr, result.returncode
    finally:
        if os.path.exists(temp_file):
            os.unlink(temp_file)


class TestSSTIVulnerability:
    """
    Test Server-Side Template Injection vulnerability in product descriptions.

    These tests verify the SSTI vulnerability by:
    1. Testing if Blade compiles and executes template syntax in strings
    2. Checking if the Blade syntax gets executed (vulnerable) or treated as literal

    Tests should FAIL when the vulnerability EXISTS (because the SSTI is triggered).
    Tests should PASS when the vulnerability is FIXED (because the SSTI is blocked).
    """

    def test_basic_ssti_arithmetic(self):
        """
        Test basic SSTI detection with arithmetic expression.

        Payload: {{7*7}}
        VULNERABLE: Blade compiles and executes to "49"
        FIXED: Blade does not compile user strings
        """
        php_code = '''
// Simulate product description with SSTI payload
$description = "<p>Product info: {{7*7}}</p>";

// Test: When Blade compiles this string (as happens in vulnerable versions)
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

// Execute the compiled code
ob_start();
try {
    eval("?>" . $compiled);
    $output = ob_get_clean();

    // If "49" appears, the expression was evaluated
    if (strpos($output, "49") !== false) {
        echo "SSTI_TRIGGERED";
    } else {
        echo "SSTI_SAFE";
    }
} catch (Exception $e) {
    ob_get_clean();
    echo "SSTI_ERROR";
}
'''
        stdout, stderr, code = run_php_code(php_code)

        # VULNERABILITY CHECK:
        # If "SSTI_TRIGGERED", the Blade compileString executed {{7*7}}
        # This test should FAIL when the vulnerability exists
        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: {{7*7}} was evaluated to 49"

    def test_ssti_php_directive(self):
        """
        Test SSTI with @php Blade directive.

        Payload: @php echo 'SSTI_EXECUTED'; @endphp
        VULNERABLE: Blade compiles and executes the PHP code
        FIXED: Directive is not executed
        """
        php_code = """
$description = "<p>Test: @php echo 'MARKER_SSTI_EXEC'; @endphp</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

ob_start();
try {
    eval("?>" . $compiled);
    $output = ob_get_clean();

    if (strpos($output, "MARKER_SSTI_EXEC") !== false) {
        echo "SSTI_TRIGGERED";
    } else {
        echo "SSTI_SAFE";
    }
} catch (Exception $e) {
    ob_get_clean();
    echo "SSTI_ERROR";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: @php directive was executed"

    def test_ssti_config_access(self):
        """
        Test SSTI attempting to access Laravel config.

        Payload: {{ config('app.name') }}
        VULNERABLE: Returns the actual app name from config
        FIXED: Expression is not evaluated (either stripped or literal config() shown)
        """
        php_code = """
$description = "<p>Config: {{ config('app.name') }}</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

ob_start();
try {
    eval("?>" . $compiled);
    $output = ob_get_clean();

    // If config() was executed, it would return "Bagisto" or similar app name
    // The fix should either strip the {{ }} entirely or leave it as literal text
    if (strpos($output, "Bagisto") !== false || strpos($output, "Laravel") !== false) {
        echo "SSTI_TRIGGERED";
    } else {
        // Either the {{ }} was stripped (output: "<p>Config: </p>")
        // or it was left as literal text (output contains "config(" literally)
        // Both cases mean the config() was NOT executed = SAFE
        echo "SSTI_SAFE";
    }
} catch (Exception $e) {
    ob_get_clean();
    echo "SSTI_ERROR";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: config() function was evaluated"

    def test_ssti_env_access(self):
        """
        Test SSTI attempting to access environment variables.

        Payload: {{ env('APP_DEBUG') }}
        VULNERABLE: The env() function is executed (even if it returns empty)
        FIXED: env() is not evaluated

        Note: We check for execution of the Blade echo by looking if the compiled
        code contains the PHP echo statement that Blade generates.
        """
        php_code = """
$description = "<p>Debug: {{ env('APP_DEBUG') }}</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

// Check if Blade compiled the {{ }} syntax into PHP echo statement
// This indicates the vulnerability exists regardless of the output value
if (strpos($compiled, 'env(') !== false && strpos($compiled, 'echo') !== false) {
    echo "SSTI_TRIGGERED";
} else {
    echo "SSTI_SAFE";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: env() function was compiled into executable code"

    def test_ssti_shell_exec(self):
        """
        Test RCE via SSTI with shell command execution.

        Payload: @php echo shell_exec('echo COMMAND_RUN'); @endphp
        VULNERABLE: Command output appears
        FIXED: Command is not executed
        """
        php_code = """
$description = "<p>@php echo shell_exec('echo MARKER_CMD_EXEC'); @endphp</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

ob_start();
try {
    eval("?>" . $compiled);
    $output = ob_get_clean();

    if (strpos($output, "MARKER_CMD_EXEC") !== false) {
        echo "SSTI_TRIGGERED";
    } else {
        echo "SSTI_SAFE";
    }
} catch (Exception $e) {
    ob_get_clean();
    echo "SSTI_ERROR";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "Critical SSTI/RCE vulnerability detected: shell_exec was executed"


class TestMultiplePayloadVectors:
    """Test multiple SSTI payload variations."""

    def test_foreach_directive(self):
        """Test @foreach Blade directive.

        Check if the @foreach is compiled into PHP foreach syntax.
        """
        php_code = """
$description = "<p>Loop: @foreach([1,2,3] as \\$i) {{ \\$i }} @endforeach</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

// Check if Blade compiled the @foreach into PHP foreach
if (strpos($compiled, 'foreach') !== false && strpos($compiled, 'endforeach') !== false) {
    echo "SSTI_TRIGGERED";
} else {
    echo "SSTI_SAFE";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: @foreach directive was compiled"

    def test_include_directive(self):
        """Test @include Blade directive.

        Check if the @include is compiled into PHP include/require syntax.
        """
        php_code = """
$description = "<p>Test: @include('errors.404')</p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

// Check if Blade compiled the @include into PHP include call
if (strpos($compiled, 'echo $__env->make') !== false || strpos($compiled, 'includeIf') !== false || strpos($compiled, 'renderComponent') !== false) {
    echo "SSTI_TRIGGERED";
} else {
    echo "SSTI_SAFE";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: @include directive was compiled"

    def test_raw_php_execution(self):
        """Test raw PHP tag execution through Blade."""
        php_code = """
$description = "<p><?php echo 'RAW_PHP_EXEC'; ?></p>";
$compiled = Illuminate\\Support\\Facades\\Blade::compileString($description);

ob_start();
try {
    eval("?>" . $compiled);
    $output = ob_get_clean();

    if (strpos($output, "RAW_PHP_EXEC") !== false) {
        echo "SSTI_TRIGGERED";
    } else {
        echo "SSTI_SAFE";
    }
} catch (Exception $e) {
    ob_get_clean();
    echo "SSTI_ERROR";
}
"""
        stdout, stderr, code = run_php_code(php_code)

        assert "SSTI_TRIGGERED" not in stdout, \
            "SSTI vulnerability detected: Raw PHP was executed"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
