#!/usr/bin/env python3
"""
Vulnerability tests for Oak header parsing performance issue (ReDoS).

These tests verify that the performance vulnerability is fixed:
- FAIL in vulnerable state (slow response indicates ReDoS)
- PASS in fixed state (fast response regardless of input)
"""

import pytest
import requests
import time
import concurrent.futures

BASE_URL = "http://localhost:8000"
TIMEOUT = 30  # Extended timeout for vulnerable state testing


def wait_for_server(max_retries=30, delay=1):
    """Wait for the server to be ready."""
    for i in range(max_retries):
        try:
            response = requests.get(BASE_URL, timeout=5)
            return True
        except requests.exceptions.RequestException:
            if i < max_retries - 1:
                time.sleep(delay)
    return False


def measure_request_time(headers, timeout=TIMEOUT):
    """
    Send request with given headers and return response time in seconds.
    Returns (elapsed_time, response_or_none, error_or_none)
    """
    start = time.time()
    try:
        response = requests.get(BASE_URL, headers=headers, timeout=timeout)
        elapsed = time.time() - start
        return elapsed, response, None
    except requests.exceptions.Timeout:
        elapsed = time.time() - start
        return elapsed, None, "timeout"
    except requests.exceptions.RequestException as e:
        elapsed = time.time() - start
        return elapsed, None, str(e)


class TestReDoSVulnerability:
    """
    Test that regex-based DoS vulnerability is fixed.

    The vulnerable regex /\\s*,\\s*/ causes exponential backtracking
    when processing headers like 'A' + ' ' * N + 'A'.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before tests."""
        assert wait_for_server(), "Server failed to start"

    def test_redos_x_forwarded_for_medium_payload(self):
        """
        Medium payload (32KB spaces): Should complete quickly after fix.

        Vulnerable behavior: Takes ~1 second
        Fixed behavior: Should complete in < 100ms
        """
        # Create ReDoS payload: 'A' followed by many spaces then 'A'
        payload = 'A' + ' ' * 32000 + 'A'

        elapsed, response, error = measure_request_time({
            "X-Forwarded-For": payload
        })

        # After fix, should be very fast (< 500ms even with overhead)
        # Before fix, this would take ~1 second
        assert elapsed < 0.5, (
            f"Request with 32KB whitespace payload took {elapsed:.2f}s. "
            f"This indicates the regex performance issue is not fixed. "
            f"Expected < 0.5s"
        )
        assert response is not None, f"Request failed: {error}"
        assert response.status_code == 200

    def test_redos_x_forwarded_for_large_payload(self):
        """
        Large payload (64KB spaces): Should complete quickly after fix.

        Vulnerable behavior: Takes ~4 seconds
        Fixed behavior: Should complete in < 200ms
        """
        payload = 'A' + ' ' * 64000 + 'A'

        elapsed, response, error = measure_request_time({
            "X-Forwarded-For": payload
        })

        # After fix, should be very fast
        # Before fix, this would take ~4 seconds
        assert elapsed < 0.5, (
            f"Request with 64KB whitespace payload took {elapsed:.2f}s. "
            f"This indicates the regex performance issue is not fixed. "
            f"Expected < 0.5s"
        )
        assert response is not None, f"Request failed: {error}"
        assert response.status_code == 200

    def test_redos_x_forwarded_for_very_large_payload(self):
        """
        Very large payload (100KB spaces): Should complete quickly after fix.

        Vulnerable behavior: Takes 10+ seconds (would timeout)
        Fixed behavior: Should complete in < 300ms
        """
        payload = 'A' + ' ' * 100000 + 'A'

        elapsed, response, error = measure_request_time({
            "X-Forwarded-For": payload
        }, timeout=20)  # Give extra time but not too much

        # After fix, should be very fast due to 4096 char bounding
        # Before fix, this would cause severe slowdown or timeout
        assert elapsed < 1.0, (
            f"Request with 100KB whitespace payload took {elapsed:.2f}s. "
            f"This indicates the regex performance issue is not fixed. "
            f"Expected < 1.0s"
        )
        # Response should succeed (not timeout)
        assert response is not None or error == "timeout", f"Unexpected error: {error}"

    def test_redos_tabs_and_newlines(self):
        """
        Test with other whitespace characters (tabs, newlines).
        The vulnerable regex /\\s*/ matches all whitespace.
        """
        # Mix of spaces, tabs, and potential newlines
        payload = 'A' + '\t' * 30000 + ' ' * 30000 + 'B'

        elapsed, response, error = measure_request_time({
            "X-Forwarded-For": payload
        })

        assert elapsed < 0.5, (
            f"Request with mixed whitespace took {elapsed:.2f}s. "
            f"This indicates the regex performance issue is not fixed."
        )


class TestInputBounding:
    """
    Test that input length is properly bounded.

    The fix should limit header processing to 4096 characters
    to prevent resource exhaustion.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before tests."""
        assert wait_for_server(), "Server failed to start"

    def test_very_long_header_is_bounded(self):
        """
        Headers longer than 4096 characters should be truncated/bounded.
        This prevents the regex from processing unbounded input.
        """
        # Create a very long header (10000 chars)
        long_header = "10.0.0.1, " * 1000  # ~10000 chars

        elapsed, response, error = measure_request_time({
            "X-Forwarded-For": long_header
        })

        # Should complete quickly regardless of length due to bounding
        assert elapsed < 1.0, f"Long header processing took {elapsed:.2f}s"
        assert response is not None, f"Request failed: {error}"
        assert response.status_code == 200

        # After fix, should have at most 100 IPs due to entry limit
        data = response.json()
        # The number of IPs should be reasonable (not thousands)
        assert len(data["ips"]) <= 100, (
            f"Got {len(data['ips'])} IPs, expected <= 100 after fix"
        )


class TestProtocolValidation:
    """
    Test that X-Forwarded-Proto is properly validated.

    After fix, only "http" and "https" should be accepted.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before tests."""
        assert wait_for_server(), "Server failed to start"

    def test_invalid_protocol_rejected(self):
        """
        Invalid protocol values should fall back to http.

        This prevents protocol injection attacks.
        """
        invalid_protocols = [
            "javascript",
            "file",
            "ftp",
            "data",
        ]

        for proto in invalid_protocols:
            response = requests.get(
                BASE_URL,
                headers={
                    "X-Forwarded-Proto": proto,
                    "X-Forwarded-For": "10.0.0.1"
                },
                timeout=10
            )

            assert response.status_code == 200, f"Request failed for protocol: {proto}"
            data = response.json()

            # After fix, invalid protocols should fall back to http:
            assert data["protocol"] in ["http:", "https:"], (
                f"Protocol '{proto}' was not rejected. "
                f"Got: {data['protocol']}, expected 'http:' or 'https:'"
            )


class TestConcurrentRequests:
    """
    Test behavior under concurrent malicious requests.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before tests."""
        assert wait_for_server(), "Server failed to start"

    def test_concurrent_redos_attempts(self):
        """
        Multiple concurrent ReDoS attempts should not block the server.

        After fix, all requests should complete quickly even under load.
        """
        def make_request(payload_size):
            payload = 'A' + ' ' * payload_size + 'A'
            return measure_request_time({
                "X-Forwarded-For": payload
            }, timeout=15)

        # Send 5 concurrent requests with large payloads
        payload_sizes = [30000, 40000, 50000, 60000, 70000]

        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            start = time.time()
            futures = [executor.submit(make_request, size) for size in payload_sizes]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]
            total_time = time.time() - start

        # All requests should complete
        for elapsed, response, error in results:
            assert response is not None or elapsed < 5.0, (
                f"Concurrent request failed or timed out: {error}"
            )

        # Total time should be reasonable (not sequential processing of ~20 seconds)
        assert total_time < 3.0, (
            f"Concurrent requests took {total_time:.2f}s total. "
            f"Expected < 3s if fix is applied."
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
