diff --git a/test/appSession.customStore.tests.js b/test/appSession.customStore.tests.js
index 4d7ede6..d323ec6 100644
--- a/test/appSession.customStore.tests.js
+++ b/test/appSession.customStore.tests.js
@@ -57,6 +57,7 @@ describe('appSession custom store', () => {
     const store = new RedisStore({ client: redisClient, prefix: '' });
     redisClient.asyncSet = promisify(redisClient.set).bind(redisClient);
     redisClient.asyncGet = promisify(redisClient.get).bind(redisClient);
+    redisClient.asyncDbsize = promisify(redisClient.dbsize).bind(redisClient);
 
     const conf = getConfig({
       ...defaultConfig,
@@ -72,6 +73,7 @@ describe('appSession custom store', () => {
       await new Promise((resolve) => server.close(resolve));
     }
     if (redisClient) {
+      await new Promise((resolve) => redisClient.flushall(resolve));
       await new Promise((resolve) => redisClient.quit(resolve));
     }
   });
@@ -116,6 +118,15 @@ describe('appSession custom store', () => {
     });
   });
 
+  it('should not populate the store when there is no session', async () => {
+    await setup();
+    await request.get('/session', {
+      baseUrl,
+      json: true,
+    });
+    assert.equal(await redisClient.asyncDbsize(), 0);
+  });
+
   it('should get a new session', async () => {
     await setup();
     const jar = await login({ sub: '__foo_user__' });
@@ -126,6 +137,7 @@ describe('appSession custom store', () => {
     });
     assert.equal(res.statusCode, 200);
     assert.deepEqual(res.body, { sub: '__foo_user__' });
+    assert.equal(await redisClient.asyncDbsize(), 1);
   });
 
   it('should destroy an existing session', async () => {
@@ -153,6 +165,7 @@ describe('appSession custom store', () => {
     });
     assert.isEmpty(loggedOutRes.body);
     assert.isEmpty(jar.getCookies(baseUrl));
+    assert.equal(await redisClient.asyncDbsize(), 0);
   });
 
   it('uses custom session id generator when provided', async () => {
@@ -178,6 +191,7 @@ describe('appSession custom store', () => {
       role: 'test',
       userid: immId,
     });
+    assert.equal(await redisClient.asyncDbsize(), 1);
   });
 
   it('should handle storage errors', async () => {
diff --git a/test/callback.tests.js b/test/callback.tests.js
index 7fefa24..f08c8c1 100644
--- a/test/callback.tests.js
+++ b/test/callback.tests.js
@@ -14,6 +14,7 @@ const { makeIdToken } = require('./fixture/cert');
 const clientID = '__test_client_id__';
 const expectedDefaultState = encodeState({ returnTo: 'https://example.org' });
 const nock = require('nock');
+const MemoryStore = require('memorystore')(auth);
 
 const baseUrl = 'http://localhost:3000';
 const defaultConfig = {
@@ -77,6 +78,17 @@ const setup = async (params) => {
       };
     });
 
+  let existingSessionCookie;
+  if (params.existingSession) {
+    await request.post('/session', {
+      baseUrl,
+      jar,
+      json: params.existingSession,
+    });
+    const cookies = jar.getCookies(baseUrl);
+    existingSessionCookie = cookies.find(({ key }) => key === 'appSession');
+  }
+
   const response = await request.post('/callback', {
     baseUrl,
     jar,
@@ -85,6 +97,9 @@ const setup = async (params) => {
   const currentUser = await request
     .get('/user', { baseUrl, jar, json: true })
     .then((r) => r.body);
+  const currentSession = await request
+    .get('/session', { baseUrl, jar, json: true })
+    .then((r) => r.body);
   const tokens = await request
     .get('/tokens', { baseUrl, jar, json: true })
     .then((r) => r.body);
@@ -96,9 +111,11 @@ const setup = async (params) => {
     jar,
     response,
     currentUser,
+    currentSession,
     tokenReqHeader,
     tokenReqBody,
     tokens,
+    existingSessionCookie,
   };
 };
 
@@ -887,4 +904,153 @@ describe('callback response_mode: form_post', () => {
       assert.equal(statusCode, 999);
     });
   });
+
+  it('should replace the cookie session when a new user is logging in over an existing different user', async () => {
+    const { currentSession, currentUser } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'bar' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+    });
+
+    assert.equal(currentUser.sub, 'bar');
+    assert.isUndefined(currentSession.shoppingCartId);
+  });
+
+  it('should preserve the cookie session when a new user is logging in over an anonymous session', async () => {
+    const { currentSession, currentUser } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+      },
+    });
+
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+  });
+
+  it('should preserve session but regenerate session id when a new user is logging in over an anonymous session', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);
+  });
+
+  it('should preserve session when the same user is logging in over their existing session', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'foo');
+    assert.equal(currentSession.shoppingCartId, 'bar');
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.equal(existingSessionCookie.value, newSessionCookie.value);
+  });
+
+  it('should regenerate the session when a new user is logging in over an existing different user', async () => {
+    const store = new MemoryStore({
+      checkPeriod: 24 * 60 * 1000,
+    });
+    const { currentSession, currentUser, existingSessionCookie, jar } = await setup({
+      cookies: generateCookies({
+        state: expectedDefaultState,
+        nonce: '__test_nonce__',
+      }),
+      body: {
+        state: expectedDefaultState,
+        id_token: makeIdToken({ sub: 'bar' }),
+      },
+      existingSession: {
+        shoppingCartId: 'bar',
+        id_token: makeIdToken({ sub: 'foo' }),
+      },
+      authOpts: {
+        session: {
+          store,
+        },
+      },
+    });
+
+    const cookies = jar.getCookies(baseUrl);
+    const newSessionCookie = cookies.find(({ key }) => key === 'appSession');
+    
+    assert.equal(currentUser.sub, 'bar');
+    assert.isUndefined(currentSession.shoppingCartId);
+    assert.equal(
+      store.store.length,
+      1,
+      'There should only be one session in the store'
+    );
+    assert.notEqual(existingSessionCookie.value, newSessionCookie.value);
+  });
 });
