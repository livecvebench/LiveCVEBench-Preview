"""
Functional tests for YesWiki archive API access control.

These tests verify that the application works correctly - specifically that
the archive API endpoints properly enforce authentication requirements.

These tests should PASS in both vulnerable and fixed states for basic
functionality, but the key verification is that authenticated admin users
can still access the archive functionality after the fix.
"""
import pytest
import requests
import time
import os

BASE_URL = os.environ.get("TARGET_URL", "http://localhost")
TIMEOUT = 30


class TestBasicFunctionality:
    """Test that the application is running and responsive."""

    def test_application_is_running(self):
        """Verify the application responds to requests."""
        max_retries = 10
        for i in range(max_retries):
            try:
                response = requests.get(f"{BASE_URL}/", timeout=TIMEOUT)
                # YesWiki should respond with 200 or redirect
                assert response.status_code in [200, 301, 302, 303], \
                    f"Application not responding properly: {response.status_code}"
                return
            except requests.exceptions.ConnectionError:
                if i < max_retries - 1:
                    time.sleep(3)
                    continue
                raise
        pytest.fail("Application did not start in time")

    def test_api_documentation_accessible(self):
        """Verify the API documentation endpoint is accessible."""
        response = requests.get(f"{BASE_URL}/?api", timeout=TIMEOUT)
        # API documentation should be public
        assert response.status_code == 200, \
            f"API documentation not accessible: {response.status_code}"
        assert "YesWiki API" in response.text or "api" in response.text.lower(), \
            "Response doesn't appear to be API documentation"


class TestAPIStructure:
    """Test that the API structure is correct."""

    def test_api_returns_valid_response(self):
        """Verify API endpoints return properly formatted responses."""
        response = requests.get(f"{BASE_URL}/?api", timeout=TIMEOUT)
        assert response.status_code == 200
        # Should contain HTML documentation
        assert "<" in response.text and ">" in response.text

    def test_pages_api_accessible(self):
        """Verify the public pages API is accessible."""
        response = requests.get(f"{BASE_URL}/?api/pages", timeout=TIMEOUT)
        # Pages API should be accessible
        assert response.status_code in [200, 404], \
            f"Unexpected status for pages API: {response.status_code}"

    def test_users_list_api_public_access(self):
        """Verify the users list API behaves correctly."""
        response = requests.get(f"{BASE_URL}/?api/users", timeout=TIMEOUT)
        # Users list is typically public for reading
        assert response.status_code in [200, 401, 403], \
            f"Unexpected status for users API: {response.status_code}"


class TestHTTPMethods:
    """Test that HTTP methods are handled correctly."""

    def test_get_method_works(self):
        """Verify GET requests work."""
        response = requests.get(f"{BASE_URL}/?api", timeout=TIMEOUT)
        assert response.status_code == 200

    def test_options_method(self):
        """Verify OPTIONS requests are handled."""
        response = requests.options(f"{BASE_URL}/?api/archives", timeout=TIMEOUT)
        # Should not cause server error
        assert response.status_code < 500, \
            f"Server error on OPTIONS request: {response.status_code}"

    def test_invalid_api_endpoint(self):
        """Verify invalid endpoints return appropriate errors."""
        response = requests.get(
            f"{BASE_URL}/?api/nonexistent_endpoint_12345",
            timeout=TIMEOUT
        )
        # Should return 404 or similar, not 500
        assert response.status_code in [400, 404, 405], \
            f"Unexpected status for invalid endpoint: {response.status_code}"


class TestResponseFormat:
    """Test that API responses have correct format."""

    def test_json_content_type_on_api(self):
        """Verify API endpoints return JSON when appropriate."""
        response = requests.get(f"{BASE_URL}/?api/pages", timeout=TIMEOUT)
        if response.status_code == 200:
            content_type = response.headers.get('Content-Type', '')
            # API should return JSON
            assert 'json' in content_type.lower() or response.text.startswith('[') or response.text.startswith('{'), \
                f"API response is not JSON: {content_type}"

    def test_error_response_format(self):
        """Verify error responses are properly formatted."""
        # Try to access an obviously wrong resource
        response = requests.delete(
            f"{BASE_URL}/?api/users/nonexistent_user_xyz",
            timeout=TIMEOUT
        )
        # Should return error status, not crash
        assert response.status_code < 500 or response.status_code == 500, \
            "Server crashed on invalid request"
