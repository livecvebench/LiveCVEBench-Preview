#!/bin/bash
# Solution script for path traversal vulnerability in pyLoad
# This applies the fix by sanitizing filenames using werkzeug's secure_filename

set -e

TARGET_FILE="/app/src/pyload/webui/app/blueprints/json_blueprint.py"

echo "Applying fix to ${TARGET_FILE}..."

# Check if file exists
if [ ! -f "$TARGET_FILE" ]; then
    echo "ERROR: Target file not found: ${TARGET_FILE}"
    exit 1
fi

# Check if already fixed (import already exists)
if grep -q "from werkzeug.utils import secure_filename" "$TARGET_FILE"; then
    echo "Fix already applied (import exists). Verifying full fix..."
    if grep -q 'safe_filename = secure_filename(file.filename)' "$TARGET_FILE"; then
        echo "Fix is complete."
        exit 0
    fi
fi

# Apply the fix using Python for reliable text manipulation
python3 << 'PYTHON_SCRIPT'
import re
import sys

target_file = "/app/src/pyload/webui/app/blueprints/json_blueprint.py"

with open(target_file, 'r') as f:
    content = f.read()

original_content = content

# Step 1: Add the import for secure_filename after 'import os'
if 'from werkzeug.utils import secure_filename' not in content:
    content = content.replace(
        'import os\n',
        'import os\nfrom werkzeug.utils import secure_filename\n'
    )
    print("Added import for secure_filename")

# Step 2: Add the secure_filename call and fix the vulnerable line
# We need to find the pattern in add_package function and replace it

# The vulnerable pattern is:
#   file_path = os.path.join(
#       api.get_config_value("general", "storage_folder"), "tmp_" + file.filename
#   )

# We need to add safe_filename = secure_filename(file.filename) before it
# and change file.filename to safe_filename

# Pattern to find the vulnerable code block
vulnerable_pattern = r'(if not package_name or package_name == "New Package":\s+package_name = file\.filename\s+)(file_path = os\.path\.join\(\s+api\.get_config_value\("general", "storage_folder"\), "tmp_" \+ file\.filename\s+\))'

# Replacement with the fix
fixed_replacement = r'''\1safe_filename = secure_filename(file.filename)
            file_path = os.path.join(
                api.get_config_value("general", "storage_folder"), "tmp_" + safe_filename
            )'''

new_content = re.sub(vulnerable_pattern, fixed_replacement, content, flags=re.DOTALL)

if new_content != content:
    print("Applied secure_filename fix to file_path construction")
    content = new_content
else:
    # Try a more specific pattern if the above didn't match
    # Look for just the file_path line
    if '"tmp_" + file.filename' in content and 'safe_filename = secure_filename' not in content:
        # Find and fix line by line
        lines = content.split('\n')
        new_lines = []
        i = 0
        while i < len(lines):
            line = lines[i]
            # Look for the file_path line with vulnerable pattern
            if 'file_path = os.path.join(' in line and i + 2 < len(lines):
                next_line = lines[i + 1]
                if '"tmp_" + file.filename' in next_line:
                    # Get the indentation
                    indent = len(line) - len(line.lstrip())
                    indent_str = ' ' * indent

                    # Add the secure_filename assignment before
                    new_lines.append(indent_str + 'safe_filename = secure_filename(file.filename)')
                    new_lines.append(line)
                    # Replace file.filename with safe_filename in next line
                    new_lines.append(next_line.replace('file.filename', 'safe_filename'))
                    i += 2
                    continue
            new_lines.append(line)
            i += 1
        content = '\n'.join(new_lines)
        print("Applied secure_filename fix using line-by-line approach")

# Write the fixed content
if content != original_content:
    with open(target_file, 'w') as f:
        f.write(content)
    print("Fix applied successfully!")
else:
    print("No changes made - file may already be fixed or pattern not found")
    sys.exit(1)
PYTHON_SCRIPT

# Verify the fix was applied
echo ""
echo "Verifying fix..."
if grep -q "from werkzeug.utils import secure_filename" "$TARGET_FILE" && \
   grep -q "safe_filename = secure_filename" "$TARGET_FILE"; then
    echo "Fix verified successfully!"
else
    echo "WARNING: Fix verification failed"
    exit 1
fi

# Restart pyLoad to apply changes
# Note: pkill is not available in minimal containers, so we find and kill pyload manually
echo ""
echo "Restarting pyLoad service..."

# Find and kill pyload process using /proc filesystem (works in minimal containers)
for pid_dir in /proc/[0-9]*; do
    pid=$(basename "$pid_dir")
    cmdline_file="$pid_dir/cmdline"
    if [ -f "$cmdline_file" ] && grep -q "pyload" "$cmdline_file" 2>/dev/null; then
        # Skip if it's a grep command or bash itself
        cmdline=$(cat "$cmdline_file" 2>/dev/null | tr '\0' ' ')
        if echo "$cmdline" | grep -q "python.*pyload"; then
            echo "Killing pyload process PID $pid"
            kill "$pid" 2>/dev/null || true
        fi
    fi
done

# Wait for entrypoint to restart pyload
echo "Waiting for pyload to restart..."
sleep 5

# Wait for service to become available
for i in $(seq 1 30); do
    if curl -sf http://localhost:8000/ > /dev/null 2>&1; then
        echo "pyLoad service is ready"
        break
    fi
    sleep 1
done

echo "Fix complete. Service restarted successfully."
