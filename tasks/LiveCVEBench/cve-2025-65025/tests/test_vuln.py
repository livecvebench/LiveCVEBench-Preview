#!/usr/bin/env python3
"""
Vulnerability tests for esm.sh path traversal (tarslip) vulnerability.
Tests verify that path traversal payloads in tarball entries can escape the extraction directory.

In VULNERABLE state: Tests should FAIL (file escapes to /tmp successfully)
In FIXED state: Tests should PASS (path traversal is blocked)
"""

import os
import subprocess
import tempfile
import tarfile
import gzip
import io
import shutil
import pytest
import uuid


# Directory where the Go extractor binary is located
EXTRACTOR_BINARY = "/app/test_extractor"

# Fixed escape target directory - we'll check for files here
ESCAPE_DIR = "/tmp/esm_vuln_test_escape"


def create_malicious_tarball(output_path: str, target_path: str, payload_content: str = "TRAVERSAL_SUCCESS"):
    """Create a malicious tarball with path traversal payload."""
    tar_buffer = io.BytesIO()

    with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
        # Add legitimate package.json
        pkg_json = b'{"name": "test-pkg", "version": "1.0.0"}'
        pkg_info = tarfile.TarInfo(name='package/package.json')
        pkg_info.size = len(pkg_json)
        tar.addfile(pkg_info, io.BytesIO(pkg_json))

        # Add legitimate index.js
        index_js = b'module.exports = {};'
        index_info = tarfile.TarInfo(name='package/index.js')
        index_info.size = len(index_js)
        tar.addfile(index_info, io.BytesIO(index_js))

        # Add malicious file with path traversal
        payload_bytes = payload_content.encode('utf-8')
        malicious_info = tarfile.TarInfo(name=f'package/{target_path}')
        malicious_info.size = len(payload_bytes)
        tar.addfile(malicious_info, io.BytesIO(payload_bytes))

    tar_buffer.seek(0)
    with gzip.open(output_path, 'wb') as gz:
        gz.write(tar_buffer.read())


def run_extraction(tarball_path: str, extract_dir: str) -> tuple:
    """Run the Go extractor and return (success, stdout, stderr)."""
    try:
        result = subprocess.run(
            [EXTRACTOR_BINARY, tarball_path, extract_dir],
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.returncode == 0, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return False, "", "Timeout"
    except FileNotFoundError:
        pytest.skip(f"Extractor binary not found at {EXTRACTOR_BINARY}")


@pytest.fixture(scope="module", autouse=True)
def setup_escape_dir():
    """Ensure the escape target directory exists."""
    os.makedirs(ESCAPE_DIR, exist_ok=True)
    yield
    # Cleanup after all tests
    if os.path.exists(ESCAPE_DIR):
        shutil.rmtree(ESCAPE_DIR, ignore_errors=True)


class TestPathTraversalBlocked:
    """Test that path traversal attacks are blocked after the fix."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup test environment."""
        self.test_id = str(uuid.uuid4())[:8]
        self.test_base = tempfile.mkdtemp(prefix="esm_vuln_test_")
        self.tarball_dir = os.path.join(self.test_base, "tarballs")
        self.extract_dir = os.path.join(self.test_base, "extract")

        os.makedirs(self.tarball_dir, exist_ok=True)
        os.makedirs(self.extract_dir, exist_ok=True)

        yield

        if os.path.exists(self.test_base):
            shutil.rmtree(self.test_base)

    def test_basic_traversal_blocked(self):
        """Test that basic path traversal to /tmp is blocked."""
        marker_file = os.path.join(ESCAPE_DIR, f"basic_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "basic.tgz")

        # Clean any previous marker
        if os.path.exists(marker_file):
            os.remove(marker_file)

        # Traversal path: Must start with a directory name (not .) to bypass the dot-prefix check
        # Use enough ../ to escape to /tmp/esm_vuln_test_escape
        traversal_path = f"x/../../../../../../../../../..{marker_file}"

        create_malicious_tarball(tarball_path, traversal_path, "BASIC_TRAVERSAL_PAYLOAD")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        # In vulnerable state, the file WILL exist (test FAILs)
        # In fixed state, the file won't exist (test PASSes)
        assert not os.path.exists(marker_file), \
            f"Path traversal succeeded! File was written to {marker_file}"

    def test_deep_traversal_blocked(self):
        """Test that deep traversal with many ../ is blocked."""
        marker_file = os.path.join(ESCAPE_DIR, f"deep_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "deep.tgz")

        if os.path.exists(marker_file):
            os.remove(marker_file)

        traversal_path = f"deep/../../../../../../../../../../../../../../../../../../..{marker_file}"

        create_malicious_tarball(tarball_path, traversal_path, "DEEP_TRAVERSAL_PAYLOAD")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker_file), \
            f"Deep path traversal succeeded! File was written to {marker_file}"

    def test_mixed_traversal_blocked(self):
        """Test mixed traversal patterns like foo/../../bar/../../../tmp/evil."""
        marker_file = os.path.join(ESCAPE_DIR, f"mixed_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "mixed.tgz")

        if os.path.exists(marker_file):
            os.remove(marker_file)

        traversal_path = f"src/../lib/../../../../../../../../../..{marker_file}"

        create_malicious_tarball(tarball_path, traversal_path, "MIXED_TRAVERSAL_PAYLOAD")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker_file), \
            f"Mixed path traversal succeeded! File was written to {marker_file}"

    def test_traversal_with_nested_dirs(self):
        """Test traversal from nested directory structure."""
        marker_file = os.path.join(ESCAPE_DIR, f"nested_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "nested.tgz")

        if os.path.exists(marker_file):
            os.remove(marker_file)

        traversal_path = f"node_modules/sub-pkg/../../../../../../../../../../..{marker_file}"

        create_malicious_tarball(tarball_path, traversal_path, "NESTED_ESCAPE")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker_file), \
            f"Nested path traversal succeeded! File was written to {marker_file}"


class TestTraversalVariations:
    """Test various path traversal payload variations."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup test environment."""
        self.test_id = str(uuid.uuid4())[:8]
        self.test_base = tempfile.mkdtemp(prefix="esm_variations_")
        self.tarball_dir = os.path.join(self.test_base, "tarballs")
        self.extract_dir = os.path.join(self.test_base, "extract")

        os.makedirs(self.tarball_dir, exist_ok=True)
        os.makedirs(self.extract_dir, exist_ok=True)

        yield

        if os.path.exists(self.test_base):
            shutil.rmtree(self.test_base)

    def test_traversal_to_escape_dir(self):
        """Test traversal attempt to escape directory."""
        marker = os.path.join(ESCAPE_DIR, f"escape_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "escape.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        traversal_path = f"x/../../../../../../../../../..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, "ESCAPE_MARKER")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Traversal succeeded! Marker file exists at {marker}"

    def test_traversal_with_double_dirs(self):
        """Test traversal with double directory components."""
        marker = os.path.join(ESCAPE_DIR, f"double_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "double.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        traversal_path = f"a/b/../../../../../../../../../../..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, "DOUBLE_DIR_TEST")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Traversal succeeded! File at {marker}"

    def test_traversal_alternate_pattern(self):
        """Test traversal with alternating directory pattern."""
        marker = os.path.join(ESCAPE_DIR, f"alternate_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "alternate.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        traversal_path = f"foo/bar/../baz/../../../../../../../../../../..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, "ALTERNATE_TEST")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Traversal succeeded! File at {marker}"

    def test_traversal_long_path(self):
        """Test traversal with long path prefix."""
        marker = os.path.join(ESCAPE_DIR, f"long_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "long.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        traversal_path = f"very/long/nested/path/here/../../../../../../../../../../../../..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, "LONG_PATH_TEST")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Traversal succeeded! File at {marker}"


class TestTraversalDepthVariations:
    """Test various traversal depths."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup test environment."""
        self.test_id = str(uuid.uuid4())[:8]
        self.test_base = tempfile.mkdtemp(prefix="esm_depth_")
        self.tarball_dir = os.path.join(self.test_base, "tarballs")
        self.extract_dir = os.path.join(self.test_base, "extract")

        os.makedirs(self.tarball_dir, exist_ok=True)
        os.makedirs(self.extract_dir, exist_ok=True)

        yield

        if os.path.exists(self.test_base):
            shutil.rmtree(self.test_base)

    # Only test depths that can actually reach the escape directory
    # From /tmp/xxx/extract/node_modules/test-pkg to /tmp/esm_vuln_test_escape
    # We need at least 5 levels to get to /tmp, then traverse to escape dir
    @pytest.mark.parametrize("depth", [5, 7, 10, 15, 20])
    def test_various_traversal_depths(self, depth):
        """Test path traversal with various depths of ../ sequences."""
        traversal = "../" * depth
        marker = os.path.join(ESCAPE_DIR, f"depth_{depth}_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, f"depth_{depth}.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        # Start with dir name, then enough ../ to reach marker
        traversal_path = f"x/{traversal}..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, f"DEPTH_{depth}_PAYLOAD")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Traversal with depth {depth} succeeded! File at {marker}"

    def test_exact_depth_traversal(self):
        """Test traversal with exact depth to reach target."""
        marker = os.path.join(ESCAPE_DIR, f"exact_{self.test_id}.txt")
        tarball_path = os.path.join(self.tarball_dir, "exact.tgz")

        if os.path.exists(marker):
            os.remove(marker)

        # Exactly enough ../ to reach from extract/node_modules/test-pkg to /tmp
        traversal_path = f"x/../../../../../../../../../..{marker}"

        create_malicious_tarball(tarball_path, traversal_path, "EXACT_DEPTH")

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Exact depth traversal succeeded! File at {marker}"


class TestMultiplePayloads:
    """Test tarballs with multiple malicious entries."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup test environment."""
        self.test_id = str(uuid.uuid4())[:8]
        self.test_base = tempfile.mkdtemp(prefix="esm_multi_")
        self.tarball_dir = os.path.join(self.test_base, "tarballs")
        self.extract_dir = os.path.join(self.test_base, "extract")

        os.makedirs(self.tarball_dir, exist_ok=True)
        os.makedirs(self.extract_dir, exist_ok=True)

        yield

        if os.path.exists(self.test_base):
            shutil.rmtree(self.test_base)

    def test_multiple_escape_attempts(self):
        """Test tarball with multiple escape attempts."""
        tarball_path = os.path.join(self.tarball_dir, "multi.tgz")

        markers = [
            os.path.join(ESCAPE_DIR, f"multi_1_{self.test_id}.txt"),
            os.path.join(ESCAPE_DIR, f"multi_2_{self.test_id}.txt"),
            os.path.join(ESCAPE_DIR, f"multi_3_{self.test_id}.txt")
        ]

        # Clean markers
        for m in markers:
            if os.path.exists(m):
                os.remove(m)

        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            # Legitimate file
            pkg_json = b'{"name": "test"}'
            info = tarfile.TarInfo(name='package/package.json')
            info.size = len(pkg_json)
            tar.addfile(info, io.BytesIO(pkg_json))

            # Multiple escape attempts
            for i, marker in enumerate(markers, 1):
                payload = f"MULTI_PAYLOAD_{i}".encode()
                traversal = f"x/../../../../../../../../../..{marker}"
                mal_info = tarfile.TarInfo(name=f'package/{traversal}')
                mal_info.size = len(payload)
                tar.addfile(mal_info, io.BytesIO(payload))

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        # At least one of the markers should exist if vulnerable
        escaped_count = sum(1 for m in markers if os.path.exists(m))
        assert escaped_count == 0, \
            f"Multiple escape attempts succeeded! {escaped_count} files written to {ESCAPE_DIR}"

    def test_mixed_legitimate_and_malicious(self):
        """Test tarball with both legitimate and malicious files."""
        tarball_path = os.path.join(self.tarball_dir, "mixed.tgz")
        marker = os.path.join(ESCAPE_DIR, f"mixed_payload_{self.test_id}.txt")

        if os.path.exists(marker):
            os.remove(marker)

        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            # Legitimate files
            for filename in ['package.json', 'index.js', 'README.md']:
                content = f'// {filename}'.encode()
                info = tarfile.TarInfo(name=f'package/{filename}')
                info.size = len(content)
                tar.addfile(info, io.BytesIO(content))

            # One malicious file hidden among legitimate ones
            payload = b'HIDDEN_PAYLOAD'
            traversal = f"lib/x/../../../../../../../../../..{marker}"
            mal_info = tarfile.TarInfo(name=f'package/{traversal}')
            mal_info.size = len(payload)
            tar.addfile(mal_info, io.BytesIO(payload))

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

        success, stdout, stderr = run_extraction(tarball_path, self.extract_dir)

        assert not os.path.exists(marker), \
            f"Hidden payload escape succeeded! File at {marker}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
