"""
Vulnerability tests for the OIDC URL correction open redirect issue.

These tests verify the vulnerability status:
- FAIL when vulnerable (open redirect is exploitable)
- PASS when fixed (malicious redirects are blocked)

The vulnerability allows attackers to inject arbitrary hosts via
X-Forwarded-Host header, causing users to be redirected to
attacker-controlled domains.
"""

import subprocess
import json
import os
import pytest


def run_tsx_script(script: str, env_vars: dict = None) -> dict:
    """Run a TypeScript script using tsx and return the result."""
    # Wrap the script in an async IIFE to support top-level await
    wrapped_script = f"""
(async () => {{
{script}
}})().catch(e => {{ console.error(e); process.exit(1); }});
"""

    env = {**os.environ}
    if env_vars:
        env.update(env_vars)

    result = subprocess.run(
        ["npx", "tsx", "-e", wrapped_script],
        cwd="/app",
        capture_output=True,
        text=True,
        env=env
    )

    return result


class TestOpenRedirectViaXForwardedHost:
    """
    Test cases for open redirect vulnerability via X-Forwarded-Host header injection.
    These tests should FAIL on vulnerable code and PASS on fixed code.
    """

    def test_malicious_x_forwarded_host_blocked(self):
        """
        Test that X-Forwarded-Host with malicious domain is blocked.

        Attack scenario: Attacker sends request with X-Forwarded-Host: evil.com
        Vulnerable behavior: URL is changed to use evil.com as host
        Fixed behavior: Original URL is returned, evil.com is not used
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'internal.example.com';
            if (header === 'x-forwarded-host') return 'evil.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/oauth/callback/success');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHost: result.host,
    resultHostname: result.hostname,
    containsEvil: result.host.includes('evil')
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        # The result should NOT contain evil.com
        assert data["containsEvil"] == False, \
            f"VULNERABLE: X-Forwarded-Host 'evil.com' was used in redirect URL. " \
            f"Got host: {data['resultHost']}. Expected original URL to be returned."

    def test_phishing_domain_blocked(self):
        """
        Test that phishing domains similar to legitimate domain are blocked.

        Attack scenario: Attacker uses evil-example.com (looks similar to example.com)
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-host') return 'evil-example.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    isPhishingDomain: result.hostname === 'evil-example.com'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["isPhishingDomain"] == False, \
            f"VULNERABLE: Phishing domain 'evil-example.com' was used. " \
            f"Got hostname: {data['resultHostname']}"

    def test_fake_subdomain_attack_blocked(self):
        """
        Test that domains pretending to be subdomains are blocked.

        Attack scenario: fakeexample.com (not a subdomain of example.com)
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'fakeexample.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    usedFakeDomain: result.hostname === 'fakeexample.com'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["usedFakeDomain"] == False, \
            f"VULNERABLE: Fake domain 'fakeexample.com' was accepted. " \
            f"This is NOT a subdomain of example.com."

    def test_external_domain_with_https_blocked(self):
        """
        Test that external domains are blocked even with HTTPS protocol.
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-host') return 'attacker.io';
            if (header === 'x-forwarded-proto') return 'https';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    containsAttacker: result.hostname.includes('attacker')
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["containsAttacker"] == False, \
            f"VULNERABLE: Attacker domain was used. Got: {data['resultHostname']}"


class TestMissingAppUrlConfiguration:
    """
    Test behavior when APP_URL is not configured.
    In fixed code, redirects should be blocked when APP_URL is missing.
    """

    def test_no_app_url_blocks_redirect(self):
        """
        Test that redirects are blocked when APP_URL is not configured.
        This is a security measure - without knowing the legitimate domain,
        no external redirects should be allowed.
        """
        script = """
// Explicitly unset APP_URL
delete process.env.APP_URL;

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'any-domain.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    isOriginalUrl: result.toString() === originalUrl.toString(),
    resultUrl: result.toString()
}));
"""
        # Remove APP_URL from environment
        env = {k: v for k, v in os.environ.items() if k != 'APP_URL'}
        result = run_tsx_script(script, env_vars=env)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["isOriginalUrl"] == True, \
            f"VULNERABLE: Redirect allowed without APP_URL configured. " \
            f"Result URL: {data['resultUrl']}"


class TestVariousAttackPayloads:
    """
    Test various attack payload variations that attackers might use.
    """

    def test_unicode_domain_attack_blocked(self):
        """
        Test that unicode/IDN domain attacks are blocked.
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

// Attacker uses unicode domain that looks like example.com
const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-host') return 'examp1e.com';  // Using '1' instead of 'l'
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    usedMalicious: result.hostname === 'examp1e.com'
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["usedMalicious"] == False, \
            f"VULNERABLE: Lookalike domain 'examp1e.com' was used."

    def test_domain_with_port_attack_blocked(self):
        """
        Test that attacks with non-standard ports are blocked.
        """
        script = """
process.env.APP_URL = 'https://example.com';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'internal.com:3000';
            if (header === 'x-forwarded-host') return 'evil.com:8443';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHost: result.host,
    containsEvil: result.host.includes('evil')
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["containsEvil"] == False, \
            f"VULNERABLE: Evil domain with port was used: {data['resultHost']}"

    def test_credential_harvesting_domain_blocked(self):
        """
        Test that obvious credential harvesting domains are blocked.
        """
        malicious_domains = [
            "login-example.com",
            "example.com.attacker.com",
            "secure-example-login.net",
            "example-auth.io"
        ]

        for domain in malicious_domains:
            script = f"""
process.env.APP_URL = 'https://example.com';

const {{ correctOIDCUrl }} = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {{
    headers: {{
        get: (header) => {{
            if (header === 'host') return 'example.com';
            if (header === 'x-forwarded-host') return '{domain}';
            return null;
        }}
    }}
}};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({{
    testedDomain: '{domain}',
    resultHostname: result.hostname,
    usedMalicious: result.hostname === '{domain}'
}}));
"""
            result = run_tsx_script(script)
            assert result.returncode == 0, f"Script failed for {domain}: {result.stderr}"
            data = json.loads(result.stdout.strip())

            assert data["usedMalicious"] == False, \
                f"VULNERABLE: Credential harvesting domain '{domain}' was used."


class TestLocalhostDevelopmentEnvironment:
    """
    Test external domain blocking in development environment.
    """

    def test_external_domain_blocked_in_dev_environment(self):
        """
        Test that external domains are still blocked in dev environment.
        Even when APP_URL is localhost, external domains should be rejected.
        """
        script = """
process.env.APP_URL = 'http://localhost:3000';

const { correctOIDCUrl } = await import('./packages/utils/src/server/correctOIDCUrl.ts');

const mockRequest = {
    headers: {
        get: (header) => {
            if (header === 'host') return 'localhost:3000';
            if (header === 'x-forwarded-host') return 'evil.com';
            return null;
        }
    }
};

const originalUrl = new URL('http://localhost:3000/auth/callback');
const result = correctOIDCUrl(mockRequest, originalUrl);

console.log(JSON.stringify({
    resultHostname: result.hostname,
    containsEvil: result.hostname.includes('evil')
}));
"""
        result = run_tsx_script(script)
        assert result.returncode == 0, f"Script failed: {result.stderr}"
        data = json.loads(result.stdout.strip())

        assert data["containsEvil"] == False, \
            f"VULNERABLE: External domain allowed in dev environment: {data['resultHostname']}"
