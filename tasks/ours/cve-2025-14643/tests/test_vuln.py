"""
Vulnerability tests for the Simple Attendance Record System.
These tests verify that SQL injection vulnerabilities are mitigated.

- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""

import pytest
import requests
import time

BASE_URL = "http://localhost"
TIMEOUT = 15


class TestBooleanBasedSQLInjection:
    """Test for boolean-based SQL injection vulnerabilities."""

    def test_always_true_condition_injection(self):
        """
        Test SQL injection with always-true condition.
        Payload: 1' OR '1'='1

        If vulnerable: Returns "Success" (bypasses check)
        If fixed: Returns "Error" (injection blocked)
        """
        payload = {"student": "1' OR '1'='1"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # After fix, this should return Error, not Success
        assert "Error" in response.text, \
            f"SQL injection payload returned Success, indicating vulnerability. Response: {response.text}"

    def test_alternative_always_true_injection(self):
        """
        Test with alternative always-true SQL injection.
        Payload: ' OR 1=1-- -
        """
        payload = {"student": "' OR 1=1-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            f"SQL injection with OR 1=1 returned Success, indicating vulnerability"

    def test_numeric_always_true_injection(self):
        """
        Test with numeric always-true condition.
        Payload: 0' OR '1
        """
        payload = {"student": "0' OR '1"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            f"SQL injection with OR '1 returned Success, indicating vulnerability"

    def test_double_quote_with_single_quote_injection(self):
        """
        Test SQL injection that starts with single quote but uses double quotes.
        Payload: ' OR "1"="1"-- -
        This payload uses single quote to break out and double quotes internally.

        If vulnerable: Returns Success (bypasses check)
        If fixed: Returns Error
        """
        payload = {"student": '\' OR "1"="1"-- -'}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # After fix, should return Error (injection blocked)
        assert "Error" in response.text, \
            f"SQL injection with single+double quotes returned Success, indicating vulnerability"


class TestTimeBasedSQLInjection:
    """Test for time-based blind SQL injection vulnerabilities."""

    def test_sleep_injection(self):
        """
        Test SQL injection with SLEEP function.
        Payload: 1' OR SLEEP(3)-- -

        If vulnerable: Response delayed by ~3 seconds
        If fixed: Response is immediate
        """
        payload = {"student": "1' OR SLEEP(3)-- -"}
        start_time = time.time()
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # After fix, response should be fast (under 2 seconds)
        assert elapsed < 2.0, \
            f"Response took {elapsed:.2f}s, indicating time-based SQL injection vulnerability"

    def test_short_sleep_injection(self):
        """
        Test SQL injection with shorter SLEEP to reliably test timing.
        Payload: 1' OR SLEEP(1)-- -

        If vulnerable: Response delayed by 1+ seconds
        If fixed: Response is immediate (under 0.5 seconds)
        """
        payload = {"student": "1' OR SLEEP(1)-- -"}
        start_time = time.time()
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # After fix, response should be fast (under 0.5 seconds)
        assert elapsed < 0.5, \
            f"Response took {elapsed:.2f}s, indicating time-based SQL injection vulnerability"


class TestUnionBasedSQLInjection:
    """Test for union-based SQL injection vulnerabilities."""

    def test_union_select_injection(self):
        """
        Test SQL injection with UNION SELECT.
        Payload: ' UNION SELECT 1,2,3,4,5,6,7-- -

        If vulnerable: May return different results or Success
        If fixed: Returns Error (treated as literal string)
        """
        payload = {"student": "' UNION SELECT 1,2,3,4,5,6,7-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # After fix, this should return Error
        assert "Error" in response.text, \
            f"UNION SELECT injection may have succeeded. Response: {response.text}"

    def test_union_select_null_injection(self):
        """
        Test SQL injection with UNION SELECT NULL.
        Payload: ' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL-- -
        """
        payload = {"student": "' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            "UNION SELECT NULL injection may have succeeded"


class TestCommentBasedInjection:
    """Test for SQL injection using SQL comments."""

    def test_single_line_comment_injection(self):
        """
        Test SQL injection with single-line comment.
        Payload: ' OR '1'='1'--
        """
        payload = {"student": "' OR '1'='1'--"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            "Single-line comment injection succeeded"

    def test_hash_comment_injection(self):
        """
        Test SQL injection with hash comment (MySQL).
        Payload: ' OR '1'='1'#
        """
        payload = {"student": "' OR '1'='1'#"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            "Hash comment injection succeeded"

    def test_multiline_comment_injection(self):
        """
        Test SQL injection with multi-line comment.
        Payload: '/**/OR/**/'1'='1
        """
        payload = {"student": "'/**/OR/**/'1'='1"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            "Multi-line comment injection succeeded"


class TestSpecialCharacterHandling:
    """Test that special SQL characters are properly handled."""

    def test_single_quote_handling(self):
        """
        Test that single quotes in input don't break the query.
        Payload: test'value
        """
        payload = {"student": "test'value"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # Should return Error (not a valid student ID), not crash
        assert "Error" in response.text

    def test_backslash_escape_injection(self):
        """
        Test that backslash escape sequences can be used for SQL injection.
        Payload: \\' OR '1'='1
        The backslash may escape the quote depending on SQL mode.

        If vulnerable: May return Success or Error depending on escaping
        If fixed: Returns Error (treated as literal string)
        """
        # Test with a payload that should work if vulnerable
        payload = {"student": "' OR '1'='1"}  # Standard injection
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # After fix, should return Error
        assert "Error" in response.text, \
            f"Standard SQL injection returned Success, indicating vulnerability"

    def test_semicolon_injection(self):
        """
        Test SQL injection with stacked queries.
        Payload: 121299; DROP TABLE student;--
        """
        payload = {"student": "121299; DROP TABLE student;--"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # After fix, this should be treated as literal and fail
        assert "Error" in response.text, \
            "Stacked query injection may have succeeded"

        # Verify table still exists by checking valid student
        verify_response = requests.post(
            f"{BASE_URL}/check.php",
            data={"student": "121299"},
            timeout=TIMEOUT
        )
        assert "Success" in verify_response.text, \
            "Student table may have been dropped by SQL injection"


class TestEncodedPayloads:
    """Test SQL injection with various encoded payloads."""

    def test_url_encoded_injection(self):
        """
        Test with URL-encoded SQL injection.
        %27 = single quote
        """
        # requests automatically handles URL encoding
        payload = {"student": "1' OR '1'='1"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text

    def test_hex_encoded_string(self):
        """
        Test SQL injection with hex-encoded values.
        Payload: ' OR 0x31=0x31-- -
        """
        payload = {"student": "' OR 0x31=0x31-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        assert "Error" in response.text, \
            "Hex-encoded SQL injection may have succeeded"


class TestDataExfiltration:
    """Test that data exfiltration via SQL injection is prevented."""

    def test_admin_password_extraction_attempt(self):
        """
        Test attempt to extract admin password via UNION SELECT.
        Payload: ' UNION SELECT 1,2,3,4,password,6,7 FROM admin WHERE admin_id=1-- -
        """
        payload = {"student": "' UNION SELECT 1,2,3,4,password,6,7 FROM admin WHERE admin_id=1-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # Should not return admin data
        assert "admin" not in response.text.lower(), \
            "Admin password may have been extracted via SQL injection"
        assert "Error" in response.text

    def test_database_version_extraction(self):
        """
        Test attempt to extract database version.
        Payload: ' UNION SELECT 1,2,3,4,@@version,6,7-- -
        """
        payload = {"student": "' UNION SELECT 1,2,3,4,@@version,6,7-- -"}
        response = requests.post(
            f"{BASE_URL}/check.php",
            data=payload,
            timeout=TIMEOUT
        )
        assert response.status_code == 200
        # Should not reveal database version
        assert "mariadb" not in response.text.lower()
        assert "mysql" not in response.text.lower()
        assert "Error" in response.text
