#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-24367: Cacti line delimiter injection.

These tests verify that the cacti_escapeshellarg() function properly sanitizes
newline characters to prevent command injection via rrdtool.

The vulnerability allows an attacker to inject newline characters into graph
template parameters (like right_axis_label), which breaks out of the rrdtool
command and executes additional rrdtool commands.

- FAIL in vulnerable state (injection creates files - vulnerability exists)
- PASS in fixed state (injection blocked - vulnerability is mitigated)
"""

import os
import re
import time
import uuid
import pytest
import requests
from bs4 import BeautifulSoup

# Configuration
CACTI_URL = os.environ.get("CACTI_URL", "http://localhost/cacti")
CACTI_USER = os.environ.get("CACTI_USER", "admin")
CACTI_PASS = os.environ.get("CACTI_PASS", "admin")


class CactiSession:
    """Helper class to manage Cacti sessions with CSRF handling"""

    def __init__(self):
        self.session = requests.Session()
        self.csrf_token = None

    def get_csrf_token(self, html_content):
        """Extract CSRF token from page content"""
        match = re.search(r'var csrfMagicToken\s*=\s*"(sid:[a-z0-9]+,[a-z0-9]+)', html_content)
        if match:
            return match.group(1)
        return None

    def login(self):
        """Login to Cacti and return True if successful"""
        res = self.session.get(f"{CACTI_URL}/index.php", timeout=30)
        self.csrf_token = self.get_csrf_token(res.text)

        if not self.csrf_token:
            return False

        login_data = {
            '__csrf_magic': self.csrf_token,
            'action': 'login',
            'login_username': CACTI_USER,
            'login_password': CACTI_PASS
        }

        res = self.session.post(f"{CACTI_URL}/index.php", data=login_data, timeout=30)
        return 'You are now logged into' in res.text or 'Console' in res.text


@pytest.fixture(scope="module")
def cacti_session():
    """Create and login a Cacti session for tests"""
    session = CactiSession()
    # Wait for Cacti to be ready
    for _ in range(10):
        try:
            if session.login():
                return session
        except Exception:
            pass
        time.sleep(2)
    pytest.skip("Could not login to Cacti - check credentials")


@pytest.fixture(scope="module")
def template_id(cacti_session):
    """Get template ID 1 which is linked to local_graph_id=1 for testing.

    The vulnerability test modifies a graph template and then triggers graph
    generation via graph_json.php with local_graph_id=1. For the exploit to
    work, we must modify the template that local_graph_id=1 is linked to.
    """
    # Template 1 is linked to local_graph_id=1 in the database setup
    # We must use this specific template for the vulnerability to trigger
    return 1


def inject_newline_payload(cacti_session, template_id, test_marker):
    """
    Inject newline characters in right_axis_label to create a file.

    This exploits CVE-2025-24367 by injecting rrdtool commands via newlines.

    Returns:
        tuple: (injection_attempted, file_created)
    """
    # Get CSRF token for template edit
    response = cacti_session.session.get(
        f"{CACTI_URL}/graph_templates.php?action=template_edit&id={template_id}",
        timeout=30
    )
    csrf_token = cacti_session.get_csrf_token(response.text)

    if not csrf_token:
        return (False, False)

    # Create file path for injection test
    # Use a unique marker to avoid conflicts between tests
    inject_file = f"/var/www/html/cacti/{test_marker}.txt"
    inject_rrd = f"/var/www/html/cacti/rra/{test_marker}.rrd"

    # Craft payload with newline injection
    # CRITICAL: The payload must contain a single quote (') to exploit the vulnerability!
    # When escapeshellarg() processes a single quote, it outputs: 'text'\''
    # This causes the newline after the quote to be OUTSIDE the quotes,
    # allowing rrdtool to interpret it as a command separator.
    # In rrdtool pipe mode, each line is a separate command.
    malicious_payload = (
        f"test'\n"  # Single quote breaks escapeshellarg quoting, newline starts new command
        f"create {inject_rrd} --step 300 DS:val:GAUGE:600:0:U RRA:AVERAGE:0.5:1:100\n"
    )

    template_data = {
        "__csrf_magic": csrf_token,
        "name": "Unix - Logged in Users",
        "graph_template_id": template_id,
        "graph_template_graph_id": template_id,
        "save_component_template": "1",
        "title": "|host_description| - Logged in Users",
        "vertical_label": "users",
        "image_format_id": "3",
        "height": "200",
        "width": "700",
        "base_value": "1000",
        "slope_mode": "on",
        "auto_scale": "on",
        "auto_scale_opts": "2",
        "upper_limit": "100",
        "lower_limit": "0",
        "right_axis": "",
        "right_axis_label": malicious_payload,
        "right_axis_format": "0",
        "action": "save"
    }

    # Submit the malicious template
    cacti_session.session.post(
        f"{CACTI_URL}/graph_templates.php?header=false",
        data=template_data,
        allow_redirects=True,
        timeout=30
    )

    # Trigger graph generation to execute rrdtool commands
    # This uses the local graph that should exist (local_graph_id=1)
    cacti_session.session.get(
        f"{CACTI_URL}/graph_json.php?rra_id=0&local_graph_id=1&graph_start=-3600&graph_end=0&graph_height=200&graph_width=700",
        timeout=30
    )

    # Small delay to ensure file operations complete
    time.sleep(1)

    # Check if injection created files
    rrd_created = os.path.exists(inject_rrd)
    txt_created = os.path.exists(inject_file)

    # Also check via HTTP
    try:
        http_response = cacti_session.session.get(f"{CACTI_URL}/{test_marker}.txt", timeout=10)
        http_accessible = http_response.status_code == 200
    except Exception:
        http_accessible = False

    return (True, rrd_created or txt_created or http_accessible)


def test_newline_injection_blocked(cacti_session, template_id):
    """
    Test that newline injection in right_axis_label is properly blocked.

    This test attempts to inject newlines in a graph template parameter.
    In a vulnerable system, rrdtool will execute the injected commands.
    In a fixed system, newlines are stripped and no injection occurs.

    - FAILS if vulnerable (injected file is created)
    - PASSES if fixed (no file created)
    """
    test_marker = f"vuln_test_{uuid.uuid4().hex[:8]}"

    attempted, file_created = inject_newline_payload(cacti_session, template_id, test_marker)

    if not attempted:
        pytest.skip("Could not perform injection test - CSRF token issue")

    # Test passes if injection was blocked (no file created)
    assert not file_created, (
        f"VULNERABILITY DETECTED (CVE-2025-24367): "
        f"Newline injection created file '{test_marker}'. "
        f"The cacti_escapeshellarg() function must strip newline characters."
    )


def test_mixed_newline_injection_blocked(cacti_session, template_id):
    """
    Test that mixed newline styles (\\r\\n) are also blocked.

    Windows-style line endings should also be sanitized.

    - FAILS if vulnerable
    - PASSES if fixed
    """
    response = cacti_session.session.get(
        f"{CACTI_URL}/graph_templates.php?action=template_edit&id={template_id}",
        timeout=30
    )
    csrf_token = cacti_session.get_csrf_token(response.text)

    if not csrf_token:
        pytest.skip("Could not get CSRF token")

    test_marker = f"crlf_test_{uuid.uuid4().hex[:8]}"
    inject_rrd = f"/var/www/html/cacti/rra/{test_marker}.rrd"

    # Use Windows-style line endings (with single quote to break escapeshellarg)
    malicious_payload = (
        f"test'\r\n"
        f"create {inject_rrd} --step 300 DS:val:GAUGE:600:0:U RRA:AVERAGE:0.5:1:100\r\n"
    )

    template_data = {
        "__csrf_magic": csrf_token,
        "name": "Unix - Logged in Users",
        "graph_template_id": template_id,
        "graph_template_graph_id": template_id,
        "save_component_template": "1",
        "title": "|host_description| - Logged in Users",
        "vertical_label": "users",
        "image_format_id": "3",
        "height": "200",
        "width": "700",
        "base_value": "1000",
        "slope_mode": "on",
        "auto_scale": "on",
        "auto_scale_opts": "2",
        "upper_limit": "100",
        "lower_limit": "0",
        "right_axis": "",
        "right_axis_label": malicious_payload,
        "right_axis_format": "0",
        "action": "save"
    }

    cacti_session.session.post(
        f"{CACTI_URL}/graph_templates.php?header=false",
        data=template_data,
        allow_redirects=True,
        timeout=30
    )

    cacti_session.session.get(
        f"{CACTI_URL}/graph_json.php?rra_id=0&local_graph_id=1&graph_start=-3600&graph_end=0&graph_height=200&graph_width=700",
        timeout=30
    )

    time.sleep(1)

    file_created = os.path.exists(inject_rrd)

    assert not file_created, (
        f"VULNERABILITY DETECTED: "
        f"Windows-style (\\r\\n) newline injection created file '{test_marker}.rrd'. "
        f"Both \\r and \\n must be stripped from input."
    )


def test_rrdtool_command_injection_prevented(cacti_session, template_id):
    """
    Test that arbitrary rrdtool command injection is prevented.

    This test verifies that an attacker cannot execute arbitrary rrdtool
    commands by injecting them via the right_axis_label field.

    - FAILS if vulnerable (arbitrary RRD file created)
    - PASSES if fixed (no RRD file created)
    """
    response = cacti_session.session.get(
        f"{CACTI_URL}/graph_templates.php?action=template_edit&id={template_id}",
        timeout=30
    )
    csrf_token = cacti_session.get_csrf_token(response.text)

    if not csrf_token:
        pytest.skip("Could not get CSRF token")

    test_marker = f"rrd_inject_{uuid.uuid4().hex[:8]}"
    inject_rrd = f"/var/www/html/cacti/rra/{test_marker}.rrd"

    # Attempt to create an RRD file via command injection (with single quote to break escapeshellarg)
    malicious_payload = (
        f"normal_label'\n"
        f"create {inject_rrd} --step 60 DS:data:GAUGE:120:0:U RRA:AVERAGE:0.5:1:1000\n"
    )

    template_data = {
        "__csrf_magic": csrf_token,
        "name": "Unix - Logged in Users",
        "graph_template_id": template_id,
        "graph_template_graph_id": template_id,
        "save_component_template": "1",
        "title": "|host_description| - Logged in Users",
        "vertical_label": "users",
        "image_format_id": "3",
        "height": "200",
        "width": "700",
        "base_value": "1000",
        "slope_mode": "on",
        "auto_scale": "on",
        "auto_scale_opts": "2",
        "upper_limit": "100",
        "lower_limit": "0",
        "right_axis": "",
        "right_axis_label": malicious_payload,
        "right_axis_format": "0",
        "action": "save"
    }

    cacti_session.session.post(
        f"{CACTI_URL}/graph_templates.php?header=false",
        data=template_data,
        allow_redirects=True,
        timeout=30
    )

    # Trigger graph generation
    cacti_session.session.get(
        f"{CACTI_URL}/graph_json.php?rra_id=0&local_graph_id=1&graph_start=-3600&graph_end=0&graph_height=200&graph_width=700",
        timeout=30
    )

    time.sleep(1)

    file_created = os.path.exists(inject_rrd)

    assert not file_created, (
        f"VULNERABILITY DETECTED (CVE-2025-24367): "
        f"RRD command injection succeeded - file '{inject_rrd}' was created. "
        f"The cacti_escapeshellarg() function must sanitize newline characters "
        f"to prevent rrdtool command injection."
    )
