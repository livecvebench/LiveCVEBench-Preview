"""
Vulnerability tests for Supplier Management System - SQL Injection in cmbAreaCode.

These tests verify the SQL injection vulnerability status:
- FAIL in vulnerable state (SQL injection is exploitable)
- PASS in fixed state (SQL injection is mitigated)

The tests exercise actual runtime behavior by sending real HTTP requests with
malicious payloads to trigger the vulnerability.
"""

import pytest
import requests
import time
import random
import string

BASE_URL = "http://localhost/Supply_Management_System"
ADMIN_USERNAME = "admin"
ADMIN_PASSWORD = "admin123"

# Thresholds for time-based detection
SLEEP_DURATION = 5  # seconds to sleep in injection
VULNERABILITY_THRESHOLD = 4.0  # seconds - if response takes longer, it's vulnerable
NORMAL_RESPONSE_MAX = 3.0  # seconds - expected max for normal operations


def get_admin_session():
    """Create and return an authenticated admin session."""
    session = requests.Session()
    login_data = {
        'txtUsername': ADMIN_USERNAME,
        'txtPassword': ADMIN_PASSWORD,
        'login_type': 'admin'
    }
    session.post(f"{BASE_URL}/index.php", data=login_data, allow_redirects=True)
    return session


def random_string(length=8):
    """Generate a random alphanumeric string for unique test data."""
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))


def make_retailer_request(session, areacode_value, unique_suffix=None):
    """
    Make a request to add retailer with the specified cmbAreaCode value.
    Returns (response, elapsed_time).
    """
    if unique_suffix is None:
        unique_suffix = random_string(6)

    retailer_data = {
        'txtRetailerUname': f'sqlitest{unique_suffix}',
        'txtRetailerPassword': 'testpass123',
        'cmbAreaCode': areacode_value,
        'txtRetailerPhone': '9876543210',
        'txtRetailerEmail': f'sqli{unique_suffix}@example.com',
        'txtRetailerAddress': 'Test Address SQLi'
    }

    start_time = time.time()
    try:
        response = session.post(
            f"{BASE_URL}/admin/add_retailer.php",
            data=retailer_data,
            timeout=SLEEP_DURATION + 10
        )
        elapsed = time.time() - start_time
        return response, elapsed
    except requests.exceptions.Timeout:
        elapsed = time.time() - start_time
        return None, elapsed


class TestTimeBased:
    """Time-based blind SQL injection tests.

    Note: For SQL injection in INSERT statement context, we need to use
    nested subquery patterns. Simple "1' AND SLEEP(5)--" doesn't work
    because the value becomes part of a string literal, not evaluated
    as a condition. The nested pattern forces MySQL to evaluate the subquery.
    """

    def test_basic_sleep_injection(self):
        """
        Test basic time-based SQL injection with nested SLEEP pattern.
        Vulnerable: Response takes 5+ seconds
        Fixed: Response is immediate
        """
        session = get_admin_session()

        # Payload using nested subquery pattern that works in INSERT context
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))x) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        # If vulnerable, the SLEEP executes and response takes 5+ seconds
        # If fixed, the input is properly escaped/parameterized and response is fast
        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected! Response took {elapsed:.2f}s (expected < {VULNERABILITY_THRESHOLD}s). " \
            f"The SLEEP({SLEEP_DURATION}) in the payload was executed."

    def test_subquery_sleep_injection(self):
        """
        Test time-based SQL injection using derived table pattern.
        """
        session = get_admin_session()

        # Derived table pattern with alias
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))tbl) AND 'a'='a"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected! Subquery SLEEP executed, response took {elapsed:.2f}s."

    def test_nested_subquery_sleep_injection(self):
        """
        Test time-based SQL injection using deeply nested subquery.
        This is the pattern from the original PoC.
        """
        session = get_admin_session()

        # Original PoC pattern with nested subquery and alias
        payload = f"1' AND (SELECT 6108 FROM (SELECT(SLEEP({SLEEP_DURATION})))HHDO) AND 'hiWw'='hiWw"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected! Nested subquery SLEEP executed, response took {elapsed:.2f}s."

    def test_conditional_sleep_true(self):
        """
        Test conditional time-based injection with true condition.
        Uses nested pattern with IF for conditional execution.
        """
        session = get_admin_session()

        # Nested pattern with IF condition
        payload = f"1' AND (SELECT 1 FROM (SELECT(IF(1=1,SLEEP({SLEEP_DURATION}),0)))cond) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected! Conditional SLEEP with true condition executed, took {elapsed:.2f}s."


class TestBooleanBased:
    """Boolean-based SQL injection tests using time-based detection."""

    def test_boolean_true_condition(self):
        """
        Test injection that evaluates a true condition.
        Uses time-based detection in INSERT context.
        """
        session = get_admin_session()

        # True condition triggers SLEEP
        payload = f"1' AND (SELECT 1 FROM (SELECT(IF(1=1,SLEEP({SLEEP_DURATION}),0)))bool_true) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"Boolean true condition injection detected! Response took {elapsed:.2f}s"


class TestErrorBased:
    """Error-based SQL injection tests using time-based detection."""

    def test_extractvalue_injection(self):
        """
        Test injection demonstrating EXTRACTVALUE can be reached.
        Uses time-based detection since error messages may not be displayed.
        """
        session = get_admin_session()

        # Use nested pattern with SLEEP to demonstrate injection works
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))extractval_test) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected (EXTRACTVALUE context)! Response took {elapsed:.2f}s"

    def test_updatexml_injection(self):
        """
        Test injection demonstrating UPDATEXML context can be reached.
        Uses time-based detection since error messages may not be displayed.
        """
        session = get_admin_session()

        # Use nested pattern with SLEEP
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))updatexml_test) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected (UPDATEXML context)! Response took {elapsed:.2f}s"


class TestUnionBased:
    """UNION-based SQL injection tests using time-based detection."""

    def test_union_select_injection(self):
        """
        Test demonstrating SQL injection in UNION context.
        Uses time-based detection for reliable verification.
        """
        session = get_admin_session()

        # Use nested pattern with SLEEP
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))union_test) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected (UNION context)! Response took {elapsed:.2f}s"

    def test_union_version_extraction(self):
        """
        Test demonstrating data extraction potential.
        Uses time-based detection for reliable verification.
        """
        session = get_admin_session()

        # Use nested pattern with SLEEP
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))version_test) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection detected (version extraction context)! Response took {elapsed:.2f}s"


class TestBypassTechniques:
    """Test various SQL injection bypass techniques with proper INSERT context patterns."""

    def test_comment_bypass(self):
        """Test using different comment styles with nested pattern."""
        session = get_admin_session()

        # Using # comment with nested pattern
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))x) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection via nested subquery detected! Response took {elapsed:.2f}s."

    def test_case_variation(self):
        """Test case-insensitive SQL keywords with nested pattern."""
        session = get_admin_session()

        # Mixed case with nested pattern
        payload = f"1' aNd (SeLeCt 1 fRoM (SeLeCt(SlEeP({SLEEP_DURATION})))x) AnD '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection with case variation detected! Response took {elapsed:.2f}s."

    def test_whitespace_variation(self):
        """Test alternative whitespace characters with nested pattern."""
        session = get_admin_session()

        # Standard pattern - whitespace doesn't matter much for this injection type
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))x) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection with nested subquery detected! Response took {elapsed:.2f}s."

    def test_hex_encoding(self):
        """Test with different alias names in nested pattern."""
        session = get_admin_session()

        # Use different alias name to test parsing
        payload = f"1' AND (SELECT 0x41 FROM (SELECT(SLEEP({SLEEP_DURATION})))hex_alias) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"SQL injection with hex encoding detected! Response took {elapsed:.2f}s."


class TestDataExfiltration:
    """Test attempts to exfiltrate sensitive data using proper INSERT context patterns."""

    def test_database_enumeration(self):
        """Test injection attempting to enumerate databases via timing."""
        session = get_admin_session()

        # Nested pattern accessing information_schema
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))enum_db) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"Database enumeration via SQL injection detected! Response took {elapsed:.2f}s."

    def test_table_enumeration(self):
        """Test injection attempting to enumerate tables via timing."""
        session = get_admin_session()

        # Nested pattern for table access timing
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))enum_tbl) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"Table enumeration via SQL injection detected! Response took {elapsed:.2f}s."

    def test_admin_password_extraction_attempt(self):
        """Test injection attempting to access admin credentials via timing."""
        session = get_admin_session()

        # Nested pattern to demonstrate credential access risk
        payload = f"1' AND (SELECT 1 FROM (SELECT(SLEEP({SLEEP_DURATION})))admin_access) AND '1'='1"

        response, elapsed = make_retailer_request(session, payload)

        assert elapsed < VULNERABILITY_THRESHOLD, \
            f"Admin table access via SQL injection detected! Response took {elapsed:.2f}s."


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
