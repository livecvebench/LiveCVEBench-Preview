#!/usr/bin/env python3
"""
Vulnerability tests for XHTMLWikiPrinter.

These tests verify that the escaping vulnerability is properly fixed.
- FAIL on vulnerable version (escaping bypass exists)
- PASS on fixed version (all dangerous patterns are escaped)

The vulnerability allows attackers to close HTML containers using whitespace
variants of the closing sequence (e.g., {{/html }} with a space), and to
inject opening sequences ({{html}}) that were not escaped in the vulnerable
version.
"""

import subprocess
import pytest
import os


JAVA_TEST_DIR = "/tests"
APP_DIR = "/app"
CLASSPATH = f"{APP_DIR}:{APP_DIR}/lib/*:."


def run_escaping_test(input_str: str, expected_output: str) -> tuple:
    """
    Run an escaping test by invoking the Java helper.
    Returns (matches: bool, actual_output: str)
    """
    compile_cmd = [
        "javac",
        "-cp", CLASSPATH,
        "-d", ".",
        "PrinterTestHelper.java"
    ]

    result = subprocess.run(
        compile_cmd,
        cwd=JAVA_TEST_DIR,
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        pytest.fail(f"Compilation failed: {result.stderr}")

    run_cmd = [
        "java",
        "-cp", CLASSPATH,
        "PrinterTestHelper",
        "escape",
        input_str
    ]

    result = subprocess.run(
        run_cmd,
        cwd=JAVA_TEST_DIR,
        capture_output=True,
        text=True,
        timeout=30
    )

    actual_output = result.stdout.strip()
    return actual_output == expected_output, actual_output


def check_pattern_escaped(input_str: str, dangerous_pattern: str) -> tuple:
    """
    Check if a dangerous pattern is properly escaped in output.
    Returns (is_escaped: bool, actual_output: str)
    """
    compile_cmd = [
        "javac",
        "-cp", CLASSPATH,
        "-d", ".",
        "PrinterTestHelper.java"
    ]

    result = subprocess.run(
        compile_cmd,
        cwd=JAVA_TEST_DIR,
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        pytest.fail(f"Compilation failed: {result.stderr}")

    run_cmd = [
        "java",
        "-cp", CLASSPATH,
        "PrinterTestHelper",
        "escape",
        input_str
    ]

    result = subprocess.run(
        run_cmd,
        cwd=JAVA_TEST_DIR,
        capture_output=True,
        text=True,
        timeout=30
    )

    actual_output = result.stdout.strip()
    # Pattern is escaped if it doesn't appear literally in output
    is_escaped = dangerous_pattern not in actual_output
    return is_escaped, actual_output


class TestClosingTagWhitespaceBypass:
    """
    Test that whitespace variants of the closing tag are properly escaped.

    The vulnerable version only escapes the exact string {{/html}} but the
    wiki syntax parser allows arbitrary whitespace before }}.
    """

    def test_closing_with_space_before_braces(self):
        """
        {{/html }} (with space before }}) must be escaped.
        This is the primary vulnerability bypass.
        """
        input_str = '{{html clean="false"}} {{/html }}'
        expected = '&#123;&#123;html clean="false"}} &#123;&#123;/html }}'

        success, actual = run_escaping_test(input_str, expected)
        assert success, (
            f"Whitespace bypass not fixed! "
            f"Expected: '{expected}' "
            f"Got: '{actual}'"
        )

    def test_closing_with_tab_before_braces(self):
        """
        {{/html\t}} (with tab before }}) must be escaped.
        """
        input_str = "Test {{/html\t}} content"
        # The {{/html should be escaped
        is_escaped, actual = check_pattern_escaped(input_str, "{{/html")
        assert is_escaped, (
            f"Tab variant not escaped! "
            f"Output still contains unescaped pattern: '{actual}'"
        )

    def test_closing_with_multiple_spaces(self):
        """
        {{/html   }} (with multiple spaces) must be escaped.
        """
        input_str = "Test {{/html   }} content"
        is_escaped, actual = check_pattern_escaped(input_str, "{{/html")
        assert is_escaped, (
            f"Multiple space variant not escaped! "
            f"Output: '{actual}'"
        )

    def test_closing_with_newline_before_braces(self):
        """
        {{/html\n}} (with newline before }}) must be escaped.
        """
        input_str = "Test {{/html\n}} content"
        is_escaped, actual = check_pattern_escaped(input_str, "{{/html")
        assert is_escaped, (
            f"Newline variant not escaped! "
            f"Output: '{actual}'"
        )


class TestOpeningTagEscaping:
    """
    Test that opening tag sequences are properly escaped.

    The vulnerable version did not escape {{html}} at all, allowing
    injection of new HTML containers.
    """

    def test_opening_html_macro_escaped(self):
        """
        {{html}} must be escaped to prevent container injection.
        """
        input_str = "{{html}}"
        expected = "&#123;&#123;html}}"

        success, actual = run_escaping_test(input_str, expected)
        assert success, (
            f"Opening macro not escaped! "
            f"Expected: '{expected}' "
            f"Got: '{actual}'"
        )

    def test_opening_with_attributes_escaped(self):
        """
        {{html clean="false"}} must have the {{html escaped.
        """
        input_str = '{{html clean="false"}}'
        is_escaped, actual = check_pattern_escaped(input_str, "{{html")
        assert is_escaped, (
            f"Opening macro with attributes not escaped! "
            f"Output: '{actual}'"
        )

    def test_opening_with_wiki_attribute_escaped(self):
        """
        {{html wiki="true"}} must be escaped.
        """
        input_str = '{{html wiki="true"}}'
        is_escaped, actual = check_pattern_escaped(input_str, "{{html")
        assert is_escaped, (
            f"Opening macro with wiki attribute not escaped! "
            f"Output: '{actual}'"
        )

    def test_partial_opening_at_end_escaped(self):
        """
        Partial {{h at end must be escaped to prevent combination attacks.
        """
        input_str = "Partial open: {{h"
        expected = "Partial open: {&#123;h"

        success, actual = run_escaping_test(input_str, expected)
        assert success, (
            f"Partial opening prefix not escaped! "
            f"Expected: '{expected}' "
            f"Got: '{actual}'"
        )


class TestInjectionPayloads:
    """
    Test realistic injection payloads that would be used in exploitation.
    """

    def test_container_breakout_payload(self):
        """
        Test the actual container breakout payload pattern.
        When user content is wrapped in {{html wiki="true"}}...{{/html}},
        an attacker tries to close early with {{/html }} variant.
        """
        payload = "{{html}}{{/html {{/html}}}}"
        # Both {{html and {{/html should be escaped
        is_html_escaped, actual = check_pattern_escaped(payload, "{{html")
        assert is_html_escaped, (
            f"Breakout payload not neutralized! "
            f"{{{{html still present in: '{actual}'"
        )

    def test_script_injection_attempt(self):
        """
        Test that closing with space followed by script macro is neutralized.
        """
        payload = "{{/html }}{{groovy}}malicious{{/groovy}}"
        is_escaped, actual = check_pattern_escaped(payload, "{{/html ")
        assert is_escaped, (
            f"Script injection payload not neutralized! "
            f"Output: '{actual}'"
        )

    def test_multiple_bypass_attempts(self):
        """
        Test multiple bypass attempts in the same content.
        """
        payload = "{{html}}first{{/html }} and {{html}}second{{/html\t}}"
        is_escaped, actual = check_pattern_escaped(payload, "{{html")
        assert is_escaped, (
            f"Multiple bypass attempts not all neutralized! "
            f"Output: '{actual}'"
        )

    def test_nested_containers_attempt(self):
        """
        Test nested container injection attempt.
        """
        payload = '{{html wiki="true"}}{{html}}inner{{/html}}{{/html }}'
        is_escaped, actual = check_pattern_escaped(payload, "{{html")
        assert is_escaped, (
            f"Nested container injection not neutralized! "
            f"Output: '{actual}'"
        )


class TestPartialPatternEscaping:
    """
    Test that partial patterns at end of content are escaped
    to prevent combination attacks.

    Note: Some partial patterns (like single '{' at end) are handled by
    the vulnerable version too. These tests focus on patterns that are
    ONLY escaped in the fixed version.
    """

    def test_partial_opening_at_end(self):
        """{{html at end must be escaped."""
        input_str = "Content ending with {{html"
        is_escaped, actual = check_pattern_escaped(input_str, "{{html")
        assert is_escaped, (
            f"Partial opening at end not escaped! "
            f"Output: '{actual}'"
        )


class TestCaseVariations:
    """
    Test various case and format variations.
    Note: XWiki macro names are case-sensitive, so {{HTML}} is different.
    """

    def test_lowercase_html_escaped(self):
        """{{html}} lowercase must be escaped."""
        input_str = "{{html}}"
        is_escaped, actual = check_pattern_escaped(input_str, "{{html")
        assert is_escaped, f"Lowercase not escaped: '{actual}'"
