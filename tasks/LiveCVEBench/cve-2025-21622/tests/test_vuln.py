"""
Vulnerability tests for ClipBucket path traversal in avatar deletion.

These tests check for the path traversal vulnerability:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerability allows arbitrary file deletion through path traversal
sequences in the avatar_url field when triggering avatar deletion.
"""

import os
import re


class TestPathTraversalVulnerability:
    """Test for path traversal vulnerability in avatar deletion."""

    def test_avatar_deletion_uses_safe_field(self):
        """
        Test that avatar deletion uses the 'avatar' field, not 'avatar_url'.

        VULNERABLE CODE uses avatar_url:
            $file = DirPath::get('avatars') . $udetails['avatar_url'];

        FIXED CODE uses avatar (safe filename only):
            $file = DirPath::get('avatars') . $udetails['avatar'];

        This is the critical fix - the avatar field only contains filenames
        set during upload, while avatar_url can contain user-controlled paths
        including traversal sequences like '../../'.
        """
        user_class_path = "/app/upload/includes/classes/user.class.php"

        with open(user_class_path, 'r') as f:
            content = f.read()

        # Find the update_user_avatar_bg function
        func_match = re.search(
            r'function\s+update_user_avatar_bg\s*\([^)]*\)\s*\{',
            content
        )
        assert func_match, "update_user_avatar_bg function not found"

        # Extract the function body (find matching braces)
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start

        for i, char in enumerate(content[func_start:], start=func_start):
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    func_end = i
                    break

        func_body = content[func_match.start():func_end + 1]

        # Check for the delete_avatar section
        delete_section_match = re.search(
            r"if\s*\(\s*\$array\s*\[\s*['\"]delete_avatar['\"]\s*\].*?\{(.*?)\}",
            func_body,
            re.DOTALL
        )

        # The vulnerable pattern: uses avatar_url for file path construction
        vulnerable_pattern = r"DirPath::get\s*\(\s*['\"]avatars['\"]\s*\)\s*\.\s*\$udetails\s*\[\s*['\"]avatar_url['\"]\s*\]"

        # The fixed pattern: uses avatar for file path construction
        fixed_pattern = r"DirPath::get\s*\(\s*['\"]avatars['\"]\s*\)\s*\.\s*\$udetails\s*\[\s*['\"]avatar['\"]\s*\]"

        has_vulnerable_code = bool(re.search(vulnerable_pattern, func_body))
        has_fixed_code = bool(re.search(fixed_pattern, func_body))

        # VULNERABLE if it uses avatar_url for file path construction
        # FIXED if it uses avatar (without _url) for file path construction
        assert not has_vulnerable_code, (
            "VULNERABILITY DETECTED: Code uses avatar_url for file deletion path. "
            "This allows path traversal attacks where an attacker can set avatar_url "
            "to '../../../../../../etc/passwd' and delete arbitrary files. "
            "Fix: Change to use $udetails['avatar'] instead of $udetails['avatar_url']"
        )

        assert has_fixed_code, (
            "Fix not properly applied: The file deletion should use "
            "$udetails['avatar'] (safe filename) instead of $udetails['avatar_url'] "
            "(user-controlled path)"
        )

    def test_avatar_url_has_url_validation(self):
        """
        Test that avatar_url input is validated as a proper URL.

        VULNERABLE CODE accepts any input:
            $uquery_field[] = 'avatar_url';
            $uquery_val[] = $array['avatar_url'];

        FIXED CODE validates URL format:
            if( filter_var($array['avatar_url'], FILTER_VALIDATE_URL) || empty($array['avatar_url']) ){
                $uquery_field[] = 'avatar_url';
                $uquery_val[] = $array['avatar_url'];
            }

        This prevents storing path traversal sequences like '../../' as avatar_url.
        """
        user_class_path = "/app/upload/includes/classes/user.class.php"

        with open(user_class_path, 'r') as f:
            content = f.read()

        # Find the update_user_avatar_bg function
        func_match = re.search(
            r'function\s+update_user_avatar_bg\s*\([^)]*\)\s*\{',
            content
        )
        assert func_match, "update_user_avatar_bg function not found"

        # Extract the function body
        func_start = func_match.end()
        brace_count = 1
        func_end = func_start

        for i, char in enumerate(content[func_start:], start=func_start):
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    func_end = i
                    break

        func_body = content[func_match.start():func_end + 1]

        # Check for URL validation using filter_var with FILTER_VALIDATE_URL
        url_validation_pattern = r"filter_var\s*\(\s*\$array\s*\[\s*['\"]avatar_url['\"]\s*\]\s*,\s*FILTER_VALIDATE_URL\s*\)"

        has_url_validation = bool(re.search(url_validation_pattern, func_body))

        assert has_url_validation, (
            "VULNERABILITY DETECTED: avatar_url input is not validated as a URL. "
            "This allows storing path traversal sequences like '../../' in the database. "
            "Fix: Add filter_var($array['avatar_url'], FILTER_VALIDATE_URL) validation "
            "before storing the avatar_url value."
        )


class TestPathTraversalPatterns:
    """Additional tests for path traversal patterns in the codebase."""

    def test_no_direct_avatar_url_in_unlink(self):
        """
        Test that avatar_url is not used directly in any unlink or file_exists call.

        Path traversal attacks are possible when user input is used directly
        in file system operations without validation.
        """
        user_class_path = "/app/upload/includes/classes/user.class.php"

        with open(user_class_path, 'r') as f:
            content = f.read()

        # Look for dangerous patterns where avatar_url is used near file operations
        # Pattern: any path construction using avatar_url followed by unlink
        dangerous_pattern = r"\$udetails\s*\[\s*['\"]avatar_url['\"]\s*\].*?unlink"

        # Search within a reasonable window (500 chars) for the pattern
        lines = content.split('\n')
        for i, line in enumerate(lines):
            if "avatar_url" in line and "DirPath" in line:
                # Check surrounding lines for unlink
                context = '\n'.join(lines[max(0, i-2):min(len(lines), i+5)])
                if "unlink" in context:
                    # This is suspicious - check if it's the vulnerable pattern
                    if re.search(r"DirPath::get.*avatar_url.*unlink|avatar_url.*DirPath::get.*unlink", context, re.DOTALL):
                        raise AssertionError(
                            f"Potential path traversal vulnerability detected near line {i+1}: "
                            f"avatar_url is used in file path construction near unlink() call. "
                            f"Context:\n{context}"
                        )

    def test_upload_class_type_parameters(self):
        """
        Test that upload_user_file uses explicit type names, not short aliases.

        VULNERABLE CODE uses short aliases that could be ambiguous:
            $Upload->upload_user_file('a', $_FILES['avatar_file'], user_id());

        FIXED CODE uses explicit type names:
            Upload::getInstance()->upload_user_file('avatar', $_FILES['avatar_file'], user_id());

        While not directly exploitable, using explicit names is better practice.
        """
        user_class_path = "/app/upload/includes/classes/user.class.php"

        with open(user_class_path, 'r') as f:
            content = f.read()

        # Check for the old pattern with single-letter type
        old_pattern_avatar = r"upload_user_file\s*\(\s*['\"]a['\"]"
        old_pattern_bg = r"upload_user_file\s*\(\s*['\"]b['\"]"

        has_old_avatar_pattern = bool(re.search(old_pattern_avatar, content))
        has_old_bg_pattern = bool(re.search(old_pattern_bg, content))

        # Note: This is a secondary check, not critical for the main vulnerability
        # but indicates proper fix application
        assert not has_old_avatar_pattern and not has_old_bg_pattern, (
            "VULNERABILITY INDICATOR: Code uses single-letter type parameters in upload_user_file calls. "
            "While not directly exploitable, this suggests the fix has not been fully applied. "
            f"Found avatar pattern: {has_old_avatar_pattern}, bg pattern: {has_old_bg_pattern}. "
            "Fix: Change from upload_user_file('a', ...) to upload_user_file('avatar', ...)"
        )
