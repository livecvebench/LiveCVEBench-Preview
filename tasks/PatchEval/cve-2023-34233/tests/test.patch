diff --git a/test/unit/test_auth_webbrowser.py b/test/unit/test_auth_webbrowser.py
index 39c9b94f82..6791a015c1 100644
--- a/test/unit/test_auth_webbrowser.py
+++ b/test/unit/test_auth_webbrowser.py
@@ -32,6 +32,7 @@
 SERVICE_NAME = ""
 REF_PROOF_KEY = "MOCK_PROOF_KEY"
 REF_SSO_URL = "https://testsso.snowflake.net/sso"
+INVALID_SSO_URL = "this is an invalid URL"
 
 
 def mock_webserver(target_instance, application, port):
@@ -318,3 +319,39 @@ class StopExecuting(Exception):
                     account="account",
                     auth_class=auth_inst,
                 )
+
+
+def test_auth_webbrowser_invalid_sso(monkeypatch):
+    """Authentication by WebBrowser with failed to start web browser case."""
+    rest = _init_rest(INVALID_SSO_URL, REF_PROOF_KEY)
+
+    # mock webbrowser
+    mock_webbrowser = MagicMock()
+    mock_webbrowser.open_new.return_value = False
+
+    # mock socket
+    mock_socket_instance = MagicMock()
+    mock_socket_instance.getsockname.return_value = [None, 12345]
+
+    mock_socket_client = MagicMock()
+    mock_socket_client.recv.return_value = (
+        "\r\n".join(["GET /?token=MOCK_TOKEN HTTP/1.1", "User-Agent: snowflake-agent"])
+    ).encode("utf-8")
+    mock_socket_instance.accept.return_value = (mock_socket_client, None)
+    mock_socket = Mock(return_value=mock_socket_instance)
+
+    auth = AuthByWebBrowser(
+        application=APPLICATION,
+        webbrowser_pkg=mock_webbrowser,
+        socket_pkg=mock_socket,
+    )
+    auth.prepare(
+        conn=rest._connection,
+        authenticator=AUTHENTICATOR,
+        service_name=SERVICE_NAME,
+        account=ACCOUNT,
+        user=USER,
+        password=PASSWORD,
+    )
+    assert rest._connection.errorhandler.called  # an error
+    assert auth.assertion_content is None
diff --git a/test/unit/test_url_util.py b/test/unit/test_url_util.py
new file mode 100644
index 0000000000..8ed8d5287f
--- /dev/null
+++ b/test/unit/test_url_util.py
@@ -0,0 +1,26 @@
+#
+# Copyright (c) 2012-2023 Snowflake Computing Inc. All rights reserved.
+#
+
+try:
+    from snowflake.connector.url_util import is_valid_url, url_encode_str
+except ImportError:
+
+    def is_valid_url(s):
+        return False
+
+
+def test_url_validator():
+    assert is_valid_url("https://ssoTestURL.okta.com")
+    assert is_valid_url("https://ssoTestURL.okta.com:8080")
+    assert is_valid_url("https://ssoTestURL.okta.com/testpathvalue")
+
+    assert not is_valid_url("-a Calculator")
+    assert not is_valid_url("This is a random text")
+    assert not is_valid_url("file://TestForFile")
+
+
+def test_encoder():
+    assert url_encode_str("Hello @World") == "Hello+%40World"
+    assert url_encode_str("Test//String") == "Test%2F%2FString"
+    assert url_encode_str(None) == ""
diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..2d21b0b
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,92 @@
+import unittest
+from unittest.mock import MagicMock, patch
+import sys
+import os
+
+# --------------------------------------------------------------------------------
+# Ensure this script can find the snowflake.connector module.
+# The script should be run from the parent directory of projects/snowflake-connector-python (i.e., AVR_Bench),
+# or the snowflake-connector-python/src directory should be in PYTHONPATH.
+# For convenience, we dynamically add the src directory to the path.
+# --------------------------------------------------------------------------------
+
+# Need to add the src directory to the python path
+# projects/snowflake-connector-python/src
+try:
+    # Get the directory where this script is located
+    script_dir = os.path.dirname(os.path.realpath(__file__))
+    src_path = os.path.join(script_dir, "src")
+    if src_path not in sys.path:
+        sys.path.insert(0, src_path)
+    from snowflake.connector.auth.webbrowser import AuthByWebBrowser
+except ImportError as e:
+    sys.stderr.write(f"Failed to import Snowflake module: {e}\nPlease ensure this script is located under 'projects/snowflake-connector-python'.\n")
+    sys.exit(1)
+
+# --- Helper classes for creating precise mock objects ---
+class MockConnection:
+    """A helper class that precisely simulates the structure required by the SnowflakeConnection object."""
+    def __init__(self, sso_url=""):
+        # Details
+        self._connection_details = MagicMock()
+        self._connection_details.application = "HandwrittenTest"
+        self._connection_details.client_version = "1.0.0"
+        self._connection_details.client_revision = "test_rev"
+
+        # Mock REST client
+        self._rest = MagicMock()
+        self._rest._connection = self._connection_details
+        self._rest.post.return_value = {
+            'data': { 'token': sso_url, 'proofkey': 'mock_proof_key' },
+            'success': True
+        }
+        
+        # Attributes of the top-level connection object
+        self.errorhandler = MagicMock()
+
+class HandWrittenVulnerabilityTest(unittest.TestCase):
+    """CVE-2023-34233"""
+
+    @patch('snowflake.connector.auth.webbrowser.AuthByWebBrowser._get_sso_url')
+    def test_sso_url_validation_vulnerability(self, mock_get_sso_url):
+        """
+        Test the validation logic by mocking _get_sso_url to directly return an invalid URL.
+        - Vulnerable code: will attempt to open the invalid URL, causing open_new() to be called, and the test fails.
+        - Fixed code: will not attempt to open the invalid URL, open_new() is not called, and the test passes.
+        """
+        # 1. Set up mocks
+        INVALID_SSO_URL = "this is an invalid URL"
+        mock_get_sso_url.return_value = INVALID_SSO_URL
+        
+        mock_conn = MagicMock(name="connection_mock")
+        mock_webbrowser = MagicMock(name="webbrowser_mock")
+        # Force code in the vulnerable version to take the 'if not open_new()' branch, avoiding subsequent complex socket logic
+        mock_webbrowser.open_new.return_value = False 
+        
+        # Even if the execution path is changed, socket is still called at the start of prepare; provide a simple mock
+        mock_socket = MagicMock(name="socket_mock")
+
+        # 2. Execute
+        auth = AuthByWebBrowser(
+            application="TestApplication",
+            webbrowser_pkg=mock_webbrowser,
+            socket_pkg=mock_socket,
+        )
+        
+        # Use patch to mock input() to prevent the test from hanging on the vulnerable code path
+        with patch('builtins.input', return_value=""):
+            auth.prepare(
+                conn=mock_conn,
+                authenticator="https://test.authenticator.com",
+                service_name="",
+                account="test_account",
+                user="test_user"
+            )
+
+        # 3. Assertions
+        # The fixed code should not call open_new; the vulnerable code would call it, triggering an AssertionError
+        mock_webbrowser.open_new.assert_not_called()
+
+if __name__ == '__main__':
+    # Use the standard unittest runner; it will automatically handle exit codes and output formatting
+    unittest.main(verbosity=2) 
\ No newline at end of file
