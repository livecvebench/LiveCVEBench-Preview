"""
Functional tests for i-Educar enrollment listing page.
These tests verify that the application works correctly in both vulnerable and fixed states.
"""

import pytest
import requests
import time
import os

BASE_URL = os.environ.get("BASE_URL", "http://localhost")
LOGIN_URL = f"{BASE_URL}/login"
TARGET_URL = f"{BASE_URL}/intranet/educar_matricula_lst.php"

# Default credentials
USERNAME = os.environ.get("TEST_USERNAME", "admin")
PASSWORD = os.environ.get("TEST_PASSWORD", "123456789")


class TestSession:
    """Shared session for authenticated tests."""
    _session = None
    _cookies = None

    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            cls._cookies = cls._authenticate()
        return cls._session, cls._cookies

    @classmethod
    def _authenticate(cls):
        """Authenticate and return session cookies."""
        session = cls._session

        # Get login page to obtain CSRF token
        response = session.get(LOGIN_URL, timeout=30)

        # Try to find CSRF token in different formats
        csrf_token = None

        # Check for Laravel CSRF token in cookies
        if 'XSRF-TOKEN' in session.cookies:
            csrf_token = session.cookies['XSRF-TOKEN']

        # Check for token in HTML meta tag
        if csrf_token is None and 'csrf-token' in response.text:
            import re
            match = re.search(r'<meta name="csrf-token" content="([^"]+)"', response.text)
            if match:
                csrf_token = match.group(1)

        # Check for _token in form
        if csrf_token is None and '_token' in response.text:
            import re
            match = re.search(r'name="_token"[^>]*value="([^"]+)"', response.text)
            if match:
                csrf_token = match.group(1)

        # Attempt login
        login_data = {
            "login": USERNAME,
            "password": PASSWORD,
        }

        if csrf_token:
            login_data["_token"] = csrf_token

        headers = {}
        if csrf_token:
            headers["X-XSRF-TOKEN"] = csrf_token

        login_response = session.post(
            LOGIN_URL,
            data=login_data,
            headers=headers,
            allow_redirects=True,
            timeout=30
        )

        return session.cookies


@pytest.fixture(scope="module")
def auth_session():
    """Provide an authenticated session for tests."""
    return TestSession.get_session()


def wait_for_app(max_retries=30, delay=2):
    """Wait for the application to be ready."""
    for _ in range(max_retries):
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code in [200, 302, 301]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


class TestApplicationAvailability:
    """Test that the application is running and accessible."""

    def test_app_is_running(self):
        """Verify the application responds to requests."""
        assert wait_for_app(), "Application failed to start within timeout"

    def test_login_page_accessible(self):
        """Verify the login page is accessible."""
        response = requests.get(LOGIN_URL, timeout=30)
        assert response.status_code in [200, 302], f"Login page returned {response.status_code}"


class TestEnrollmentListingFunctionality:
    """Test basic functionality of the enrollment listing page."""

    def test_page_loads_with_valid_integer_id(self, auth_session):
        """Test that page loads correctly with a valid integer ref_cod_aluno."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": "1"},
            timeout=30
        )

        # The page should load (200) or redirect (302) if student doesn't exist
        assert response.status_code in [200, 302, 301], \
            f"Expected 200 or redirect, got {response.status_code}"

    def test_page_redirects_without_aluno_id(self, auth_session):
        """Test that page redirects when ref_cod_aluno is missing."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            allow_redirects=False,
            timeout=30
        )

        # Should redirect to student listing page when no ref_cod_aluno
        assert response.status_code in [302, 301, 200], \
            f"Expected redirect or OK, got {response.status_code}"

    def test_page_handles_numeric_string(self, auth_session):
        """Test that page handles numeric string input correctly."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": "12345"},
            timeout=30
        )

        assert response.status_code in [200, 302, 301], \
            f"Expected 200 or redirect, got {response.status_code}"

    def test_page_handles_zero_value(self, auth_session):
        """Test that page handles zero value correctly."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": "0"},
            allow_redirects=False,
            timeout=30
        )

        # Zero should be treated as empty/invalid and redirect
        assert response.status_code in [200, 302, 301], \
            f"Expected redirect, got {response.status_code}"

    def test_page_with_escola_parameter(self, auth_session):
        """Test that page works with both ref_cod_aluno and ref_cod_escola."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={
                "ref_cod_aluno": "1",
                "ref_cod_escola": "1"
            },
            timeout=30
        )

        # Accept 200, redirect, or 500 (app may error due to missing data)
        assert response.status_code in [200, 302, 301, 500], \
            f"Expected 200, redirect, or 500, got {response.status_code}"


class TestInputHandling:
    """Test proper input handling behavior."""

    def test_empty_parameter_handling(self, auth_session):
        """Test that empty parameter is handled correctly."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": ""},
            allow_redirects=False,
            timeout=30
        )

        # Empty value should redirect
        assert response.status_code in [302, 301, 200], \
            f"Expected redirect, got {response.status_code}"

    def test_negative_number_handling(self, auth_session):
        """Test that negative numbers are handled (should be treated as 0 or fail gracefully)."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": "-1"},
            timeout=30
        )

        # Should not crash
        assert response.status_code in [200, 302, 301, 400], \
            f"Unexpected status code {response.status_code}"

    def test_large_number_handling(self, auth_session):
        """Test that large numbers are handled without error."""
        session, cookies = auth_session

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": "999999999"},
            timeout=30
        )

        # Should return page or redirect, not crash
        assert response.status_code in [200, 302, 301], \
            f"Expected 200 or redirect, got {response.status_code}"
