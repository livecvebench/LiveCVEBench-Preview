#!/usr/bin/env python3
"""
Functionality tests for H2O HTTP/2 server.
These tests verify that the server correctly handles valid HTTP/2 requests.
Should PASS in both vulnerable and fixed states.
"""

import ssl
import socket
import struct
import pytest
from h2.connection import H2Connection
from h2.config import H2Configuration
from h2.events import ResponseReceived, DataReceived, StreamEnded, SettingsAcknowledged


TARGET_HOST = "localhost"
TARGET_PORT = 8081  # HTTPS port
TIMEOUT = 5


def create_ssl_context():
    """Create SSL context for HTTP/2 connection."""
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    ctx.set_alpn_protocols(["h2"])
    return ctx


def open_h2_connection():
    """Open TLS socket with HTTP/2 ALPN negotiation and return socket + h2 connection."""
    ctx = create_ssl_context()
    sock = socket.create_connection((TARGET_HOST, TARGET_PORT), timeout=TIMEOUT)
    tls_sock = ctx.wrap_socket(sock, server_hostname=TARGET_HOST)

    if tls_sock.selected_alpn_protocol() != "h2":
        raise RuntimeError("ALPN did not negotiate h2")

    config = H2Configuration(client_side=True)
    h2_conn = H2Connection(config=config)
    h2_conn.initiate_connection()
    tls_sock.sendall(h2_conn.data_to_send())

    # Receive server settings
    tls_sock.settimeout(TIMEOUT)
    data = tls_sock.recv(65535)
    if data:
        h2_conn.receive_data(data)
        tls_sock.sendall(h2_conn.data_to_send())

    return tls_sock, h2_conn


def send_request_and_get_response(sock, h2_conn, path="/", end_stream=True):
    """Send a GET request and collect the response."""
    stream_id = h2_conn.get_next_available_stream_id()

    headers = [
        (":method", "GET"),
        (":scheme", "https"),
        (":authority", TARGET_HOST),
        (":path", path),
        ("user-agent", "h2o-func-test"),
    ]

    h2_conn.send_headers(stream_id, headers, end_stream=end_stream)
    sock.sendall(h2_conn.data_to_send())

    response_headers = None
    response_data = b""
    stream_ended = False

    sock.settimeout(TIMEOUT)
    while not stream_ended:
        try:
            data = sock.recv(65535)
            if not data:
                break

            events = h2_conn.receive_data(data)
            for event in events:
                if isinstance(event, ResponseReceived) and event.stream_id == stream_id:
                    response_headers = dict(event.headers)
                elif isinstance(event, DataReceived) and event.stream_id == stream_id:
                    response_data += event.data
                    h2_conn.acknowledge_received_data(event.flow_controlled_length, event.stream_id)
                elif isinstance(event, StreamEnded) and event.stream_id == stream_id:
                    stream_ended = True

            to_send = h2_conn.data_to_send()
            if to_send:
                sock.sendall(to_send)

        except socket.timeout:
            break

    return stream_id, response_headers, response_data


class TestBasicHTTP2Functionality:
    """Test basic HTTP/2 functionality."""

    def test_server_accepts_h2_connection(self):
        """Test that server accepts HTTP/2 connections via ALPN."""
        ctx = create_ssl_context()
        sock = socket.create_connection((TARGET_HOST, TARGET_PORT), timeout=TIMEOUT)
        tls_sock = ctx.wrap_socket(sock, server_hostname=TARGET_HOST)

        assert tls_sock.selected_alpn_protocol() == "h2", \
            "Server should negotiate HTTP/2 via ALPN"

        tls_sock.close()

    def test_server_sends_settings_frame(self):
        """Test that server sends SETTINGS frame on connection initialization."""
        sock, h2_conn = open_h2_connection()
        try:
            # Connection was established successfully, meaning SETTINGS exchange happened
            assert h2_conn is not None
            # Check local settings were acknowledged
            assert h2_conn.local_settings is not None
        finally:
            sock.close()

    def test_basic_get_request(self):
        """Test basic HTTP/2 GET request returns a response."""
        sock, h2_conn = open_h2_connection()
        try:
            stream_id, headers, data = send_request_and_get_response(sock, h2_conn, "/")

            # Should get some response (even 404 is acceptable for basic connectivity)
            assert headers is not None, "Should receive response headers"
            assert b":status" in headers or ":status" in headers, "Should have status in response"
        finally:
            sock.close()

    def test_multiple_sequential_requests(self):
        """Test multiple sequential requests on same connection."""
        sock, h2_conn = open_h2_connection()
        try:
            responses_received = 0

            for i in range(5):
                stream_id, headers, data = send_request_and_get_response(
                    sock, h2_conn, f"/?test={i}"
                )
                if headers is not None:
                    responses_received += 1

            assert responses_received >= 3, \
                f"Should receive most responses, got {responses_received}/5"
        finally:
            sock.close()


class TestWindowUpdate:
    """Test valid WINDOW_UPDATE handling."""

    def test_valid_window_update_on_connection(self):
        """Test that server accepts valid WINDOW_UPDATE on connection level."""
        sock, h2_conn = open_h2_connection()
        try:
            # Send valid window update on connection (stream 0)
            h2_conn.increment_flow_control_window(1024, stream_id=None)
            sock.sendall(h2_conn.data_to_send())

            # Connection should remain open
            sock.settimeout(1)
            try:
                data = sock.recv(65535)
                if data:
                    events = h2_conn.receive_data(data)
                    # Should not receive GOAWAY for valid window update
                    goaway_received = any(
                        e.__class__.__name__ == "ConnectionTerminated" for e in events
                    )
                    assert not goaway_received, "Valid WINDOW_UPDATE should not cause GOAWAY"
            except socket.timeout:
                pass  # No response is fine for WINDOW_UPDATE

            # Verify connection still works
            stream_id, headers, _ = send_request_and_get_response(sock, h2_conn, "/")
            assert headers is not None, "Connection should still accept requests"
        finally:
            sock.close()

    def test_valid_window_update_on_stream(self):
        """Test that server accepts valid WINDOW_UPDATE on active stream."""
        sock, h2_conn = open_h2_connection()
        try:
            # Open a stream without ending it
            stream_id = h2_conn.get_next_available_stream_id()
            headers = [
                (":method", "POST"),
                (":scheme", "https"),
                (":authority", TARGET_HOST),
                (":path", "/"),
                ("user-agent", "h2o-func-test"),
                ("content-length", "100"),
            ]
            h2_conn.send_headers(stream_id, headers, end_stream=False)
            sock.sendall(h2_conn.data_to_send())

            # Send valid window update on the stream
            h2_conn.increment_flow_control_window(1024, stream_id=stream_id)
            sock.sendall(h2_conn.data_to_send())

            # Should be able to complete the request
            h2_conn.send_data(stream_id, b"x" * 100, end_stream=True)
            sock.sendall(h2_conn.data_to_send())

            # Read response
            sock.settimeout(TIMEOUT)
            response_received = False
            try:
                while True:
                    data = sock.recv(65535)
                    if not data:
                        break
                    events = h2_conn.receive_data(data)
                    for event in events:
                        if isinstance(event, ResponseReceived):
                            response_received = True
                    to_send = h2_conn.data_to_send()
                    if to_send:
                        sock.sendall(to_send)
            except socket.timeout:
                pass

            # We should have received a response
            assert response_received, "Should receive response after valid WINDOW_UPDATE"
        finally:
            sock.close()


class TestConcurrentStreams:
    """Test concurrent stream handling."""

    def test_multiple_concurrent_streams(self):
        """Test server handles multiple concurrent streams."""
        sock, h2_conn = open_h2_connection()
        try:
            stream_ids = []

            # Open multiple streams concurrently
            for i in range(5):
                stream_id = h2_conn.get_next_available_stream_id()
                headers = [
                    (":method", "GET"),
                    (":scheme", "https"),
                    (":authority", TARGET_HOST),
                    (":path", f"/concurrent?id={i}"),
                    ("user-agent", "h2o-func-test"),
                ]
                h2_conn.send_headers(stream_id, headers, end_stream=True)
                stream_ids.append(stream_id)

            sock.sendall(h2_conn.data_to_send())

            # Collect responses
            responses = {}
            sock.settimeout(TIMEOUT)

            try:
                while len(responses) < len(stream_ids):
                    data = sock.recv(65535)
                    if not data:
                        break

                    events = h2_conn.receive_data(data)
                    for event in events:
                        if isinstance(event, ResponseReceived):
                            responses[event.stream_id] = dict(event.headers)

                    to_send = h2_conn.data_to_send()
                    if to_send:
                        sock.sendall(to_send)
            except socket.timeout:
                pass

            assert len(responses) >= 3, \
                f"Should handle multiple concurrent streams, got {len(responses)}/{len(stream_ids)} responses"
        finally:
            sock.close()


class TestConnectionReuse:
    """Test connection reuse capabilities."""

    def test_connection_stays_open(self):
        """Test that connection stays open for multiple requests."""
        sock, h2_conn = open_h2_connection()
        try:
            # Make several requests
            for i in range(3):
                stream_id, headers, _ = send_request_and_get_response(
                    sock, h2_conn, f"/reuse?req={i}"
                )
                assert headers is not None, f"Request {i} should get response"

            # Verify socket is still connected
            assert sock.fileno() >= 0, "Socket should still be valid"
        finally:
            sock.close()
