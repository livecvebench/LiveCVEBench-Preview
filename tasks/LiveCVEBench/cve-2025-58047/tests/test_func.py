"""
Functional tests for Volto application.
These tests verify that the application works correctly in both vulnerable and fixed states.
"""

import requests
import time
import pytest

BASE_URL = "http://localhost:3000"
TIMEOUT = 10


def wait_for_server(max_retries=30, delay=2):
    """Wait for the Volto server to become available."""
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/", timeout=5)
            if response.status_code in [200, 302, 401, 403, 404, 500]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


class TestVoltoFunctionality:
    """Test basic Volto functionality."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is running before each test."""
        assert wait_for_server(max_retries=30, delay=2), \
            "Volto server is not responding"

    def test_homepage_loads(self):
        """Test that the Volto homepage returns a response."""
        response = requests.get(f"{BASE_URL}/", timeout=TIMEOUT)
        # Accept various status codes - the key is the server responds
        assert response.status_code in [200, 302, 401, 403, 404, 500], \
            f"Unexpected status code: {response.status_code}"

    def test_server_responds_to_normal_paths(self):
        """Test that normal URL paths work correctly."""
        paths = [
            "/",
            "/test-page",
            "/some/nested/path",
        ]
        for path in paths:
            try:
                response = requests.get(f"{BASE_URL}{path}", timeout=TIMEOUT)
                # Server should respond (any status code is fine)
                assert response.status_code is not None
            except requests.exceptions.ConnectionError:
                pytest.fail(f"Server crashed when accessing {path}")

    def test_api_endpoint_responds(self):
        """Test that API proxy endpoints return a response."""
        try:
            response = requests.get(
                f"{BASE_URL}/++api++/@site",
                headers={"Accept": "application/json"},
                timeout=TIMEOUT
            )
            # Should get some response, not a connection error
            assert response.status_code in [200, 302, 401, 403, 404, 500, 502, 503]
        except requests.exceptions.ConnectionError:
            pytest.fail("Server crashed when accessing API endpoint")

    def test_static_content_served(self):
        """Test that static files are served."""
        try:
            response = requests.get(f"{BASE_URL}/robots.txt", timeout=TIMEOUT)
            # Either exists or 404, but server should respond
            assert response.status_code in [200, 404]
        except requests.exceptions.ConnectionError:
            pytest.fail("Server crashed when accessing static content")

    def test_multiple_concurrent_requests(self):
        """Test that the server handles multiple requests."""
        import concurrent.futures

        def make_request(path):
            try:
                response = requests.get(f"{BASE_URL}{path}", timeout=TIMEOUT)
                return response.status_code
            except requests.exceptions.RequestException as e:
                return str(e)

        paths = ["/", "/test", "/another-page", "/++api++/@site"]

        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            results = list(executor.map(make_request, paths))

        # All requests should complete without connection errors
        for result in results:
            if isinstance(result, str) and "Connection" in result:
                pytest.fail(f"Server connection issue: {result}")
