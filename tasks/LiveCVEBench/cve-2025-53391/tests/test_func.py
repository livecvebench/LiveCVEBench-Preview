"""
Functional tests for zuluPolkit component.

These tests verify that zuluPolkit is properly installed and configured,
regardless of the security posture. They should PASS in both vulnerable
and fixed states.
"""

import os
import subprocess
import xml.etree.ElementTree as ET

import pytest


# Paths in the container
ZULUPOLKIT_BINARY = "/usr/bin/zuluPolkit"
POLICY_FILE = "/usr/share/polkit-1/actions/org.zulucrypt.zulupolkit.policy"
SOURCE_DIR = "/app"
CMAKE_FILE = f"{SOURCE_DIR}/zuluPolkit/CMakeLists.txt"


class TestZuluPolkitInstallation:
    """Tests verifying zuluPolkit is correctly installed."""

    def test_zulupolkit_binary_exists(self):
        """Verify zuluPolkit binary is installed."""
        assert os.path.isfile(ZULUPOLKIT_BINARY), \
            f"zuluPolkit binary not found at {ZULUPOLKIT_BINARY}"

    def test_zulupolkit_binary_executable(self):
        """Verify zuluPolkit binary is executable."""
        assert os.access(ZULUPOLKIT_BINARY, os.X_OK), \
            f"zuluPolkit binary at {ZULUPOLKIT_BINARY} is not executable"

    def test_policy_file_exists(self):
        """Verify PolicyKit policy file is installed."""
        assert os.path.isfile(POLICY_FILE), \
            f"PolicyKit policy file not found at {POLICY_FILE}"


class TestPolicyFileStructure:
    """Tests verifying the PolicyKit policy file has valid structure."""

    def test_policy_file_is_valid_xml(self):
        """Verify policy file is valid XML."""
        try:
            tree = ET.parse(POLICY_FILE)
            root = tree.getroot()
            assert root is not None, "Policy file has no root element"
        except ET.ParseError as e:
            pytest.fail(f"Policy file is not valid XML: {e}")

    def test_policy_has_policyconfig_root(self):
        """Verify policy file has policyconfig root element."""
        tree = ET.parse(POLICY_FILE)
        root = tree.getroot()
        # Remove namespace for comparison
        tag = root.tag.split('}')[-1] if '}' in root.tag else root.tag
        assert tag == "policyconfig", \
            f"Expected 'policyconfig' root element, got '{tag}'"

    def test_policy_has_action_element(self):
        """Verify policy file contains an action definition."""
        tree = ET.parse(POLICY_FILE)
        root = tree.getroot()

        # Find action element (may have namespace)
        actions = root.findall(".//{*}action")
        if not actions:
            actions = root.findall(".//action")

        assert len(actions) > 0, "Policy file contains no action definitions"

    def test_policy_action_has_correct_id(self):
        """Verify the action has the correct ID for zuluPolkit."""
        tree = ET.parse(POLICY_FILE)
        root = tree.getroot()

        # Find action element
        actions = root.findall(".//{*}action")
        if not actions:
            actions = root.findall(".//action")

        assert len(actions) > 0, "No action elements found"

        action_id = actions[0].get("id", "")
        assert "zulupolkit" in action_id.lower() or "zulucrypt" in action_id.lower(), \
            f"Action ID '{action_id}' doesn't appear to be for zuluPolkit"

    def test_policy_has_defaults_section(self):
        """Verify policy file has defaults section with authorization settings."""
        tree = ET.parse(POLICY_FILE)
        root = tree.getroot()

        # Find defaults element
        defaults = root.findall(".//{*}defaults")
        if not defaults:
            defaults = root.findall(".//defaults")

        assert len(defaults) > 0, "Policy file has no defaults section"

    def test_policy_has_all_authorization_settings(self):
        """Verify policy has all three authorization level settings."""
        with open(POLICY_FILE, 'r') as f:
            content = f.read()

        # Check for all three authorization settings (regardless of their values)
        has_allow_any = "allow_any" in content
        has_allow_inactive = "allow_inactive" in content
        has_allow_active = "allow_active" in content

        assert has_allow_any, "Policy file missing 'allow_any' setting"
        assert has_allow_inactive, "Policy file missing 'allow_inactive' setting"
        assert has_allow_active, "Policy file missing 'allow_active' setting"


class TestSourceCodePresence:
    """Tests verifying source code is available for modification."""

    def test_source_directory_exists(self):
        """Verify source code directory exists."""
        assert os.path.isdir(SOURCE_DIR), \
            f"Source directory not found at {SOURCE_DIR}"

    def test_zulupolkit_source_directory_exists(self):
        """Verify zuluPolkit source subdirectory exists."""
        zulupolkit_dir = f"{SOURCE_DIR}/zuluPolkit"
        assert os.path.isdir(zulupolkit_dir), \
            f"zuluPolkit source directory not found at {zulupolkit_dir}"

    def test_cmake_file_exists(self):
        """Verify CMakeLists.txt exists in zuluPolkit directory."""
        assert os.path.isfile(CMAKE_FILE), \
            f"CMakeLists.txt not found at {CMAKE_FILE}"

    def test_cmake_file_contains_policy_generation(self):
        """Verify CMakeLists.txt contains PolicyKit policy generation code."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        # Check for key elements that indicate policy generation
        assert "policyconfig" in content.lower() or "org.zulucrypt" in content, \
            "CMakeLists.txt doesn't appear to contain policy generation code"

    def test_cmake_file_has_authorization_config(self):
        """Verify CMakeLists.txt has authorization configuration."""
        with open(CMAKE_FILE, 'r') as f:
            content = f.read()

        # Either auth_self (vulnerable) or auth_admin (fixed) should be present
        has_auth_self = "auth_self" in content
        has_auth_admin = "auth_admin" in content

        assert has_auth_self or has_auth_admin, \
            "CMakeLists.txt doesn't contain any authorization level configuration"


class TestBuildEnvironment:
    """Tests verifying build tools are available for rebuilding."""

    def test_cmake_available(self):
        """Verify cmake is available for rebuilding."""
        result = subprocess.run(
            ["which", "cmake"],
            capture_output=True,
            text=True
        )
        assert result.returncode == 0, "cmake not found in PATH"

    def test_make_available(self):
        """Verify make is available for rebuilding."""
        result = subprocess.run(
            ["which", "make"],
            capture_output=True,
            text=True
        )
        assert result.returncode == 0, "make not found in PATH"

    def test_cpp_compiler_available(self):
        """Verify C++ compiler is available for rebuilding."""
        result = subprocess.run(
            ["which", "g++"],
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            result = subprocess.run(
                ["which", "c++"],
                capture_output=True,
                text=True
            )
        assert result.returncode == 0, "C++ compiler not found in PATH"
