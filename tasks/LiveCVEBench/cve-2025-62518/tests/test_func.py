"""
Functional tests for the async tar library.

These tests verify that basic tar operations work correctly.
They should PASS in both vulnerable and fixed states.
"""
import subprocess
import tempfile
import os
import struct


def write_octal(value: int, field_size: int) -> bytes:
    """Write an octal value with proper padding for tar header fields."""
    octal_str = f'{value:o}'
    if len(octal_str) >= field_size:
        return b'7' * (field_size - 1) + b'\x00'
    padding = field_size - 1 - len(octal_str)
    return (b'0' * padding + octal_str.encode() + b'\x00')


def calculate_checksum(header: bytes) -> int:
    """Calculate tar header checksum."""
    total = 0
    for i in range(512):
        if 148 <= i < 156:
            total += 32
        else:
            total += header[i] if i < len(header) else 0
    return total


def set_header_field(header: bytearray, offset: int, data: bytes):
    """Set a field in the header without changing header size."""
    for i, b in enumerate(data):
        if offset + i < 512:
            header[offset + i] = b


def create_tar_header(name: bytes, size: int, typeflag: str = '0') -> bytearray:
    """Create a tar header with proper checksum."""
    header = bytearray(512)

    set_header_field(header, 0, name[:100])
    set_header_field(header, 100, b'0000644\x00')
    set_header_field(header, 108, b'0000000\x00')
    set_header_field(header, 116, b'0000000\x00')
    set_header_field(header, 124, write_octal(size, 12))
    set_header_field(header, 136, b'00000000000\x00')
    set_header_field(header, 148, b'        ')
    header[156] = ord(typeflag)
    set_header_field(header, 257, b'ustar\x00')
    set_header_field(header, 263, b'00')

    checksum = calculate_checksum(bytes(header))
    checksum_str = f'{checksum:06o}\x00 '.encode()
    set_header_field(header, 148, checksum_str)

    return header


def create_simple_tar(output_path: str, files: dict):
    """Create a simple tar file with given files."""
    with open(output_path, 'wb') as f:
        for name, content in files.items():
            header = create_tar_header(name.encode('utf-8'), len(content), '0')
            f.write(bytes(header))
            f.write(content)
            padding = (512 - (len(content) % 512)) % 512
            f.write(b'\x00' * padding)

        # End of archive (two zero blocks)
        f.write(b'\x00' * 1024)


class TestBasicTarOperations:
    """Test basic tar parsing functionality."""

    def test_simple_extraction(self, tmp_path):
        """Test that a simple tar file can be extracted."""
        tar_path = str(tmp_path / "simple.tar")
        extract_dir = str(tmp_path / "extracted")
        os.makedirs(extract_dir, exist_ok=True)

        # Create a simple tar
        create_simple_tar(tar_path, {
            "hello.txt": b"Hello, World!\n",
            "data.bin": b"\x00\x01\x02\x03\x04"
        })

        # Run extraction using the library's test binary
        result = subprocess.run(
            ["cargo", "run", "--release", "--example", "extract", "--", tar_path, extract_dir],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=60
        )

        # If example doesn't exist, try direct test
        if result.returncode != 0:
            # Use cargo test to verify library loads properly
            result = subprocess.run(
                ["cargo", "test", "--release", "--", "--test-threads=1", "reading"],
                cwd="/app",
                capture_output=True,
                text=True,
                timeout=120
            )

        # Library should at least compile and run tests
        assert result.returncode == 0 or "running" in result.stdout.lower()

    def test_library_builds(self):
        """Test that the library compiles successfully."""
        result = subprocess.run(
            ["cargo", "build", "--release"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=300
        )

        assert result.returncode == 0, f"Build failed: {result.stderr}"

    def test_existing_tests_pass(self):
        """Test that existing library tests pass (excluding our specific test)."""
        result = subprocess.run(
            ["cargo", "test", "--release", "--",
             "--skip", "pax_precedence",  # Skip our vuln test
             "--test-threads=1"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=300
        )

        # Allow for some tests to be skipped but overall should pass
        assert result.returncode == 0 or "test result: ok" in result.stdout.lower(), \
            f"Tests failed: {result.stdout}\n{result.stderr}"


class TestPaxHeaderReading:
    """Test PAX header functionality at a basic level."""

    def test_library_has_pax_support(self):
        """Verify the library has PAX support in its code."""
        # Check that pax.rs exists
        assert os.path.exists("/app/src/pax.rs"), "PAX module should exist"

        # Check that it's exported
        result = subprocess.run(
            ["grep", "-r", "pax", "/app/src/lib.rs"],
            capture_output=True,
            text=True
        )
        assert result.returncode == 0, "PAX module should be referenced in lib.rs"

    def test_archive_entries_method_exists(self):
        """Verify the entries() method is available."""
        # Build and check API exists
        result = subprocess.run(
            ["cargo", "doc", "--release", "--no-deps"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=120
        )

        # Documentation should build
        assert result.returncode == 0, f"Doc build failed: {result.stderr}"


class TestEdgeCases:
    """Test edge cases that should work in both vulnerable and fixed states."""

    def test_library_runs_basic_tests(self):
        """Test that library handles basic tar operations correctly."""
        result = subprocess.run(
            ["cargo", "build", "--release"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=300
        )

        assert result.returncode == 0, f"Build failed: {result.stderr}"

    def test_simple_tar_parsing(self, tmp_path):
        """Test parsing a simple tar with consistent sizes."""
        tar_path = str(tmp_path / "matching.tar")

        # Create a simple tar with consistent sizes (no bug scenario)
        with open(tar_path, 'wb') as f:
            content = b"Test content\n"
            header = create_tar_header(b"test.txt", len(content), '0')
            f.write(bytes(header))
            f.write(content)
            padding = (512 - (len(content) % 512)) % 512
            f.write(b'\x00' * padding)
            f.write(b'\x00' * 1024)

        # Library should handle this correctly
        # Try to run cargo test to verify library works
        result = subprocess.run(
            ["cargo", "test", "--release", "--", "--test-threads=1", "simple"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=120
        )

        # Should at least not crash
        assert "panicked" not in result.stderr.lower()

    def test_library_tests_complete(self):
        """Test that library tests complete without major failures."""
        result = subprocess.run(
            ["cargo", "test", "--release", "--", "--test-threads=1"],
            cwd="/app",
            capture_output=True,
            text=True,
            timeout=300
        )

        # Library tests should pass
        assert result.returncode == 0 or "test result: ok" in result.stdout.lower(), (
            f"Library tests failed: {result.stdout}\n{result.stderr}"
        )
