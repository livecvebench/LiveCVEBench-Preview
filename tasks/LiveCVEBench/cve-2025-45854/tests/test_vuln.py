"""
Vulnerability Tests for JEHC-BPM Actuator Authentication Bypass

These tests verify that the vulnerability exists (unauthenticated access to command execution).
- In VULNERABLE state: Tests should FAIL (vulnerability is exploitable)
- In FIXED state: Tests should PASS (vulnerability is mitigated)

The tests work by attempting to access the endpoint WITHOUT authentication.
If the vulnerability exists, the endpoint will allow access and execute commands.
After the fix, the endpoint should reject unauthenticated requests.
"""

import pytest
import requests
import time
import os

# Configuration
BASE_URL = os.environ.get("APP_URL", "http://localhost:8082")
CLIENT_ENDPOINT = f"{BASE_URL}/actuator/info/executeExec"
SERVER_ENDPOINT = f"{BASE_URL}/actuator/server/executeExec"
TIMEOUT = 10


def is_auth_blocked(response):
    """
    Check if the response indicates that authentication is blocking the request.

    The JEHC-BPM framework may return different auth error formats:
    - HTTP 401/403 status codes
    - {"success": false, ...} - standard format
    - {"message": "未能获取到客户端Token", "status": 200} - token missing error
    - {"message": "未登录...", ...} - not logged in error
    - {"message": "未授权...", ...} - unauthorized error
    """
    if response.status_code in [401, 403]:
        return True

    try:
        response_json = response.json()
        # Check success field
        if response_json.get("success") == False:
            return True
        # Check for auth-related error messages (Chinese)
        message = response_json.get("message", "")
        if any(kw in message for kw in ["Token", "未登录", "未授权", "登录", "认证", "权限"]):
            return True
    except:
        pass

    return False


class TestUnauthenticatedAccessBlocked:
    """
    These tests verify that unauthenticated access is properly blocked after the fix.
    Tests PASS when the fix is applied (401/403 response).
    Tests FAIL when vulnerable (200 response with command output).
    """

    def test_client_endpoint_blocks_simple_command(self):
        """Test that simple command execution is blocked without authentication"""
        payload = {"0": "whoami"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Unauthenticated request returned status {response.status_code} with body: {response.text[:500]}"

    def test_client_endpoint_blocks_id_command(self):
        """Test that 'id' command is blocked without authentication"""
        payload = {"0": "id"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! 'id' command executed without auth. Response: {response.text[:500]}"

    def test_client_endpoint_blocks_system_info_command(self):
        """Test that 'uname -a' command is blocked without authentication"""
        payload = {"0": "uname", "1": "-a"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! 'uname -a' executed without auth. Response: {response.text[:500]}"

    def test_client_endpoint_blocks_file_read_command(self):
        """Test that file read commands are blocked without authentication"""
        payload = {"0": "cat", "1": "/etc/hostname"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! File read executed without auth. Response: {response.text[:500]}"

    def test_client_endpoint_blocks_shell_command(self):
        """Test that shell commands via 'sh -c' are blocked without authentication"""
        payload = {"0": "sh", "1": "-c", "2": "echo 'test_marker_12345'"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Shell command executed without auth. Response: {response.text[:500]}"

        # Additional check: the marker should not appear if properly blocked
        if response.status_code == 200:
            assert "test_marker_12345" not in response.text, \
                   "Vulnerability exists! Command output 'test_marker_12345' found in response"

    def test_client_endpoint_blocks_env_command(self):
        """Test that environment variable access is blocked without authentication"""
        payload = {"0": "env"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Environment dump without auth. Response: {response.text[:500]}"

    def test_client_endpoint_blocks_process_listing(self):
        """Test that process listing is blocked without authentication"""
        payload = {"0": "ps", "1": "aux"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Process listing without auth. Response: {response.text[:500]}"

    def test_client_endpoint_blocks_network_info(self):
        """Test that network information commands are blocked without authentication"""
        payload = {"0": "hostname"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Network info without auth. Response: {response.text[:500]}"


class TestServerEndpointBlocked:
    """
    Tests for the server-side proxy endpoint (/actuator/server/executeExec).
    This endpoint proxies requests to clients and should also require authentication.

    Note: The server endpoint is a proxy that forwards requests to client actuators.
    It has complex parameter validation that can return success=false for reasons
    other than authentication. The core vulnerability is better tested via the
    client endpoint (/actuator/info/executeExec) which directly executes commands.
    """

    @pytest.mark.skip(reason="Server endpoint proxy has complex parameter validation that returns success=false for non-auth reasons, making this test unreliable. Core vulnerability is demonstrated by client endpoint tests.")
    def test_server_endpoint_blocks_unauthenticated_requests(self):
        """Test that server endpoint blocks unauthenticated requests"""
        # Server endpoint expects different payload structure with actuator info
        payload = {
            "actuator": {
                "ip": "localhost",
                "port": 8082
            },
            "execParams": {
                "0": "whoami"
            }
        }

        try:
            response = requests.post(SERVER_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            # Connection errors might happen if server endpoint is not accessible
            # This is acceptable - the important thing is the client endpoint test passes
            pytest.skip(f"Server endpoint not accessible: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists on server endpoint! Response: {response.text[:500]}"


class TestMaliciousPayloads:
    """
    Test various malicious payload variations to ensure comprehensive protection.
    """

    def test_blocks_directory_traversal_attempt(self):
        """Test blocking directory traversal via command"""
        payload = {"0": "cat", "1": "../../../etc/passwd"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Directory traversal not blocked. Response: {response.text[:500]}"

    def test_blocks_curl_command(self):
        """Test that network commands like curl are blocked"""
        payload = {"0": "curl", "1": "-s", "2": "http://localhost"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! curl command not blocked. Response: {response.text[:500]}"

    def test_blocks_wget_command(self):
        """Test that wget commands are blocked"""
        payload = {"0": "wget", "1": "-q", "2": "-O-", "3": "http://localhost"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! wget command not blocked. Response: {response.text[:500]}"

    def test_blocks_base64_encoded_command(self):
        """Test blocking encoded command execution"""
        # Try to execute: echo "test" | base64
        payload = {"0": "sh", "1": "-c", "2": "echo dGVzdA== | base64 -d"}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Encoded command not blocked. Response: {response.text[:500]}"


class TestEdgeCases:
    """
    Test edge cases and boundary conditions.
    """

    def test_blocks_empty_command(self):
        """Test that even empty commands are rejected without auth"""
        payload = {"0": ""}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        # Should be blocked by authentication or handled gracefully
        assert response.status_code in [400] or is_auth_blocked(response), \
               f"Unexpected behavior with empty command. Response: {response.text[:500]}"

    def test_blocks_whitespace_command(self):
        """Test that whitespace-only commands are rejected without auth"""
        payload = {"0": "   ", "1": "   "}

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        # Should be blocked by authentication
        assert response.status_code in [400] or is_auth_blocked(response), \
               f"Unexpected behavior with whitespace command. Response: {response.text[:500]}"

    def test_blocks_multiple_commands_in_array(self):
        """Test blocking multiple command arguments"""
        payload = {
            "0": "ls",
            "1": "-la",
            "2": "/tmp",
            "3": "&&",
            "4": "whoami"
        }

        try:
            response = requests.post(CLIENT_ENDPOINT, json=payload, timeout=TIMEOUT)
        except requests.exceptions.RequestException as e:
            pytest.fail(f"Failed to connect to application: {e}")

        assert is_auth_blocked(response), \
               f"Vulnerability exists! Multiple commands not blocked. Response: {response.text[:500]}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
