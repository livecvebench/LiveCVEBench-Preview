#!/bin/bash
set -e

cd /app

echo "Applying fix for command injection vulnerability..."

# The source file to fix
SOURCE_FILE="src/package-docs-server.ts"

# Check if the source file exists
if [ ! -f "$SOURCE_FILE" ]; then
    echo "Error: Source file $SOURCE_FILE not found"
    exit 1
fi

# Create a backup
cp "$SOURCE_FILE" "${SOURCE_FILE}.backup"

echo "Step 1: Replacing exec import with execFile..."
sed -i 's/import { exec } from "child_process"/import { execFile } from "child_process"/g' "$SOURCE_FILE"

echo "Step 2: Replacing execAsync with execFileAsync..."
sed -i 's/const execAsync = promisify(exec)/const execFileAsync = promisify(execFile)/g' "$SOURCE_FILE"

echo "Step 3: Adding sanitization and safe wrapper functions..."

# Create the safe functions code block
SAFE_FUNCTIONS='
/**
 * Sanitise input to prevent command injection
 */
function sanitiseInput(input: string): string {
  // Remove shell metacharacters and limit to alphanumeric, dots, hyphens, underscores, and forward slashes
  return input.replace(/[^a-zA-Z0-9.\\-_\\/]/g, "")
}

/**
 * Safely execute go doc command using execFile
 */
async function safeGoDoc(packageName: string, symbol?: string): Promise<{ stdout: string }> {
  const sanitisedPackage = sanitiseInput(packageName)
  const args = ["doc"]

  if (symbol) {
    const sanitisedSymbol = sanitiseInput(symbol)
    args.push(`${sanitisedPackage}.${sanitisedSymbol}`)
  } else {
    args.push(sanitisedPackage)
  }

  return await execFileAsync("go", args)
}

/**
 * Safely execute go list command using execFile
 */
async function safeGoList(packageName: string): Promise<{ stdout: string }> {
  const sanitisedPackage = sanitiseInput(packageName)
  return await execFileAsync("go", ["list", "-f", "{{.Dir}}", sanitisedPackage])
}

/**
 * Safely execute python command using execFile
 */
async function safePythonExec(code: string): Promise<{ stdout: string }> {
  return await execFileAsync("python3", ["-c", code])
}

'

# Check if the functions already exist (idempotency)
if grep -q "function sanitiseInput" "$SOURCE_FILE"; then
    echo "Safe functions already exist, skipping insertion..."
else
    # Insert the safe functions after the execFileAsync declaration using awk
    awk -v funcs="$SAFE_FUNCTIONS" '
    /const execFileAsync = promisify\(execFile\)/ {
        print
        print funcs
        next
    }
    {print}
    ' "$SOURCE_FILE" > "${SOURCE_FILE}.tmp" && mv "${SOURCE_FILE}.tmp" "$SOURCE_FILE"
fi

echo "Step 4: Replacing vulnerable Go exec calls..."

# Replace go list exec call in isGoPackageInstalledLocally
sed -i "s/const { stdout } = await execAsync(\`go list -f '{{\.Dir}}' \${packageName}\`)/const { stdout } = await safeGoList(packageName)/g" "$SOURCE_FILE"

# Replace the multi-line cmd pattern in getLocalGoDoc
# First, identify and remove the cmd variable definition and replace the exec call
python3 << 'PYTHON_SCRIPT'
import re

with open('src/package-docs-server.ts', 'r') as f:
    content = f.read()

# Pattern for getLocalGoDoc vulnerable code
# Replace the cmd definition and execAsync(cmd) pattern
old_pattern = r'''const cmd = symbol
\s*\? `go doc \$\{packageName\}\.\$\{symbol\}`
\s*: `go doc \$\{packageName\}`
\s*const \{ stdout \} = await execAsync\(cmd\)'''

new_code = 'const { stdout } = await safeGoDoc(packageName, symbol)'

content = re.sub(old_pattern, new_code, content)

# Also handle the describeGoPackage similar pattern
old_pattern2 = r'''const cmd = symbol
\s*\? `go doc \$\{packageName\}\.\$\{symbol\}`
\s*: `go doc \$\{packageName\}`
\s*const \{ stdout \} = await execAsync\(cmd\)'''

content = re.sub(old_pattern2, new_code, content)

# Replace direct execAsync go doc calls
content = re.sub(
    r'const \{ stdout \} = await execAsync\(`go doc \$\{packageName\}`\)',
    'const { stdout } = await safeGoDoc(packageName)',
    content
)

content = re.sub(
    r'const \{ stdout \} = await execAsync\(`go doc \$\{packageName\}\.\$\{symbol\}`\)',
    'const { stdout } = await safeGoDoc(packageName, symbol)',
    content
)

# Handle remaining execAsync(cmd) for go doc
content = re.sub(
    r'const \{ stdout \} = await execAsync\(cmd\)',
    'const { stdout } = await safeGoDoc(packageName, symbol)',
    content
)

with open('src/package-docs-server.ts', 'w') as f:
    f.write(content)

print("Python regex replacements completed")
PYTHON_SCRIPT

echo "Step 5: Replacing vulnerable Python exec calls..."

# Replace python exec calls
sed -i 's/const { stdout } = await execAsync(`python3 -c "${pythonCode}"`)/const { stdout } = await safePythonExec(pythonCode)/g' "$SOURCE_FILE"

echo "Step 5b: Sanitizing Python package names before interpolation..."

# The Python code strings still interpolate packageName directly, which allows Python code injection
# We need to sanitize the packageName BEFORE it's used in Python code string interpolation
python3 << 'PYTHON_SCRIPT_PY_FIX'
import re

with open('src/package-docs-server.ts', 'r') as f:
    content = f.read()

# Fix isPythonPackageInstalledLocally - add sanitization before building pythonCode
# Find the pattern where pythonCode is built with ${packageName}
old_is_installed = r'''(private async isPythonPackageInstalledLocally\(packageName: string\): Promise<boolean> \{[\s\S]*?try \{)(\s*// Check if we can import the package\s*const pythonCode = `)'''

new_is_installed = r'''\1
      // Sanitize package name to prevent Python code injection
      const sanitisedPackageName = sanitiseInput(packageName)
\2'''

content = re.sub(old_is_installed, new_is_installed, content)

# Replace ${packageName} with ${sanitisedPackageName} in isPythonPackageInstalledLocally's pythonCode
# This is specific to the find_spec pattern
old_findspec = r"spec = importlib\.util\.find_spec\('\$\{packageName\}'\)"
new_findspec = "spec = importlib.util.find_spec('${sanitisedPackageName}')"
content = re.sub(old_findspec, new_findspec, content)

# Fix getLocalPythonDoc - add sanitization before building pythonCode
old_local_py_doc = r'''(private async getLocalPythonDoc\(packageName: string, symbol\?: string\): Promise<DocResult> \{[\s\S]*?try \{)(\s*const pythonCode = symbol)'''

new_local_py_doc = r'''\1
      // Sanitize package name and symbol to prevent Python code injection
      const sanitisedPackageName = sanitiseInput(packageName)
      const sanitisedSymbol = symbol ? sanitiseInput(symbol) : undefined
\2'''

content = re.sub(old_local_py_doc, new_local_py_doc, content)

# Replace ${packageName} and ${symbol} with sanitized versions in getLocalPythonDoc's pythonCode
# Pattern for the ternary pythonCode with imports and help
old_py_help = r'''const pythonCode = symbol
        \? `
import \$\{packageName\}
help\(\$\{packageName\}\.\$\{symbol\}\)
`
        : `
import \$\{packageName\}
help\(\$\{packageName\}\)
`'''

new_py_help = '''const pythonCode = sanitisedSymbol
        ? `
import ${sanitisedPackageName}
help(${sanitisedPackageName}.${sanitisedSymbol})
`
        : `
import ${sanitisedPackageName}
help(${sanitisedPackageName})
`'''

content = re.sub(old_py_help, new_py_help, content)

with open('src/package-docs-server.ts', 'w') as f:
    f.write(content)

print("Python package name sanitization completed")
PYTHON_SCRIPT_PY_FIX

echo "Step 6: Handling Swift exec calls..."

# For Swift, replace the cmd-based exec with execFileAsync directly
python3 << 'PYTHON_SCRIPT2'
import re

with open('src/package-docs-server.ts', 'r') as f:
    content = f.read()

# Find and replace the Swift vulnerable pattern in getLocalSwiftDoc
old_swift = r'''const cmd = symbol
\s*\? `swift doc generate \$\{packageName\} --module-name \$\{packageName\} --symbol \$\{symbol\}`
\s*: `swift doc generate \$\{packageName\} --module-name \$\{packageName\}`

\s*const \{ stdout \} = await execAsync\(cmd\)'''

new_swift = '''const args = ['doc', 'generate', packageName, '--module-name', packageName]
        if (symbol) {
          args.push('--symbol', symbol)
        }
        const { stdout } = await execFileAsync('swift', args)'''

content = re.sub(old_swift, new_swift, content, flags=re.DOTALL)

with open('src/package-docs-server.ts', 'w') as f:
    f.write(content)

print("Swift exec replacement completed")
PYTHON_SCRIPT2

# Clean up leftover cmd variable definitions
python3 << 'PYTHON_SCRIPT3'
import re

with open('src/package-docs-server.ts', 'r') as f:
    content = f.read()

# Remove orphaned cmd variable definitions
orphaned_cmd = r'''const cmd = symbol
\s*\? `go doc \$\{packageName\}\.\$\{symbol\}`
\s*: `go doc \$\{packageName\}`\s*'''

content = re.sub(orphaned_cmd, '', content)

with open('src/package-docs-server.ts', 'w') as f:
    f.write(content)

print("Cleanup completed")
PYTHON_SCRIPT3

echo "Step 7: Rebuilding the application..."
npm run build

echo "Step 8: Restarting the server if running..."
pkill -f "node.*build/index.js" 2>/dev/null || true
sleep 2

echo ""
echo "Fix applied successfully!"
echo ""
echo "Summary of changes:"
echo "  1. Replaced 'exec' import with 'execFile'"
echo "  2. Replaced 'execAsync' with 'execFileAsync'"
echo "  3. Added sanitiseInput() function to filter dangerous characters"
echo "  4. Added safeGoDoc(), safeGoList(), safePythonExec() wrapper functions"
echo "  5. Replaced all vulnerable execAsync() calls with safe alternatives"
echo "  6. Rebuilt the application"
