"""
Vulnerability tests for copyparty ReDoS vulnerability.

These tests verify the vulnerability status:
- FAIL when vulnerable (server hangs on malicious patterns)
- PASS when fixed (server handles malicious patterns safely)
"""

import time
import threading
import requests
import pytest


BASE_URL = "http://localhost:3923"
# Short timeout since we're testing for hangs
REQUEST_TIMEOUT = 5
# Maximum acceptable response time for any request
MAX_RESPONSE_TIME = 3


class TestReDoSVulnerability:
    """Test that ReDoS patterns don't cause server hangs."""

    def _make_request_with_timeout(self, url, timeout=REQUEST_TIMEOUT):
        """Helper to make request and measure time."""
        start = time.time()
        try:
            resp = requests.get(url, timeout=timeout)
            elapsed = time.time() - start
            return {"completed": True, "status_code": resp.status_code, "elapsed": elapsed}
        except requests.Timeout:
            elapsed = time.time() - start
            return {"completed": False, "error": "timeout", "elapsed": elapsed}
        except Exception as e:
            elapsed = time.time() - start
            return {"completed": False, "error": str(e), "elapsed": elapsed}

    def test_basic_redos_pattern_nested_quantifier(self):
        """Test that (.+)+x pattern doesn't hang the server.

        The regex (.+)+x has exponential backtracking when matching
        strings that don't contain 'x'. This is a classic ReDoS pattern.
        """
        # URL encoded: (.+)+x -> (.%2B)%2Bx
        url = f"{BASE_URL}/?ru&filter=(.%2B)%2Bx"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete, not timeout. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_redos_pattern_repeated_alternation(self):
        """Test that (a|aa)+$ pattern doesn't hang the server.

        This pattern causes exponential backtracking when matching
        strings of 'a' characters that don't end properly.
        """
        # URL encoded: (a|aa)+$ -> (a%7Caa)%2B%24
        url = f"{BASE_URL}/?ru&filter=(a%7Caa)%2B%24"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete, not timeout. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_redos_pattern_char_class_quantifier(self):
        """Test that ([a-zA-Z]+)*$ pattern doesn't hang the server.

        Character class with nested quantifiers is another ReDoS pattern.
        """
        # URL encoded: ([a-zA-Z]+)*$ -> (%5Ba-zA-Z%5D%2B)*%24
        url = f"{BASE_URL}/?ru&filter=(%5Ba-zA-Z%5D%2B)*%24"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete, not timeout. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_redos_pattern_simple_catastrophic(self):
        """Test that (a+)+$ pattern doesn't hang the server.

        One of the simplest catastrophic backtracking patterns.
        """
        # URL encoded: (a+)+$ -> (a%2B)%2B%24
        url = f"{BASE_URL}/?ru&filter=(a%2B)%2B%24"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete, not timeout. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_redos_on_ups_endpoint(self):
        """Test ReDoS pattern on the user uploads endpoint (/?ups)."""
        # URL encoded: (.+)+x
        url = f"{BASE_URL}/?ups&filter=(.%2B)%2Bx"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete, not timeout. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"


class TestReDoSPatternVariations:
    """Test various ReDoS pattern variations."""

    def _make_request_with_timeout(self, url, timeout=REQUEST_TIMEOUT):
        """Helper to make request and measure time."""
        start = time.time()
        try:
            resp = requests.get(url, timeout=timeout)
            elapsed = time.time() - start
            return {"completed": True, "status_code": resp.status_code, "elapsed": elapsed}
        except requests.Timeout:
            elapsed = time.time() - start
            return {"completed": False, "error": "timeout", "elapsed": elapsed}
        except Exception as e:
            elapsed = time.time() - start
            return {"completed": False, "error": str(e), "elapsed": elapsed}

    def test_evil_regex_with_dot_star(self):
        """Test (.*)*x pattern variation."""
        # URL encoded: (.*)*x -> (.*)*x
        url = f"{BASE_URL}/?ru&filter=(.*)*x"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_complex_nested_pattern(self):
        """Test more complex nested pattern ((a+)+)+$."""
        # URL encoded: ((a+)+)+$
        url = f"{BASE_URL}/?ru&filter=((a%2B)%2B)%2B%24"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_overlapping_alternation(self):
        """Test (ab|a|b)+$ overlapping alternation pattern."""
        # URL encoded: (ab|a|b)+$
        url = f"{BASE_URL}/?ru&filter=(ab%7Ca%7Cb)%2B%24"
        result = self._make_request_with_timeout(url)

        assert result["completed"], f"Request should complete. Error: {result.get('error')}"
        assert result["elapsed"] < MAX_RESPONSE_TIME, \
            f"Request took {result['elapsed']:.2f}s, should be under {MAX_RESPONSE_TIME}s"


class TestServerAvailabilityDuringAttack:
    """Test that server remains responsive during attack attempts."""

    def test_server_responds_after_malicious_request(self):
        """Verify server still works after receiving malicious pattern."""
        # First, send a potentially malicious request (with timeout)
        try:
            requests.get(f"{BASE_URL}/?ru&filter=(.%2B)%2Bx", timeout=3)
        except requests.Timeout:
            pass  # Expected if vulnerable
        except:
            pass  # Other errors are fine

        # Now verify server is still responsive
        start = time.time()
        resp = requests.get(f"{BASE_URL}/", timeout=10)
        elapsed = time.time() - start

        assert resp.status_code == 200, "Server should still be responsive"
        assert elapsed < 5, f"Server response slow after attack: {elapsed:.2f}s"

    def test_concurrent_requests_not_blocked(self):
        """Test that one malicious request doesn't block others."""
        results = {"normal": None, "malicious": None}

        def normal_request():
            try:
                time.sleep(0.5)  # Start slightly after malicious
                start = time.time()
                resp = requests.get(f"{BASE_URL}/", timeout=5)
                elapsed = time.time() - start
                results["normal"] = {"success": True, "elapsed": elapsed}
            except Exception as e:
                results["normal"] = {"success": False, "error": str(e)}

        def malicious_request():
            try:
                resp = requests.get(f"{BASE_URL}/?ru&filter=(.%2B)%2Bx", timeout=3)
                results["malicious"] = {"completed": True}
            except requests.Timeout:
                results["malicious"] = {"completed": False, "timeout": True}
            except Exception as e:
                results["malicious"] = {"completed": False, "error": str(e)}

        # Start both requests
        t1 = threading.Thread(target=malicious_request)
        t2 = threading.Thread(target=normal_request)

        t1.start()
        t2.start()

        t1.join(timeout=5)
        t2.join(timeout=5)

        # Normal request should complete successfully
        assert results["normal"] is not None, "Normal request should complete"
        assert results["normal"].get("success"), \
            f"Normal request should succeed. Result: {results['normal']}"


class TestMaliciousInputHandling:
    """Test that various malicious inputs are handled safely."""

    def test_deeply_nested_groups(self):
        """Test deeply nested group patterns."""
        # ((((((.+)+)+)+)+)+)
        nested = "(((((((.%2B)%2B)%2B)%2B)%2B)%2B)%2B)"
        url = f"{BASE_URL}/?ru&filter={nested}"

        start = time.time()
        try:
            resp = requests.get(url, timeout=REQUEST_TIMEOUT)
            completed = True
        except requests.Timeout:
            completed = False
        elapsed = time.time() - start

        assert completed, "Request should not timeout"
        assert elapsed < MAX_RESPONSE_TIME, \
            f"Request took {elapsed:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_long_pattern_with_quantifiers(self):
        """Test long pattern with multiple quantifiers."""
        # a+b+c+d+e+f+g+h+i+j+$
        pattern = "a%2Bb%2Bc%2Bd%2Be%2Bf%2Bg%2Bh%2Bi%2Bj%2B%24"
        url = f"{BASE_URL}/?ru&filter={pattern}"

        start = time.time()
        try:
            resp = requests.get(url, timeout=REQUEST_TIMEOUT)
            completed = True
        except requests.Timeout:
            completed = False
        elapsed = time.time() - start

        assert completed, "Request should not timeout"
        assert elapsed < MAX_RESPONSE_TIME, \
            f"Request took {elapsed:.2f}s, should be under {MAX_RESPONSE_TIME}s"

    def test_unicode_in_pattern(self):
        """Test patterns with unicode characters."""
        # Pattern with unicode
        url = f"{BASE_URL}/?ru&filter=(.%2B)%2B%E2%9C%93"  # (.+)+âœ“

        start = time.time()
        try:
            resp = requests.get(url, timeout=REQUEST_TIMEOUT)
            completed = True
        except requests.Timeout:
            completed = False
        elapsed = time.time() - start

        assert completed, "Request should not timeout"
        assert elapsed < MAX_RESPONSE_TIME, \
            f"Request took {elapsed:.2f}s, should be under {MAX_RESPONSE_TIME}s"
