#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-62171: ImageMagick BMP integer overflow.

These tests detect if the VULNERABILITY EXISTS (tests FAIL in vulnerable state).

In VULNERABLE state:
- The overflow happens AFTER the multiplication (too late to prevent it)
- ImageMagick may crash (SIGABRT, SIGSEGV) or print dimensions to stdout
- Tests FAIL because vulnerable behavior is detected

In FIXED state:
- The overflow is caught BEFORE the multiplication
- ImageMagick rejects the file early with MemoryAllocationFailed
- No crash, no dimensions printed
- Tests PASS because the early rejection prevents vulnerable behavior
"""

import subprocess
import os
import struct
import tempfile
import pytest
import signal


def create_overflow_bmp(filename, width, height, bits_per_pixel):
    """
    Create a BMP file with specified dimensions that may trigger overflow.

    The overflow occurs when: width * bits_per_pixel > 2^32 on 32-bit systems.
    """
    # BMP File Header (14 bytes)
    file_header = struct.pack('<2sIHHI',
        b'BM',              # Signature
        58,                 # File size (minimal)
        0,                  # Reserved1
        0,                  # Reserved2
        54                  # Data offset
    )

    # BMP Info Header (40 bytes) - BITMAPINFOHEADER
    info_header = struct.pack('<IiiHHIIiiII',
        40,                 # Header size
        width,              # Width (signed int)
        height,             # Height (signed int)
        1,                  # Planes
        bits_per_pixel,     # Bits per pixel
        0,                  # Compression (BI_RGB)
        0,                  # Image size
        0,                  # X pixels per meter
        0,                  # Y pixels per meter
        0,                  # Colors used
        0                   # Colors important
    )

    # Minimal pixel data
    pixel_data = b'\x00\x00\x00\x00'

    with open(filename, 'wb') as f:
        f.write(file_header + info_header + pixel_data)


def get_test_env():
    """Get environment with increased resource limits for testing."""
    env = os.environ.copy()
    # Must increase limits to allow file processing (defaults prevent exploitation)
    env["MAGICK_WIDTH_LIMIT"] = "1000000000"
    env["MAGICK_HEIGHT_LIMIT"] = "1000000000"
    env["MAGICK_AREA_LIMIT"] = "1000000000000"
    return env


def is_crash_exit_code(returncode):
    """
    Check if the exit code indicates a crash (signal-based termination).

    Negative return codes in Python subprocess indicate signal termination:
    -6 = SIGABRT
    -11 = SIGSEGV
    """
    return returncode < 0


class TestBMPOverflowVulnerability:
    """
    Test that BMP files triggering integer overflow are EARLY rejected.

    The vulnerability: width * bits_per_pixel overflows on 32-bit systems
    when the check is performed AFTER the multiplication.

    Fixed behavior: Check BEFORE multiplication, reject early.
    Vulnerable behavior: Crash OR dimensions parsed (overflow happened).

    These tests FAIL in vulnerable state.
    These tests PASS in fixed state.
    """

    def test_primary_overflow_vector(self):
        """
        Test the primary overflow case: width=536870912, bpp=32.

        Calculation: 536870912 * 32 = 17179869184 (0x400000000)
        On 32-bit: truncates to 0, causing memory issues.

        VULNERABLE: Prints "536870912x1" to stdout OR crashes
        FIXED: Early rejection, no dimensions printed, no crash
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_primary.bmp")

            # Width=0x20000000 (536870912), Height=1, BPP=32
            # This causes: 536870912 * 32 = 2^34, which overflows 32-bit size_t
            create_overflow_bmp(poc_file, 536870912, 1, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # Check for dimensions in output (vulnerable - overflow happened)
            assert "536870912" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed and printed. Stdout: {result.stdout}"

    def test_overflow_with_convert_command(self):
        """Test overflow handling with convert command."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_convert.bmp")
            out_file = os.path.join(tmpdir, "output.png")

            create_overflow_bmp(poc_file, 536870912, 1, 32)

            result = subprocess.run(
                ["convert", poc_file, out_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # Should fail (non-zero) but not crash
            assert result.returncode != 0, "Should fail to convert malformed BMP"

            # Output file should not exist
            assert not os.path.exists(out_file), \
                "Should not create output file from malformed input"

            # In vulnerable version, error comes from cache.c, stream.c, or png.c
            # In fixed version, error should come from bmp.c early check
            stderr_lower = result.stderr.lower()
            vulnerable_sources = ["cache.c", "stream.c", "png.c"]
            error_from_vulnerable_source = any(src in stderr_lower for src in vulnerable_sources)

            # FAIL if error from downstream (vulnerable)
            assert not error_from_vulnerable_source, \
                f"VULNERABLE: Error from downstream source, not early bmp.c check. Stderr: {result.stderr}"

    def test_alternative_overflow_width(self):
        """Test with alternative width value that also causes overflow."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_alt.bmp")

            # Width=0x10000000 (268435456), BPP=32
            # 268435456 * 32 = 2^33, still overflows 32-bit
            create_overflow_bmp(poc_file, 268435456, 1, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # FAIL if dimensions printed (vulnerable)
            assert "268435456" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"

    def test_overflow_with_24bpp(self):
        """Test overflow with 24 bits per pixel."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_24bpp.bmp")

            # Width that overflows when multiplied by 24
            # 178956971 * 24 = 4294967304 (overflows)
            create_overflow_bmp(poc_file, 178956971, 1, 24)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # FAIL if dimensions printed (vulnerable)
            assert "178956971" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"

    def test_overflow_with_16bpp(self):
        """Test overflow with 16 bits per pixel."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_16bpp.bmp")

            # Width that overflows when multiplied by 16
            # 268435456 * 16 = 2^32, exact overflow boundary
            create_overflow_bmp(poc_file, 268435456, 1, 16)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # FAIL if dimensions printed (vulnerable)
            assert "268435456" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"

    def test_multiple_row_overflow(self):
        """Test overflow with multiple rows."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_multirow.bmp")

            # Use height=2 which passes existing checks but still triggers the CVE
            # (height=10 would be caught by a different existing check at line 1128)
            create_overflow_bmp(poc_file, 536870912, 2, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # FAIL if dimensions printed (vulnerable)
            assert "536870912" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"


class TestOverflowErrorMessages:
    """Test that proper error messages indicate rejection."""

    def test_error_message_content(self):
        """Verify the file is rejected with an error (not a crash)."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "overflow_msg.bmp")
            create_overflow_bmp(poc_file, 536870912, 1, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # Should have some error output
            assert result.stderr, "Should have error message"

            # Should not have dimensions in stdout
            assert "536870912" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"


class TestBoundaryConditions:
    """Test boundary conditions at the overflow threshold."""

    def test_exact_overflow_boundary(self):
        """Test at exact 32-bit overflow boundary."""
        with tempfile.TemporaryDirectory() as tmpdir:
            poc_file = os.path.join(tmpdir, "exact_overflow.bmp")

            # 134217728 * 32 = 2^32 exactly (overflows to 0)
            create_overflow_bmp(poc_file, 134217728, 1, 32)

            result = subprocess.run(
                ["identify", poc_file],
                capture_output=True, text=True,
                env=get_test_env(),
                timeout=60
            )

            # Check for crash (vulnerable)
            assert not is_crash_exit_code(result.returncode), \
                f"VULNERABLE: Process crashed with signal {-result.returncode}"

            # FAIL if dimensions printed (vulnerable)
            assert "134217728" not in result.stdout, \
                f"VULNERABLE: Overflow dimensions were parsed. Stdout: {result.stdout}"
