#!/bin/bash
# Solution script for NiceGUI path traversal vulnerability
# This script patches the add_media_files method to validate file paths

set -e
cd /app

echo "Finding NiceGUI installation path..."
NICEGUI_APP=$(python3 -c "from nicegui.app import app; print(app.__file__)")
echo "Found: ${NICEGUI_APP}"

echo "Applying fix to add_media_files method..."

# Apply the fix using Python for reliable multiline replacement
python3 << 'PYFIX'
import re
import sys

# Find nicegui app.py
from nicegui.app import app
filepath = app.__file__

print(f"Reading {filepath}")
with open(filepath, 'r') as f:
    content = f.read()

# Check if already fixed
if 'is_relative_to(local_dir)' in content:
    print("File already patched, skipping...")
    sys.exit(0)

# The vulnerable pattern - simple string replacement approach
old_str = "filepath = Path(local_directory) / filename\n            if not filepath.is_file():"
new_str = """local_dir = Path(local_directory).resolve()
            filepath = (local_dir / filename).resolve()
            if not filepath.is_relative_to(local_dir) or not filepath.is_file():"""

if old_str in content:
    new_content = content.replace(old_str, new_str)
    with open(filepath, 'w') as f:
        f.write(new_content)
    print(f"Successfully patched: {filepath}")
else:
    # Try regex approach for slight whitespace variations
    pattern = r'filepath = Path\(local_directory\) / filename\n(\s+)if not filepath\.is_file\(\):'

    def replacement(match):
        indent = match.group(1)
        return f'''local_dir = Path(local_directory).resolve()
{indent}filepath = (local_dir / filename).resolve()
{indent}if not filepath.is_relative_to(local_dir) or not filepath.is_file():'''

    new_content = re.sub(pattern, replacement, content)

    if new_content != content:
        with open(filepath, 'w') as f:
            f.write(new_content)
        print(f"Successfully patched (regex): {filepath}")
    else:
        print("ERROR: Could not find vulnerable pattern in file", file=sys.stderr)
        print("File content around read_item:", file=sys.stderr)
        if 'def read_item' in content:
            idx = content.find('def read_item')
            print(content[idx:idx+500], file=sys.stderr)
        sys.exit(1)
PYFIX

echo "Fix applied successfully!"

# Kill the running NiceGUI process so it restarts with the patched code
echo "Restarting NiceGUI application..."
# Use Python to find and kill the python process since pkill may not be available
python3 << 'PYKILL'
import os
import signal

# Find Python process PIDs (excluding ourselves)
my_pid = os.getpid()
for proc_dir in os.listdir('/proc'):
    if not proc_dir.isdigit():
        continue
    pid = int(proc_dir)
    if pid == my_pid or pid == 1:  # Skip self and init
        continue
    try:
        with open(f'/proc/{pid}/comm', 'r') as f:
            if 'python' in f.read():
                print(f"Killing Python process {pid}")
                os.kill(pid, signal.SIGTERM)
    except (FileNotFoundError, PermissionError, ProcessLookupError):
        pass
PYKILL

# Wait a moment for the process to terminate
sleep 2

echo "Solution applied. The application will restart with the fix."
