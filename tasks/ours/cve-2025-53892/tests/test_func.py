"""
Functional tests for Vue I18n translate function.

These tests verify that the basic translation functionality works correctly
and should PASS in both vulnerable and fixed states.
"""
import subprocess
import json
import pytest
import os

# Test cases will be run via Node.js since vue-i18n is a JavaScript library
TEST_SCRIPT_PATH = "/tests/test_runner.mjs"


def run_node_test(test_code: str) -> dict:
    """Run a JavaScript test using Node.js and return the result."""
    # Write test code to a temporary file
    test_file = "/tests/_temp_test.mjs"

    # Use the full @intlify/core package which includes the message compiler
    # Import from the CJS version via dynamic import for better compatibility
    full_code = f'''
import {{ createCoreContext, translate }} from '/app/packages/core/dist/core.mjs';

// Polyfill __DEV__ if not defined
globalThis.__DEV__ = false;

{test_code}
'''

    with open(test_file, 'w') as f:
        f.write(full_code)

    try:
        result = subprocess.run(
            ['node', test_file],
            capture_output=True,
            text=True,
            timeout=30,
            cwd='/app'
        )

        # Parse output as JSON if possible
        output = result.stdout.strip()
        stderr = result.stderr.strip()

        return {
            'success': result.returncode == 0,
            'stdout': output,
            'stderr': stderr,
            'returncode': result.returncode
        }
    except subprocess.TimeoutExpired:
        return {
            'success': False,
            'stdout': '',
            'stderr': 'Test timed out',
            'returncode': -1
        }
    except Exception as e:
        return {
            'success': False,
            'stdout': '',
            'stderr': str(e),
            'returncode': -1
        }
    finally:
        if os.path.exists(test_file):
            os.remove(test_file)


class TestBasicTranslation:
    """Test basic translation functionality."""

    def test_simple_text_translation(self):
        """Test simple text translation without interpolation."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    messages: {
        en: { greeting: 'Hello World!' }
    }
});

const output = translate(ctx, 'greeting');
console.log(JSON.stringify({ output }));

if (output !== 'Hello World!') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output'] == 'Hello World!'

    def test_named_interpolation(self):
        """Test translation with named parameter interpolation."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    messages: {
        en: { hello: 'Hello, {name}!' }
    }
});

const output = translate(ctx, 'hello', { name: 'Alice' });
console.log(JSON.stringify({ output }));

if (output !== 'Hello, Alice!') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output'] == 'Hello, Alice!'

    def test_list_interpolation(self):
        """Test translation with list parameter interpolation."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    messages: {
        en: { message: 'Item {0} costs {1} dollars' }
    }
});

const output = translate(ctx, 'message', ['Apple', '5']);
console.log(JSON.stringify({ output }));

if (output !== 'Item Apple costs 5 dollars') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output'] == 'Item Apple costs 5 dollars'


class TestEscapeParameterBasic:
    """Test basic escapeParameter functionality."""

    def test_escape_html_special_chars(self):
        """Test that HTML special characters are escaped when escapeParameter is true."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    escapeParameter: true,
    messages: {
        en: { message: 'Content: {content}' }
    }
});

const output = translate(ctx, 'message', { content: '<script>alert(1)</script>' });
console.log(JSON.stringify({ output }));

// Should escape < and >
if (output.includes('<script>') || output.includes('</script>')) {
    console.error('HTML tags were not escaped');
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        # Verify HTML special chars are escaped
        assert '<script>' not in data['output']
        assert '</script>' not in data['output']
        assert '&lt;' in data['output']

    def test_escape_quotes(self):
        """Test that quote characters are escaped when escapeParameter is true."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    escapeParameter: true,
    messages: {
        en: { message: 'Value: {val}' }
    }
});

const output = translate(ctx, 'message', { val: '"test" and \\'other\\'' });
console.log(JSON.stringify({ output }));

// Should escape quotes
if (output.includes('Value: "') && !output.includes('&quot;')) {
    console.error('Double quotes were not escaped');
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        # Quotes should be escaped
        assert '&quot;' in data['output'] or '&#34;' in data['output']

    def test_no_escape_when_disabled(self):
        """Test that HTML is not escaped when escapeParameter is false."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    escapeParameter: false,
    warnHtmlMessage: false,
    messages: {
        en: { message: 'Content: {content}' }
    }
});

const output = translate(ctx, 'message', { content: '<b>bold</b>' });
console.log(JSON.stringify({ output }));

// Should NOT escape when disabled
if (!output.includes('<b>bold</b>')) {
    console.error('HTML was escaped when it should not be');
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        # HTML should not be escaped when disabled
        assert '<b>bold</b>' in data['output']


class TestPluralMessages:
    """Test plural message translation."""

    def test_plural_forms(self):
        """Test plural message selection."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    messages: {
        en: { items: 'no items | one item | {count} items' }
    }
});

const output0 = translate(ctx, 'items', 0);
const output1 = translate(ctx, 'items', 1);
const output5 = translate(ctx, 'items', 5);

console.log(JSON.stringify({ output0, output1, output5 }));

if (output0 !== 'no items' || output1 !== 'one item' || output5 !== '5 items') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output0'] == 'no items'
        assert data['output1'] == 'one item'
        assert data['output5'] == '5 items'


class TestFallbackBehavior:
    """Test fallback behavior for missing translations."""

    def test_fallback_to_key(self):
        """Test that missing keys fall back to the key itself."""
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    missingWarn: false,
    fallbackWarn: false,
    messages: {
        en: {}
    }
});

const output = translate(ctx, 'missing.key');
console.log(JSON.stringify({ output }));

if (output !== 'missing.key') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output'] == 'missing.key'


class TestLinkedMessages:
    """Test linked message translations."""

    def test_nested_interpolation(self):
        """Test nested message key translation (without @: linked syntax)."""
        # Note: The @:name linked message syntax may not work in standalone core context.
        # This test uses explicit nested key access instead.
        result = run_node_test('''
const ctx = createCoreContext({
    locale: 'en',
    messages: {
        en: {
            name: 'World',
            greeting: 'Hello {name}!'
        }
    }
});

const name = translate(ctx, 'name');
const output = translate(ctx, 'greeting', { name });
console.log(JSON.stringify({ output, name }));

if (output !== 'Hello World!') {
    process.exit(1);
}
''')
        assert result['success'], f"Test failed: {result['stderr']}"
        data = json.loads(result['stdout'])
        assert data['output'] == 'Hello World!'
