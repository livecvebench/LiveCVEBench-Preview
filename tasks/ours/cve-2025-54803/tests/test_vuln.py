"""
Vulnerability tests for js-toml parser prototype pollution.
These tests verify that the prototype pollution vulnerability is blocked.
Should FAIL in vulnerable state (pollution occurs) and PASS in fixed state.
"""
import subprocess
import pytest


def run_node(script):
    """Helper to run a Node.js script and return the result."""
    result = subprocess.run(
        ['node', '-e', script],
        capture_output=True,
        text=True,
        cwd='/app'
    )
    return result


class TestPrototypePollutionBlocked:
    """Test that various prototype pollution attack vectors are blocked."""

    def test_basic_proto_table_pollution(self):
        """Test that basic __proto__ table pollution is blocked."""
        result = run_node('''
const { load } = require("js-toml");

// Create object BEFORE parsing
const testObj = {};
const beforeValue = testObj.polluted;

// Attempt prototype pollution via TOML table
const maliciousToml = `
[__proto__]
polluted = true
`;
load(maliciousToml);

// Check if pollution occurred
const afterValue = testObj.polluted;

// Output results for debugging
console.log("Before:", beforeValue);
console.log("After:", afterValue);

// Exit with code 1 if polluted (vulnerability exists)
// Exit with code 0 if not polluted (fixed)
process.exit(afterValue === true ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Prototype pollution occurred! Object was polluted. Output: {result.stdout}"

    def test_isadmin_bypass_attack(self):
        """Test the authentication bypass scenario is blocked."""
        result = run_node('''
const { load } = require("js-toml");

const user = { username: "attacker" };
const beforeIsAdmin = user.isAdmin;

const toml = `
[__proto__]
isAdmin = true
`;
load(toml);

const afterIsAdmin = user.isAdmin;

console.log("Before isAdmin:", beforeIsAdmin);
console.log("After isAdmin:", afterIsAdmin);

// If fixed, user.isAdmin should remain undefined
process.exit(afterIsAdmin === true ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Authentication bypass still possible! Output: {result.stdout}"

    def test_multiple_property_pollution(self):
        """Test pollution with multiple properties is blocked."""
        result = run_node('''
const { load } = require("js-toml");

const testObj = {};

const toml = `
[__proto__]
isAdmin = true
role = "superuser"
canDelete = true
`;
load(toml);

const polluted = testObj.isAdmin === true ||
                 testObj.role === "superuser" ||
                 testObj.canDelete === true;

console.log("isAdmin:", testObj.isAdmin);
console.log("role:", testObj.role);
console.log("canDelete:", testObj.canDelete);

process.exit(polluted ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Multiple property pollution occurred! Output: {result.stdout}"

    def test_dotted_proto_key_pollution(self):
        """Test dotted __proto__ key notation pollution is blocked."""
        result = run_node('''
const { load } = require("js-toml");

const testObj = {};

const toml = `__proto__.polluted = true`;
load(toml);

console.log("polluted:", testObj.polluted);
process.exit(testObj.polluted === true ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Dotted __proto__ key pollution occurred! Output: {result.stdout}"

    def test_nested_proto_pollution(self):
        """Test nested __proto__ table pollution is blocked."""
        result = run_node('''
const { load } = require("js-toml");

const testObj = {};

const toml = `
[__proto__]
nested = "value1"

[__proto__.deeper]
value = "polluted"
`;
load(toml);

const polluted = testObj.nested === "value1" ||
                 (testObj.deeper && testObj.deeper.value === "polluted");

console.log("nested:", testObj.nested);
console.log("deeper:", testObj.deeper);

process.exit(polluted ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Nested __proto__ pollution occurred! Output: {result.stdout}"

    def test_array_table_proto_pollution(self):
        """Test array of tables with __proto__ pollution is blocked."""
        result = run_node('''
const { load } = require("js-toml");

const testObj = {};

const toml = `
[[__proto__]]
item = "polluted"
`;
load(toml);

// Check if __proto__ became an array that pollutes
const polluted = Array.isArray(testObj) || testObj.item === "polluted";

console.log("testObj:", testObj);
console.log("polluted:", polluted);

process.exit(polluted ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Array table __proto__ pollution occurred! Output: {result.stdout}"


class TestNewObjectsNotPolluted:
    """Test that newly created objects after parsing are not polluted."""

    def test_new_object_after_parse(self):
        """Test that objects created after parsing are not polluted."""
        result = run_node('''
const { load } = require("js-toml");

// Parse malicious TOML first
const toml = `
[__proto__]
injected = "malicious"
`;
load(toml);

// Create NEW object after parsing
const newObj = {};

console.log("injected:", newObj.injected);
process.exit(newObj.injected === "malicious" ? 1 : 0);
        ''')
        assert result.returncode == 0, f"New object was polluted! Output: {result.stdout}"

    def test_object_literal_not_polluted(self):
        """Test that object literals are not affected."""
        result = run_node('''
const { load } = require("js-toml");

const toml = `
[__proto__]
secret = "exposed"
`;
load(toml);

// Create object literal
const config = { name: "test" };

console.log("secret:", config.secret);
process.exit(config.secret === "exposed" ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Object literal was polluted! Output: {result.stdout}"

    def test_class_instance_not_polluted(self):
        """Test that class instances are not polluted."""
        result = run_node('''
const { load } = require("js-toml");

class User {
    constructor(name) {
        this.name = name;
    }
}

const toml = `
[__proto__]
admin = true
`;
load(toml);

const user = new User("test");

console.log("admin:", user.admin);
process.exit(user.admin === true ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Class instance was polluted! Output: {result.stdout}"


class TestGlobalObjectNotAffected:
    """Test that global Object.prototype is not modified."""

    def test_object_prototype_unchanged(self):
        """Test that Object.prototype is not modified."""
        result = run_node('''
const { load } = require("js-toml");

// Get prototype properties before
const beforeKeys = Object.keys(Object.prototype);

const toml = `
[__proto__]
newProperty = "injected"
`;
load(toml);

// Get prototype properties after
const afterKeys = Object.keys(Object.prototype);

// Check if new properties were added to Object.prototype
const hasNewProperty = "newProperty" in Object.prototype ||
                       afterKeys.length > beforeKeys.length;

console.log("Before keys:", beforeKeys.length);
console.log("After keys:", afterKeys.length);
console.log("Has newProperty:", "newProperty" in Object.prototype);

process.exit(hasNewProperty ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Object.prototype was modified! Output: {result.stdout}"

    def test_hasownproperty_still_works(self):
        """Test that hasOwnProperty is not overwritten."""
        result = run_node('''
const { load } = require("js-toml");

const toml = `
[__proto__]
hasOwnProperty = "hacked"
`;
load(toml);

const obj = { test: "value" };

// If hasOwnProperty was polluted, this would fail or return wrong value
let polluted = false;
try {
    const result = obj.hasOwnProperty("test");
    // If polluted, hasOwnProperty would be "hacked" string, not a function
    polluted = typeof obj.hasOwnProperty !== "function";
} catch (e) {
    polluted = true;
}

console.log("hasOwnProperty type:", typeof obj.hasOwnProperty);
process.exit(polluted ? 1 : 0);
        ''')
        assert result.returncode == 0, f"hasOwnProperty was polluted! Output: {result.stdout}"


class TestParsedDataIsolation:
    """Test that parsed data is properly isolated."""

    def test_proto_stored_as_regular_key(self):
        """Test that __proto__ in TOML becomes a regular key in result."""
        result = run_node('''
const { load } = require("js-toml");

const toml = `
[__proto__]
value = "test"
`;
const parsed = load(toml);

// In the fixed version, __proto__ should be stored as a regular key
// Check using Object.getOwnPropertyNames to see own properties
const ownProps = Object.getOwnPropertyNames(parsed);
console.log("Own properties:", ownProps);
console.log("parsed:", JSON.stringify(parsed, (k, v) => v, 2));

// Check that a new empty object is NOT polluted
const newObj = {};
const notPolluted = newObj.value !== "test";

console.log("newObj.value:", newObj.value);
process.exit(notPolluted ? 0 : 1);
        ''')
        assert result.returncode == 0, f"Parsed data leaked to other objects! Output: {result.stdout}"

    def test_multiple_parses_isolated(self):
        """Test that multiple parses don't accumulate pollution."""
        result = run_node('''
const { load } = require("js-toml");

// Parse multiple malicious TOMLs
load('[__proto__]\\nprop1 = "a"');
load('[__proto__]\\nprop2 = "b"');
load('[__proto__]\\nprop3 = "c"');

const testObj = {};
const polluted = testObj.prop1 === "a" ||
                 testObj.prop2 === "b" ||
                 testObj.prop3 === "c";

console.log("prop1:", testObj.prop1);
console.log("prop2:", testObj.prop2);
console.log("prop3:", testObj.prop3);

process.exit(polluted ? 1 : 0);
        ''')
        assert result.returncode == 0, f"Multiple parses caused pollution! Output: {result.stdout}"
