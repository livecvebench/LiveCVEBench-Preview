"""
Vulnerability tests for CVE-2025-47947: ModSecurity JSON processing memory issue.

These tests verify that the VULNERABILITY IS FIXED:
- Should FAIL in vulnerable state (vulnerability is present)
- Should PASS in fixed state (vulnerability is patched)

The vulnerability causes O(n^2) growth in sanitize table entries when processing
JSON arrays with rules using sanitiseMatchedBytes. The key observable symptom
is duplicate entries in the Sanitised-Args field of the audit log.
"""

import pytest
import requests
import time
import subprocess
import os
import re


# Base URL for the Apache server with ModSecurity
BASE_URL = "http://localhost:80"

# Audit log location
AUDIT_LOG_PATH = "/var/log/modsec_audit.log"


def wait_for_server(max_retries=30, delay=1):
    """Wait for the server to be ready."""
    for i in range(max_retries):
        try:
            response = requests.get(BASE_URL, timeout=5)
            return True
        except requests.exceptions.ConnectionError:
            time.sleep(delay)
        except requests.exceptions.Timeout:
            time.sleep(delay)
    return False


def send_json_payload(payload, timeout=60):
    """Send a JSON POST request and return response."""
    try:
        response = requests.post(
            BASE_URL,
            json=payload,
            timeout=timeout
        )
        return response
    except requests.exceptions.Timeout:
        return None
    except requests.exceptions.ConnectionError:
        return None


def clear_audit_log():
    """Clear the ModSecurity audit log."""
    try:
        subprocess.run(["truncate", "-s", "0", AUDIT_LOG_PATH], timeout=5)
    except Exception:
        pass


def get_audit_log_content():
    """Read the content of the audit log."""
    try:
        with open(AUDIT_LOG_PATH, 'r') as f:
            return f.read()
    except Exception:
        return ""


def get_sanitised_args_line_length(log_content):
    """
    Get the total length of all Sanitised-Args lines.
    In vulnerable version, this is extremely long due to duplicate entries.
    """
    total_length = 0
    for line in log_content.split('\n'):
        if line.startswith('Sanitised-Args:'):
            total_length += len(line)
    return total_length


def count_quoted_entries_in_sanitised_args(log_content):
    """
    Count the number of quoted entries in Sanitised-Args lines.
    Each entry is enclosed in quotes like "key.subkey".

    In fixed version: count ~= number of JSON elements
    In vulnerable version: count ~= (number of elements)^2
    """
    total_count = 0
    for line in log_content.split('\n'):
        if line.startswith('Sanitised-Args:'):
            # Count quoted strings (each sanitized arg is quoted)
            matches = re.findall(r'"[^"]+"', line)
            total_count += len(matches)
    return total_count


class TestVulnerabilityDetection:
    """
    Tests that detect whether CVE-2025-47947 vulnerability is present.

    These tests should FAIL when the vulnerability exists and PASS when fixed.
    The vulnerability is detected by checking for excessive sanitization entries
    in the audit log - each JSON array element should only be sanitized once.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready and clear the audit log."""
        assert wait_for_server(), "Server did not start in time"
        time.sleep(1)
        clear_audit_log()
        time.sleep(0.5)

    def test_small_array_sanitization_count(self):
        """
        Test that small JSON arrays have linear sanitization count.

        With 10 elements:
        - Fixed: ~10-20 sanitization entries (linear)
        - Vulnerable: ~100+ entries (quadratic - each element * total elements)

        This test FAILS if too many sanitization entries are created.
        """
        array_size = 10
        payload = {"arr": [f"v{i}" for i in range(array_size)]}

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(1)
        log_content = get_audit_log_content()

        entry_count = count_quoted_entries_in_sanitised_args(log_content)

        # Fixed: expect ~10-20 entries (ARGS + ARGS_NAMES rules)
        # Vulnerable: expect ~100+ entries (10*10 for just ARGS, more with both rules)
        # Threshold: 40 (allows some overhead but catches quadratic growth)
        max_expected = array_size * 4  # Linear with generous buffer

        assert entry_count <= max_expected, \
            f"Too many sanitization entries: {entry_count} (expected <= {max_expected} for {array_size} elements, quadratic would be ~{array_size * array_size})"

    def test_medium_array_sanitization_count(self):
        """
        Test that medium JSON arrays have linear sanitization count.

        With 30 elements:
        - Fixed: ~30-60 entries (linear)
        - Vulnerable: ~900+ entries (quadratic)
        """
        array_size = 30
        payload = {"data": [f"item{i}" for i in range(array_size)]}

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(1)
        log_content = get_audit_log_content()

        entry_count = count_quoted_entries_in_sanitised_args(log_content)

        max_expected = array_size * 4  # Linear with buffer

        assert entry_count <= max_expected, \
            f"Too many sanitization entries: {entry_count} (expected <= {max_expected} for {array_size} elements, quadratic would be ~{array_size * array_size})"

    def test_sanitised_args_line_not_excessive(self):
        """
        Test that Sanitised-Args line doesn't grow excessively.

        The Sanitised-Args line length should be proportional to array size.
        In vulnerable version, it grows quadratically.
        """
        array_size = 20
        payload = {"items": [f"val{i}" for i in range(array_size)]}

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(1)
        log_content = get_audit_log_content()

        line_length = get_sanitised_args_line_length(log_content)

        # Each entry is roughly 15-25 chars ("items.items", plus comma and space)
        # With 20 elements, fixed version: ~20-40 entries = ~400-1000 chars
        # Vulnerable version: ~400 entries = ~8000-12000 chars
        max_expected_length = array_size * 100  # ~2000 chars for 20 elements

        assert line_length <= max_expected_length, \
            f"Sanitised-Args line too long: {line_length} chars (expected <= {max_expected_length}, indicating quadratic growth)"

    def test_larger_array_sanitization_count(self):
        """
        Test that larger JSON arrays have linear sanitization count.

        With 50 elements:
        - Fixed: ~50-100 entries
        - Vulnerable: ~2500+ entries
        """
        array_size = 50
        payload = {"users": [f"u{i}" for i in range(array_size)]}

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(2)
        log_content = get_audit_log_content()

        entry_count = count_quoted_entries_in_sanitised_args(log_content)

        max_expected = array_size * 4

        assert entry_count <= max_expected, \
            f"Too many sanitization entries: {entry_count} (expected <= {max_expected} for {array_size} elements, quadratic would be ~{array_size * array_size})"

    def test_scaling_is_linear_not_quadratic(self):
        """
        Test that sanitization count scales linearly with array size.

        Compare 20 elements vs 40 elements:
        - Fixed: 40-element count ~= 2x 20-element count (linear)
        - Vulnerable: 40-element count ~= 4x 20-element count (quadratic)
        """
        # Test with 20 elements
        clear_audit_log()
        time.sleep(0.5)

        size_small = 20
        payload_small = {"test": [f"v{i}" for i in range(size_small)]}
        response = send_json_payload(payload_small)
        assert response is not None, "Small request failed"

        time.sleep(1)
        log_small = get_audit_log_content()
        count_small = count_quoted_entries_in_sanitised_args(log_small)

        # Test with 40 elements
        clear_audit_log()
        time.sleep(0.5)

        size_large = 40
        payload_large = {"test": [f"v{i}" for i in range(size_large)]}
        response = send_json_payload(payload_large)
        assert response is not None, "Large request failed"

        time.sleep(1)
        log_large = get_audit_log_content()
        count_large = count_quoted_entries_in_sanitised_args(log_large)

        # Calculate ratio
        if count_small > 0:
            ratio = count_large / count_small
            # Linear: ratio ~2 (2x data = 2x entries)
            # Quadratic: ratio ~4 (2x data = 4x entries)
            assert ratio < 3.0, \
                f"Sanitization count scales quadratically: {count_small} (n={size_small}) -> {count_large} (n={size_large}), ratio={ratio:.1f} (expected ~2 for linear, got {ratio:.1f} suggesting quadratic)"

    def test_multiple_arrays_sanitization(self):
        """
        Test sanitization count with multiple arrays in one request.
        """
        array_size = 15
        payload = {
            "arr1": [f"a{i}" for i in range(array_size)],
            "arr2": [f"b{i}" for i in range(array_size)],
        }

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(1)
        log_content = get_audit_log_content()

        entry_count = count_quoted_entries_in_sanitised_args(log_content)

        # Total elements = 30, expect linear growth
        total_elements = array_size * 2
        max_expected = total_elements * 4

        assert entry_count <= max_expected, \
            f"Too many sanitization entries for multiple arrays: {entry_count} (expected <= {max_expected})"

    def test_nested_structure_sanitization(self):
        """
        Test sanitization count with nested JSON structure.
        """
        payload = {
            "level1": [
                {"nested": [f"v{i}" for i in range(10)]}
                for _ in range(3)
            ]
        }

        response = send_json_payload(payload)
        assert response is not None, "Request failed"

        time.sleep(1)
        log_content = get_audit_log_content()

        line_length = get_sanitised_args_line_length(log_content)

        # Nested structure with ~30 elements
        # Fixed: ~30-60 entries = ~1000-2000 chars
        # Vulnerable: ~900+ entries = ~20000+ chars
        assert line_length < 8000, \
            f"Sanitised-Args line too long for nested structure: {line_length} chars (suggests quadratic duplication)"

