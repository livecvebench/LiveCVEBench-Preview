"""
Vulnerability tests for Tautulli path traversal.

These tests verify that the path traversal vulnerability EXISTS in the vulnerable environment.

Expected behavior:
- FAIL in vulnerable state (the vulnerability exists and data is leaked, triggering assertion failures)
- PASS in fixed state (path traversal is blocked, no secret data leaked)

The tests assert that secret data should NOT be in the response. In a vulnerable environment,
the secret WILL be leaked, causing assertion failure (test FAILS) - proving the vulnerability exists.

Directory structure:
- App is at: /app/tautulli/
- Images served from: /app/tautulli/data/interfaces/default/images/
- Config/secret at: /config/
- Need 6 levels of ../ to traverse from images to /config/
"""

import socket
import time
import os

BASE_URL = "http://localhost:8181"
SECRET_CONTENT = "SENSITIVE_DATA_12345"
SECRET_FILE = "/config/secret.txt"

# Number of ../ levels needed to traverse from data/interfaces/default/images to /
# /app/tautulli/data/interfaces/default/images -> / needs 6 levels
TRAVERSAL_PREFIX = "interfaces/default/images/../../../../../../"


def wait_for_service(timeout=60):
    """Wait for Tautulli service to be ready using raw sockets."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect(("localhost", 8181))
            sock.close()
            return True
        except:
            pass
        time.sleep(1)
    return False


def setup_secret_file():
    """Create the secret file for testing."""
    os.makedirs(os.path.dirname(SECRET_FILE), exist_ok=True)
    with open(SECRET_FILE, 'w') as f:
        f.write(SECRET_CONTENT)


def make_raw_request(path):
    """
    Make a raw HTTP request that preserves path traversal sequences.

    The requests library normalizes URLs and removes ../ sequences.
    We need to use a raw HTTP request to test path traversal properly.
    """
    host = "localhost"
    port = 8181

    # Build the raw HTTP request - preserve the exact path
    request = f"GET {path} HTTP/1.1\r\n"
    request += f"Host: {host}:{port}\r\n"
    request += "Connection: close\r\n"
    request += "\r\n"

    try:
        # Create socket and send request
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        sock.sendall(request.encode())

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
        sock.close()

        # Decode response
        return response.decode('utf-8', errors='replace')
    except Exception as e:
        return f"Error: {e}"


class TestPathTraversalVulnerability:
    """Test path traversal vulnerability detection."""

    @classmethod
    def setup_class(cls):
        """Set up test environment."""
        assert wait_for_service(), "Tautulli service did not start in time"
        setup_secret_file()

    def test_path_traversal_to_secret_file(self):
        """
        Test path traversal to read the secret file at /config/secret.txt.

        Attack vector: interfaces/default/images/../../../../../../config/secret.txt

        In VULNERABLE state: Response contains SECRET_CONTENT -> assertion FAILS
        In FIXED state: Response is empty -> assertion PASSES
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}config/secret.txt"
        response = make_raw_request(path)

        assert SECRET_CONTENT not in response, \
            f"VULNERABILITY EXISTS: Path traversal leaked secret data!"

    def test_path_traversal_to_etc_passwd(self):
        """
        Test path traversal to read /etc/passwd.

        Attack vector: Attempt to read system file
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}etc/passwd"
        response = make_raw_request(path)

        assert "root:" not in response, \
            f"VULNERABILITY EXISTS: Path traversal leaked /etc/passwd!"

    def test_path_traversal_to_config_ini(self):
        """
        Test path traversal to read config.ini at /config/config.ini.

        Attack vector: Attempt to read the application configuration file.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}config/config.ini"
        response = make_raw_request(path)

        # Config file indicators
        config_indicators = ["[General]", "http_port", "http_host"]

        for indicator in config_indicators:
            assert indicator not in response, \
                f"VULNERABILITY EXISTS: Path traversal leaked config.ini! Found '{indicator}'"

    def test_path_traversal_to_source_code(self):
        """
        Test path traversal to read application source code.

        Attack vector: Attempt to read webserve.py
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}app/tautulli/plexpy/webserve.py"
        response = make_raw_request(path)

        # Source code indicators
        code_indicators = ["cherrypy", "def ", "import "]

        for indicator in code_indicators:
            assert indicator not in response, \
                f"VULNERABILITY EXISTS: Path traversal leaked source code! Found '{indicator}'"

    def test_path_traversal_to_tautulli_main(self):
        """
        Test path traversal to read Tautulli.py main file.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}app/tautulli/Tautulli.py"
        response = make_raw_request(path)

        code_indicators = ["plexpy", "__main__", "import"]

        for indicator in code_indicators:
            assert indicator not in response, \
                f"VULNERABILITY EXISTS: Path traversal leaked Tautulli.py! Found '{indicator}'"

    def test_path_traversal_to_requirements(self):
        """
        Test reading requirements.txt via path traversal.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}app/tautulli/requirements.txt"
        response = make_raw_request(path)

        # requirements.txt typically contains these
        indicators = ["cherrypy", "plexapi"]

        for indicator in indicators:
            assert indicator not in response, \
                f"VULNERABILITY EXISTS: Path traversal leaked requirements.txt! Found '{indicator}'"

    def test_path_traversal_to_database(self):
        """
        Test reading database file header via path traversal.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}config/tautulli.db"
        response = make_raw_request(path)

        # SQLite files start with this header
        assert "SQLite format 3" not in response, \
            "VULNERABILITY EXISTS: Path traversal leaked database file!"


class TestMultipleVulnerabilityVectors:
    """Additional test vectors to verify vulnerability coverage."""

    @classmethod
    def setup_class(cls):
        """Set up test environment."""
        assert wait_for_service(), "Tautulli service did not start in time"
        setup_secret_file()

    def test_vulnerability_read_proc_version(self):
        """
        Test reading /proc/version via path traversal.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}proc/version"
        response = make_raw_request(path)

        # /proc/version typically contains "Linux version"
        assert "Linux version" not in response, \
            "VULNERABILITY EXISTS: Path traversal leaked /proc/version!"

    def test_vulnerability_read_proc_cmdline(self):
        """
        Test reading /proc/self/cmdline via path traversal.
        """
        path = f"/pms_image_proxy?img={TRAVERSAL_PREFIX}proc/self/cmdline"
        response = make_raw_request(path)

        # cmdline might contain python or tautulli
        cmdline_indicators = ["python", "tautulli", "Tautulli"]

        for indicator in cmdline_indicators:
            assert indicator.lower() not in response.lower(), \
                f"VULNERABILITY EXISTS: Path traversal leaked /proc/self/cmdline! Found '{indicator}'"

    def test_vulnerability_with_extra_traversal(self):
        """
        Test with more ../ levels than necessary (should still work).
        """
        # More traversal levels than needed - should still resolve to /config/
        extra_traversal = "interfaces/default/images/../../../../../../../../../../../config/secret.txt"
        path = f"/pms_image_proxy?img={extra_traversal}"
        response = make_raw_request(path)

        assert SECRET_CONTENT not in response, \
            "VULNERABILITY EXISTS: Extra traversal attack succeeded!"
