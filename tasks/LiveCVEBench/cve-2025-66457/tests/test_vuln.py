"""
Vulnerability Tests for Elysia Cookie Config Code Injection (CVE-2025-66457)

These tests verify that the code injection vulnerability is properly mitigated.
- FAIL in vulnerable state (vulnerability is exploitable, injected code executes)
- PASS in fixed state (vulnerability is mitigated, no code execution)

The vulnerability exists in how Elysia handles cookie configuration values
during lazy route compilation. The `secrets` value is interpolated directly
into generated JavaScript code without proper escaping.

IMPORTANT: The vulnerability triggers on FIRST REQUEST to a route with cookies,
not at server startup. This is because Elysia uses lazy compilation.
"""

import subprocess
import time
import os
import requests
import pytest

# Base directory where the app is located
APP_DIR = "/app"
INJECTION_MARKER = "VULN_INJECTION_MARKER_CVE66457"


def start_server_and_test_injection(payload_secret, marker_to_find, port=3001):
    """
    Start the Elysia server with a malicious COOKIE_SECRET,
    make a request to trigger lazy compilation, then check if
    the injection marker appears in the output.

    Returns True if marker was found (vulnerability exists),
    False if not found (vulnerability is fixed).
    """
    env = os.environ.copy()
    env["COOKIE_SECRET"] = payload_secret

    # Kill any existing server on our test port
    subprocess.run(["pkill", "-f", f"bun.*test_vuln_server"], capture_output=True)
    time.sleep(1)

    # Create a temp test file that uses a different port
    test_script = f'''
import {{ Elysia, t }} from "elysia";
const secret = process.env.COOKIE_SECRET || "default";
const app = new Elysia({{ cookie: {{ secrets: secret }} }})
    .get("/", () => "Hello", {{
        cookie: t.Cookie({{ session: t.Optional(t.String()) }}),
    }})
    .listen({port});
console.log("Test server ready on port {port}");
setTimeout(async () => {{
    try {{ await fetch("http://localhost:{port}/"); }} catch(e) {{}}
    process.exit(0);
}}, 500);
'''

    try:
        # Write test script
        with open("/app/test_vuln_server.ts", "w") as f:
            f.write(test_script)

        # Start the server with the malicious payload
        proc = subprocess.Popen(
            ["bun", "run", "/app/test_vuln_server.ts"],
            cwd=APP_DIR,
            env=env,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Wait for the process to complete (it exits after making the request)
        try:
            stdout, stderr = proc.communicate(timeout=10)
        except subprocess.TimeoutExpired:
            proc.kill()
            stdout, stderr = proc.communicate()

        output = stdout + stderr
        return marker_to_find in output

    except Exception as e:
        print(f"Error: {e}")
        return False
    finally:
        subprocess.run(["pkill", "-f", "test_vuln_server"], capture_output=True)


class TestCookieSecretInjection:
    """
    Test code injection through cookie secrets configuration.

    These tests use console.log injection. If the vulnerability exists,
    the console.log output will appear in stdout after making a request.

    Expected: FAIL in vulnerable version (injection detected)
              PASS in fixed version (no injection)
    """

    def setup_method(self):
        """Clean up before each test."""
        subprocess.run(["pkill", "-f", "bun.*app.ts"], capture_output=True)
        time.sleep(1)

    def teardown_method(self):
        """Clean up after each test."""
        subprocess.run(["pkill", "-f", "bun.*app.ts"], capture_output=True)

    def test_single_quote_injection_blocked(self):
        """
        Test that single quote injection is blocked.

        Payload breaks out of string context: 'PAYLOAD'
        Becomes: secrets:'' + console.log('MARKER') + ''

        In vulnerable version: MARKER appears in stdout
        In fixed version: quotes are escaped, no execution
        """
        marker = f"{INJECTION_MARKER}_QUOTE1"
        payload = f"' + console.log('{marker}') + '"

        injection_occurred = start_server_and_test_injection(payload, marker)

        assert not injection_occurred, \
            f"Code injection vulnerability detected - {marker} was executed"

    def test_double_single_quote_injection_blocked(self):
        """
        Test variation of quote injection.
        """
        marker = f"{INJECTION_MARKER}_QUOTE2"
        payload = f"test' + console.log('{marker}') + 'test"

        injection_occurred = start_server_and_test_injection(payload, marker)

        assert not injection_occurred, \
            f"Code injection vulnerability detected - {marker} was executed"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
