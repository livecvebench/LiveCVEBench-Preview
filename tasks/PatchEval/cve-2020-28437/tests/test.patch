diff --git a/poc/heroku-env.test.js b/poc/heroku-env.test.js
new file mode 100644
index 0000000..e38b3ec
--- /dev/null
+++ b/poc/heroku-env.test.js
@@ -0,0 +1,90 @@
+// poc/heroku-env.test.js
+const fs = require('fs');
+const path = require('path');
+
+const filePath = path.join(__dirname, '..', 'heroku-env');
+const injectionPayload = '& touch heroku-env';
+
+// reset module registry to ensure clean require() for each test run
+jest.resetModules();
+
+// provide a factory mock for child_process so the tested module always gets the mock
+jest.mock('child_process', () => {
+  const { EventEmitter } = require('events');
+
+  return {
+    exec: jest.fn((cmd, opts, cb) => {
+      if (typeof opts === 'function') cb = opts;
+      // simulate async callback without touching filesystem
+      if (cb) process.nextTick(() => cb(null, 'mock-exec-stdout', ''));
+    }),
+    execFile: jest.fn((file, args, cb) => {
+      if (cb) process.nextTick(() => cb(null, 'mock-execFile-stdout', ''));
+    }),
+    spawn: jest.fn((file, args) => {
+      const emitter = new EventEmitter();
+      emitter.stdout = new EventEmitter();
+      emitter.stderr = new EventEmitter();
+      // simulate output + close
+      process.nextTick(() => {
+        emitter.stdout.emit('data', 'mock');
+        emitter.stderr.emit('data', '');
+        emitter.emit('close', 0);
+      });
+      return emitter;
+    }),
+  };
+});
+
+beforeEach(() => {
+  // ensure no leftover file
+  try { if (fs.existsSync(filePath)) fs.unlinkSync(filePath); } catch (e) {}
+  jest.clearAllMocks();
+});
+
+afterEach(() => {
+  try { if (fs.existsSync(filePath)) fs.unlinkSync(filePath); } catch (e) {}
+});
+
+test('should not execute shell command or create file with injection payload', (done) => {
+  expect.assertions(3);
+
+  // require child_process (mocked) and module under test after mock is set up
+  const child_process = require('child_process');
+  // require the module under test; it will receive the mocked child_process
+  const root = require('heroku-env');
+
+  // call the module (common signature: (app, cb) or (app, env, cb))
+  // try calling (app, cb) first; if it throws synchronously, try (app, env, cb)
+  const callback = () => {
+    // 1) file should not be created by injection
+    expect(fs.existsSync(filePath)).toBe(false);
+
+    // 2) exec (shell-based API) must NOT be used
+    expect(child_process.exec).not.toHaveBeenCalled();
+
+    // 3) at least one safe API (execFile or spawn) should have been used
+    const usedSafe = child_process.execFile.mock.calls.length > 0 || child_process.spawn.mock.calls.length > 0;
+    expect(usedSafe).toBe(true);
+
+    done();
+  };
+
+  try {
+    root(injectionPayload, callback);
+  } catch (err1) {
+    try {
+      root(injectionPayload, 'AA', callback);
+    } catch (err2) {
+      // both signatures threw synchronously -> treat as safe (cannot execute)
+      // still need to satisfy expect.assertions(3)
+      expect(fs.existsSync(filePath)).toBe(false);
+      const child_process = require('child_process');
+      expect(child_process.exec).not.toHaveBeenCalled();
+      const usedSafe = child_process.execFile.mock.calls.length > 0 || child_process.spawn.mock.calls.length > 0;
+      expect(usedSafe).toBe(true);
+      done();
+    }
+  }
+});
+
