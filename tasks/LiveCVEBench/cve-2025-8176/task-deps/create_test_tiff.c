/*
 * Simple test TIFF generator for CVE-2025-8176 vulnerability testing
 * Creates a small RGB TIFF image that can be used with tiffmedian
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tiffio.h"

int main(int argc, char *argv[])
{
    const char *filename = (argc > 1) ? argv[1] : "test_rgb.tif";
    uint32_t width = 64;
    uint32_t height = 64;

    TIFF *tif = TIFFOpen(filename, "w");
    if (!tif) {
        fprintf(stderr, "Cannot create %s\n", filename);
        return 1;
    }

    /* Set required TIFF tags for RGB image */
    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, width * 3));
    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);

    /* Allocate scanline buffer */
    unsigned char *buf = (unsigned char *)_TIFFmalloc(width * 3);
    if (!buf) {
        TIFFClose(tif);
        return 1;
    }

    /* Write RGB data - gradient pattern */
    for (uint32_t row = 0; row < height; row++) {
        for (uint32_t col = 0; col < width; col++) {
            buf[col * 3 + 0] = (unsigned char)((row * 255) / height);     /* Red */
            buf[col * 3 + 1] = (unsigned char)((col * 255) / width);      /* Green */
            buf[col * 3 + 2] = (unsigned char)(((row + col) * 127) / (height + width)); /* Blue */
        }
        if (TIFFWriteScanline(tif, buf, row, 0) < 0) {
            fprintf(stderr, "Error writing scanline %u\n", row);
            break;
        }
    }

    _TIFFfree(buf);
    TIFFClose(tif);

    printf("Created test TIFF: %s (%ux%u RGB)\n", filename, width, height);
    return 0;
}
