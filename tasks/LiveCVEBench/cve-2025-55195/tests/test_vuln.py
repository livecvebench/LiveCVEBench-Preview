"""
Vulnerability tests for prototype pollution in the TOML parser.

These tests verify that parsing specially-crafted TOML input does NOT
pollute Object.prototype in Node.js environments.

- FAIL in vulnerable state (prototype pollution occurs)
- PASS in fixed state (prototype pollution is prevented)

Each test runs in a separate Node.js subprocess to ensure isolation
and prevent cross-test prototype pollution.
"""

import subprocess
import sys


def run_vulnerability_test(test_code: str, test_name: str) -> subprocess.CompletedProcess:
    """
    Run a vulnerability test in an isolated Node.js subprocess.
    Returns the completed process for assertion checking.
    """
    result = subprocess.run(
        ['node', '-e', test_code],
        capture_output=True,
        text=True,
        cwd='/app',
        timeout=30
    )
    return result


class TestDirectProtoTablePollution:
    """Tests for direct __proto__ table key pollution."""

    def test_proto_table_basic(self):
        """Test that [__proto__.isAdmin] doesn't pollute Object.prototype."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// Parse malicious TOML with __proto__ table - using dotted key pattern
parse('[__proto__.isAdmin]\\nvalue = true');

// Check if prototype is polluted
const obj = {};
if (obj.isAdmin !== undefined) {
    console.log("VULNERABLE: Object.prototype.isAdmin is polluted");
    console.log("Value:", JSON.stringify(obj.isAdmin));
    process.exit(1);
}
console.log("SAFE: No prototype pollution detected");
process.exit(0);
'''
        result = run_vulnerability_test(code, "proto_table_basic")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"

    def test_proto_table_with_value(self):
        """Test that [__proto__.data] with nested values doesn't pollute."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// Use the dotted key pattern that actually works
parse('[__proto__.data]\\nisAdmin = true\\nrole = "admin"');

const obj = {};
if (obj.data !== undefined) {
    console.log("VULNERABLE: __proto__.data polluted Object.prototype");
    console.log("Value:", JSON.stringify(obj.data));
    process.exit(1);
}
console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "proto_table_with_value")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"

    def test_proto_deeply_nested(self):
        """Test that [__proto__.a.b.c] doesn't pollute nested prototype."""
        code = '''
const { parse } = require('/app/toml/parse.js');

parse('[__proto__.deep.nested.path]\\nvalue = "polluted"');

const obj = {};
if (obj.deep !== undefined) {
    console.log("VULNERABLE: Deep nested __proto__ pollution");
    console.log("Value:", JSON.stringify(obj.deep));
    process.exit(1);
}
console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "proto_deeply_nested")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"


class TestArrayTablePollution:
    """Tests for array table syntax pollution."""

    def test_proto_array_table_basic(self):
        """Test that [[__proto__.arrayProp]] doesn't pollute prototype."""
        code = '''
const { parse } = require('/app/toml/parse.js');

parse('[[__proto__.arrayTable]]\\npolluted = true');

const obj = {};
if (obj.arrayTable !== undefined) {
    console.log("VULNERABLE: Array table syntax polluted Object.prototype");
    console.log("Value:", JSON.stringify(obj.arrayTable));
    process.exit(1);
}
console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "proto_array_table_basic")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"

    def test_proto_array_table_multiple(self):
        """Test that multiple [[__proto__.*]] entries don't pollute."""
        code = '''
const { parse } = require('/app/toml/parse.js');

parse('[[__proto__.items]]\\nname = "first"\\n\\n[[__proto__.items]]\\nname = "second"');

const obj = {};
if (obj.items !== undefined) {
    console.log("VULNERABLE: Multiple array tables polluted prototype");
    console.log("Value:", JSON.stringify(obj.items));
    process.exit(1);
}
console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "proto_array_table_multiple")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"


class TestMultiplePollutionAttempts:
    """Tests combining multiple pollution vectors."""

    def test_combined_attack(self):
        """Test multiple __proto__ pollution attempts in one TOML."""
        code = '''
const { parse } = require('/app/toml/parse.js');

const maliciousTOML = `
[__proto__.isAdmin]
value = true

[[__proto__.roles]]
name = "admin"
`;

parse(maliciousTOML);

const obj = {};
const polluted = obj.isAdmin !== undefined ||
                 obj.roles !== undefined;

if (polluted) {
    console.log("VULNERABLE: Combined attack polluted Object.prototype");
    console.log("isAdmin:", obj.isAdmin);
    console.log("roles:", obj.roles);
    process.exit(1);
}
console.log("SAFE: All pollution attempts blocked");
process.exit(0);
'''
        result = run_vulnerability_test(code, "combined_attack")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"

    def test_simple_proto_pollution(self):
        """Test basic __proto__ table pollution."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// Simple test of __proto__ table
parse('[__proto__.test]\\nvalue = true');

const obj = {};
if (obj.test !== undefined) {
    console.log("VULNERABLE");
    process.exit(1);
}
console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "simple_proto_pollution")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"


class TestPollutionPersistence:
    """Tests that verify pollution doesn't persist across parsing calls."""

    def test_sequential_parses(self):
        """Test that sequential parses don't accumulate pollution."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// First parse with __proto__
parse('[__proto__.first]\\nvalue = 1');

// Second parse with different __proto__
parse('[__proto__.second]\\nvalue = 2');

// Third normal parse
const result = parse('[normal]\\nkey = "value"');

const obj = {};
if (obj.first !== undefined || obj.second !== undefined) {
    console.log("VULNERABLE: Sequential parses accumulated pollution");
    console.log("first:", obj.first);
    console.log("second:", obj.second);
    process.exit(1);
}

// Verify normal parsing still works
if (!result.normal || result.normal.key !== "value") {
    console.log("ERROR: Normal parsing broken");
    process.exit(1);
}

console.log("SAFE");
process.exit(0);
'''
        result = run_vulnerability_test(code, "sequential_parses")
        assert result.returncode == 0, f"Prototype pollution detected! {result.stdout} {result.stderr}"


class TestRealWorldExploits:
    """Tests simulating real-world exploit scenarios."""

    def test_authentication_bypass(self):
        """Test that __proto__ can't be used for auth bypass."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// Attacker submits malicious TOML config using dotted key pattern
parse('[__proto__.isAuthenticated]\\nvalue = true');
parse('[__proto__.isAdmin]\\nvalue = true');

// Application checks user permissions on a fresh object
function checkAccess(user) {
    // user object comes from somewhere (e.g., session)
    const permissions = {};
    if (permissions.isAuthenticated) {
        if (permissions.isAdmin) {
            return "ADMIN_ACCESS";
        }
        return "USER_ACCESS";
    }
    return "NO_ACCESS";
}

const access = checkAccess({});
if (access !== "NO_ACCESS") {
    console.log("VULNERABLE: Authentication bypass possible!");
    console.log("Access level:", access);
    process.exit(1);
}
console.log("SAFE: No auth bypass");
process.exit(0);
'''
        result = run_vulnerability_test(code, "authentication_bypass")
        assert result.returncode == 0, f"Authentication bypass possible! {result.stdout} {result.stderr}"

    def test_config_injection(self):
        """Test that __proto__ can't inject config values."""
        code = '''
const { parse } = require('/app/toml/parse.js');

// Attacker injects malicious defaults using dotted key pattern
parse('[__proto__.defaultTimeout]\\nvalue = 0');
parse('[__proto__.maxRetries]\\nvalue = 999999');

// Application uses config with defaults
function getConfig(userConfig) {
    const config = {};
    return {
        timeout: config.defaultTimeout?.value ?? 30000,
        retries: config.maxRetries?.value ?? 3
    };
}

const config = getConfig({});
if (config.timeout === 0 || config.retries === 999999) {
    console.log("VULNERABLE: Config injection possible!");
    console.log("Config:", JSON.stringify(config));
    process.exit(1);
}
console.log("SAFE: No config injection");
process.exit(0);
'''
        result = run_vulnerability_test(code, "config_injection")
        assert result.returncode == 0, f"Config injection possible! {result.stdout} {result.stderr}"
