"""
Vulnerability Tests for WordPress Make Connector Plugin - CVE-2025-6085

These tests verify that the file upload validation happens BEFORE files are
written to disk. The vulnerability is that files are copied to the uploads
directory before validation, allowing dangerous files to persist even when
the API returns an error.

- FAIL in vulnerable state (files exist despite error response)
- PASS in fixed state (files never written if validation fails)
"""

import os
import pytest
import requests
import subprocess
from datetime import datetime
import time


# Configuration
WP_URL = os.environ.get('WP_URL', 'http://localhost')
API_KEY = os.environ.get('API_KEY', '')
UPLOADS_BASE = '/var/www/html/wp-content/uploads'


def get_api_key():
    """Get API key from environment or from WordPress database."""
    if API_KEY:
        return API_KEY

    # Try to get from WP-CLI
    try:
        result = subprocess.run(
            ['wp', '--path=/var/www/html', 'option', 'get', 'iwc_api_key', '--allow-root'],
            capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass

    # Fallback: query database directly
    try:
        result = subprocess.run(
            ['wp', '--path=/var/www/html', 'db', 'query',
             "SELECT option_value FROM wp_options WHERE option_name='iwc_api_key';",
             '--allow-root', '--skip-column-names'],
            capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass

    pytest.fail("Could not retrieve API key. Set API_KEY environment variable.")


def get_upload_date_path():
    """Get current YYYY/MM path for uploads directory."""
    now = datetime.now()
    return f"{now.year}/{now.month:02d}"


def file_exists_on_disk(filename, retries=3, delay=0.5):
    """Check if a file exists in the uploads directory.

    Retries multiple times to handle filesystem sync delays.
    """
    date_path = get_upload_date_path()
    full_path = f"{UPLOADS_BASE}/{date_path}/{filename}"

    for attempt in range(retries):
        # Check via filesystem using ls command for more reliability
        result = subprocess.run(
            ['ls', '-la', full_path],
            capture_output=True
        )
        if result.returncode == 0:
            return True
        if attempt < retries - 1:
            time.sleep(delay)

    return False


def file_exists_via_http(filename):
    """Check if a file is accessible via HTTP."""
    date_path = get_upload_date_path()
    url = f"{WP_URL}/wp-content/uploads/{date_path}/{filename}"

    try:
        response = requests.head(url, timeout=10)
        return response.status_code == 200
    except Exception:
        return False


def cleanup_file(filename):
    """Remove a file from the uploads directory."""
    date_path = get_upload_date_path()
    full_path = f"{UPLOADS_BASE}/{date_path}/{filename}"
    try:
        subprocess.run(['rm', '-f', full_path], capture_output=True, timeout=10)
    except Exception:
        pass


class TestPHPFileUploadBlocked:
    """Test that PHP files cannot be uploaded and do not persist on disk."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup for each test."""
        self.api_key = get_api_key()
        self.headers = {"IWC-API-KEY": self.api_key}
        self.test_files = []
        yield
        # Cleanup any files that may have been created
        for filename in self.test_files:
            cleanup_file(filename)

    def test_php_file_upload_blocked(self):
        """Test that .php files are rejected AND do not exist on disk after."""
        filename = f"test_vuln_php_{int(time.time())}.php"
        self.test_files.append(filename)

        php_content = b"<?php echo 'test'; phpinfo(); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-php")},
            timeout=30
        )

        # API should return an error
        assert response.status_code >= 400 or 'not permitted' in response.text.lower(), \
            f"PHP upload should be rejected. Status: {response.status_code}"

        # Critical: File should NOT exist on disk
        time.sleep(3.0)  # Brief delay to ensure filesystem is synced
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP file '{filename}' exists on disk despite error response!"
        assert not file_exists_via_http(filename), \
            f"VULNERABLE: PHP file '{filename}' is accessible via HTTP!"

    def test_php_file_with_uppercase_extension(self):
        """Test that .PHP (uppercase) files are blocked."""
        filename = f"test_vuln_PHP_{int(time.time())}.PHP"
        self.test_files.append(filename)

        php_content = b"<?php system($_GET['c']); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename.lower()) and not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP file with uppercase extension exists on disk!"

    def test_phtml_file_upload_blocked(self):
        """Test that .phtml files are rejected AND do not exist on disk."""
        filename = f"test_vuln_phtml_{int(time.time())}.phtml"
        self.test_files.append(filename)

        php_content = b"<?php passthru($_REQUEST['x']); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-httpd-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHTML file '{filename}' exists on disk despite rejection!"

    def test_php5_file_upload_blocked(self):
        """Test that .php5 files are rejected AND do not exist on disk."""
        filename = f"test_vuln_php5_{int(time.time())}.php5"
        self.test_files.append(filename)

        php_content = b"<?php exec($_GET['cmd']); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP5 file '{filename}' exists on disk!"

    def test_phar_file_upload_blocked(self):
        """Test that .phar files are rejected AND do not exist on disk."""
        filename = f"test_vuln_phar_{int(time.time())}.phar"
        self.test_files.append(filename)

        # Minimal PHAR structure
        phar_content = b"<?php __HALT_COMPILER(); ?>\x0d\x0a"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, phar_content, "application/x-phar")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHAR file '{filename}' exists on disk!"


class TestDoubleExtensionBypass:
    """Test that double extension bypass attempts are blocked."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup for each test."""
        self.api_key = get_api_key()
        self.headers = {"IWC-API-KEY": self.api_key}
        self.test_files = []
        yield
        for filename in self.test_files:
            cleanup_file(filename)

    def test_php_jpg_double_extension(self):
        """Test that .php.jpg files are blocked and don't persist on disk.

        CVE-2025-6085: Files should NOT persist on disk even if rejected.
        WordPress may sanitize the filename, but any persistence is a vulnerability.
        """
        filename = f"test_vuln_double_{int(time.time())}.php.jpg"
        self.test_files.append(filename)

        # Also track the sanitized version
        sanitized = filename.replace('.php.', '.php_.')
        self.test_files.append(sanitized)

        # PHP content with JPEG header to try bypass
        php_content = b"\xFF\xD8\xFF\xE0<?php echo shell_exec($_GET['cmd']); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "image/jpeg")},
            timeout=30
        )

        time.sleep(3.0)

        # CVE-2025-6085 vulnerability: file should NOT exist on disk at all
        # Even with sanitized name, file persistence means vulnerability exists
        original_exists = file_exists_on_disk(filename)
        sanitized_exists = file_exists_on_disk(sanitized)
        php_only_exists = file_exists_on_disk(filename.replace('.php.jpg', '.php'))

        assert not original_exists and not sanitized_exists and not php_only_exists, \
            f"VULNERABLE: Double extension file persists on disk (original={original_exists}, sanitized={sanitized_exists}, php={php_only_exists})"

    def test_jpg_php_double_extension(self):
        """Test that .jpg.php files are blocked."""
        filename = f"test_vuln_reverse_{int(time.time())}.jpg.php"
        self.test_files.append(filename)

        php_content = b"GIF89a<?php eval($_POST['x']); ?>"

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: .jpg.php file exists on disk!"


class TestAlternativePHPExtensions:
    """Test various alternative PHP extensions that could execute code."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup for each test."""
        self.api_key = get_api_key()
        self.headers = {"IWC-API-KEY": self.api_key}
        self.test_files = []
        yield
        for filename in self.test_files:
            cleanup_file(filename)

    def test_php3_extension_blocked(self):
        """Test that .php3 files are blocked."""
        filename = f"test_vuln_php3_{int(time.time())}.php3"
        self.test_files.append(filename)

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, b"<?php echo 1; ?>", "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP3 file exists on disk!"

    def test_php4_extension_blocked(self):
        """Test that .php4 files are blocked."""
        filename = f"test_vuln_php4_{int(time.time())}.php4"
        self.test_files.append(filename)

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, b"<?php echo 2; ?>", "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP4 file exists on disk!"

    def test_phps_extension_blocked(self):
        """Test that .phps files are blocked."""
        filename = f"test_vuln_phps_{int(time.time())}.phps"
        self.test_files.append(filename)

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, b"<?php highlight_file(__FILE__); ?>", "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHPS file exists on disk!"

    def test_inc_extension_blocked(self):
        """Test that .inc files with PHP content are blocked and don't persist.

        CVE-2025-6085: The vulnerability is about file persistence on disk,
        regardless of whether the file can execute. Files should NOT exist.
        """
        filename = f"test_vuln_inc_{int(time.time())}.inc"
        self.test_files.append(filename)

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, b"<?php include('evil.php'); ?>", "text/plain")},
            timeout=30
        )

        # File should NOT exist on disk - that's the vulnerability
        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: .inc file '{filename}' persists on disk despite rejection!"


class TestWebShellUploadBlocked:
    """Test that actual webshell payloads are blocked."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup for each test."""
        self.api_key = get_api_key()
        self.headers = {"IWC-API-KEY": self.api_key}
        self.test_files = []
        yield
        for filename in self.test_files:
            cleanup_file(filename)

    def test_simple_webshell_blocked(self):
        """Test that a simple webshell cannot be uploaded."""
        filename = f"shell_{int(time.time())}.php"
        self.test_files.append(filename)

        webshell = b'''<?php
if (!empty($_GET['cmd'])) {
    echo "<pre>".shell_exec($_GET["cmd"])."</pre>";
}
?>'''

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, webshell, "application/x-php")},
            timeout=30
        )

        # Verify error response
        assert response.status_code >= 400 or 'not permitted' in response.text.lower(), \
            f"Webshell upload should be rejected"

        # Critical: Verify file doesn't exist
        time.sleep(3.0)  # Ensure filesystem sync
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: Webshell file exists on disk!"

        # Double-check via HTTP
        assert not file_exists_via_http(filename), \
            f"VULNERABLE: Webshell is accessible via HTTP!"

    def test_eval_webshell_blocked(self):
        """Test that eval-based webshell is blocked."""
        filename = f"eval_shell_{int(time.time())}.php"
        self.test_files.append(filename)

        webshell = b'<?php eval($_POST["c"]); ?>'

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, webshell, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: Eval webshell exists on disk!"

    def test_obfuscated_webshell_blocked(self):
        """Test that obfuscated PHP is blocked (based on extension, not content)."""
        filename = f"obf_shell_{int(time.time())}.php"
        self.test_files.append(filename)

        # Base64 encoded payload (still has .php extension)
        webshell = b'<?php eval(base64_decode("c3lzdGVtKCRfR0VUWydjJ10pOw==")); ?>'

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, webshell, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: Obfuscated webshell exists on disk!"


class TestPHPCodeExecution:
    """Test that uploaded PHP files cannot be executed even if they persist."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup for each test."""
        self.api_key = get_api_key()
        self.headers = {"IWC-API-KEY": self.api_key}
        self.test_files = []
        yield
        for filename in self.test_files:
            cleanup_file(filename)

    def test_uploaded_php_not_executable(self):
        """
        Test that PHP files cannot be uploaded and persist on disk.
        CVE-2025-6085: The vulnerability is that files are copied BEFORE validation,
        so the file persists on disk even when the API returns an error.
        """
        filename = f"exec_test_{int(time.time())}.php"
        self.test_files.append(filename)

        # Simple phpinfo that we can detect in response
        php_content = b'<?php echo "EXECUTION_MARKER_12345"; phpinfo(); ?>'

        response = requests.post(
            f"{WP_URL}/wp-json/wp/v2/media",
            headers=self.headers,
            files={"file": (filename, php_content, "application/x-php")},
            timeout=30
        )

        time.sleep(3.0)

        # CVE-2025-6085: File should NOT exist on disk
        # If it exists, the vulnerability is present (file copied before validation)
        assert not file_exists_on_disk(filename), \
            f"VULNERABLE: PHP file '{filename}' was written to disk despite rejection!"
