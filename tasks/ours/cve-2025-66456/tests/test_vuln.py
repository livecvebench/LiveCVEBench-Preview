"""
Vulnerability tests for prototype pollution in deep object merge.
These tests verify that the vulnerability is mitigated.
- FAIL in vulnerable state (prototype pollution is exploitable)
- PASS in fixed state (prototype pollution is blocked)
"""

import pytest
import requests
import time

BASE_URL = "http://localhost:3000"


def wait_for_server(url: str, timeout: int = 30) -> bool:
    """Wait for server to become available."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{url}/", timeout=2)
            return True
        except requests.exceptions.ConnectionError:
            time.sleep(0.5)
        except requests.exceptions.Timeout:
            time.sleep(0.5)
    return False


@pytest.fixture(scope="module", autouse=True)
def server_ready():
    """Ensure server is ready before running tests."""
    assert wait_for_server(BASE_URL), f"Server at {BASE_URL} did not become available"
    yield


class TestPrototypePollutionVia__proto__:
    """Test prototype pollution via __proto__ key."""

    def test_basic_proto_pollution(self):
        """
        Test basic prototype pollution via __proto__ key.

        Sends a payload with __proto__.foo = "bar" and checks if the pollution
        affects unrelated objects. The response contains {}.foo which should
        be null/undefined normally, but will be "bar" if polluted.
        """
        payload = {
            "data": {
                "messageId": "pollute-me",
                "__proto__": {
                    "foo": "bar"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()

        # If vulnerable: win will be "bar" (polluted)
        # If fixed: win will be null/None (not polluted)
        assert data.get("win") is None or data.get("win") == "null", \
            f"Prototype pollution detected! Expected 'win' to be null, but got: {data.get('win')}"

    def test_proto_pollution_with_different_property(self):
        """
        Test prototype pollution with a different property name.
        """
        payload = {
            "data": {
                "messageId": "test-pollute",
                "__proto__": {
                    "polluted": "yes"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        # The specific property might not be visible in response,
        # but we verify by checking the win field behavior
        data = response.json()
        # win should still be null (no pollution)
        assert data.get("win") is None or data.get("win") == "null"

    def test_nested_proto_pollution(self):
        """
        Test nested __proto__ pollution attempt.
        """
        payload = {
            "data": {
                "messageId": "nested-test",
                "__proto__": {
                    "foo": "outer",
                    "__proto__": {
                        "bar": "inner"
                    }
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        # Should not be polluted
        assert data.get("win") is None or data.get("win") == "null"

    def test_proto_pollution_multiple_properties(self):
        """
        Test prototype pollution with multiple properties.
        """
        payload = {
            "data": {
                "messageId": "multi-prop-test",
                "__proto__": {
                    "foo": "value1",
                    "bar": "value2",
                    "baz": "value3"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"

    def test_proto_pollution_with_numeric_value(self):
        """
        Test prototype pollution with numeric property value.
        """
        payload = {
            "data": {
                "messageId": "numeric-test",
                "__proto__": {
                    "foo": 12345
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        # win should be null, not 12345
        assert data.get("win") is None or data.get("win") == "null"

    def test_proto_pollution_with_boolean_value(self):
        """
        Test prototype pollution with boolean property value.
        """
        payload = {
            "data": {
                "messageId": "boolean-test",
                "__proto__": {
                    "foo": True
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"


class TestPrototypePollutionViaConstructor:
    """Test prototype pollution via constructor key."""

    def test_constructor_pollution(self):
        """
        Test prototype pollution via constructor.prototype.
        """
        payload = {
            "data": {
                "messageId": "constructor-test",
                "constructor": {
                    "prototype": {
                        "foo": "polluted-via-constructor"
                    }
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        # Should not be polluted
        assert data.get("win") is None or data.get("win") == "null"


class TestPrototypePollutionViaPrototype:
    """Test prototype pollution via prototype key."""

    def test_prototype_key_pollution(self):
        """
        Test prototype pollution via 'prototype' key.
        """
        payload = {
            "data": {
                "messageId": "prototype-key-test",
                "prototype": {
                    "foo": "polluted-via-prototype"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        # Should not affect prototype
        assert data.get("win") is None or data.get("win") == "null"


class TestPrototypePollutionEncodings:
    """Test prototype pollution with various encodings and bypass attempts."""

    def test_proto_with_unicode_bypass_attempt(self):
        """
        Test that unicode variations don't bypass protection.
        Note: JSON naturally uses the literal key, this tests the merge behavior.
        """
        # Standard __proto__ test with different value
        payload = {
            "data": {
                "messageId": "unicode-test",
                "__proto__": {
                    "foo": "unicode-bypass"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"

    def test_proto_in_array_context(self):
        """
        Test __proto__ doesn't pollute when in unusual context.
        """
        payload = {
            "data": {
                "messageId": "array-context-test",
                "__proto__": {
                    "foo": "array-test"
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"


class TestPersistentPollution:
    """Test that pollution doesn't persist across requests."""

    def test_pollution_does_not_persist(self):
        """
        Verify that even if first request attempts pollution,
        subsequent clean requests are not affected.
        """
        # First request - attempt pollution
        pollute_payload = {
            "data": {
                "messageId": "pollute-attempt",
                "__proto__": {
                    "foo": "persistent-pollution"
                }
            }
        }
        response1 = requests.post(
            f"{BASE_URL}/",
            json=pollute_payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response1.status_code == 200

        # Second request - clean request
        clean_payload = {
            "data": {
                "messageId": "clean-request"
            }
        }
        response2 = requests.post(
            f"{BASE_URL}/",
            json=clean_payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response2.status_code == 200
        data2 = response2.json()

        # win should still be null on clean request
        assert data2.get("win") is None or data2.get("win") == "null", \
            f"Persistent pollution detected! Expected 'win' to be null on clean request, got: {data2.get('win')}"

    def test_multiple_pollution_attempts_dont_accumulate(self):
        """
        Test that multiple pollution attempts don't accumulate.
        """
        properties = ["prop1", "prop2", "prop3"]

        for prop in properties:
            payload = {
                "data": {
                    "messageId": f"test-{prop}",
                    "__proto__": {
                        "foo": prop
                    }
                }
            }
            response = requests.post(
                f"{BASE_URL}/",
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=10
            )
            assert response.status_code == 200
            data = response.json()
            # Each should be protected
            assert data.get("win") is None or data.get("win") == "null"


class TestEdgeCasePayloads:
    """Test edge case payloads that might bypass protections."""

    def test_deeply_nested_proto(self):
        """
        Test deeply nested __proto__ attempt.
        """
        payload = {
            "data": {
                "messageId": "deep-nested",
                "nested": {
                    "level1": {
                        "level2": {
                            "__proto__": {
                                "foo": "deeply-nested-pollution"
                            }
                        }
                    }
                }
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"

    def test_proto_with_empty_object(self):
        """
        Test __proto__ with empty object.
        """
        payload = {
            "data": {
                "messageId": "empty-proto-test",
                "__proto__": {}
            }
        }
        response = requests.post(
            f"{BASE_URL}/",
            json=payload,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        assert response.status_code == 200
        data = response.json()
        assert data.get("win") is None or data.get("win") == "null"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
