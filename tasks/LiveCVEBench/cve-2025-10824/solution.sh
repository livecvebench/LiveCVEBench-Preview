#!/bin/bash
# Solution script for CVE-2025-10824: Use-after-free in fio job parser
#
# The vulnerability occurs because free(opts) is called unconditionally,
# but when parsing nested include files, opts points to the parent's memory.
# When an error occurs during nested parsing, free(opts) is called on the
# parent's opts array, causing UAF when the parent continues processing.
#
# The fix:
# 1. Move free(opts) from before out: label to after it
# 2. Add a check to only free(opts) when !nested (similar to the existing
#    check for free(name))
# This ensures opts is only freed by the top-level caller who allocated it.

set -e

cd /app/fio

echo "Applying fix for memory management issue in job parser..."

# The vulnerable code pattern (around line 2302):
#   nr_job_sections = 0;
#
#   free(opts);      <-- This is freed unconditionally, causing UAF in nested calls
# out:
#   free(string);
#   if (!nested)
#       free(name);
#
# The fix:
#   nr_job_sections = 0;
#
# out:
#   if (!nested)     <-- Only free when not nested (parent owns the memory)
#       free(opts);
#   free(string);
#   if (!nested)
#       free(name);

# Step 1: Remove the free(opts); line that appears before out: label
sed -i '/nr_job_sections = 0;/,/^out:/{
    /^[[:space:]]*free(opts);$/d
}' init.c

# Step 2: Add "if (!nested) free(opts);" after the out: label
# We need to add two lines: the if statement and the free call with proper indentation
sed -i '/^out:$/a\	if (!nested)\n\t\tfree(opts);' init.c

echo "Source fix applied successfully."

# Verify the fix was applied
if grep -A2 "^out:" init.c | grep -q "if (!nested)"; then
    echo "Verification: free(opts) is now conditional on !nested after out: label"
else
    echo "Warning: Fix verification failed, checking manually..."
    grep -n "free(opts)" init.c || true
    grep -n "^out:" init.c || true
    exit 1
fi

# Rebuild fio with the fixed source code
echo "Rebuilding fio..."
make -j$(nproc)

echo "Fix applied and fio rebuilt successfully."
