diff --git a/hand_test.py b/hand_test.py
new file mode 100644
index 0000000..9492c46
--- /dev/null
+++ b/hand_test.py
@@ -0,0 +1,86 @@
+import unittest
+import os
+import tempfile
+import stat
+import sys
+import shutil
+from pathlib import Path
+
+# Add the project root directory to the Python path
+sys.path.insert(0, str(Path(__file__).parent.parent))
+from spotipy.cache_handler import CacheFileHandler
+
+class TestCacheFileHandler(unittest.TestCase):
+    def setUp(self):
+        # Create a temporary directory
+        self.temp_dir = tempfile.mkdtemp()
+        self.cache_path = os.path.join(self.temp_dir, "test_cache.json")
+        
+    def tearDown(self):
+        # Clean up the temporary directory and its contents
+        if os.path.exists(self.temp_dir):
+            shutil.rmtree(self.temp_dir)
+    
+    def test_file_permissions(self):
+        """Test that cache file permissions are correctly set to 600"""
+        handler = CacheFileHandler(cache_path=self.cache_path)
+        test_token = {"access_token": "test", "token_type": "Bearer"}
+        
+        # Save the token and check permissions
+        handler.save_token_to_cache(test_token)
+        
+        # Verify that the file exists
+        self.assertTrue(os.path.exists(self.cache_path))
+        
+        # Verify file permissions
+        file_mode = os.stat(self.cache_path).st_mode
+        self.assertEqual(stat.S_IMODE(file_mode), 0o600)
+        
+        # Verify file content
+        with open(self.cache_path, 'r') as f:
+            content = f.read()
+        self.assertIn("access_token", content)
+    
+    def test_os_error_handling(self):
+        """Test handling of OSError exceptions (e.g., NotADirectoryError)"""
+        # Create a file to serve as an invalid intermediate path component
+        # This will cause open() to fail because it tries to create a file in a path
+        # where one directory component is actually a file.
+        intermediate_component_as_file = os.path.join(self.temp_dir, "intermediate_file_component")
+        with open(intermediate_component_as_file, "w", encoding='utf-8') as f:
+            f.write("This is a file, not a directory.")
+        
+        # This path will cause open() to fail because part of the path is a file
+        invalid_path = os.path.join(intermediate_component_as_file, "cache.json")
+        
+        handler = CacheFileHandler(cache_path=invalid_path)
+        # Use the same token structure as other tests
+        test_token = {"access_token": "test", "token_type": "Bearer"}
+        
+        # This should trigger an OSError (e.g., NotADirectoryError) when trying to open invalid_path.
+        # The handler's except OSError block should catch this error, log a warning, and not re-raise.
+        handler.save_token_to_cache(test_token)
+        
+        # Verify that the cache file was not created due to open() failure.
+        # If os.path.exists(invalid_path) is False, the entire condition in assertFalse is False.
+        # self.assertFalse(False) will pass.
+        self.assertFalse(os.path.exists(invalid_path) and os.access(invalid_path, os.W_OK))
+    
+    def test_file_not_found_error_handling(self):
+        """Test handling of FileNotFoundError exceptions"""
+        # Create a file and then immediately delete it
+        handler = CacheFileHandler(cache_path=self.cache_path)
+        test_token = {"access_token": "test"}
+        
+        # Create the file
+        with open(self.cache_path, 'w') as f:
+            f.write("test")
+        
+        # Delete the file to trigger FileNotFoundError
+        os.remove(self.cache_path)
+        
+        # Should trigger FileNotFoundError but not raise an exception
+        handler.save_token_to_cache(test_token)
+
+if __name__ == '__main__':
+    unittest.main()
