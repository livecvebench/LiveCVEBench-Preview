#!/usr/bin/env python3
"""
Functionality tests for AIDE file integrity checker.

These tests verify that AIDE works correctly - they should PASS
in both vulnerable and fixed states.
"""

import os
import subprocess
import tempfile
import shutil
import pytest


class TestAIDEBasicFunctionality:
    """Test basic AIDE operations"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        """Create a temporary test directory for each test"""
        self.test_dir = tempfile.mkdtemp(prefix="aide_test_")
        self.db_file = os.path.join(self.test_dir, "aide.db")
        self.db_out_file = os.path.join(self.test_dir, "aide.db.new")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        os.makedirs(self.monitored_dir)
        yield
        # Cleanup
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def _create_config(self, extra_options=""):
        """Create a minimal AIDE config file"""
        config_path = os.path.join(self.test_dir, "aide.conf")
        config = f"""
database_in=file:{self.db_file}
database_out=file:{self.db_out_file}
root_prefix={self.monitored_dir}
{extra_options}
/ R
"""
        with open(config_path, "w") as f:
            f.write(config)
        return config_path

    def _run_aide(self, args, config_path=None, expect_success=True):
        """Run AIDE with given arguments"""
        cmd = ["aide"]
        if config_path:
            cmd.extend(["--config", config_path])
        cmd.extend(args)

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=60
        )
        return result

    def test_aide_version(self):
        """Test that AIDE binary is available and reports version"""
        result = subprocess.run(
            ["aide", "--version"],
            capture_output=True,
            text=True,
            timeout=10
        )
        # AIDE --version may return non-zero but still outputs version info
        output = result.stdout + result.stderr
        assert "AIDE" in output or "aide" in output.lower(), \
            f"AIDE should report version info. Got: {output}"

    def test_aide_help(self):
        """Test that AIDE help is available"""
        result = subprocess.run(
            ["aide", "--help"],
            capture_output=True,
            text=True,
            timeout=10
        )
        output = result.stdout + result.stderr
        assert "--check" in output or "--init" in output, \
            f"AIDE help should list available options. Got: {output}"

    def test_aide_init_creates_database(self):
        """Test that AIDE --init creates a database file"""
        # Create a test file
        test_file = os.path.join(self.monitored_dir, "testfile.txt")
        with open(test_file, "w") as f:
            f.write("test content")

        config_path = self._create_config()

        # Run AIDE init
        result = self._run_aide(["--init"], config_path)

        # Init should complete (exit code 0 or produce database)
        assert os.path.exists(self.db_out_file), \
            f"AIDE --init should create database. stderr: {result.stderr}"

    def test_aide_check_detects_no_changes(self):
        """Test that AIDE check reports no changes when files unchanged"""
        # Create a test file
        test_file = os.path.join(self.monitored_dir, "stable_file.txt")
        with open(test_file, "w") as f:
            f.write("unchanged content")

        config_path = self._create_config()

        # Initialize database
        self._run_aide(["--init"], config_path)

        # Copy new database to input database location
        shutil.copy(self.db_out_file, self.db_file)

        # Run check - should find no changes
        result = self._run_aide(["--check"], config_path)
        output = result.stdout + result.stderr

        # AIDE returns 0 for no changes
        assert result.returncode == 0, \
            f"AIDE check should return 0 for no changes. Got: {result.returncode}, output: {output}"

    def test_aide_detects_file_modification(self):
        """Test that AIDE detects when a file is modified"""
        # Create a test file
        test_file = os.path.join(self.monitored_dir, "to_modify.txt")
        with open(test_file, "w") as f:
            f.write("original content")

        config_path = self._create_config()

        # Initialize database
        self._run_aide(["--init"], config_path)
        shutil.copy(self.db_out_file, self.db_file)

        # Modify the file
        with open(test_file, "w") as f:
            f.write("modified content - different!")

        # Run check - should detect change
        result = self._run_aide(["--check"], config_path)
        output = result.stdout + result.stderr

        # AIDE returns non-zero when changes detected
        assert result.returncode != 0 or "changed" in output.lower(), \
            f"AIDE should detect file modification. output: {output}"

    def test_aide_detects_new_file(self):
        """Test that AIDE detects when a new file is added"""
        # Create initial file
        initial_file = os.path.join(self.monitored_dir, "initial.txt")
        with open(initial_file, "w") as f:
            f.write("initial file")

        config_path = self._create_config()

        # Initialize database
        self._run_aide(["--init"], config_path)
        shutil.copy(self.db_out_file, self.db_file)

        # Add a new file
        new_file = os.path.join(self.monitored_dir, "new_file.txt")
        with open(new_file, "w") as f:
            f.write("new file content")

        # Run check - should detect new file
        result = self._run_aide(["--check"], config_path)
        output = result.stdout + result.stderr

        # AIDE returns non-zero when changes detected
        assert result.returncode != 0 or "added" in output.lower(), \
            f"AIDE should detect new file. output: {output}"

    def test_aide_detects_deleted_file(self):
        """Test that AIDE detects when a file is deleted"""
        # Create test files
        to_delete = os.path.join(self.monitored_dir, "to_delete.txt")
        keep_file = os.path.join(self.monitored_dir, "keep_this.txt")
        with open(to_delete, "w") as f:
            f.write("will be deleted")
        with open(keep_file, "w") as f:
            f.write("keep this")

        config_path = self._create_config()

        # Initialize database
        self._run_aide(["--init"], config_path)
        shutil.copy(self.db_out_file, self.db_file)

        # Delete the file
        os.remove(to_delete)

        # Run check - should detect deletion
        result = self._run_aide(["--check"], config_path)
        output = result.stdout + result.stderr

        # AIDE returns non-zero when changes detected
        assert result.returncode != 0 or "removed" in output.lower(), \
            f"AIDE should detect deleted file. output: {output}"

    def test_aide_handles_multiple_files(self):
        """Test that AIDE handles multiple files correctly"""
        # Create multiple test files
        for i in range(5):
            test_file = os.path.join(self.monitored_dir, f"file_{i}.txt")
            with open(test_file, "w") as f:
                f.write(f"content {i}")

        config_path = self._create_config()

        # Initialize database
        result = self._run_aide(["--init"], config_path)

        # Should complete without error
        assert os.path.exists(self.db_out_file), \
            f"AIDE should handle multiple files. stderr: {result.stderr}"

    def test_aide_handles_subdirectories(self):
        """Test that AIDE handles subdirectories correctly"""
        # Create nested directory structure
        subdir = os.path.join(self.monitored_dir, "subdir1", "subdir2")
        os.makedirs(subdir)
        test_file = os.path.join(subdir, "nested_file.txt")
        with open(test_file, "w") as f:
            f.write("nested content")

        config_path = self._create_config()

        # Initialize database
        result = self._run_aide(["--init"], config_path)

        # Should complete without error
        assert os.path.exists(self.db_out_file), \
            f"AIDE should handle subdirectories. stderr: {result.stderr}"


class TestAIDEFilenameHandling:
    """Test AIDE handling of various filename characters"""

    @pytest.fixture(autouse=True)
    def setup_test_env(self):
        """Create a temporary test directory for each test"""
        self.test_dir = tempfile.mkdtemp(prefix="aide_func_")
        self.db_file = os.path.join(self.test_dir, "aide.db")
        self.db_out_file = os.path.join(self.test_dir, "aide.db.new")
        self.monitored_dir = os.path.join(self.test_dir, "monitored")
        os.makedirs(self.monitored_dir)
        yield
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def _create_config(self):
        config_path = os.path.join(self.test_dir, "aide.conf")
        config = f"""
database_in=file:{self.db_file}
database_out=file:{self.db_out_file}
root_prefix={self.monitored_dir}
/ R
"""
        with open(config_path, "w") as f:
            f.write(config)
        return config_path

    def _run_aide(self, args, config_path):
        cmd = ["aide", "--config", config_path] + args
        return subprocess.run(cmd, capture_output=True, text=True, timeout=60)

    def test_handles_spaces_in_filename(self):
        """Test that AIDE handles filenames with spaces"""
        test_file = os.path.join(self.monitored_dir, "file with spaces.txt")
        with open(test_file, "w") as f:
            f.write("content")

        config_path = self._create_config()
        result = self._run_aide(["--init"], config_path)

        assert os.path.exists(self.db_out_file), \
            f"AIDE should handle spaces in filenames. stderr: {result.stderr}"

    def test_handles_unicode_in_filename(self):
        """Test that AIDE handles Unicode characters in filenames"""
        test_file = os.path.join(self.monitored_dir, "file_unicode_\u00e9\u00e8\u00e0.txt")
        with open(test_file, "w") as f:
            f.write("content")

        config_path = self._create_config()
        result = self._run_aide(["--init"], config_path)

        assert os.path.exists(self.db_out_file), \
            f"AIDE should handle Unicode in filenames. stderr: {result.stderr}"

    def test_handles_dots_and_dashes(self):
        """Test that AIDE handles dots and dashes in filenames"""
        test_file = os.path.join(self.monitored_dir, "file-with.dots.and-dashes.txt")
        with open(test_file, "w") as f:
            f.write("content")

        config_path = self._create_config()
        result = self._run_aide(["--init"], config_path)

        assert os.path.exists(self.db_out_file), \
            f"AIDE should handle dots and dashes. stderr: {result.stderr}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
