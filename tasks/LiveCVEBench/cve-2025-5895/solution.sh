#!/bin/bash
# Solution script for fixing the parseDataUri performance issue
# This replaces the problematic regex pattern with an optimized version

set -e

TARGET_FILE="/app/frontend/src/metabase/lib/dom.js"

echo "Applying fix to parseDataUri function in $TARGET_FILE"

# Check if the file exists
if [ ! -f "$TARGET_FILE" ]; then
    echo "Error: Target file not found: $TARGET_FILE"
    exit 1
fi

# Check if already fixed (idempotency check)
if grep -q '(?:(?!\\1|,)\.)' "$TARGET_FILE" 2>/dev/null; then
    echo "Fix already applied, skipping..."
    exit 0
fi

# Use Node.js for reliable regex replacement
cat > /tmp/fix_regex.js << 'ENDFIX'
const fs = require('fs');
const path = '/app/frontend/src/metabase/lib/dom.js';

let content = fs.readFileSync(path, 'utf8');
let modified = false;

// The vulnerable pattern has (.*) at the end
// We need to replace it with ((?:(?!\1|,).)*)

// Try multiple patterns to handle different file formats
const patterns = [
    // Pattern 1: Original multi-line format
    {
        find: /url && url\.match\(\/\^data:\(\?:\(\[\^;\]\+\)\(\?:;\(\[\^;\]\+\)\)\?\)\?\(;base64\)\?,\(\.\*\)\\\$\/\)/g,
        replace: `url &&
    url.match(/^data:(?:([^;]+)(?:;([^;]+))?)?(;base64)?,((?:(?!\\1|,).)*)$/)`
    },
    // Pattern 2: Single line format
    {
        find: /url\.match\(\/\^data:\(\?:\(\[\^;\]\+\)\(\?:;\(\[\^;\]\+\)\)\?\)\?\(;base64\)\?,\(\.\*\)\\\$\/\)/g,
        replace: `url.match(/^data:(?:([^;]+)(?:;([^;]+))?)?(;base64)?,((?:(?!\\1|,).)*)$/)`
    },
    // Pattern 3: Look for the specific regex pattern itself
    {
        find: /\/\^data:\(\?:\(\[\^;\]\+\)\(\?:;\(\[\^;\]\+\)\)\?\)\?\(;base64\)\?,\(\.\*\)\\\$\//g,
        replace: `/^data:(?:([^;]+)(?:;([^;]+))?)?(;base64)?,((?:(?!\\1|,).)*)$/`
    }
];

for (const pattern of patterns) {
    if (pattern.find.test(content)) {
        content = content.replace(pattern.find, pattern.replace);
        modified = true;
        console.log('Pattern found and replaced');
        break;
    }
}

// If no pattern matched, try a more flexible approach
if (!modified) {
    // Look for the greedy (.*) pattern near the end of regex
    const flexibleFind = /(parseDataUri.*?url\.match\(.*?)(,\(\.\*\))(\\\$\/\))/s;
    if (flexibleFind.test(content)) {
        content = content.replace(flexibleFind, '$1,((?:(?!\\1|,).)*)$3');
        modified = true;
        console.log('Applied fix using flexible pattern match');
    }
}

// Last resort: string replacement
if (!modified) {
    const oldStr = ',(.*)\$/';
    const newStr = ',((?:(?!\\1|,).)*)$/';
    if (content.includes(oldStr)) {
        content = content.replace(oldStr, newStr);
        modified = true;
        console.log('Applied fix using direct string replacement');
    }
}

if (modified) {
    // Add comment if not already present
    if (!content.includes('// https://regexr.com/8e8gt') && content.includes('export function parseDataUri')) {
        content = content.replace(
            /export function parseDataUri\(url\) \{\s*\n\s*const match =/,
            `export function parseDataUri(url) {
  // https://regexr.com/8e8gt
  const match =`
        );
    }
    fs.writeFileSync(path, content);
    console.log('Fix successfully written to file');
} else {
    console.log('WARNING: Could not find vulnerable pattern');
    console.log('File content around parseDataUri:');
    const funcMatch = content.match(/parseDataUri[\s\S]{0,500}/);
    if (funcMatch) {
        console.log(funcMatch[0]);
    }
    process.exit(1);
}
ENDFIX

node /tmp/fix_regex.js
FIX_RESULT=$?
rm -f /tmp/fix_regex.js

if [ $FIX_RESULT -ne 0 ]; then
    echo "Error: Fix script failed"
    exit 1
fi

# Verify the fix was applied
echo ""
echo "Verifying fix..."
if grep -q '(?:(?!\\1|,)\.)' "$TARGET_FILE" 2>/dev/null; then
    echo "SUCCESS: Fixed regex pattern found in file"
else
    echo "WARNING: Could not verify fix pattern - checking file contents..."
    grep -A 10 "parseDataUri" "$TARGET_FILE" | head -15
fi

echo ""
echo "Fix complete!"
