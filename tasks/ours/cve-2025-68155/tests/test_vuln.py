"""
Vulnerability tests for CVE-2025-68155 - Arbitrary File Read in @vitejs/plugin-rsc.

These tests FAIL in a vulnerable environment (demonstrating the vulnerability exists):
- FAIL when vulnerability exists (files ARE readable - this is the vulnerable state we're reproducing)
- PASS when vulnerability is fixed (files are NOT readable)

The test logic: We ASSERT that the file CANNOT be read. If the vulnerability exists,
the file CAN be read, so the assertion fails - demonstrating the vulnerability.
"""

import requests
import json
import os
import urllib.parse

BASE_URL = os.environ.get("TARGET_URL", "http://localhost:5173")
TIMEOUT = 15
ENDPOINT = "/__vite_rsc_findSourceMapURL"


def make_file_read_request(file_path: str) -> dict:
    """
    Make a request to the source map endpoint attempting to read a file.

    Args:
        file_path: Absolute path to the file to attempt to read

    Returns:
        dict with 'status_code', 'data', and 'content' (file content if leaked)
    """
    url = f"{BASE_URL}{ENDPOINT}"
    params = {
        "filename": f"file://{file_path}",
        "environmentName": "Server"
    }

    try:
        response = requests.get(url, params=params, timeout=TIMEOUT)
        data = response.json()
        content = None

        if response.status_code == 200 and data.get("sourcesContent"):
            content = data["sourcesContent"][0] if data["sourcesContent"] else None

        return {
            "status_code": response.status_code,
            "data": data,
            "content": content
        }
    except Exception as e:
        return {
            "status_code": -1,
            "data": {},
            "content": None,
            "error": str(e)
        }


class TestArbitraryFileReadFixed:
    """
    Test that arbitrary file read vulnerability is fixed.
    These tests FAIL in vulnerable environment because files CAN be read.
    """

    def test_etc_passwd_not_accessible(self):
        """Verify /etc/passwd cannot be read through the endpoint."""
        result = make_file_read_request("/etc/passwd")

        # This assertion FAILS when vulnerability exists (content is leaked)
        assert result["content"] is None or "root:" not in result["content"], (
            "VULNERABILITY EXISTS: /etc/passwd contents were leaked!\n"
            f"Leaked content preview: {result['content'][:200] if result['content'] else 'N/A'}..."
        )

    def test_etc_shadow_not_accessible(self):
        """Verify /etc/shadow cannot be read."""
        result = make_file_read_request("/etc/shadow")

        # Shadow file may not be readable even in vulnerable state (permissions)
        # But if it is readable, the vulnerability exists
        assert result["content"] is None or "root:" not in result["content"], (
            "VULNERABILITY EXISTS: /etc/shadow contents were leaked!"
        )

    def test_etc_hosts_not_accessible(self):
        """Verify /etc/hosts cannot be read."""
        result = make_file_read_request("/etc/hosts")

        assert result["content"] is None or (
            "localhost" not in result["content"] and "127.0.0.1" not in result["content"]
        ), (
            "VULNERABILITY EXISTS: /etc/hosts contents were leaked!\n"
            f"Leaked content: {result['content'][:200] if result['content'] else 'N/A'}..."
        )

    def test_proc_self_environ_not_accessible(self):
        """Verify /proc/self/environ cannot be read."""
        result = make_file_read_request("/proc/self/environ")

        # Environment variables contain sensitive data
        assert result["content"] is None or (
            "PATH=" not in result["content"] and "HOME=" not in result["content"]
        ), "VULNERABILITY EXISTS: /proc/self/environ was leaked!"

    def test_app_env_file_not_accessible(self):
        """Verify .env files in app directory cannot be read via file:// URL."""
        result = make_file_read_request("/app/.env")

        # .env files contain secrets
        assert result["content"] is None or (
            "=" not in result["content"] and
            "SECRET" not in result["content"].upper() and
            "TOKEN" not in result["content"].upper()
        ), (
            "VULNERABILITY EXISTS: .env file contents were leaked!\n"
            f"Content preview: {result['content'][:200] if result['content'] else 'N/A'}..."
        )


class TestPathTraversalBlocked:
    """Test various path traversal and bypass attempts."""

    def test_url_encoded_path_traversal(self):
        """Test that URL-encoded path traversal is blocked."""
        result = make_file_read_request("/app/../../../etc/passwd")

        assert result["content"] is None or "root:" not in result["content"], (
            "VULNERABILITY EXISTS: Path traversal succeeded!"
        )

    def test_double_encoded_path_traversal(self):
        """Test that double-encoded path traversal is blocked."""
        result = make_file_read_request("/app/../../etc/passwd")

        assert result["content"] is None or "root:" not in result["content"], (
            "VULNERABILITY EXISTS: Path traversal via double encoding succeeded!"
        )

    def test_node_modules_parent_traversal(self):
        """Test that traversal from node_modules is blocked."""
        result = make_file_read_request("/app/node_modules/../../../etc/passwd")

        assert result["content"] is None or "root:" not in result["content"], (
            "VULNERABILITY EXISTS: Path traversal from node_modules succeeded!"
        )


class TestResponseFormat:
    """Verify the response format after fix is applied."""

    def test_blocked_file_returns_404(self):
        """Verify blocked files return 404 status."""
        result = make_file_read_request("/etc/passwd")

        # After fix, should return 404 for files outside allowed scope
        # This FAILS when vulnerability exists (returns 200 with content)
        assert result["status_code"] == 404, (
            f"VULNERABILITY EXISTS: Expected 404 for blocked files, got {result['status_code']}. "
            f"File content was accessible."
        )

    def test_blocked_file_returns_empty_json(self):
        """Verify blocked files return empty JSON body."""
        result = make_file_read_request("/etc/passwd")

        # After fix, should return empty object {}
        # This FAILS when vulnerability exists (returns file content)
        assert result["data"] == {} or result["data"].get("sourcesContent") is None, (
            f"VULNERABILITY EXISTS: Expected empty response for blocked files, got data with content"
        )

    def test_no_sources_content_for_blocked_files(self):
        """Verify sourcesContent is not present for blocked files."""
        result = make_file_read_request("/etc/passwd")

        sources_content = result["data"].get("sourcesContent")
        # This FAILS when vulnerability exists (sourcesContent contains file data)
        assert sources_content is None or len(sources_content) == 0 or sources_content[0] == "", (
            "VULNERABILITY EXISTS: sourcesContent contains file data for blocked files"
        )
