"""
Vulnerability tests for Emlog admin store search - Reflected XSS via keyword parameter.

These tests verify that user input is properly sanitized before being rendered in HTML.
- FAIL in vulnerable state: XSS payloads are reflected without encoding
- PASS in fixed state: XSS payloads are HTML-encoded

The vulnerability exists in three view files:
- admin/views/store.php (main store)
- admin/views/store_tpl.php (template store)
- admin/views/store_plu.php (plugin store)
"""

import pytest
import requests
import re
import os
from urllib.parse import quote, urljoin
import html

BASE_URL = os.environ.get("APP_URL", "http://localhost:8080")
ADMIN_USER = os.environ.get("ADMIN_USER", "admin")
ADMIN_PASS = os.environ.get("ADMIN_PASS", "admin123")


class TestXSSMitigationMainStore:
    """Test XSS mitigation on main store page (/admin/store.php)"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup session with admin authentication"""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authenticate()
        yield
        self.session.close()

    def _authenticate(self):
        """Authenticate as admin user"""
        login_url = urljoin(BASE_URL, "/admin/account.php?action=dosignin")

        try:
            resp = self.session.get(urljoin(BASE_URL, "/admin/"), timeout=10)
        except requests.exceptions.RequestException:
            pytest.skip("Application not accessible")

        login_data = {
            'user': ADMIN_USER,
            'pw': ADMIN_PASS,
            'persist': '1'
        }

        try:
            self.session.post(login_url, data=login_data, timeout=10, allow_redirects=True)
        except requests.exceptions.RequestException:
            pytest.skip("Login failed")

    def _check_xss_payload_encoded(self, response_text, payload):
        """
        Check if XSS payload is properly encoded in the response.
        Returns True if safe (encoded), False if vulnerable (not encoded).
        """
        # The payload should NOT appear as-is in the response
        # Instead, special chars should be HTML-encoded
        if payload in response_text:
            return False  # Vulnerable - payload reflected without encoding

        # Check that encoded versions appear
        # " -> &quot;  < -> &lt;  > -> &gt;
        return True

    def _extract_keyword_value(self, response_text):
        """Extract the value attribute of the keyword input field"""
        # Pattern to match: value="..." for name="keyword"
        pattern = r'name="keyword"[^>]*value="([^"]*)"'
        match = re.search(pattern, response_text)
        if match:
            return match.group(1)

        # Try alternative pattern
        pattern = r'value="([^"]*)"[^>]*name="keyword"'
        match = re.search(pattern, response_text)
        if match:
            return match.group(1)

        return None

    def test_basic_script_tag_injection(self):
        """Test basic <script> tag injection is prevented"""
        payload = '"><script>alert(1)</script>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # The raw payload should NOT appear in response
        assert payload not in resp.text, \
            "XSS payload reflected without encoding - vulnerability exists"

        # Check that <script> tag is not present unencoded
        assert '<script>alert(1)</script>' not in resp.text, \
            "Script tag injection possible - vulnerability exists"

    def test_img_onerror_injection(self):
        """Test img onerror event handler injection is prevented"""
        payload = '"><img src=x onerror=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # The raw payload should NOT appear in response
        assert payload not in resp.text, \
            "XSS payload reflected without encoding - vulnerability exists"

        # Specifically check that onerror handler is not executable
        assert 'onerror=alert(1)>' not in resp.text, \
            "Event handler injection possible - vulnerability exists"

    def test_svg_onload_injection(self):
        """Test SVG onload event handler injection is prevented"""
        payload = '"><svg onload=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding - vulnerability exists"

    def test_attribute_breakout_double_quote(self):
        """Test attribute breakout with double quote is prevented"""
        payload = '" onclick="alert(1)" x="'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Check that the double quote doesn't break out of attribute
        # Note: PHP's addslashes escapes quotes, so check for both patterns
        assert 'onclick="alert(1)"' not in resp.text and 'onclick=\\"alert(1)\\"' not in resp.text, \
            "Attribute injection possible - vulnerability exists"

    def test_html_entity_encoding_present(self):
        """Test that special chars are HTML-encoded"""
        payload = '"><test>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Raw payload should not appear
        assert payload not in resp.text, \
            "Special characters not encoded - vulnerability exists"

        # Check for encoded versions (at least partial encoding)
        has_encoding = ('&quot;' in resp.text or '&lt;' in resp.text or
                       '&gt;' in resp.text or '&#' in resp.text)
        # Or the payload simply doesn't appear at all (also acceptable)
        assert has_encoding or payload not in resp.text, \
            "HTML encoding not applied"


class TestXSSMitigationTemplateStore:
    """Test XSS mitigation on template store page (/admin/store.php?action=tpl)"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup session with admin authentication"""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authenticate()
        yield
        self.session.close()

    def _authenticate(self):
        """Authenticate as admin user"""
        login_url = urljoin(BASE_URL, "/admin/account.php?action=dosignin")

        try:
            resp = self.session.get(urljoin(BASE_URL, "/admin/"), timeout=10)
        except requests.exceptions.RequestException:
            pytest.skip("Application not accessible")

        login_data = {
            'user': ADMIN_USER,
            'pw': ADMIN_PASS,
            'persist': '1'
        }

        try:
            self.session.post(login_url, data=login_data, timeout=10, allow_redirects=True)
        except requests.exceptions.RequestException:
            pytest.skip("Login failed")

    def test_basic_script_tag_injection_tpl(self):
        """Test basic <script> tag injection is prevented on template store"""
        payload = '"><script>alert(document.domain)</script>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=tpl&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on template store - vulnerability exists"

    def test_img_onerror_injection_tpl(self):
        """Test img onerror injection is prevented on template store"""
        payload = '"><img src=x onerror=alert(document.cookie)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=tpl&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on template store - vulnerability exists"

    def test_body_onload_injection_tpl(self):
        """Test body onload injection is prevented on template store"""
        payload = '"><body onload=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=tpl&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on template store - vulnerability exists"

    def test_input_onfocus_injection_tpl(self):
        """Test input onfocus injection is prevented on template store"""
        payload = '" onfocus="alert(1)" autofocus="'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=tpl&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Note: PHP's addslashes escapes quotes, so check for both patterns
        assert 'onfocus="alert(1)"' not in resp.text and 'onfocus=\\"alert(1)\\"' not in resp.text, \
            "Event handler injection possible on template store - vulnerability exists"


class TestXSSMitigationPluginStore:
    """Test XSS mitigation on plugin store page (/admin/store.php?action=plu)"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup session with admin authentication"""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authenticate()
        yield
        self.session.close()

    def _authenticate(self):
        """Authenticate as admin user"""
        login_url = urljoin(BASE_URL, "/admin/account.php?action=dosignin")

        try:
            resp = self.session.get(urljoin(BASE_URL, "/admin/"), timeout=10)
        except requests.exceptions.RequestException:
            pytest.skip("Application not accessible")

        login_data = {
            'user': ADMIN_USER,
            'pw': ADMIN_PASS,
            'persist': '1'
        }

        try:
            self.session.post(login_url, data=login_data, timeout=10, allow_redirects=True)
        except requests.exceptions.RequestException:
            pytest.skip("Login failed")

    def test_basic_script_tag_injection_plu(self):
        """Test basic <script> tag injection is prevented on plugin store"""
        payload = '"><script>alert(1)</script>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=plu&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on plugin store - vulnerability exists"

    def test_img_onerror_injection_plu(self):
        """Test img onerror injection is prevented on plugin store"""
        payload = '"><img src=x onerror=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=plu&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on plugin store - vulnerability exists"

    def test_details_open_ontoggle_injection_plu(self):
        """Test details ontoggle injection is prevented on plugin store"""
        payload = '"><details open ontoggle=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=plu&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on plugin store - vulnerability exists"

    def test_marquee_onstart_injection_plu(self):
        """Test marquee onstart injection is prevented on plugin store"""
        payload = '"><marquee onstart=alert(1)>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?action=plu&keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "XSS payload reflected without encoding on plugin store - vulnerability exists"


class TestAdvancedXSSPayloads:
    """Test advanced XSS payloads and bypass attempts"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup session with admin authentication"""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authenticate()
        yield
        self.session.close()

    def _authenticate(self):
        """Authenticate as admin user"""
        login_url = urljoin(BASE_URL, "/admin/account.php?action=dosignin")

        try:
            resp = self.session.get(urljoin(BASE_URL, "/admin/"), timeout=10)
        except requests.exceptions.RequestException:
            pytest.skip("Application not accessible")

        login_data = {
            'user': ADMIN_USER,
            'pw': ADMIN_PASS,
            'persist': '1'
        }

        try:
            self.session.post(login_url, data=login_data, timeout=10, allow_redirects=True)
        except requests.exceptions.RequestException:
            pytest.skip("Login failed")

    def test_javascript_uri_injection(self):
        """Test javascript: URI injection is prevented"""
        # Use a unique marker to avoid false positives from legitimate page content
        payload = '"><xss-test-marker>XSS_INJECTION_TEST</xss-test-marker>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # The XSS is prevented if < and > are HTML-encoded
        # In vulnerable state: the <xss-test-marker> tag will be rendered as HTML
        # In fixed state with htmlspecialchars: <xss-test-marker> becomes &lt;xss-test-marker&gt;
        # We check for the custom tag being present unencoded
        assert '<xss-test-marker>' not in resp.text, \
            "HTML injection possible - vulnerability exists"

    def test_data_uri_injection(self):
        """Test data: URI injection is prevented"""
        payload = '"><object data="data:text/html,<script>alert(1)</script>">'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Check for unencoded HTML object tag
        assert '<object data=' not in resp.text, \
            "Data URI injection possible - vulnerability exists"

    def test_style_expression_injection(self):
        """Test style expression injection is prevented"""
        payload = '" style="background:url(javascript:alert(1))"'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # The XSS is prevented if quotes are HTML-encoded (" -> &quot;)
        # With just addslashes(), " becomes \" which still closes the attribute in HTML
        # Input: " style="background:url(javascript:alert(1))"
        # After addslashes: \" style=\"background:url(javascript:alert(1))\"
        # The backslash-quote still closes the value attribute, allowing style injection
        # Check that the style attribute injection pattern isn't present
        # We look for " style=" which indicates attribute breakout
        # (addslashes makes it \" style=\" but HTML still treats \" as closing the attr)
        assert 'style="background:url(' not in resp.text and 'style=\\"background:url(' not in resp.text, \
            "Style expression injection possible - vulnerability exists"

    def test_iframe_injection(self):
        """Test iframe injection is prevented"""
        payload = '"><iframe src="javascript:alert(1)">'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Check for unencoded iframe tag
        assert '<iframe ' not in resp.text, \
            "Iframe injection possible - vulnerability exists"

    def test_form_action_injection(self):
        """Test form action injection is prevented"""
        payload = '"><form action="http://evil.com"><input type=submit>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Check for injected form tag (this would be present if XSS exists)
        # Look for pattern that indicates the payload broke out: > followed by <form
        assert '><form ' not in resp.text, \
            "Form action injection possible - vulnerability exists"

    def test_multiple_quote_bypass(self):
        """Test multiple quote bypass attempt"""
        payload = '"></input><script>alert(1)</script><input value="'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert '<script>alert(1)</script>' not in resp.text, \
            "Quote bypass injection possible - vulnerability exists"

    def test_unicode_escape_bypass(self):
        """Test Unicode escape sequence bypass attempt"""
        # This tests that various encoding attempts are handled
        payload = '"><script>alert(String.fromCharCode(88,83,83))</script>'
        store_url = urljoin(BASE_URL, f"/admin/store.php?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        assert payload not in resp.text, \
            "Unicode escape bypass possible - vulnerability exists"


class TestAllEndpointsComprehensive:
    """Comprehensive test ensuring all three endpoints are properly protected"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup session with admin authentication"""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authenticate()
        yield
        self.session.close()

    def _authenticate(self):
        """Authenticate as admin user"""
        login_url = urljoin(BASE_URL, "/admin/account.php?action=dosignin")

        try:
            resp = self.session.get(urljoin(BASE_URL, "/admin/"), timeout=10)
        except requests.exceptions.RequestException:
            pytest.skip("Application not accessible")

        login_data = {
            'user': ADMIN_USER,
            'pw': ADMIN_PASS,
            'persist': '1'
        }

        try:
            self.session.post(login_url, data=login_data, timeout=10, allow_redirects=True)
        except requests.exceptions.RequestException:
            pytest.skip("Login failed")

    @pytest.mark.parametrize("endpoint,action", [
        ("/admin/store.php", None),
        ("/admin/store.php", "tpl"),
        ("/admin/store.php", "plu"),
    ])
    def test_all_endpoints_sanitize_keyword(self, endpoint, action):
        """Test that all store endpoints properly sanitize keyword input"""
        payload = '"><img src=x onerror=alert(document.domain)>'

        if action:
            store_url = urljoin(BASE_URL, f"{endpoint}?action={action}&keyword={quote(payload)}")
        else:
            store_url = urljoin(BASE_URL, f"{endpoint}?keyword={quote(payload)}")

        resp = self.session.get(store_url, timeout=10)
        assert resp.status_code == 200

        # Critical check: the raw payload should NOT appear in response
        assert payload not in resp.text, \
            f"XSS payload reflected without encoding on {endpoint} (action={action}) - vulnerability exists"

        # Secondary check: specific dangerous pattern should not be present
        assert 'onerror=alert(document.domain)>' not in resp.text, \
            f"Event handler injection possible on {endpoint} (action={action}) - vulnerability exists"
