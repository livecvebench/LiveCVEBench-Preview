"""
Vulnerability tests for Open5GS UPF - Missing FAR-ID validation (CVE-2025-14953).

These tests verify that the vulnerability is present:
- FAIL in vulnerable state (PoC triggers crash - this is what we WANT for reproduction)
- PASS in fixed state (PoC doesn't crash UPF)

Test Logic:
- We use the Go-based PoC that sends a malformed PFCP Session Establishment
  (CreatePDR without mandatory FAR-ID) followed by a GTP-U packet.
- In VULNERABLE state: UPF crashes, tests FAIL (expected for reproduction)
- In FIXED state: UPF rejects the malformed session, tests PASS
"""
import subprocess
import time
import os
import pytest


# Configuration
PFCP_HOST = "127.0.0.7"
PFCP_PORT = 8805
GTP_HOST = "127.0.0.7"
GTP_PORT = 2152
POC_PATH = "/poc/poc"


def is_upf_running() -> bool:
    """Check if UPF process is running."""
    try:
        result = subprocess.run(
            ["pgrep", "-f", "open5gs-upfd"],
            capture_output=True,
            timeout=5
        )
        return result.returncode == 0
    except Exception:
        return False


def get_upf_pid() -> int:
    """Get UPF process PID."""
    try:
        result = subprocess.run(
            ["pgrep", "-f", "open5gs-upfd"],
            capture_output=True,
            timeout=5,
            text=True
        )
        if result.returncode == 0:
            return int(result.stdout.strip().split('\n')[0])
    except Exception:
        pass
    return 0


def wait_for_upf_ready(max_wait: int = 30) -> bool:
    """Wait for UPF to be ready."""
    for _ in range(max_wait):
        if is_upf_running():
            try:
                result = subprocess.run(
                    ["ss", "-ulnp"],
                    capture_output=True,
                    timeout=5,
                    text=True
                )
                if f"{PFCP_HOST}:{PFCP_PORT}" in result.stdout:
                    return True
            except Exception:
                pass
        time.sleep(1)
    return False


def run_poc(teid: int = 0xDEADBEEF) -> tuple:
    """
    Run the PoC to trigger the vulnerability.
    Returns (success, output) tuple.
    """
    teid_hex = hex(teid)
    try:
        result = subprocess.run(
            [
                POC_PATH,
                "-pfcp-target", f"{PFCP_HOST}:{PFCP_PORT}",
                "-gtp-target", f"{GTP_HOST}:{GTP_PORT}",
                "-teid", teid_hex,
            ],
            capture_output=True,
            timeout=10,
            text=True
        )
        return True, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return False, "PoC timed out"
    except Exception as e:
        return False, str(e)


class TestMissingFarIdVulnerability:
    """
    Tests for missing FAR-ID validation vulnerability.

    These tests are designed to FAIL in the VULNERABLE state because:
    - The PoC successfully triggers the vulnerability
    - UPF crashes when GTP-U packet matches the malformed PDR
    - We assert that UPF should SURVIVE (which it doesn't in vulnerable state)

    In FIXED state, these tests PASS because:
    - UPF rejects the malformed session with MANDATORY_IE_MISSING
    - UPF remains operational
    """

    def test_upf_survives_malformed_session_attack(self):
        """
        Test that UPF survives a malformed PFCP session followed by GTP-U attack.

        VULNERABLE behavior: UPF CRASHES -> Test FAILS (expected)
        FIXED behavior: UPF survives -> Test PASSES
        """
        assert wait_for_upf_ready(30), "UPF not ready before test"

        pid_before = get_upf_pid()
        assert pid_before > 0, "Could not get UPF PID"

        # Run the PoC
        success, output = run_poc(teid=0xCAFEBABE)
        assert success, f"PoC failed to run: {output}"

        # Wait for potential crash
        time.sleep(2)

        # In FIXED state, UPF should still be running with same PID
        # In VULNERABLE state, UPF crashes (test fails)
        assert is_upf_running(), \
            "UPF crashed after malformed session attack - vulnerability confirmed"

        pid_after = get_upf_pid()
        assert pid_after == pid_before, \
            f"UPF restarted (PID changed from {pid_before} to {pid_after}) - vulnerability triggered"

    def test_upf_survives_multiple_attacks(self):
        """
        Test that UPF survives multiple malformed session attacks.

        VULNERABLE behavior: UPF CRASHES on first attack -> Test FAILS
        FIXED behavior: UPF rejects all attacks, survives -> Test PASSES
        """
        assert wait_for_upf_ready(30), "UPF not ready before test"

        pid_before = get_upf_pid()

        # Run multiple attacks with different TEIDs
        for i, teid in enumerate([0xDEAD0001, 0xDEAD0002, 0xDEAD0003]):
            success, output = run_poc(teid=teid)
            assert success, f"PoC run {i+1} failed: {output}"
            time.sleep(1)

        # Check UPF status
        assert is_upf_running(), "UPF crashed during multiple attack test"
        assert get_upf_pid() == pid_before, "UPF restarted during test"

    def test_upf_stability_after_attack(self):
        """
        Test UPF stability after attack attempt.

        VULNERABLE behavior: UPF CRASHES -> Test FAILS
        FIXED behavior: UPF continues normal operation -> Test PASSES
        """
        assert wait_for_upf_ready(30), "UPF not ready"

        pid_before = get_upf_pid()

        # Run PoC
        run_poc(teid=0xBEEFBEEF)
        time.sleep(2)

        # Verify UPF is still running
        assert is_upf_running(), "UPF not running after attack"
        assert get_upf_pid() == pid_before, "UPF restarted after attack"

        # Verify ports are still listening
        result = subprocess.run(
            ["ss", "-ulnp"],
            capture_output=True,
            timeout=5,
            text=True
        )
        assert f"{PFCP_HOST}:{PFCP_PORT}" in result.stdout, "PFCP port not listening after attack"
        assert f"{GTP_HOST}:{GTP_PORT}" in result.stdout, "GTP-U port not listening after attack"
