#!/bin/bash
set -e

echo "=== Applying fix for null pathname handling in devproxy.js (CVE-2025-58047) ==="

cd /app

# The vulnerability exists in the COMPILED server.js file, not in the source files.
# The server runs from /app/build/server.js which is a pre-compiled webpack bundle.
# We need to patch the compiled bundle directly.

BUILD_SERVER="/app/build/server.js"

if [ ! -f "$BUILD_SERVER" ]; then
    echo "Error: Could not find compiled server.js at $BUILD_SERVER"
    exit 1
fi

echo "Found compiled server at: $BUILD_SERVER"

# Check if already patched (idempotent check)
# The vulnerable pattern is: settings.devProxyToApiPath&&e.startsWith("/++api++")
# The fixed pattern should be: e&&settings.devProxyToApiPath&&e.startsWith("/++api++")
if grep -q 'e&&[a-z]\.settings\.devProxyToApiPath&&e\.startsWith' "$BUILD_SERVER"; then
    echo "Fix already applied - compiled server already contains pathname null check"
else
    echo "Applying fix to compiled server.js..."

    # Create a backup
    cp "$BUILD_SERVER" "${BUILD_SERVER}.bak"

    # The vulnerable minified code pattern is:
    # settings.devProxyToApiPath&&e.startsWith("/++api++")
    #
    # We need to add a null check for 'e' (pathname) before calling startsWith:
    # e&&settings.devProxyToApiPath&&e.startsWith("/++api++")
    #
    # The 'e' variable is the pathname parameter passed to the filter function

    # Use sed to add the null check
    # Pattern: settings.devProxyToApiPath&&e.startsWith("/++api++")
    # Replace with: e&&settings.devProxyToApiPath&&e.startsWith("/++api++")
    sed -i 's/settings\.devProxyToApiPath&&e\.startsWith("\/++api++")/e\&\&settings.devProxyToApiPath\&\&e.startsWith("\/++api++")/g' "$BUILD_SERVER"

    # Verify the fix was applied
    if grep -q 'e&&settings\.devProxyToApiPath&&e\.startsWith' "$BUILD_SERVER"; then
        echo "Fix successfully applied to compiled server.js!"
        rm -f "${BUILD_SERVER}.bak"
    else
        echo "Warning: sed replacement may not have worked, checking alternative patterns..."

        # Restore backup and try alternative approach
        cp "${BUILD_SERVER}.bak" "$BUILD_SERVER"

        # Try with Python for more reliable replacement
        python3 << 'PYEOF'
import re

build_server = "/app/build/server.js"

with open(build_server, 'r') as f:
    content = f.read()

# Pattern to match the vulnerable code in minified form
# The pattern is: settings.devProxyToApiPath&&e.startsWith("/++api++")
old_pattern = r'settings\.devProxyToApiPath&&e\.startsWith\("/\+\+api\+\+"\)'
new_pattern = r'e&&settings.devProxyToApiPath&&e.startsWith("/++api++")'

new_content, count = re.subn(old_pattern, new_pattern, content)

if count > 0:
    with open(build_server, 'w') as f:
        f.write(new_content)
    print(f"Python fix applied - replaced {count} occurrences")
else:
    print("Warning: Pattern not found in server.js")
    # Try to find what patterns exist
    import subprocess
    result = subprocess.run(['grep', '-o', 'devProxyToApiPath&&[a-z]\\.startsWith', build_server],
                          capture_output=True, text=True)
    print(f"Found patterns: {result.stdout}")
PYEOF

        # Final check
        if grep -q 'e&&settings\.devProxyToApiPath&&e\.startsWith' "$BUILD_SERVER"; then
            echo "Fix successfully applied using Python!"
            rm -f "${BUILD_SERVER}.bak"
        else
            echo "Error: Could not apply fix to compiled server.js"
            # Restore backup
            mv "${BUILD_SERVER}.bak" "$BUILD_SERVER"
            exit 1
        fi
    fi
fi

# Restart the Node.js server to pick up the changes in server.js
echo "=== Restarting Node.js server ==="

# Find and kill the Node.js process running Volto
pkill -f "node.*server" 2>/dev/null || true
pkill -f "yarn.*start" 2>/dev/null || true

# Give it time to terminate
sleep 3

echo "Server process terminated. Entrypoint will restart it."
echo "=== Fix complete ==="
