diff --git a/poc/growl.test.js b/poc/growl.test.js
new file mode 100644
index 0000000..c01f9d1
--- /dev/null
+++ b/poc/growl.test.js
@@ -0,0 +1,90 @@
+// poc/growl.test.js
+const fs = require('fs');
+const path = './growl';
+const child_process = require('child_process');
+
+describe('Command injection prevention in growl', () => {
+  // ensure clean start for each test run
+  beforeEach(() => {
+    try {
+      if (fs.existsSync(path)) fs.unlinkSync(path);
+    } catch (e) {
+      // ignore
+    }
+  });
+
+  afterEach(() => {
+    // cleanup any created file
+    try {
+      if (fs.existsSync(path)) fs.unlinkSync(path);
+    } catch (e) {
+      // ignore
+    }
+    // restore any spies/mocks if Jest created them
+    if (child_process.exec && child_process.exec._isMockFunction) {
+      child_process.exec.mockRestore();
+    }
+    if (child_process.spawn && child_process.spawn._isMockFunction) {
+      child_process.spawn.mockRestore();
+    }
+    // reset module cache to ensure fresh require next run
+    jest.resetModules();
+  });
+
+  test('injection payload should not create a file when growl is fixed', () => {
+    // assert initial state
+    expect(fs.existsSync(path)).toBe(false);
+
+    // Spy / mock child_process.exec so that if code calls exec it will
+    // execute the given command synchronously (to make detection deterministic).
+    // This simulates the vulnerable behavior: if growl uses exec with a shell string,
+    // the injected `touch growl` will run immediately and create the file.
+    const execSpy = jest
+      .spyOn(child_process, 'exec')
+      .mockImplementation((cmd, cb) => {
+        // execute synchronously so the test can detect side effect immediately
+        try {
+          child_process.execSync(cmd, { stdio: 'ignore' });
+          if (typeof cb === 'function') cb(null, '', '');
+        } catch (err) {
+          // if execSync fails, call callback with error if provided
+          if (typeof cb === 'function') cb(err);
+        }
+      });
+
+    // Mock spawn to a no-op to avoid ENOENT or actual system notifications.
+    // The patched growl uses spawn; we want it to be harmless in tests.
+    const spawnSpy = jest
+      .spyOn(child_process, 'spawn')
+      .mockImplementation(() => {
+        // return a minimal mock ChildProcess-like object
+        return {
+          on: () => {},
+          stdout: { on: () => {} },
+          stderr: { on: () => {} },
+          kill: () => {},
+        };
+      });
+
+    // reset modules and require growl after setting up mocks so its internal
+    // calls use the spied functions
+    jest.resetModules();
+    const growl = require('growl');
+
+    // Attempt injection
+    // - Vulnerable growl that calls exec('... `touch growl` ...') will cause file creation synchronously.
+    // - Patched growl that uses spawn(...) will NOT result in file creation.
+    growl('`touch growl`');
+
+    // Now check whether the injection created the file.
+    const fileExists = fs.existsSync(path);
+
+    // Expected: file must NOT exist for safe (patched) growl.
+    expect(fileExists).toBe(false);
+
+    // Restore spies (also handled in afterEach, but restore early to be explicit)
+    execSpy.mockRestore();
+    spawnSpy.mockRestore();
+  });
+});
+
