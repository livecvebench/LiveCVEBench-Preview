diff --git a/db/db_test.go b/db/db_test.go
new file mode 100644
index 0000000..6f74f07
--- /dev/null
+++ b/db/db_test.go
@@ -0,0 +1,98 @@
+package db_test
+
+import (
+	"fmt"
+	"net/url"
+	"regexp"
+	"testing"
+	"time" // Needed for GORM
+
+	"github.com/DATA-DOG/go-sqlmock"
+	"github.com/camptocamp/terraboard/db" // Import your db package
+	"github.com/stretchr/testify/require"
+	"gorm.io/driver/postgres"
+	"gorm.io/gorm"
+	"gorm.io/gorm/logger" // Import GORM logger
+	"gorm.io/gorm/schema" // Import GORM schema for NamingStrategy
+)
+
+// Helper function to setup GORM with sqlmock for testing
+func setupMockDB(t *testing.T) (*db.Database, sqlmock.Sqlmock) {
+	sqlDB, mock, err := sqlmock.New()
+	require.NoError(t, err)
+
+	// Use the actual GORM setup but with the mock connection
+	gormDB, err := gorm.Open(postgres.New(postgres.Config{
+		Conn: sqlDB, // Use the mock connection
+		// Disable prepared statement caching for easier regex matching in mocks
+		PreferSimpleProtocol: true,
+	}), &gorm.Config{
+		// Prevent GORM from running BEGIN/COMMIT if not expected by the mock
+		SkipDefaultTransaction: true,
+		// Use a simple Namer to avoid complex quoting issues with mock expectations
+		NamingStrategy: schema.NamingStrategy{SingularTable: true},
+		// Use a silent logger for tests unless debugging
+		Logger: logger.Default.LogMode(logger.Silent),
+		// Set NowFunc for consistent time if needed by GORM internals (optional here)
+		NowFunc: func() time.Time { return time.Now().UTC() },
+	})
+	require.NoError(t, err)
+
+	// Assuming your db.Database struct just wraps *gorm.DB
+	appDB := &db.Database{DB: gormDB}
+
+	return appDB, mock
+}
+
+func TestSearchAttribute_SQLInjectionProtection(t *testing.T) {
+	appDB, mock := setupMockDB(t)
+	defer func() {
+		sqlDB, _ := appDB.DB.DB()
+		sqlDB.Close()
+	}()
+
+	// --- Test Case: Malicious Input for tf_version and lineage_value ---
+	maliciousValue := "' OR 1=1; --"
+	query := url.Values{}
+	query.Set("tf_version", maliciousValue)
+	query.Set("lineage_value", maliciousValue)
+	query.Set("page", "1") // Include pagination parameters
+
+	// Expected parameter value for LIKE clauses (with wildcards)
+	expectedParamValue := fmt.Sprintf("%%%s%%", maliciousValue)
+
+	// --- Mock Expectations ---
+
+	// 1. Expect the COUNT query
+	//    Use regex to match the query structure, focusing on the parameterized WHERE clause.
+	//    The exact JOINs and subqueries might vary, so regex is safer.
+	//    Postgres uses $1, $2, etc. as placeholders.
+	mock.ExpectQuery(regexp.QuoteMeta(`SELECT count(*) FROM (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t JOIN states ON t.path = states.path AND t.mx = states.serial JOIN modules ON states.id = modules.state_id JOIN resources ON modules.id = resources.module_id JOIN attributes ON resources.id = attributes.resource_id JOIN lineages ON lineages.id = states.lineage_id JOIN versions ON states.version_id = versions.id WHERE states.tf_version LIKE $1 AND lineages.value LIKE $2`)).
+		WithArgs(expectedParamValue, expectedParamValue).            // Check that the malicious value (with %) is passed as a parameter
+		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(0)) // Simulate 0 results found
+
+	// 2. Expect the main SELECT query for results
+	//    Again, use regex. Include LIMIT and OFFSET placeholders ($3, $4).
+	mock.ExpectQuery(regexp.QuoteMeta(`SELECT states.path, versions.version_id, states.tf_version, states.serial, lineages.value as lineage_value, modules.path as module_path, resources.type, resources.name, resources.index, attributes.key, attributes.value FROM (SELECT states.path, max(states.serial) as mx FROM states GROUP BY states.path) t JOIN states ON t.path = states.path AND t.mx = states.serial JOIN modules ON states.id = modules.state_id JOIN resources ON modules.id = resources.module_id JOIN attributes ON resources.id = attributes.resource_id JOIN lineages ON lineages.id = states.lineage_id JOIN versions ON states.version_id = versions.id WHERE states.tf_version LIKE $1 AND lineages.value LIKE $2 ORDER BY states.path, states.serial, lineage_value, modules.path, resources.type, resources.name, resources.index, attributes.key LIMIT $3 OFFSET $4`)).
+		WithArgs(expectedParamValue, expectedParamValue, 20, 0). // Check parameters: malicious values (with %), limit, offset
+		WillReturnRows(sqlmock.NewRows([]string{                 // Define columns matching the SELECT
+			"path", "version_id", "tf_version", "serial", "lineage_value",
+			"module_path", "type", "name", "index", "key", "value",
+		})) // Simulate returning no actual data rows
+
+	// --- Call the function under test ---
+	results, page, total := appDB.SearchAttribute(query)
+
+	// --- Assertions ---
+	// Check that the function returned expected pagination values
+	require.Equal(t, 0, total, "Total count should be 0 as mocked")
+	require.Equal(t, 1, page, "Page number should be 1")
+	require.Empty(t, results, "Results slice should be empty")
+
+	// Crucially, verify that all mock expectations were met.
+	// This fails the test if the executed SQL or parameters didn't match the expectations.
+	err := mock.ExpectationsWereMet()
+	require.NoError(t, err, "SQL mock expectations were not met")
+}
+
+// Add more test cases if needed, e.g., testing only one parameter, different pages, etc.
