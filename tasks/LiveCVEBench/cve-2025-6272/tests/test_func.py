"""
Functionality tests for wasm3 WebAssembly interpreter.

These tests verify basic wasm3 functionality works correctly.
Should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import tempfile
import pytest
import struct

# Path to wasm3 binary
WASM3_PATH = "/app/build/wasm3"


def create_wasm_file(binary_data: bytes) -> str:
    """Create a WASM file from binary data and return its path."""
    fd, path = tempfile.mkstemp(suffix=".wasm")
    with os.fdopen(fd, 'wb') as f:
        f.write(binary_data)
    return path


def run_wasm3(wasm_path: str, func_name: str = None, args: list = None, timeout: int = 10) -> tuple:
    """
    Run wasm3 with the given WASM file.
    Returns (exit_code, stdout, stderr).
    """
    # wasm3 command syntax: wasm3 [options] <file> [args...]
    # Options like --func must come BEFORE the file
    cmd = [WASM3_PATH]
    if func_name:
        cmd.extend(["--func", func_name])
    cmd.append(wasm_path)
    if args:
        cmd.extend([str(a) for a in args])

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Timeout"
    except FileNotFoundError:
        pytest.skip(f"wasm3 binary not found at {WASM3_PATH}")
    except Exception as e:
        return -1, "", str(e)


def create_simple_add_module() -> bytes:
    """
    Create a simple WASM module with an add function.
    (i32, i32) -> i32: returns a + b
    """
    return bytes.fromhex(
        "0061736d"  # magic
        "01000000"  # version 1
        # Type section: (i32, i32) -> i32
        "01"        # section id
        "07"        # section size
        "01"        # 1 type
        "60"        # func type
        "02"        # 2 params
        "7f7f"      # i32, i32
        "01"        # 1 result
        "7f"        # i32
        # Function section
        "03"        # section id
        "02"        # section size
        "01"        # 1 function
        "00"        # type index 0
        # Export section
        "07"        # section id
        "07"        # section size
        "01"        # 1 export
        "03"        # name length
        "616464"    # "add"
        "00"        # func export
        "00"        # func index 0
        # Code section
        "0a"        # section id
        "09"        # section size
        "01"        # 1 code
        "07"        # code size
        "00"        # 0 locals
        "20"        # local.get
        "00"        # index 0
        "20"        # local.get
        "01"        # index 1
        "6a"        # i32.add
        "0b"        # end
    )


def create_factorial_module() -> bytes:
    """
    Create a WASM module with a factorial function.
    (i32) -> i32: returns n!
    """
    return bytes.fromhex(
        "0061736d"  # magic
        "01000000"  # version 1
        # Type section: (i32) -> i32
        "01"        # section id
        "06"        # section size
        "01"        # 1 type
        "60"        # func type
        "01"        # 1 param
        "7f"        # i32
        "01"        # 1 result
        "7f"        # i32
        # Function section
        "03"        # section id
        "02"        # section size
        "01"        # 1 function
        "00"        # type index 0
        # Export section
        "07"        # section id
        "07"        # section size
        "01"        # 1 export
        "03"        # name length
        "666163"    # "fac"
        "00"        # func export
        "00"        # func index 0
        # Code section (recursive factorial)
        "0a"        # section id
        "19"        # section size (1 + 1 + 23 = 25 = 0x19)
        "01"        # 1 code
        "17"        # code size (23 = 0x17)
        "00"        # 0 locals
        "20"        # local.get
        "00"        # 0
        "41"        # i32.const
        "02"        # 2
        "49"        # i32.lt_s
        "04"        # if
        "7f"        # i32
        "41"        # i32.const
        "01"        # 1
        "05"        # else
        "20"        # local.get
        "00"        # 0
        "20"        # local.get
        "00"        # 0
        "41"        # i32.const
        "01"        # 1
        "6b"        # i32.sub
        "10"        # call
        "00"        # func 0
        "6c"        # i32.mul
        "0b"        # end
        "0b"        # end
    )


def create_const_module() -> bytes:
    """
    Create a simple module that returns a constant.
    () -> i32: returns 42
    """
    return bytes.fromhex(
        "0061736d"
        "01000000"
        # Type section: () -> i32
        "01"
        "05"
        "01"
        "60"
        "00"        # 0 params
        "01"        # 1 result
        "7f"        # i32
        # Function section
        "03"
        "02"
        "01"
        "00"
        # Export section
        "07"
        "09"        # section size (1 + 1 + 5 + 1 + 1 = 9)
        "01"
        "05"        # name length = 5 ("get42")
        "6765743432"  # "get42"
        "00"
        "00"
        # Code section
        "0a"
        "06"
        "01"
        "04"
        "00"        # 0 locals
        "41"        # i32.const
        "2a"        # 42
        "0b"        # end
    )


def create_multiply_module() -> bytes:
    """
    Create a module with multiply function.
    (i32, i32) -> i32: returns a * b
    """
    return bytes.fromhex(
        "0061736d"
        "01000000"
        # Type section
        "01"
        "07"
        "01"
        "60"
        "02"
        "7f7f"
        "01"
        "7f"
        # Function section
        "03"
        "02"
        "01"
        "00"
        # Export section
        "07"
        "07"
        "01"
        "03"
        "6d756c"    # "mul"
        "00"
        "00"
        # Code section
        "0a"
        "09"
        "01"
        "07"
        "00"
        "20"
        "00"
        "20"
        "01"
        "6c"        # i32.mul
        "0b"
    )


def create_subtract_module() -> bytes:
    """
    Create a module with subtract function.
    (i32, i32) -> i32: returns a - b
    """
    return bytes.fromhex(
        "0061736d"
        "01000000"
        # Type section
        "01"
        "07"
        "01"
        "60"
        "02"
        "7f7f"
        "01"
        "7f"
        # Function section
        "03"
        "02"
        "01"
        "00"
        # Export section
        "07"
        "07"
        "01"
        "03"
        "737562"    # "sub"
        "00"
        "00"
        # Code section
        "0a"
        "09"
        "01"
        "07"
        "00"
        "20"
        "00"
        "20"
        "01"
        "6b"        # i32.sub
        "0b"
    )


class TestBasicArithmetic:
    """Test basic arithmetic operations in wasm3."""

    def test_wasm3_binary_exists(self):
        """Verify wasm3 binary exists and is executable."""
        assert os.path.exists(WASM3_PATH), f"wasm3 binary not found at {WASM3_PATH}"
        assert os.access(WASM3_PATH, os.X_OK), f"wasm3 binary is not executable"

    def test_add_function(self):
        """Test simple addition: 5 + 3 = 8"""
        wasm_data = create_simple_add_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "add", [5, 3])
            # wasm3 should load the module without error
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed to run add function. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)

    def test_multiply_function(self):
        """Test multiplication: 6 * 7 = 42"""
        wasm_data = create_multiply_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "mul", [6, 7])
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed to run mul function. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)

    def test_subtract_function(self):
        """Test subtraction: 10 - 4 = 6"""
        wasm_data = create_subtract_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "sub", [10, 4])
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed to run sub function. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)

    def test_const_return(self):
        """Test function that returns a constant."""
        wasm_data = create_const_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "get42", [])
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed to run get42 function. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)


class TestControlFlow:
    """Test control flow constructs."""

    def test_factorial_base_case(self):
        """Test factorial with base case: 1! = 1"""
        wasm_data = create_factorial_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "fac", [1])
            # Module should load and execute
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed factorial base case. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)

    def test_factorial_recursive(self):
        """Test factorial with recursion: 5! = 120"""
        wasm_data = create_factorial_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "fac", [5])
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed recursive factorial. Exit: {exit_code}, "
                f"stdout: {stdout}, stderr: {stderr}"
            )
        finally:
            os.unlink(wasm_path)


class TestModuleLoading:
    """Test WASM module loading capabilities."""

    def test_valid_module_loads(self):
        """Test that a valid module loads without error."""
        wasm_data = create_simple_add_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            # Just try to load the module (wasm3 without function call)
            result = subprocess.run(
                [WASM3_PATH, wasm_path],
                capture_output=True,
                text=True,
                timeout=10
            )
            # Should not crash
            assert result.returncode not in [139, 134, -11, -6], (
                f"wasm3 crashed loading valid module. Exit: {result.returncode}, "
                f"stderr: {result.stderr}"
            )
        finally:
            os.unlink(wasm_path)

    def test_invalid_magic_rejected(self):
        """Test that invalid WASM (bad magic number) is rejected gracefully."""
        # Create a file with invalid magic
        invalid_wasm = bytes.fromhex("deadbeef01000000")
        wasm_path = create_wasm_file(invalid_wasm)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path)
            # Should reject with error, not crash
            assert exit_code not in [139, 134, -11, -6], (
                f"wasm3 crashed on invalid module instead of rejecting. "
                f"Exit: {exit_code}"
            )
        finally:
            os.unlink(wasm_path)

    def test_truncated_module_rejected(self):
        """Test that truncated WASM is rejected gracefully."""
        # Create a truncated WASM file
        truncated = bytes.fromhex("0061736d01")  # Just magic and partial version
        wasm_path = create_wasm_file(truncated)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path)
            # Should reject, not crash
            assert exit_code not in [139, 134, -11, -6], (
                f"wasm3 crashed on truncated module. Exit: {exit_code}"
            )
        finally:
            os.unlink(wasm_path)


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_zero_arguments(self):
        """Test function with zero value arguments."""
        wasm_data = create_simple_add_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "add", [0, 0])
            assert exit_code == 0 or "Result:" in stdout, (
                f"Failed with zero arguments. Exit: {exit_code}"
            )
        finally:
            os.unlink(wasm_path)

    def test_negative_numbers(self):
        """Test with negative number handling."""
        wasm_data = create_simple_add_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            # Note: wasm3 CLI may interpret this differently
            exit_code, stdout, stderr = run_wasm3(wasm_path, "add", ["-5", "10"])
            # Should not crash
            assert exit_code not in [139, 134, -11, -6], (
                f"wasm3 crashed with negative numbers. Exit: {exit_code}"
            )
        finally:
            os.unlink(wasm_path)

    def test_large_numbers(self):
        """Test with large i32 values."""
        wasm_data = create_simple_add_module()
        wasm_path = create_wasm_file(wasm_data)

        try:
            exit_code, stdout, stderr = run_wasm3(wasm_path, "add", [2147483647, 0])
            assert exit_code == 0 or exit_code not in [139, 134], (
                f"Failed with large numbers. Exit: {exit_code}"
            )
        finally:
            os.unlink(wasm_path)


class TestNoRegressions:
    """Verify no regression from fix application."""

    def test_multiple_function_calls(self):
        """Test calling multiple functions in sequence."""
        add_wasm = create_simple_add_module()
        mul_wasm = create_multiply_module()
        sub_wasm = create_subtract_module()

        paths = []
        try:
            for wasm_data in [add_wasm, mul_wasm, sub_wasm]:
                path = create_wasm_file(wasm_data)
                paths.append(path)
                exit_code, stdout, stderr = run_wasm3(path)
                assert exit_code not in [139, 134, -11, -6], (
                    f"Crash during multiple module tests"
                )
        finally:
            for path in paths:
                if os.path.exists(path):
                    os.unlink(path)

    def test_repeated_module_loads(self):
        """Test loading the same module multiple times."""
        wasm_data = create_simple_add_module()

        for i in range(5):
            wasm_path = create_wasm_file(wasm_data)
            try:
                exit_code, stdout, stderr = run_wasm3(wasm_path, "add", [i, i])
                assert exit_code not in [139, 134, -11, -6], (
                    f"Crash on iteration {i}"
                )
            finally:
                os.unlink(wasm_path)
