"""
Vulnerability tests for PMS Check endpoint.

These tests verify that the command injection vulnerability is patched.
- FAIL when vulnerable (command injection is possible)
- PASS when fixed (command injection is blocked)
"""

import requests
import pytest
import os
import time
import uuid
import subprocess

BASE_URL = os.environ.get("BASE_URL", "http://localhost:8080")


class TestCommandInjectionBackticks:
    """Test command injection via backtick substitution."""

    def test_backtick_id_command(self):
        """Test command injection using backticks with id command."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_backtick_{unique_id}.txt"
        payload = f"`id>/app/network/{output_file}`"

        # Send malicious request
        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        # Wait for potential command execution
        time.sleep(0.5)

        # Try to retrieve command output via web
        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        # If vulnerable: output file exists and contains uid/gid info
        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via backticks succeeded. "
                f"File {output_file} contains: {output_response.text[:100]}"
            )

    def test_backtick_whoami_command(self):
        """Test command injection using backticks with whoami."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_whoami_{unique_id}.txt"
        payload = f"`whoami>/app/network/{output_file}`"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        # Check if command executed (file exists and has content)
        is_vulnerable = (
            output_response.status_code == 200
            and len(output_response.text.strip()) > 0
            and "Invalid" not in output_response.text
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via backticks (whoami) succeeded. "
                f"Output: {output_response.text[:50]}"
            )

    def test_backtick_cat_passwd(self):
        """Test reading /etc/passwd via backtick injection."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_passwd_{unique_id}.txt"
        payload = f"`cat /etc/passwd>/app/network/{output_file}`"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        # Check for passwd file content
        is_vulnerable = (
            output_response.status_code == 200
            and "root:" in output_response.text
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Sensitive file disclosure via command injection. "
                "/etc/passwd content leaked."
            )


class TestCommandInjectionDollarParen:
    """Test command injection via $() substitution."""

    def test_dollar_paren_id_command(self):
        """Test command injection using $() syntax."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_dollarparen_{unique_id}.txt"
        payload = f"$(id>/app/network/{output_file})"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via $() syntax succeeded. "
                f"Output: {output_response.text[:100]}"
            )

    def test_dollar_paren_hostname(self):
        """Test command injection to read hostname."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_hostname_{unique_id}.txt"
        payload = f"$(hostname>/app/network/{output_file})"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        # Check if file was created with content
        is_vulnerable = (
            output_response.status_code == 200
            and len(output_response.text.strip()) > 0
            and "Invalid" not in output_response.text
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via $() succeeded. "
                f"Hostname leaked: {output_response.text[:50]}"
            )


class TestCommandInjectionSemicolon:
    """Test command injection via semicolon command chaining."""

    def test_semicolon_id_command(self):
        """Test command injection using semicolon chaining."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_semicolon_{unique_id}.txt"
        payload = f"127.0.0.1;id>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via semicolon chaining succeeded. "
                f"Output: {output_response.text[:100]}"
            )

    def test_semicolon_env_command(self):
        """Test command injection to dump environment variables."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_env_{unique_id}.txt"
        payload = f"127.0.0.1;env>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        # Environment dump usually contains PATH or HOME
        is_vulnerable = (
            output_response.status_code == 200
            and ("PATH=" in output_response.text or "HOME=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Environment variables leaked via command injection."
            )


class TestCommandInjectionNewline:
    """Test command injection via newline character."""

    def test_newline_encoded_injection(self):
        """Test command injection using URL-encoded newline (%0a)."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_newline_{unique_id}.txt"
        # Using raw string with newline
        payload = f"127.0.0.1\nid>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via newline succeeded. "
                f"Output: {output_response.text[:100]}"
            )

    # Note: Carriage return (\r) injection test removed as \r doesn't
    # actually cause command injection in shell - it's not a valid injection vector


class TestCommandInjectionPipe:
    """Test command injection via pipe character."""

    def test_pipe_id_command(self):
        """Test command injection using pipe to redirect output."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_pipe_{unique_id}.txt"
        payload = f"127.0.0.1|id>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via pipe succeeded. "
                f"Output: {output_response.text[:100]}"
            )

    def test_double_pipe_fallback(self):
        """Test command injection using || for fallback execution."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_doublepipe_{unique_id}.txt"
        payload = f"invalid.ip.addr||id>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via || fallback succeeded."
            )


class TestCommandInjectionAmpersand:
    """Test command injection via ampersand character."""

    def test_ampersand_background_execution(self):
        """Test command injection using & for background execution."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_ampersand_{unique_id}.txt"
        payload = f"127.0.0.1&id>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)  # Wait a bit longer for background execution

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via & background exec succeeded."
            )

    def test_double_ampersand_chaining(self):
        """Test command injection using && for conditional chaining."""
        unique_id = str(uuid.uuid4())[:8]
        output_file = f"test_doubleamp_{unique_id}.txt"
        payload = f"127.0.0.1&&id>/app/network/{output_file}"

        response = requests.get(
            f"{BASE_URL}/billing/pms_check.php",
            params={"ipaddress": payload},
            timeout=5,
        )

        time.sleep(0.5)

        output_response = requests.get(
            f"{BASE_URL}/network/{output_file}",
            timeout=5,
        )

        is_vulnerable = (
            output_response.status_code == 200
            and ("uid=" in output_response.text or "gid=" in output_response.text)
        )

        if is_vulnerable:
            pytest.fail(
                "VULNERABLE: Command injection via && chaining succeeded."
            )


# Note: TestInputValidationAfterFix class removed from test_vuln.py
# Those tests were designed to verify the FIX works (checking that invalid input is rejected),
# not to verify the vulnerability exists. They belong in a post-fix validation suite,
# not in vulnerability detection tests. In a vulnerable environment, all vuln tests
# should FAIL to indicate the vulnerability is present and exploitable.
