import pytest
import requests
import os
import time
import sys
import json

# 配置
BASE_URL = "http://localhost"
ADMIN_EMAIL = "admin@example.com"
ADMIN_PASSWORD = "admin"
LOW_PRIV_EMAIL = "nopriv@example.com"
LOW_PRIV_PASSWORD = "password123"

def wait_for_server():
    """等待服务器启动"""
    print(f"[DEBUG] Waiting for {BASE_URL}...")
    for i in range(30):
        try:
            resp = requests.get(BASE_URL, timeout=5)
            if resp.status_code < 500:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(1)
        if i % 5 == 0:
            print(f"[DEBUG] Still waiting... ({i}s)")
    return False

def _get_csrf_token(session):
    """获取 CSRF Token"""
    url = f"{BASE_URL}/admin/login"
    resp = session.get(url)
    
    from bs4 import BeautifulSoup
    soup = BeautifulSoup(resp.text, 'html.parser')
    token_input = soup.find('input', {'name': '_token'})
    
    if token_input is None:
        print(f"\n[ERROR] Failed to find CSRF token at {url}")
        print(f"[STATUS CODE] {resp.status_code}")
        # print(resp.text[:1000]) 
        raise ValueError("Could not find CSRF token")
        
    return token_input['value']

@pytest.fixture(scope="module")
def setup_data():
    if not wait_for_server():
        pytest.fail("Server did not start")

    session = requests.Session()
    
    # 1. 登录管理员
    print("[INFO] Attempting Admin Login...")
    try:
        token = _get_csrf_token(session)
    except ValueError as e:
        pytest.fail(str(e))

    resp = session.post(f"{BASE_URL}/admin/login", data={
        "email": ADMIN_EMAIL,
        "password": ADMIN_PASSWORD,
        "_token": token
    })
    
    # 2. 登录低权限用户
    print("[INFO] Attempting Low Priv User Login...")
    low_priv_session = requests.Session()
    try:
        low_token = _get_csrf_token(low_priv_session)
    except ValueError as e:
        pytest.fail(str(e))
        
    resp_low = low_priv_session.post(f"{BASE_URL}/admin/login", data={
        "email": LOW_PRIV_EMAIL,
        "password": LOW_PRIV_PASSWORD,
        "_token": low_token
    })
    
    return {
        "admin_session": session,
        "low_priv_session": low_priv_session
    }

def test_cve_2025_55741_mass_delete_bypass(setup_data):
    admin_session = setup_data['admin_session']
    low_priv_session = setup_data['low_priv_session']
    
    product_id = 1
    
    csrf_token = _get_csrf_token(low_priv_session)
    
    # 使用 JSON 时，Laravel 依然需要 X-CSRF-TOKEN 头
    headers = {
        "X-CSRF-TOKEN": csrf_token,
        "X-Requested-With": "XMLHttpRequest",
        "Content-Type": "application/json", # 显式声明 JSON
        "Accept": "application/json"
    }
    
    print(f"\n[INFO] Attempting to mass-delete product {product_id} as low-privilege user...")
    
    # === 关键修正点：使用 json= 而不是 data= ===
    # 这样 requests 会自动序列化为 JSON 字符串，保留数组结构
    response = low_priv_session.post(
        f"{BASE_URL}/admin/catalog/products/mass-delete",
        json={ 
            "indices": [product_id], 
            "_token": csrf_token
        },
        headers=headers
    )

    print(f"[INFO] Response Status: {response.status_code}")
    
    # 漏洞验证逻辑
    if response.status_code == 200:
        # 如果包含 successful 字样，说明删除了
        if "successful" in response.text.lower() or "deleted" in response.text.lower():
             pytest.fail(f"VULNERABILITY DETECTED: Low privilege user successfully deleted product {product_id}.")
        # 有时候 Laravel 返回 JSON: {"message": "Selected products deleted successfully"}
        elif "message" in response.text.lower():
             pytest.fail(f"VULNERABILITY DETECTED: Server returned success message: {response.text}")
        else:
             print(f"[WARNING] 200 OK received but message unclear: {response.text[:100]}")
             pytest.fail(f"VULNERABILITY DETECTED: Server returned 200 OK to unauthorized request.")
    
    elif response.status_code == 403 or "unauthorized" in response.text.lower():
         print("[PASS] Access denied as expected (Vulnerability Patched).")
         assert True
    else:
        print(f"[WARNING] Unexpected response: {response.status_code}")
        print(response.text[:500])
        if response.status_code == 422:
            pytest.fail(f"Test Payload Invalid (422 Error) - {response.text}")
        else:
            assert True 

if __name__ == "__main__":
    sys.exit(pytest.main(["-v", "-s", __file__]))