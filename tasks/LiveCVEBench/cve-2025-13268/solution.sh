#!/bin/bash
set -e
cd /app

echo "=== Applying JDBC URL validation fix ==="

# File to patch
FILE="src/main/java/com/vince/xq/project/system/dbconfig/service/DbconfigServiceImpl.java"

if [ ! -f "$FILE" ]; then
    echo "ERROR: Service file not found at $FILE"
    exit 1
fi

# Create backup
cp "$FILE" "${FILE}.bak"

# Check if fix is already applied
if grep -q "DANGEROUS_JDBC_PARAMS" "$FILE"; then
    echo "Fix already applied, skipping..."
else
    echo "Applying fix to $FILE..."

    # Create the fixed version of the file
    cat > "$FILE" << 'FIXED_FILE'
package com.vince.xq.project.system.dbconfig.service;

import com.vince.xq.common.constant.Constants;
import com.vince.xq.common.constant.UserConstants;
import com.vince.xq.common.utils.StringUtils;
import com.vince.xq.common.utils.security.ShiroUtils;
import com.vince.xq.common.utils.text.Convert;
import com.vince.xq.project.common.DbTypeEnum;
import com.vince.xq.project.system.dbconfig.domain.Dbconfig;
import com.vince.xq.project.system.dbconfig.mapper.DbconfigMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 岗位信息 服务层处理
 *
 * @author ruoyi
 */
@Service
public class DbconfigServiceImpl implements IDbconfigService {

    @Autowired
    private DbconfigMapper dbconfigMapper;

    // List of dangerous JDBC parameters that should be blocked
    private static final List<String> DANGEROUS_JDBC_PARAMS = Arrays.asList(
        "allowloadlocalinfile",
        "allowurlinlocalinfile",
        "autodeserialize",
        "queryinterceptors",
        "statementinterceptors",
        "detectcustomcollations",
        "allowloadlocalinfileinpath",
        "allowpublickeyretrieval"
    );

    @Override
    public List<Dbconfig> selectDbconfigList(Dbconfig dbconfig) {
        return dbconfigMapper.selectDbconfigList(dbconfig);
    }

    @Override
    public List<Dbconfig> selectDbconfigAll() {
        return dbconfigMapper.selectDbconfigAll();
    }

    /*@Override
    public List<Dbconfig> selectDbconfigsByUserId(Long userId)
    {
        List<Dbconfig> userDbconfigs = dbconfigMapper.selectDbconfigsByUserId(userId);
        List<Dbconfig> dbconfigs = dbconfigMapper.selectDbconfigAll();
        for (Dbconfig dbconfig : dbconfigs)
        {
            for (Dbconfig userDbconfig : userDbconfigs)
            {
                if (dbconfig.getId().longValue() == userDbconfig.getId().longValue())
                {
                    dbconfig.setFlag(true);
                    break;
                }
            }
        }
        return dbconfigs;
    }*/


    @Override
    public Dbconfig selectDbconfigById(Long id) {
        return dbconfigMapper.selectDbconfigById(id);
    }

    @Override
    public List<String> selectDbTypesAll() {
        List<String> list = new ArrayList<>();
        for (DbTypeEnum dbTypeEnum : DbTypeEnum.values()) {
            list.add(dbTypeEnum.getType());
        }
        return list;
    }

    @Override
    public int deleteDbconfigByIds(String ids) {
        Long[] idsArray = Convert.toLongArray(ids);
        /*for (Long id : idsArray)
        {
            Dbconfig dbconfig = selectDbconfigById(id);
            if (countUserPostById(dbconfig) > 0)
            {
                throw new ServiceException(String.format("%1$s已分配,不能删除", post.getPostName()));
            }
        }*/
        return dbconfigMapper.deleteDbconfigByIds(idsArray);
    }


    @Override
    public int insertDbconfig(Dbconfig dbconfig) {
        dbconfig.setCreateBy(ShiroUtils.getLoginName());
        return dbconfigMapper.insertDbconfig(dbconfig);
    }


    @Override
    public int updateDbconfig(Dbconfig dbconfig) {
        dbconfig.setCreateBy(ShiroUtils.getLoginName());
        return dbconfigMapper.updateDbconfig(dbconfig);
    }

    @Override
    public int countUserPostById(Long postId) {
        return 0;
    }


    /*@Override
    public int countUserPostById(Long postId)
    {
        return userPostMapper.countUserPostById(postId);
    }*/


    @Override
    public String checkConnectNameUnique(Dbconfig dbconfig) {
        Dbconfig info = dbconfigMapper.checkConnectNameUnique(dbconfig.getConnectName());
        if (StringUtils.isNotNull(info)) {
            return UserConstants.DBCONFIG_NAME_NOT_UNIQUE;
        }
        return UserConstants.DBCONFIG_NAME_UNIQUE;
    }

    /**
     * Validate JDBC URL to prevent injection of dangerous parameters
     * @param url The JDBC URL to validate
     * @throws Exception if dangerous parameters are detected
     */
    private void validateJdbcUrl(String url) throws Exception {
        if (url == null || url.isEmpty()) {
            throw new Exception("URL不能为空");
        }
        String lowerUrl = url.toLowerCase();
        for (String param : DANGEROUS_JDBC_PARAMS) {
            if (lowerUrl.contains(param)) {
                throw new Exception("检测到非法JDBC参数: " + param);
            }
        }
    }

    @Override
    public void testConnection(Dbconfig dbconfig) throws Exception {
        DbTypeEnum dbTypeEnum = DbTypeEnum.findEnumByType(dbconfig.getType());
        if (dbTypeEnum == null) {
            throw new Exception("不识别的类型");
        } else {
            testConnectionDriver(dbconfig, dbTypeEnum.getConnectDriver());
        }
    }


    private void testConnectionDriver(Dbconfig dbconfig, String connectDriver) throws Exception {
        // Validate JDBC URL before establishing connection
        validateJdbcUrl(dbconfig.getUrl());

        try {
            Class.forName(connectDriver);
        } catch (ClassNotFoundException e) {
            throw new Exception("注册驱动失败");
        }
        Connection conn = null;
        try {
            conn = DriverManager.getConnection(dbconfig.getUrl(), dbconfig.getUserName(), dbconfig.getPwd());
            Statement stat = conn.createStatement();
            ResultSet re = stat.executeQuery(Constants.TEST_CONNECT_SQL);
            int i = 0;
            while (re.next()) {
                i++;
                //System.out.println(re.getString(1));
            }
            re.close();
            stat.close();
            conn.close();
            if (i == 0) {
                throw new Exception("该连接下没有库");
            }
        } catch (SQLException e) {
            throw new Exception("连接数据库失败");
        }
    }
}
FIXED_FILE

    echo "Source code patched successfully"
fi

echo "=== Rebuilding application ==="

# Check if Maven wrapper exists
if [ -f "./mvnw" ]; then
    chmod +x ./mvnw
    ./mvnw clean package -DskipTests -q || {
        echo "Maven wrapper build failed, trying mvn..."
        mvn clean package -DskipTests -q
    }
elif command -v mvn &> /dev/null; then
    mvn clean package -DskipTests -q
else
    echo "ERROR: Maven not found. Cannot rebuild application."
    exit 1
fi

echo "=== Restarting application ==="

# Find and kill the running Java process
pkill -f "java.*dataCompare" || true
pkill -f "java.*-jar.*\.jar" || true
sleep 3

# Find the newly built JAR file
JAR_FILE=$(find target -name "*.jar" -type f 2>/dev/null | grep -v sources | grep -v original | head -1)

if [ -z "$JAR_FILE" ]; then
    echo "WARNING: Could not find JAR file in target directory"
    # Try to find elsewhere
    JAR_FILE=$(find . -name "dataCompare*.jar" -type f 2>/dev/null | grep -v sources | head -1)
fi

if [ -n "$JAR_FILE" ]; then
    echo "Starting application from $JAR_FILE"
    nohup java -jar "$JAR_FILE" > /app/app.log 2>&1 &

    # Wait for application to start
    echo "Waiting for application to start..."
    for i in {1..60}; do
        if curl -s http://localhost/login > /dev/null 2>&1; then
            echo "Application started successfully!"
            break
        fi
        if curl -s http://localhost:80/login > /dev/null 2>&1; then
            echo "Application started successfully!"
            break
        fi
        sleep 2
    done
else
    echo "WARNING: JAR file not found, application may need manual restart"
fi

echo "=== Fix applied successfully ==="
