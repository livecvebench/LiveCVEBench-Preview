"""
Vulnerability tests for SQL injection in admin login.
These tests FAIL in vulnerable state (vulnerability is exploitable).
These tests PASS in fixed state (vulnerability is mitigated).
"""
import requests
import time
import pytest

BASE_URL = "http://localhost/cts"
LOGIN_URL = f"{BASE_URL}/classes/Login.php?f=login"


class TestTimeBased:
    """Time-based blind SQL injection tests."""

    def test_time_based_sqli_sleep_3_seconds(self):
        """
        Test time-based SQL injection using SLEEP(3).
        If vulnerable, response will be delayed by ~3 seconds.
        """
        payload = {
            "username": "admin' AND (SELECT 1 FROM (SELECT(SLEEP(3)))a) AND 'x'='x",
            "password": "test"
        }

        start_time = time.time()
        try:
            response = requests.post(LOGIN_URL, data=payload, timeout=15)
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - possible vulnerability")
        elapsed_time = time.time() - start_time

        # If NOT vulnerable, query executes quickly (< 2 seconds)
        # If vulnerable, response is delayed by ~3 seconds
        assert elapsed_time < 2.5, (
            f"Response took {elapsed_time:.2f}s - SQL injection vulnerability detected! "
            f"SLEEP function was executed in the database."
        )

    def test_time_based_sqli_sleep_5_seconds(self):
        """
        Test time-based SQL injection using SLEEP(5).
        Different payload format to test various bypass techniques.
        """
        payload = {
            "username": "test' OR (SELECT SLEEP(5)) OR '1'='1",
            "password": "anything"
        }

        start_time = time.time()
        try:
            response = requests.post(LOGIN_URL, data=payload, timeout=15)
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - possible vulnerability")
        elapsed_time = time.time() - start_time

        assert elapsed_time < 2.5, (
            f"Response took {elapsed_time:.2f}s - SQL injection vulnerability detected!"
        )

    def test_time_based_sqli_benchmark(self):
        """
        Test time-based SQL injection using a subquery with SLEEP.
        Alternative time-based detection method.
        """
        # Use a different time-based payload with subquery
        payload = {
            "username": "admin' AND (SELECT 1 FROM (SELECT(SLEEP(2)))tbl) AND 'x'='x",
            "password": "test"
        }

        start_time = time.time()
        try:
            response = requests.post(LOGIN_URL, data=payload, timeout=15)
        except requests.exceptions.Timeout:
            pytest.fail("Request timed out - possible vulnerability")
        elapsed_time = time.time() - start_time

        # Normal login should complete in under 1 second
        # Time-based injection causes ~2 second delay
        assert elapsed_time < 1.5, (
            f"Response took {elapsed_time:.2f}s - SQL injection via time delay detected!"
        )


class TestAuthenticationBypass:
    """Authentication bypass via SQL injection tests."""

    def test_sqli_comment_bypass(self):
        """
        Test SQL injection using comment to bypass password check.
        Payload: admin'-- comments out the password verification.
        """
        payload = {
            "username": "admin'-- ",
            "password": "wrongpassword"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        # If NOT vulnerable, should return 'incorrect' (invalid login)
        # If vulnerable, may return 'success' (bypassed authentication)
        assert data.get("status") == "incorrect", (
            f"Authentication bypass detected! Login succeeded with injected payload. "
            f"Response: {data}"
        )

    def test_sqli_or_true_bypass(self):
        """
        Test SQL injection using OR TRUE condition with comment to bypass password check.
        Payload: admin' OR '1'='1'-- comments out the password verification.
        """
        payload = {
            "username": "admin' OR '1'='1'-- ",
            "password": "anything"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"Authentication bypass via OR injection detected! Response: {data}"
        )

    def test_sqli_admin_bypass_hashcomment(self):
        """
        Test SQL injection using # comment (MySQL style).
        """
        payload = {
            "username": "admin'#",
            "password": "irrelevant"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"Authentication bypass via # comment detected! Response: {data}"
        )

    def test_sqli_union_select_bypass(self):
        """
        Test SQL injection using UNION SELECT to inject fake credentials.
        """
        # This attempts to inject a fake user row
        payload = {
            "username": "' UNION SELECT 1,'fake','user','admin',md5('injected'),NULL,NULL,NULL,NULL -- ",
            "password": "injected"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"UNION-based authentication bypass detected! Response: {data}"
        )


class TestErrorBasedDetection:
    """Tests to detect SQL injection via error-based techniques."""

    def test_single_quote_error(self):
        """
        Test if single quote allows SQL injection via comment bypass.
        This verifies the username field is injectable.
        """
        payload = {
            "username": "admin'-- ",
            "password": "wrongpassword"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)

        try:
            data = response.json()
            # If vulnerable, the comment bypasses password check and logs in
            # If fixed, it would return 'incorrect'
            assert data.get("status") == "incorrect", (
                f"SQL injection via comment detected! "
                f"Authentication bypassed with status: {data.get('status')}"
            )
        except:
            # If not JSON response, also indicates issue
            pytest.fail(f"Unexpected response format: {response.text[:200]}")


class TestInformationLeakage:
    """Tests for information leakage in responses."""

    def test_no_query_leakage_on_failure(self):
        """
        Test that failed login does not expose the SQL query.
        The vulnerable version includes 'last_qry' in error response.
        """
        payload = {
            "username": "testuser",
            "password": "testpass"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        # The vulnerable version returns: {"status":"incorrect","last_qry":"SELECT..."}
        # Fixed version should only return: {"status":"incorrect"}
        assert "last_qry" not in data, (
            f"Information leakage detected! Response exposes SQL query: {data.get('last_qry', '')[:100]}..."
        )
        assert "SELECT" not in response.text.upper() or "last_qry" not in data, (
            "SQL query structure exposed in response!"
        )

    def test_no_query_leakage_with_injection_attempt(self):
        """
        Test that injection attempts don't cause query leakage.
        """
        payload = {
            "username": "test' OR '1'='1",
            "password": "test"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)

        try:
            data = response.json()
            assert "last_qry" not in data, (
                f"Query leakage with injection payload! Exposed: {data.get('last_qry', '')[:100]}..."
            )
        except:
            # If not JSON, check raw response
            assert "SELECT" not in response.text.upper(), (
                "SQL query structure exposed in raw response!"
            )


class TestAdvancedInjectionVectors:
    """Advanced SQL injection test vectors."""

    def test_stacked_queries(self):
        """
        Test authentication bypass with UNION-based injection.
        Uses UNION to inject a result that matches the query expectations.
        """
        # UNION-based bypass - inject a valid user row
        payload = {
            "username": "' UNION SELECT 1,2,'admin','admin',md5('test'),5,6,7,8-- ",
            "password": "test"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        try:
            data = response.json()
        except:
            data = {}

        # If vulnerable, UNION injection might return rows allowing bypass
        # We mainly check it doesn't bypass to success
        assert data.get("status") == "incorrect", (
            f"UNION-based SQL injection bypass detected - response: {data}"
        )

    def test_encoded_injection(self):
        """
        Test another authentication bypass variant using double-dash comment.
        """
        # Different comment style bypass
        payload = {
            "username": "admin' -- ",
            "password": "test"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"Double-dash comment injection bypass detected! Response: {data}"
        )

    def test_case_variation_injection(self):
        """
        Test case variation injection to bypass simple filters.
        """
        payload = {
            "username": "admin' oR '1'='1",
            "password": "test"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"Case variation bypass detected! Response: {data}"
        )

    def test_null_byte_injection(self):
        """
        Test boolean-based SQL injection with always true condition.
        """
        payload = {
            "username": "admin' OR 1=1#",
            "password": "test"
        }

        response = requests.post(LOGIN_URL, data=payload, timeout=10)
        data = response.json()

        assert data.get("status") == "incorrect", (
            f"Boolean-based injection bypass detected! Response: {data}"
        )
