"""
Functional tests for joserfc library.
These tests verify the library works correctly after the fix is applied.
All tests should PASS in both vulnerable and fixed states.
"""
import pytest
from joserfc.jws import serialize_compact, deserialize_compact
from joserfc.jwt import encode, decode
from joserfc.jwk import OctKey
from joserfc.errors import ExceededSizeError
from joserfc.util import urlsafe_b64encode, json_b64encode


class TestJWTFunctionality:
    """Tests for basic JWT encode/decode functionality."""

    def test_basic_jwt_roundtrip(self):
        """JWT encode/decode should work normally with valid tokens."""
        key = OctKey.import_key("secret-key-for-testing-purposes")
        token = encode({"alg": "HS256"}, {"sub": "user123", "name": "Test User"}, key)
        result = decode(token, key)
        assert result.claims["sub"] == "user123"
        assert result.claims["name"] == "Test User"

    def test_jwt_with_multiple_claims(self):
        """JWT should handle multiple claims correctly."""
        key = OctKey.import_key("another-secret-key")
        claims = {
            "sub": "user456",
            "aud": "my-app",
            "iss": "auth-server",
            "data": {"role": "admin", "permissions": ["read", "write"]},
        }
        token = encode({"alg": "HS256"}, claims, key)
        result = decode(token, key)
        assert result.claims["sub"] == "user456"
        assert result.claims["aud"] == "my-app"
        assert result.claims["data"]["role"] == "admin"

    def test_jwt_with_different_algorithms(self):
        """JWT should work with HS256 algorithm."""
        key = OctKey.import_key("secret-key-at-least-32-characters-long")

        # HS256
        token = encode({"alg": "HS256"}, {"alg_test": "HS256"}, key)
        result = decode(token, key)
        assert result.claims["alg_test"] == "HS256"


class TestJWSFunctionality:
    """Tests for JWS serialize/deserialize functionality."""

    def test_jws_compact_roundtrip(self):
        """JWS serialize/deserialize should work normally."""
        key = OctKey.import_key("secret")
        token = serialize_compact({"alg": "HS256"}, b"test payload data", key)
        obj = deserialize_compact(token, key)
        assert obj.payload == b"test payload data"

    def test_jws_with_binary_payload(self):
        """JWS should handle binary payloads correctly."""
        key = OctKey.import_key("secret")
        binary_data = b"\x00\x01\x02\x03\x04\x05binary\xfe\xff"
        token = serialize_compact({"alg": "HS256"}, binary_data, key)
        obj = deserialize_compact(token, key)
        assert obj.payload == binary_data

    def test_jws_with_json_payload(self):
        """JWS should handle JSON-encoded payloads."""
        key = OctKey.import_key("secret")
        import json
        payload = json.dumps({"key": "value", "number": 42}).encode()
        token = serialize_compact({"alg": "HS256"}, payload, key)
        obj = deserialize_compact(token, key)
        assert obj.payload == payload
        decoded = json.loads(obj.payload)
        assert decoded["key"] == "value"


class TestSizeLimitsEnforced:
    """Tests that size limits are still properly enforced."""

    def test_oversized_header_rejected(self):
        """Oversized headers should still raise ExceededSizeError."""
        key = OctKey.import_key("secret")
        # Create header > 512 bytes
        large_header = json_b64encode({f"key{i}": "x" * 50 for i in range(30)})
        fake_jwt = large_header + b"." + urlsafe_b64encode(b"payload") + b"." + urlsafe_b64encode(b"sig")

        with pytest.raises(ExceededSizeError):
            deserialize_compact(fake_jwt, key)

    def test_oversized_payload_rejected(self):
        """Oversized payloads should still raise ExceededSizeError."""
        key = OctKey.import_key("secret")
        header = json_b64encode({"alg": "HS256"})
        # Create payload > 8000 bytes
        large_payload = urlsafe_b64encode(b"X" * 10000)
        fake_jwt = header + b"." + large_payload + b"." + urlsafe_b64encode(b"sig")

        with pytest.raises(ExceededSizeError):
            deserialize_compact(fake_jwt, key)

    def test_oversized_signature_rejected(self):
        """Oversized signatures should still raise ExceededSizeError."""
        key = OctKey.import_key("secret")
        header = json_b64encode({"alg": "HS256"})
        payload = urlsafe_b64encode(b"normal payload")
        # Create signature > 1024 bytes
        large_sig = urlsafe_b64encode(b"S" * 1500)
        fake_jwt = header + b"." + payload + b"." + large_sig

        with pytest.raises(ExceededSizeError):
            deserialize_compact(fake_jwt, key)


class TestErrorMessageContent:
    """Tests that error messages are informative after the fix."""

    def test_header_error_mentions_limit(self):
        """Error message should mention the header limit."""
        key = OctKey.import_key("secret")
        large_header = json_b64encode({f"k{i}": "x" * 50 for i in range(30)})
        fake_jwt = large_header + b"." + urlsafe_b64encode(b"x") + b"." + urlsafe_b64encode(b"y")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # Error should mention "Header" and the limit
        assert "Header" in error_msg or "header" in error_msg.lower()
        assert "512" in error_msg

    def test_payload_error_mentions_limit(self):
        """Error message should mention the payload limit."""
        key = OctKey.import_key("secret")
        header = json_b64encode({"alg": "HS256"})
        large_payload = urlsafe_b64encode(b"P" * 10000)
        fake_jwt = header + b"." + large_payload + b"." + urlsafe_b64encode(b"sig")

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # Error should mention "Payload" and the limit
        assert "Payload" in error_msg or "payload" in error_msg.lower()
        assert "8000" in error_msg

    def test_signature_error_mentions_limit(self):
        """Error message should mention the signature limit."""
        key = OctKey.import_key("secret")
        header = json_b64encode({"alg": "HS256"})
        payload = urlsafe_b64encode(b"pay")
        large_sig = urlsafe_b64encode(b"S" * 1500)
        fake_jwt = header + b"." + payload + b"." + large_sig

        with pytest.raises(ExceededSizeError) as exc_info:
            deserialize_compact(fake_jwt, key)

        error_msg = str(exc_info.value)
        # Error should mention "Signature" and the limit
        assert "Signature" in error_msg or "signature" in error_msg.lower()
        assert "1024" in error_msg


class TestEdgeCases:
    """Tests for edge cases and boundary conditions."""

    def test_valid_token_at_size_limit(self):
        """Tokens at exactly the size limit should be processed."""
        key = OctKey.import_key("secret")
        # Create a valid token that's close to but under limits
        token = serialize_compact({"alg": "HS256"}, b"normal payload", key)
        obj = deserialize_compact(token, key)
        assert obj.payload == b"normal payload"

    def test_empty_payload(self):
        """Empty payloads should be handled correctly."""
        key = OctKey.import_key("secret")
        token = serialize_compact({"alg": "HS256"}, b"", key)
        obj = deserialize_compact(token, key)
        assert obj.payload == b""

    def test_ascii_special_chars_in_claims(self):
        """ASCII special characters in claims should be handled."""
        key = OctKey.import_key("secret-key-for-special-test")
        claims = {
            "sub": "user",
            "name": "Test User <test@example.com>",
            "special": "!@#$%^&*()_+-=[]{}|;':\",./<>?",
        }
        token = encode({"alg": "HS256"}, claims, key)
        result = decode(token, key)
        assert result.claims["name"] == claims["name"]
        assert result.claims["special"] == claims["special"]
