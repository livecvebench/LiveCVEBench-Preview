"""
Vulnerability tests for the MCP Package Docs Server.

These tests verify that command injection via shell metacharacters is blocked.
They should:
- FAIL in vulnerable state (command injection succeeds)
- PASS in fixed state (command injection is blocked)
"""

import subprocess
import json
import time
import os
import pytest
import uuid
import signal


# Generate unique test file paths to avoid collisions
TEST_ID = uuid.uuid4().hex[:8]
TEST_BASE = f"/tmp/mcp_test_{TEST_ID}"


def cleanup_test_files():
    """Remove any test files created during testing."""
    import glob
    for pattern in [f"{TEST_BASE}*", "/tmp/mcp_vuln_test_*"]:
        for filepath in glob.glob(pattern):
            try:
                os.remove(filepath)
            except OSError:
                pass


def start_server():
    """Start the MCP server process."""
    proc = subprocess.Popen(
        ["node", "/app/build/index.js"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        cwd="/app"
    )
    time.sleep(1)  # Give server time to initialize
    return proc


def stop_server(proc):
    """Stop the MCP server process."""
    proc.terminate()
    try:
        proc.wait(timeout=3)
    except subprocess.TimeoutExpired:
        proc.kill()
        proc.wait()


def send_mcp_call_tool(proc, tool_name, arguments):
    """Send a tools/call request to the MCP server."""
    # First, send initialize
    init_request = {
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "clientInfo": {"name": "test", "version": "1.0"}
        }
    }
    proc.stdin.write(json.dumps(init_request) + "\n")
    proc.stdin.flush()
    proc.stdout.readline()  # Read initialize response

    # Send initialized notification
    init_notif = {
        "jsonrpc": "2.0",
        "method": "notifications/initialized"
    }
    proc.stdin.write(json.dumps(init_notif) + "\n")
    proc.stdin.flush()

    # Now send the actual tool call
    call_request = {
        "jsonrpc": "2.0",
        "id": 2,
        "method": "tools/call",
        "params": {
            "name": tool_name,
            "arguments": arguments
        }
    }
    proc.stdin.write(json.dumps(call_request) + "\n")
    proc.stdin.flush()

    # Read response (may need to skip notifications)
    for _ in range(5):  # Try reading up to 5 lines
        try:
            line = proc.stdout.readline()
            if line:
                data = json.loads(line)
                if data.get("id") == 2:
                    return data
        except json.JSONDecodeError:
            continue

    return None


class TestGoCommandInjection:
    """Test Go package command injection vulnerabilities."""

    def setup_method(self):
        """Setup before each test."""
        cleanup_test_files()

    def teardown_method(self):
        """Cleanup after each test."""
        cleanup_test_files()

    def test_go_package_semicolon_injection(self):
        """Test that semicolon-based command injection is blocked."""
        test_file = f"{TEST_BASE}_go_semicolon"
        malicious_package = f"fmt; touch {test_file}"

        proc = start_server()
        try:
            # Try to exploit via describe_go_package
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            # Give time for any command to execute
            time.sleep(2)

            # If the file was created, the injection succeeded (vulnerability exists)
            assert not os.path.exists(test_file), \
                f"Command injection via semicolon succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_go_package_command_substitution(self):
        """Test that $() command substitution is blocked."""
        test_file = f"{TEST_BASE}_go_subst"
        malicious_package = f"$(touch {test_file})"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via $() succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_go_package_backtick_injection(self):
        """Test that backtick command substitution is blocked."""
        test_file = f"{TEST_BASE}_go_backtick"
        malicious_package = f"`touch {test_file}`"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via backticks succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_go_package_pipe_injection(self):
        """Test that pipe-based command injection is blocked."""
        test_file = f"{TEST_BASE}_go_pipe"
        malicious_package = f"fmt | touch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via pipe succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_go_package_and_injection(self):
        """Test that && command chaining is blocked."""
        test_file = f"{TEST_BASE}_go_and"
        malicious_package = f"fmt && touch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via && succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_go_lookup_doc_injection(self):
        """Test that lookup_go_doc tool is also protected."""
        test_file = f"{TEST_BASE}_go_lookup"
        malicious_package = f"fmt; touch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "lookup_go_doc", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection in lookup_go_doc succeeded!"
        finally:
            stop_server(proc)


class TestPythonCommandInjection:
    """Test Python package command injection vulnerabilities."""

    def setup_method(self):
        cleanup_test_files()

    def teardown_method(self):
        cleanup_test_files()

    def test_python_package_quote_injection(self):
        """Test that quote-based Python code injection is blocked."""
        test_file = f"{TEST_BASE}_py_quote"
        # This payload attempts to break out of the Python string and execute code
        malicious_package = f"requests'); import os; os.system('touch {test_file}'); print('"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_python_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Python injection via quote escape succeeded! File {test_file} was created."
        finally:
            stop_server(proc)

    def test_python_package_semicolon_injection(self):
        """Test that semicolon-based injection in Python context is blocked."""
        test_file = f"{TEST_BASE}_py_semi"
        # Use shell command injection that breaks out of the python3 -c context
        # The vulnerable code does: python3 -c "...find_spec('${packageName}')..."
        # We inject: '); import os; os.system('touch FILE'); print('
        malicious_package = f"'); import os; os.system('touch {test_file}'); print('"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_python_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Python injection via semicolon succeeded!"
        finally:
            stop_server(proc)

    def test_python_lookup_doc_injection(self):
        """Test that lookup_python_doc tool is also protected."""
        test_file = f"{TEST_BASE}_py_lookup"
        # Use shell-level injection via $() to bypass Python context
        malicious_package = f"$(touch {test_file})"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "lookup_python_doc", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection in lookup_python_doc succeeded!"
        finally:
            stop_server(proc)


class TestSearchDocsInjection:
    """Test search_package_docs command injection vulnerabilities."""

    def setup_method(self):
        cleanup_test_files()

    def teardown_method(self):
        cleanup_test_files()

    def test_search_go_injection(self):
        """Test that search_package_docs with Go language is protected."""
        test_file = f"{TEST_BASE}_search_go"
        malicious_package = f"fmt; touch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "search_package_docs", {
                "package": malicious_package,
                "query": "print",
                "language": "go"
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection in search_package_docs (go) succeeded!"
        finally:
            stop_server(proc)

    def test_search_python_injection(self):
        """Test that search_package_docs with Python language is protected."""
        test_file = f"{TEST_BASE}_search_py"
        # Use shell-level injection via $() which works regardless of Python context
        malicious_package = f"$(touch {test_file})"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "search_package_docs", {
                "package": malicious_package,
                "query": "path",
                "language": "python"
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection in search_package_docs (python) succeeded!"
        finally:
            stop_server(proc)


class TestSymbolParameterInjection:
    """Test injection via the symbol parameter."""

    def setup_method(self):
        cleanup_test_files()

    def teardown_method(self):
        cleanup_test_files()

    def test_go_symbol_injection(self):
        """Test that symbol parameter is also protected for Go."""
        test_file = f"{TEST_BASE}_symbol_go"
        malicious_symbol = f"Println; touch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": "fmt",
                "symbol": malicious_symbol
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via Go symbol parameter succeeded!"
        finally:
            stop_server(proc)

    def test_python_symbol_injection(self):
        """Test that symbol parameter is also protected for Python."""
        test_file = f"{TEST_BASE}_symbol_py"
        # Use shell-level injection via $() which is processed by exec() before Python
        malicious_symbol = f"$(touch {test_file})"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_python_package", {
                "package": "os",
                "symbol": malicious_symbol
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Command injection via Python symbol parameter succeeded!"
        finally:
            stop_server(proc)


class TestRedirectionInjection:
    """Test output redirection-based injection."""

    def setup_method(self):
        cleanup_test_files()

    def teardown_method(self):
        cleanup_test_files()

    def test_go_output_redirection(self):
        """Test that output redirection is blocked."""
        test_file = f"{TEST_BASE}_redirect"
        malicious_package = f"fmt > {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Output redirection injection succeeded!"
        finally:
            stop_server(proc)

    def test_go_append_redirection(self):
        """Test that append redirection is blocked."""
        test_file = f"{TEST_BASE}_append"
        malicious_package = f"fmt >> {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Append redirection injection succeeded!"
        finally:
            stop_server(proc)


class TestNewlineInjection:
    """Test newline-based command injection."""

    def setup_method(self):
        cleanup_test_files()

    def teardown_method(self):
        cleanup_test_files()

    def test_go_newline_injection(self):
        """Test that newline-based injection is blocked."""
        test_file = f"{TEST_BASE}_newline"
        malicious_package = f"fmt\ntouch {test_file}"

        proc = start_server()
        try:
            send_mcp_call_tool(proc, "describe_go_package", {
                "package": malicious_package
            })

            time.sleep(2)

            assert not os.path.exists(test_file), \
                f"Newline-based command injection succeeded!"
        finally:
            stop_server(proc)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
