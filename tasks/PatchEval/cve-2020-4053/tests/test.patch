diff --git a/pkg/plugin/installer/http_installer_test.go b/pkg/plugin/installer/http_installer_test.go
new file mode 100644
index 0000000..f5f32e3
--- /dev/null
+++ b/pkg/plugin/installer/http_installer_test.go
@@ -0,0 +1,286 @@
+/*
+Copyright The Helm Authors.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package installer // import "helm.sh/helm/v3/pkg/plugin/installer"
+
+import (
+	"archive/tar"
+	"bytes"
+	"compress/gzip"
+	"encoding/base64"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+
+	"github.com/pkg/errors"
+	"github.com/stretchr/testify/require"
+	"helm.sh/helm/v3/internal/test/ensure"
+	"helm.sh/helm/v3/pkg/getter"
+	"helm.sh/helm/v3/pkg/helmpath"
+)
+
+var _ Installer = new(HTTPInstaller)
+
+// Fake http client
+type TestHTTPGetter struct {
+	MockResponse *bytes.Buffer
+	MockError    error
+}
+
+func (t *TestHTTPGetter) Get(href string, _ ...getter.Option) (*bytes.Buffer, error) {
+	return t.MockResponse, t.MockError
+}
+
+// Fake plugin tarball data
+var fakePluginB64 = "H4sIAKRj51kAA+3UX0vCUBgGcC9jn+Iwuk3Peza3GeyiUlJQkcogCOzgli7dJm4TvYk+a5+k479UqquUCJ/fLs549sLO2TnvWnJa9aXnjwujYdYLovxMhsPcfnHOLdNkOXthM/IVQQYjg2yyLLJ4kXGhLp5j0z3P41tZksqxmspL3B/O+j/XtZu1y8rdYzkOZRCxduKPk53ny6Wwz/GfIIf1As8lxzGJSmoHNLJZphKHG4YpTCE0wVk3DULfpSJ3DMMqkj3P5JfMYLdX1Vr9Ie/5E5cstcdC8K04iGLX5HaJuKpWL17F0TCIBi5pf/0pjtLhun5j3f9v6r7wfnI/H0eNp9d1/5P6Gez0vzo7wsoxfrAZbTny/o9k6J8z/VkO/LPlWdC1iVpbEEcq5nmeJ13LEtmbV0k2r2PrOs9PuuNglC5rL1Y5S/syXRQmutaNw1BGnnp8Wq3UG51WvX1da3bKtZtCN/R09DwAAAAAAAAAAAAAAAAAAADAb30AoMczDwAoAAA="
+
+func TestStripName(t *testing.T) {
+	if stripPluginName("fake-plugin-0.0.1.tar.gz") != "fake-plugin" {
+		t.Errorf("name does not match expected value")
+	}
+	if stripPluginName("fake-plugin-0.0.1.tgz") != "fake-plugin" {
+		t.Errorf("name does not match expected value")
+	}
+	if stripPluginName("fake-plugin.tgz") != "fake-plugin" {
+		t.Errorf("name does not match expected value")
+	}
+	if stripPluginName("fake-plugin.tar.gz") != "fake-plugin" {
+		t.Errorf("name does not match expected value")
+	}
+}
+
+func TestHTTPInstaller(t *testing.T) {
+	defer ensure.HelmHome(t)()
+	source := "https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz"
+
+	if err := os.MkdirAll(helmpath.DataPath("plugins"), 0755); err != nil {
+		t.Fatalf("Could not create %s: %s", helmpath.DataPath("plugins"), err)
+	}
+
+	i, err := NewForSource(source, "0.0.1")
+	if err != nil {
+		t.Fatalf("unexpected error: %s", err)
+	}
+
+	// ensure a HTTPInstaller was returned
+	httpInstaller, ok := i.(*HTTPInstaller)
+	if !ok {
+		t.Fatal("expected a HTTPInstaller")
+	}
+
+	// inject fake http client responding with minimal plugin tarball
+	mockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)
+	if err != nil {
+		t.Fatalf("Could not decode fake tgz plugin: %s", err)
+	}
+
+	httpInstaller.getter = &TestHTTPGetter{
+		MockResponse: bytes.NewBuffer(mockTgz),
+	}
+
+	// install the plugin
+	if err := Install(i); err != nil {
+		t.Fatal(err)
+	}
+	if i.Path() != helmpath.DataPath("plugins", "fake-plugin") {
+		t.Fatalf("expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q", i.Path())
+	}
+
+	// Install again to test plugin exists error
+	if err := Install(i); err == nil {
+		t.Fatal("expected error for plugin exists, got none")
+	} else if err.Error() != "plugin already exists" {
+		t.Fatalf("expected error for plugin exists, got (%v)", err)
+	}
+
+}
+
+func TestHTTPInstallerNonExistentVersion(t *testing.T) {
+	defer ensure.HelmHome(t)()
+	source := "https://repo.localdomain/plugins/fake-plugin-0.0.2.tar.gz"
+
+	if err := os.MkdirAll(helmpath.DataPath("plugins"), 0755); err != nil {
+		t.Fatalf("Could not create %s: %s", helmpath.DataPath("plugins"), err)
+	}
+
+	i, err := NewForSource(source, "0.0.2")
+	if err != nil {
+		t.Fatalf("unexpected error: %s", err)
+	}
+
+	// ensure a HTTPInstaller was returned
+	httpInstaller, ok := i.(*HTTPInstaller)
+	if !ok {
+		t.Fatal("expected a HTTPInstaller")
+	}
+
+	// inject fake http client responding with error
+	httpInstaller.getter = &TestHTTPGetter{
+		MockError: errors.Errorf("failed to download plugin for some reason"),
+	}
+
+	// attempt to install the plugin
+	if err := Install(i); err == nil {
+		t.Fatal("expected error from http client")
+	}
+
+}
+
+func TestHTTPInstallerUpdate(t *testing.T) {
+	source := "https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz"
+	defer ensure.HelmHome(t)()
+
+	if err := os.MkdirAll(helmpath.DataPath("plugins"), 0755); err != nil {
+		t.Fatalf("Could not create %s: %s", helmpath.DataPath("plugins"), err)
+	}
+
+	i, err := NewForSource(source, "0.0.1")
+	if err != nil {
+		t.Fatalf("unexpected error: %s", err)
+	}
+
+	// ensure a HTTPInstaller was returned
+	httpInstaller, ok := i.(*HTTPInstaller)
+	if !ok {
+		t.Fatal("expected a HTTPInstaller")
+	}
+
+	// inject fake http client responding with minimal plugin tarball
+	mockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)
+	if err != nil {
+		t.Fatalf("Could not decode fake tgz plugin: %s", err)
+	}
+
+	httpInstaller.getter = &TestHTTPGetter{
+		MockResponse: bytes.NewBuffer(mockTgz),
+	}
+
+	// install the plugin before updating
+	if err := Install(i); err != nil {
+		t.Fatal(err)
+	}
+	if i.Path() != helmpath.DataPath("plugins", "fake-plugin") {
+		t.Fatalf("expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q", i.Path())
+	}
+
+	// Update plugin, should fail because it is not implemented
+	if err := Update(i); err == nil {
+		t.Fatal("update method not implemented for http installer")
+	}
+}
+
+func TestCleanJoin(t *testing.T) {
+	for i, fixture := range []struct {
+		path        string
+		expect      string
+		expectError bool
+	} {
+		{"foo/bar.txt", "/tmp/foo/bar.txt", false},
+		{"/foo/bar.txt", "", true},
+		{"./foo/bar.txt", "/tmp/foo/bar.txt", false},
+		{"./././././foo/bar.txt", "/tmp/foo/bar.txt", false},
+		{"../../../../foo/bar.txt", "", true},
+		{"foo/../../../../bar.txt", "", true},
+		{"c:/foo/bar.txt", "/tmp/c:/foo/bar.txt", true},
+		{"foo\\bar.txt", "/tmp/foo/bar.txt", false},
+		{"c:\\foo\\bar.txt", "", true},
+	} {
+		out, err := cleanJoin("/tmp", fixture.path)
+		if err != nil {
+			if !fixture.expectError {
+				t.Errorf("Test %d: Path was not cleaned: %s", i, err)
+			}
+			continue
+		}
+		if fixture.expect != out {
+			t.Errorf("Test %d: Expected %q but got %q", i, fixture.expect, out)
+		}
+	}
+
+}
+
+// TestExtract tests installer.TarGzExtractor's Extract method,
+// indirectly verifying that internal calls to cleanJoin follow the logic in TestCleanJoin.
+func TestExtract(t *testing.T) {
+	fixtures := []struct {
+		path        string
+		expect      string
+		expectError bool
+	}{
+		{"bar.txt", "/tmp/bar.txt", false},
+		{"/foo/bar.txt", "", true},
+		{"./bar.txt", "/tmp/bar.txt", false},
+		{"./././././bar.txt", "/tmp/bar.txt", false},
+		{"../../../../foo/bar.txt", "", true},
+		{"foo/../../../../bar.txt", "", true},
+		{"c:/foo/bar.txt", "/tmp/c:/foo/bar.txt", true},
+		{"c:\\foo\\bar.txt", "", true},
+	}
+
+	for i, fixture := range fixtures {
+		t.Run(fixture.path, func(t *testing.T) {
+			// 1. Create a temporary directory as extraction root
+			tempDir, err := os.MkdirTemp("", "testextract-*")
+			require.NoError(t, err)
+			defer os.RemoveAll(tempDir)
+
+			// 2. Build a tar.gz stream containing a single file with fixture.path
+			var buf bytes.Buffer
+			gzw := gzip.NewWriter(&buf)
+			tw := tar.NewWriter(gzw)
+
+			// Write header
+			hdr := &tar.Header{
+				Name: fixture.path,
+				Mode: 0644,
+				Size: int64(len("Hello, World!")),
+			}
+			require.NoError(t, tw.WriteHeader(hdr))
+			// Write body
+			_, err = tw.Write([]byte("Hello, World!"))
+			require.NoError(t, err)
+
+			require.NoError(t, tw.Close())
+			require.NoError(t, gzw.Close())
+
+			// 3. Call Extract
+			extractor := &TarGzExtractor{}
+			err = extractor.Extract(&buf, tempDir)
+
+			// According to TestCleanJoin logic, expectError true means error must occur
+			if fixture.expectError {
+				require.Error(t, err, "Test %d: Path was not cleaned: %s", i, fixture.path)
+				return
+			}
+
+			// Fail if unexpected error occurred
+			require.NoError(t, err, "Test %d: Unexpected error extracting: %s", i, fixture.path)
+
+			// 4. Check that the extracted file exists at the expected location
+			//    In TestCleanJoin the root is hardcoded as /tmp, here we replace /tmp with tempDir
+			if fixture.expect != "" {
+				// Replace "/tmp/foo/bar.txt" with "<tempDir>/foo/bar.txt"
+				trimmed := strings.TrimPrefix(fixture.expect, "/tmp")
+				expectedPath := filepath.ToSlash(filepath.Join(tempDir, trimmed))
+
+				// Verify file exists at expectedPath
+				info, statErr := os.Stat(expectedPath)
+				require.NoError(t, statErr, "Test %d: expected file not found at path: %s", i, expectedPath)
+				require.False(t, info.IsDir(), "Test %d: expected a regular file, but got a directory", i)
+			}
+		})
+	}
+}
