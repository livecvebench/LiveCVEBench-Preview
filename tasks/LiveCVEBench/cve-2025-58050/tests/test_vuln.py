"""
Vulnerability tests for PCRE2 heap-buffer-overflow in SCS with ACCEPT.

These tests verify the vulnerability status:
- FAIL in vulnerable state (incorrect behavior / crash / ASAN error)
- PASS in fixed state (correct behavior, no memory errors)

The vulnerability occurs when (*ACCEPT) is used inside a (*scs:...) block.
The matching engine fails to restore buffer boundaries after ACCEPT,
causing subsequent pattern elements to use corrupted state.
"""

import subprocess
import os
import tempfile
import pytest
import signal
import re


PCRE2TEST_BIN = "/app/build/pcre2test"


def run_pcre2test(pattern: str, subject: str, timeout: int = 30) -> dict:
    """
    Run pcre2test with given pattern and subject.
    Returns dict with stdout, stderr, returncode, and timed_out flag.
    """
    input_text = f"{pattern}\n    {subject}\n"

    try:
        result = subprocess.run(
            [PCRE2TEST_BIN],
            input=input_text,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return {
            "stdout": result.stdout,
            "stderr": result.stderr,
            "returncode": result.returncode,
            "timed_out": False,
            "output": result.stdout + result.stderr
        }
    except subprocess.TimeoutExpired:
        return {
            "stdout": "",
            "stderr": "Timeout",
            "returncode": -1,
            "timed_out": True,
            "output": "Timeout"
        }


def has_asan_error(output: str) -> bool:
    """Check if output contains AddressSanitizer error."""
    asan_patterns = [
        "AddressSanitizer",
        "ASAN:",
        "heap-buffer-overflow",
        "heap-use-after-free",
        "stack-buffer-overflow",
        "ERROR: AddressSanitizer",
        "SUMMARY: AddressSanitizer"
    ]
    for pattern in asan_patterns:
        if pattern in output:
            return True
    return False


def has_crash_indicators(output: str, returncode: int) -> bool:
    """Check if the process crashed or had abnormal termination."""
    # Check for crash signals
    if returncode < 0:
        crash_signals = [
            signal.SIGSEGV,
            signal.SIGBUS,
            signal.SIGABRT,
            signal.SIGFPE
        ]
        if -returncode in [s.value for s in crash_signals]:
            return True

    # Check for crash-related output
    crash_patterns = [
        "Segmentation fault",
        "Bus error",
        "Aborted",
        "core dumped"
    ]
    for pattern in crash_patterns:
        if pattern in output:
            return True

    return False


class TestSCSWithAcceptVulnerability:
    """
    Test the specific vulnerability: SCS assertion with (*ACCEPT) fails to
    restore buffer boundaries, causing heap-buffer-overflow in subsequent
    pattern elements.

    These tests verify FIXED behavior - they check for:
    1. No ASAN errors (memory safety)
    2. Correct output values

    In vulnerable version: tests FAIL (ASAN errors or incorrect output)
    In fixed version: tests PASS (no errors, correct output)
    """

    def test_scs_accept_basic(self):
        """
        Test SCS with ACCEPT followed by literal string.
        Pattern: /(a)(*scs:(1)a(*ACCEPT))bbb/
        Subject: abbb
        Expected: Match "abbb" with capture group 1 = "a"

        In vulnerable version: Returns "No match" due to buffer corruption.
        """
        result = run_pcre2test("/(a)(*scs:(1)a(*ACCEPT))bbb/", "abbb")

        # Should not have ASAN errors or crash
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

        # Should produce correct match (fails in vulnerable version with "No match")
        assert "0: abbb" in result["stdout"], \
            f"Expected '0: abbb' in output, got: {result['stdout']}"
        assert "1: a" in result["stdout"], \
            f"Expected '1: a' in output, got: {result['stdout']}"

    def test_scs_accept_with_backreference(self):
        """
        Primary PoC: SCS with ACCEPT followed by backreference.
        This is the main vulnerability trigger.

        Pattern: /(a)(b+)(*scs:(1)a(*ACCEPT))(\2)/
        Subject: abbb

        Expected after fix:
         0: abb
         1: a
         2: b
         3: b

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test("/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)/", "abbb")

        # Should not have ASAN errors or crash
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

        # Should produce correct match
        assert "0: abb" in result["stdout"], \
            f"Expected '0: abb' in output, got: {result['stdout']}"
        assert "1: a" in result["stdout"], \
            f"Expected '1: a' in output, got: {result['stdout']}"
        assert "2: b" in result["stdout"], \
            f"Expected '2: b' in output, got: {result['stdout']}"
        assert "3: b" in result["stdout"], \
            f"Expected '3: b' in output, got: {result['stdout']}"

    def test_scs_accept_longer_subject(self):
        """
        Test with longer subject to increase chance of OOB read detection.
        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)/",
            "abbbbbbbbb"
        )

        # Should not have ASAN errors or crash
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

        # Should produce a valid match
        assert "0:" in result["stdout"], \
            f"Expected match output, got: {result['stdout']}"

    def test_scs_accept_nested_groups(self):
        """
        Test with nested groups and ACCEPT inside SCS.
        Pattern: /((a)(b+))(*scs:(2)a(*ACCEPT))(\3)/
        Subject: abbbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/((a)(b+))(*scs:(2)a(*ACCEPT))(\\3)/",
            "abbbb"
        )

        # Should not have ASAN errors or crash
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

    def test_scs_accept_backreference_with_digits(self):
        """
        Test with backreference pattern that captures digits.
        Pattern: /(a)(d+)(*scs:(1)a(*ACCEPT))(\\2)/
        Subject: addddd

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(d+)(*scs:(1)a(*ACCEPT))(\\2)/",
            "addddd"
        )

        # Should not have ASAN errors or crash
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"


class TestSCSAcceptEdgeCases:
    """
    Test edge cases for SCS with ACCEPT vulnerability.
    All tests use patterns with backreferences after SCS+ACCEPT to trigger the bug.
    """

    def test_scs_accept_alternation(self):
        """
        Test SCS+ACCEPT with alternation and backreference.
        Pattern: /(a|b)(c+)(*scs:(1)a(*ACCEPT))(\\2)/
        Subject: acccc

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(c+)(*scs:(1)a(*ACCEPT))(\\2)/",
            "acccc"
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

    def test_scs_accept_with_quantified_backref(self):
        """
        Test SCS+ACCEPT with quantified backreference.
        Pattern: /(a)(bb)(*scs:(1)a(*ACCEPT))(\\2)+/
        Subject: abbbbbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(bb)(*scs:(1)a(*ACCEPT))(\\2)+/",
            "abbbbbb"
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

    def test_scs_accept_long_subject_short_capture(self):
        """
        Test with long subject but short capture - maximizes OOB read distance.
        Pattern: /(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)/
        Subject: abbbbbbbbbbbbbbbbbbbbbbbbbbbbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)/",
            "a" + "b" * 50
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"


class TestSCSAcceptWithVariousBackrefs:
    """
    Test various backreference scenarios after SCS+ACCEPT.
    The backreference is what triggers the OOB read in vulnerable version.
    All tests check for ASAN errors to detect the vulnerability.
    """

    def test_backref_with_plus_quantifier(self):
        """
        Test backreference with + quantifier after SCS block.
        Pattern: /(a)(b+)(*scs:(1)a(*ACCEPT))(\\2+)/
        Subject: abbbbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2+)/",
            "abbbbb"
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

    def test_backref_with_star_quantifier(self):
        """
        Test backreference with * quantifier after SCS block.
        Pattern: /(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)*/
        Subject: abbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)*/",
            "abbb"
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"

    def test_multiple_consecutive_backrefs(self):
        """
        Test multiple consecutive backreferences after SCS block.
        Pattern: /(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)(\\2)/
        Subject: abbbb

        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test(
            "/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)(\\2)/",
            "abbbb"
        )

        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"
        assert not has_crash_indicators(result["output"], result["returncode"]), \
            f"Crash detected: {result['output']}"
        assert not result["timed_out"], "Command timed out"


class TestSCSAcceptCorrectOutput:
    """
    Verify correct output values after fix.
    These tests ensure the fix actually works correctly,
    not just that it doesn't crash.

    All tests check for:
    1. ASAN errors (memory safety)
    2. Correct output values (functionality)
    """

    def test_correct_capture_groups(self):
        """
        Verify capture groups are correct after SCS+ACCEPT.
        In vulnerable version: Triggers ASAN heap-buffer-overflow.
        """
        result = run_pcre2test("/(a)(b+)(*scs:(1)a(*ACCEPT))(\\2)/", "abbb")

        # Check for ASAN errors first
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"

        # Parse output to verify captures
        output = result["stdout"]

        # Extract match and captures
        match_0 = re.search(r'0: (\S+)', output)
        match_1 = re.search(r'1: (\S+)', output)
        match_2 = re.search(r'2: (\S+)', output)
        match_3 = re.search(r'3: (\S+)', output)

        assert match_0 is not None, f"No full match found in: {output}"
        assert match_1 is not None, f"Capture 1 not found in: {output}"
        assert match_2 is not None, f"Capture 2 not found in: {output}"
        assert match_3 is not None, f"Capture 3 not found in: {output}"

        # Verify values
        assert match_0.group(1) == "abb", f"Full match should be 'abb', got '{match_0.group(1)}'"
        assert match_1.group(1) == "a", f"Capture 1 should be 'a', got '{match_1.group(1)}'"
        assert match_2.group(1) == "b", f"Capture 2 should be 'b', got '{match_2.group(1)}'"
        assert match_3.group(1) == "b", f"Capture 3 should be 'b', got '{match_3.group(1)}'"

    def test_correct_full_match_length(self):
        """
        Verify the full match has correct length.
        The bug causes incorrect match boundaries.

        In vulnerable version: Returns "No match" due to buffer corruption.
        """
        result = run_pcre2test("/(a)(*scs:(1)a(*ACCEPT))bbb/", "abbb")

        # Check for ASAN errors
        assert not has_asan_error(result["output"]), \
            f"ASAN error detected: {result['output']}"

        output = result["stdout"]
        match_0 = re.search(r'0: (\S+)', output)

        assert match_0 is not None, f"No full match found in: {output}"
        assert match_0.group(1) == "abbb", f"Full match should be 'abbb', got '{match_0.group(1)}'"
