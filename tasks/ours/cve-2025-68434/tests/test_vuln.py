"""
Vulnerability Tests for OpenSourcePOS CSRF Protection

These tests verify the CSRF vulnerability status:
- FAIL in vulnerable state (requests without token succeed)
- PASS in fixed state (requests without token are rejected)

The vulnerability allows cross-origin form submissions to be processed
when an admin is logged in, enabling unauthorized actions like creating
admin accounts.
"""

import pytest
import requests
import re
import time
import random

BASE_URL = "http://localhost"
ADMIN_USER = "admin"
ADMIN_PASS = "pointofsale"


class TestCSRFProtection:
    """Test that CSRF protection properly rejects unauthorized requests."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Wait for application to be ready."""
        max_retries = 30
        for i in range(max_retries):
            try:
                response = requests.get(f"{BASE_URL}/", timeout=5)
                if response.status_code in [200, 302]:
                    break
            except requests.exceptions.ConnectionError:
                pass
            time.sleep(2)
        else:
            pytest.fail("Application did not become ready in time")

    def get_authenticated_session(self):
        """Create an authenticated session (simulating victim's browser)."""
        session = requests.Session()

        # Get login page
        login_page = session.get(f"{BASE_URL}/index.php/login", allow_redirects=True)

        # Extract any CSRF token for login
        csrf_match = re.search(r'name="csrf_ospos_v4"\s+value="([^"]+)"', login_page.text)
        csrf_token = csrf_match.group(1) if csrf_match else None

        login_data = {
            "username": ADMIN_USER,
            "password": ADMIN_PASS
        }
        if csrf_token:
            login_data["csrf_ospos_v4"] = csrf_token

        session.post(
            f"{BASE_URL}/index.php/login",
            data=login_data,
            allow_redirects=True
        )

        return session

    def generate_employee_payload(self, unique_suffix):
        """Generate a complete employee creation payload without CSRF token."""
        # Note: DO NOT use "CSRF", "token", "security", "forbidden" etc. as field values
        # because they would trigger false-positive CSRF detection in is_csrf_rejected()
        return {
            "first_name": "Malicious",
            "last_name": "Attacker",
            "username": f"vulntest_{unique_suffix}",
            "email": f"vulntest_{unique_suffix}@evil.com",
            "password": "Password123!",
            "repeat_password": "Password123!",
            "gender": "1",
            "language": ":",
            "phone_number": "",
            "address_1": "",
            "address_2": "",
            "city": "",
            "state": "",
            "zip": "",
            "country": "",
            "comments": "Vulnerability_Test",
            # Admin permissions
            "grant_home": "home",
            "menu_group_home": "both",
            "grant_customers": "customers",
            "menu_group_customers": "both",
            "grant_items": "items",
            "menu_group_items": "both",
            "grant_suppliers": "suppliers",
            "menu_group_suppliers": "both",
            "grant_reports": "reports",
            "menu_group_reports": "both",
            "grant_sales": "sales",
            "menu_group_sales": "both",
            "grant_employees": "employees",
            "menu_group_employees": "both",
            "grant_config": "config",
            "menu_group_config": "home",
            "honeypot": ""
            # Deliberately NO csrf_ospos_v4 token
        }

    def is_csrf_rejected(self, response):
        """Check if the response indicates CSRF rejection."""
        # Check for various CSRF rejection indicators
        if response.status_code == 403:
            return True

        if response.status_code == 500:
            # Sometimes CSRF errors cause 500 errors
            return True

        response_text = response.text.lower()

        # Check for CSRF error messages
        csrf_indicators = [
            "csrf",
            "token",
            "forbidden",
            "security",
            "invalid request",
            "request could not be verified",
            "the action you have requested is not allowed"
        ]

        for indicator in csrf_indicators:
            if indicator in response_text:
                return True

        # Check if the response indicates success (vulnerability exists)
        # If we see success indicators, the CSRF protection is NOT working
        success_indicators = [
            '"success":true',
            '"success": true',
            'successfully',
            'employee_id',
            '"id":'
        ]

        for indicator in success_indicators:
            if indicator in response_text:
                return False

        # If status is 200 but no clear success, might still be protected
        # Check if it's a redirect back to login or error page
        if response.status_code == 200:
            if "login" in response.url.lower():
                return True

        return False

    def test_employee_creation_without_csrf_token_rejected(self):
        """
        Test that employee creation without CSRF token is rejected.

        This simulates a CSRF attack where:
        1. Admin is logged in (has valid session cookie)
        2. Attacker's page sends POST request using admin's session
        3. Request contains NO CSRF token

        EXPECTED: Request should be REJECTED (403 or error)
        VULNERABLE: Request succeeds, employee is created
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = self.generate_employee_payload(unique_id)

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Request without CSRF token should be rejected. Status: {response.status_code}, " \
            f"URL: {response.url}, Response: {response.text[:500]}"

    def test_employee_creation_with_empty_csrf_token_rejected(self):
        """
        Test that employee creation with empty CSRF token is rejected.
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = self.generate_employee_payload(unique_id)
        payload["csrf_ospos_v4"] = ""  # Empty token

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Request with empty CSRF token should be rejected. Status: {response.status_code}"

    def test_employee_creation_with_invalid_csrf_token_rejected(self):
        """
        Test that employee creation with invalid CSRF token is rejected.
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = self.generate_employee_payload(unique_id)
        payload["csrf_ospos_v4"] = "invalid_token_12345"  # Invalid token

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Request with invalid CSRF token should be rejected. Status: {response.status_code}"

    def test_employee_creation_with_random_csrf_token_rejected(self):
        """
        Test that employee creation with random/forged CSRF token is rejected.
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = self.generate_employee_payload(unique_id)
        # Generate a random token that looks legitimate
        import hashlib
        fake_token = hashlib.sha256(f"fake_{unique_id}".encode()).hexdigest()[:32]
        payload["csrf_ospos_v4"] = fake_token

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Request with forged CSRF token should be rejected. Status: {response.status_code}"

    def test_cross_origin_attack_simulation(self):
        """
        Simulate a complete cross-origin CSRF attack scenario.

        This simulates what happens when:
        1. Admin is logged into the POS system
        2. Admin visits attacker's malicious page
        3. Attacker's page auto-submits form to create admin account
        4. The browser sends admin's session cookie automatically

        The key difference from legitimate requests is NO CSRF token.
        """
        session = self.get_authenticated_session()

        # Verify we're authenticated
        home_response = session.get(f"{BASE_URL}/index.php/home", allow_redirects=True)
        assert home_response.status_code == 200, "Should be authenticated"

        # Now simulate the cross-origin attack
        unique_id = random.randint(10000, 99999)
        attack_payload = {
            "first_name": "Valid",
            "last_name": "User",
            "username": f"attacker_{unique_id}",
            "email": f"attacker_{unique_id}@evil.com",
            "password": "Password123!",
            "repeat_password": "Password123!",
            "gender": "1",
            "language": ":",
            "phone_number": "",
            "address_1": "",
            "address_2": "",
            "city": "",
            "state": "",
            "zip": "",
            "country": "",
            "comments": "CSRF_Attack_Simulated",
            # Full admin permissions (like a real attack would request)
            "grant_home": "home",
            "menu_group_home": "both",
            "grant_customers": "customers",
            "menu_group_customers": "both",
            "grant_items": "items",
            "menu_group_items": "both",
            "grant_suppliers": "suppliers",
            "menu_group_suppliers": "both",
            "grant_reports": "reports",
            "menu_group_reports": "both",
            "grant_sales": "sales",
            "menu_group_sales": "both",
            "grant_employees": "employees",
            "menu_group_employees": "both",
            "grant_config": "config",
            "menu_group_config": "home",
            "honeypot": ""
            # NO CSRF TOKEN - this is the attack
        }

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=attack_payload,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Cross-origin attack should be rejected. Status: {response.status_code}, " \
            f"The application should not create employees without valid CSRF token."

    def test_config_save_without_csrf_rejected(self):
        """
        Test that saving configuration without CSRF token is rejected.
        This tests the config/save endpoint using a proper POST request.
        """
        session = self.get_authenticated_session()

        # First get the config page to see the proper endpoint
        config_page = session.get(f"{BASE_URL}/index.php/config", allow_redirects=True)

        # Use a more complete config payload for the general config
        config_payload = {
            "company": "Hacked Company",
            "address": "123 Attacker St",
            "phone": "555-1234",
            "email": "hacked@evil.com",
            "website": "http://evil.com",
            "fax": "",
            "return_policy": "",
            "honeypot": ""
            # No CSRF token
        }

        # Try the config/save endpoint
        response = session.post(
            f"{BASE_URL}/index.php/config/save",
            data=config_payload,
            allow_redirects=True
        )

        # Should be rejected - not 404 (endpoint must exist and process)
        # If 404, the test is invalid (endpoint doesn't exist)
        if response.status_code == 404:
            pytest.skip("Config save endpoint not found at expected path")

        assert self.is_csrf_rejected(response), \
            f"Config save without CSRF should be rejected. Status: {response.status_code}"

    def test_multiple_rapid_attacks_all_rejected(self):
        """
        Test that multiple rapid CSRF attacks are all rejected.
        This ensures the protection doesn't have race conditions.
        """
        session = self.get_authenticated_session()

        results = []
        for i in range(5):
            unique_id = random.randint(10000, 99999)
            payload = self.generate_employee_payload(unique_id)

            response = session.post(
                f"{BASE_URL}/index.php/employees/save/-1",
                data=payload,
                allow_redirects=True
            )
            results.append(self.is_csrf_rejected(response))
            time.sleep(0.2)

        assert all(results), \
            f"All rapid CSRF attacks should be rejected. Results: {results}"

    def test_csrf_token_header_without_body_rejected(self):
        """
        Test that sending CSRF in header without form token is rejected.
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = self.generate_employee_payload(unique_id)

        # Send with a header but no form token
        headers = {
            "X-CSRF-TOKEN": "some_fake_token"
        }

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            headers=headers,
            allow_redirects=True
        )

        assert self.is_csrf_rejected(response), \
            f"Request with only header token should be rejected. Status: {response.status_code}"


class TestAttackVectors:
    """Test various CSRF attack vectors."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Wait for application to be ready."""
        max_retries = 30
        for i in range(max_retries):
            try:
                response = requests.get(f"{BASE_URL}/", timeout=5)
                if response.status_code in [200, 302]:
                    break
            except requests.exceptions.ConnectionError:
                pass
            time.sleep(2)

    def get_authenticated_session(self):
        """Get authenticated session."""
        session = requests.Session()
        login_page = session.get(f"{BASE_URL}/index.php/login", allow_redirects=True)
        csrf_match = re.search(r'name="csrf_ospos_v4"\s+value="([^"]+)"', login_page.text)
        csrf_token = csrf_match.group(1) if csrf_match else None

        login_data = {"username": ADMIN_USER, "password": ADMIN_PASS}
        if csrf_token:
            login_data["csrf_ospos_v4"] = csrf_token

        session.post(f"{BASE_URL}/index.php/login", data=login_data, allow_redirects=True)
        return session

    def is_protected(self, response):
        """Check if response indicates CSRF protection is active."""
        if response.status_code in [403, 500]:
            return True
        text = response.text.lower()

        # If attack succeeded (employee created), protection is NOT active
        if '"success":true' in text or '"success": true' in text:
            return False

        # Check for explicit CSRF rejection messages (not user-submitted content)
        # Note: "csrf" check is risky if user content echoes back, but we control payloads now
        if 'the action you have requested is not allowed' in text:
            return True
        if 'request could not be verified' in text:
            return True

        # If we get validation errors (success:false), the request was processed
        # but data was invalid - this means NO CSRF protection blocked it
        if '"success":false' in text or '"success": false' in text:
            return False

        # CodeIgniter CSRF filter with redirect=true redirects back to previous page
        # If the final URL is /home (not the target endpoint), CSRF protection worked
        final_url = response.url.lower()
        if final_url.endswith('/home') or '/home?' in final_url:
            return True

        # If redirected away from the save endpoint, CSRF protection likely worked
        if 'save' not in final_url and response.status_code == 200:
            # Check if it's a dashboard/home page (HTML response, not JSON)
            if '<html' in text and '"success"' not in text:
                return True

        return False  # Default: assume not protected

    def test_json_content_type_attack(self):
        """
        Test CSRF attack using a form submission that mimics JSON attack scenario.

        In real CSRF attacks, JSON content type is often used but browsers
        won't send pure JSON in cross-origin requests. This test uses
        form data to simulate an attacker who tries various content types.
        """
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)

        # Use form-urlencoded but with different Accept header to simulate
        # an attacker trying to bypass protections
        payload = {
            "first_name": "JsonMimicTest",
            "last_name": "User",
            "username": f"jsonmimic_{unique_id}",
            "email": f"jsonmimic_{unique_id}@evil.com",
            "password": "Password123!",
            "repeat_password": "Password123!",
            "gender": "1",
            "language": ":",
            "phone_number": "",
            "address_1": "",
            "address_2": "",
            "city": "",
            "state": "",
            "zip": "",
            "country": "",
            "comments": "Json_Mimic_Test",
            "grant_home": "home",
            "menu_group_home": "both",
            "grant_customers": "customers",
            "menu_group_customers": "both",
            "grant_items": "items",
            "menu_group_items": "both",
            "grant_suppliers": "suppliers",
            "menu_group_suppliers": "both",
            "grant_reports": "reports",
            "menu_group_reports": "both",
            "grant_sales": "sales",
            "menu_group_sales": "both",
            "grant_employees": "employees",
            "menu_group_employees": "both",
            "grant_config": "config",
            "menu_group_config": "home",
            "honeypot": ""
        }

        headers = {
            "Accept": "application/json",
            "X-Requested-With": "fetch"  # Simulate fetch API call
        }

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            headers=headers,
            allow_redirects=True
        )

        # Should be rejected - attack without CSRF token
        assert self.is_protected(response), \
            f"JSON-style CSRF attack should be rejected. Status: {response.status_code}, Response: {response.text[:200]}"

    def test_multipart_form_attack(self):
        """Test CSRF attack with multipart form data."""
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)

        files = {
            'first_name': (None, 'MultiTest'),
            'last_name': (None, 'User'),
            'username': (None, f'multipart_{unique_id}'),
            'email': (None, f'multipart_{unique_id}@evil.com'),
            'password': (None, 'Password123!'),
            'repeat_password': (None, 'Password123!'),
            'gender': (None, '1'),
            'language': (None, ':'),
            'phone_number': (None, ''),
            'address_1': (None, ''),
            'address_2': (None, ''),
            'city': (None, ''),
            'state': (None, ''),
            'zip': (None, ''),
            'country': (None, ''),
            'comments': (None, 'Multipart_Test'),
            'grant_home': (None, 'home'),
            'menu_group_home': (None, 'both'),
            'grant_customers': (None, 'customers'),
            'menu_group_customers': (None, 'both'),
            'grant_items': (None, 'items'),
            'menu_group_items': (None, 'both'),
            'grant_suppliers': (None, 'suppliers'),
            'menu_group_suppliers': (None, 'both'),
            'grant_reports': (None, 'reports'),
            'menu_group_reports': (None, 'both'),
            'grant_sales': (None, 'sales'),
            'menu_group_sales': (None, 'both'),
            'grant_employees': (None, 'employees'),
            'menu_group_employees': (None, 'both'),
            'grant_config': (None, 'config'),
            'menu_group_config': (None, 'home'),
            'honeypot': (None, '')
        }

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            files=files,
            allow_redirects=True
        )

        assert self.is_protected(response), \
            f"Multipart CSRF attack should be rejected. Status: {response.status_code}"

    def test_xhr_attack_without_token(self):
        """Test XHR-style CSRF attack without token."""
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)
        payload = {
            "first_name": "XhrTest",
            "last_name": "User",
            "username": f"xhrtest_{unique_id}",
            "email": f"xhrtest_{unique_id}@evil.com",
            "password": "Password123!",
            "repeat_password": "Password123!",
            "gender": "1",
            "language": ":",
            "phone_number": "",
            "address_1": "",
            "address_2": "",
            "city": "",
            "state": "",
            "zip": "",
            "country": "",
            "comments": "XHR_Test",
            "grant_home": "home",
            "menu_group_home": "both",
            "grant_customers": "customers",
            "menu_group_customers": "both",
            "grant_items": "items",
            "menu_group_items": "both",
            "grant_suppliers": "suppliers",
            "menu_group_suppliers": "both",
            "grant_reports": "reports",
            "menu_group_reports": "both",
            "grant_sales": "sales",
            "menu_group_sales": "both",
            "grant_employees": "employees",
            "menu_group_employees": "both",
            "grant_config": "config",
            "menu_group_config": "home",
            "honeypot": ""
        }

        headers = {
            "X-Requested-With": "XMLHttpRequest",
            "Content-Type": "application/x-www-form-urlencoded"
        }

        response = session.post(
            f"{BASE_URL}/index.php/employees/save/-1",
            data=payload,
            headers=headers,
            allow_redirects=True
        )

        assert self.is_protected(response), \
            f"XHR CSRF attack should be rejected. Status: {response.status_code}"

    def test_different_sensitive_endpoints_protected(self):
        """Test that various sensitive endpoints are CSRF protected."""
        session = self.get_authenticated_session()

        unique_id = random.randint(10000, 99999)

        # Complete employee payload
        employee_payload = {
            "first_name": "EndpointTest",
            "last_name": "User",
            "username": f"endpointtest_{unique_id}",
            "email": f"endpointtest_{unique_id}@evil.com",
            "password": "Password123!",
            "repeat_password": "Password123!",
            "gender": "1",
            "language": ":",
            "phone_number": "",
            "address_1": "",
            "address_2": "",
            "city": "",
            "state": "",
            "zip": "",
            "country": "",
            "comments": "Endpoint_Test",
            "grant_home": "home",
            "menu_group_home": "both",
            "honeypot": ""
        }

        endpoints = [
            ("/index.php/employees/save/-1", employee_payload),
            ("/index.php/customers/save/-1", {
                "first_name": "CustTest",
                "last_name": "User",
                "email": f"custtest_{unique_id}@evil.com",
                "company_name": "",
                "account_number": "",
                "comments": ""
            }),
            ("/index.php/items/save/-1", {
                "name": f"Item_{unique_id}",
                "cost_price": "10",
                "unit_price": "20",
                "quantity": "0",
                "item_number": "",
                "category": "",
                "description": ""
            }),
        ]

        for endpoint, payload in endpoints:
            response = session.post(
                f"{BASE_URL}{endpoint}",
                data=payload,
                allow_redirects=True
            )

            # All should be protected (rejected without token) or return 404 if endpoint doesn't exist
            is_protected = self.is_protected(response) or response.status_code == 404
            assert is_protected, \
                f"Endpoint {endpoint} should be CSRF protected. Status: {response.status_code}"
