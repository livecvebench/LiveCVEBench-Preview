"""
Vulnerability tests for expr-eval prototype pollution.
These tests verify that the vulnerability is properly mitigated.
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is blocked)
"""

import subprocess
import pytest


def run_node_isolated(code):
    """
    Execute Node.js code in an isolated process.
    Each test runs in a fresh Node.js process to avoid prototype pollution
    affecting subsequent tests.
    """
    full_code = f"""
const {{ Parser }} = require('expr-eval');
{code}
"""
    result = subprocess.run(
        ['node', '-e', full_code],
        cwd='/app',
        capture_output=True,
        text=True,
        timeout=30
    )
    return result.stdout.strip(), result.stderr.strip(), result.returncode


class TestPrototypePollutionBlocked:
    """Test that prototype pollution attacks are blocked."""

    def test_constructor_access_blocked(self):
        """Verify that direct constructor access is blocked."""
        code = """
try {
    Parser.evaluate('x = constructor');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor access should be blocked. Got: {stdout}"

    def test_proto_access_blocked(self):
        """Verify that __proto__ access is blocked."""
        code = """
try {
    Parser.evaluate('x = __proto__');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"__proto__ access should be blocked. Got: {stdout}"

    def test_prototype_access_blocked(self):
        """Verify that prototype access is blocked."""
        code = """
try {
    Parser.evaluate('x = constructor');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype access detected')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor access should be blocked. Got: {stdout}"


class TestBasicPrototypePollution:
    """Test basic prototype pollution attack vectors."""

    def test_basic_prototype_pollution_blocked(self):
        """
        Verify basic prototype pollution via Object.assign is blocked.
        This is the primary attack vector.
        """
        code = """
const testObj = {};

try {
    // Use valid expr-eval syntax for prototype pollution
    Parser.evaluate('Object=constructor; a=Object.fromEntries([["polluted","yes"]]); Object.assign(__proto__, a)');

    if (testObj.polluted === 'yes') {
        console.log('RESULT:VULNERABLE');
    } else {
        console.log('RESULT:SECURE');
    }
} catch (e) {
    console.log('RESULT:SECURE');
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert "RESULT:SECURE" in stdout, f"Basic prototype pollution should be blocked. Got: {stdout}"

    def test_pollution_via_fromEntries(self):
        """Verify prototype pollution via Object.fromEntries is blocked."""
        code = """
const testObj = {};

try {
    Parser.evaluate('Object=constructor; a=Object.fromEntries([["pwned","yes"]]); Object.assign(__proto__, a)');

    if (testObj.pwned === 'yes') {
        console.log('VULNERABLE');
    } else {
        console.log('SECURE');
    }
} catch (e) {
    console.log('SECURE');
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"fromEntries-based pollution should be blocked. Got: {stdout}"

    def test_pollution_affects_new_objects(self):
        """Verify that prototype pollution affecting new objects is blocked."""
        code = """
try {
    // Use valid expr-eval syntax for prototype pollution
    Parser.evaluate('Object=constructor; a=Object.fromEntries([["injected","yes"]]); Object.assign(__proto__, a)');
} catch (e) {
    // Expected in secure environment
}

// Check if a newly created object has the injected property
const newObj = {};
if (newObj.injected === "yes") {
    console.log('VULNERABLE');
} else {
    console.log('SECURE');
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Pollution should not affect new objects. Got: {stdout}"


class TestAdvancedAttackVectors:
    """Test advanced and alternative attack vectors."""

    def test_constructor_chain_access(self):
        """Verify constructor chain attacks are blocked."""
        code = """
try {
    // Try to access constructor chain
    const result = Parser.evaluate('x = constructor; x.name');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor chain access should be blocked. Got: {stdout}"

    def test_assign_to_constructor(self):
        """Verify reading constructor variable is blocked."""
        code = """
try {
    // Reading constructor value (used in prototype pollution attacks)
    const result = Parser.evaluate('x = constructor; x');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype access detected')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Reading constructor should be blocked. Got: {stdout}"

    def test_getOwnPropertyDescriptor_attack(self):
        """Verify attacks using getOwnPropertyDescriptor are blocked."""
        code = """
try {
    Parser.evaluate('o = constructor; o.getOwnPropertyDescriptor(o.getPrototypeOf(toString), "constructor")');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"getOwnPropertyDescriptor attack should be blocked. Got: {stdout}"

    def test_prototype_in_nested_expression(self):
        """Verify that prototype access in nested expressions is blocked."""
        code = """
try {
    Parser.evaluate('a = 1 + (b = constructor)');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Nested constructor access should be blocked. Got: {stdout}"

    def test_prototype_via_member_expression(self):
        """Verify that __proto__ access is blocked in member expressions."""
        code = """
try {
    // Test basic function definition works
    Parser.evaluate('f(x) = x + 1; f(5)');

    // Now test if __proto__ is accessible (vulnerability check)
    Parser.evaluate('__proto__');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype access detected')) {
        console.log('SECURE');
    } else {
        console.log('SECURE');
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"__proto__ access should be blocked in member expressions. Got: {stdout}"


class TestRCEPrevention:
    """Test that Remote Code Execution attack vectors are blocked."""

    def test_rce_payload_blocked(self):
        """
        Verify that the classic RCE payload is blocked.
        This payload would execute arbitrary commands on vulnerable systems.
        """
        code = """
try {
    const payload = 'o = constructor; o.assign(__proto__, o.getOwnPropertyDescriptor(o.getPrototypeOf(toString), "constructor")); f = value("return 1"); f()';
    const result = Parser.evaluate(payload);
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype')) {
        console.log('SECURE');
    } else {
        // Any error is good as long as RCE didn't happen
        console.log('SECURE');
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"RCE payload should be blocked. Got: {stdout}"

    def test_function_constructor_access_blocked(self):
        """Verify that access to Function constructor via prototype chain is blocked."""
        code = """
try {
    // The dangerous part is accessing 'constructor' variable
    const result = Parser.evaluate('f = constructor');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype access detected')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Function constructor access should be blocked. Got: {stdout}"


class TestMultiplePayloadVariants:
    """Test various payload variants and bypass attempts."""

    def test_uppercase_constructor(self):
        """Test that lowercase constructor is still blocked even when uppercase fails."""
        code = """
try {
    // Test that CONSTRUCTOR (uppercase) fails as expected
    Parser.evaluate('x = CONSTRUCTOR');
    // If we get here, it means CONSTRUCTOR was defined somehow (shouldn't happen)
    console.log('UNEXPECTED');
} catch (e) {
    // Expected - CONSTRUCTOR is undefined
    // Now test if lowercase constructor is still accessible (vulnerability check)
    try {
        Parser.evaluate('constructor');
        console.log('VULNERABLE');
    } catch (e2) {
        if (e2.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Lowercase constructor should be blocked. Got: {stdout}"

    def test_mixed_case_proto(self):
        """Test that lowercase __proto__ is still blocked even when mixed case fails."""
        code = """
try {
    // Test that __Proto__ (mixed case) fails as expected
    Parser.evaluate('x = __Proto__');
    // If we get here, it means __Proto__ was defined somehow (shouldn't happen)
    console.log('UNEXPECTED');
} catch (e) {
    // Expected - __Proto__ is undefined
    // Now test if lowercase __proto__ is still accessible (vulnerability check)
    try {
        Parser.evaluate('__proto__');
        console.log('VULNERABLE');
    } catch (e2) {
        if (e2.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Lowercase __proto__ should be blocked. Got: {stdout}"

    def test_pollution_multiple_properties(self):
        """Test pollution with multiple properties is blocked."""
        code = """
const testObj = {};

try {
    // Use valid expr-eval syntax
    Parser.evaluate('Object=constructor; a=Object.fromEntries([["prop1","val1"],["prop2","val2"]]); Object.assign(__proto__, a)');

    if (testObj.prop1 === "val1" || testObj.prop2 === "val2") {
        console.log('VULNERABLE');
    } else {
        console.log('SECURE');
    }
} catch (e) {
    console.log('SECURE');
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Multi-property pollution should be blocked. Got: {stdout}"

    def test_pollution_with_semicolon_separation(self):
        """Test payload with semicolon-separated statements."""
        code = """
try {
    // Test accessing constructor and __proto__ (both should work in vulnerable env)
    Parser.evaluate('a = constructor; b = __proto__');
    console.log('VULNERABLE');
} catch (e) {
    if (e.message.includes('prototype access detected')) {
        console.log('SECURE');
    } else {
        console.log('ERROR:' + e.message);
    }
}
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor and __proto__ access should be blocked. Got: {stdout}"


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    def test_legitimate_variable_named_const(self):
        """Verify that constructor access is blocked even in normal variable contexts."""
        code = """
(function() {
    try {
        // First test normal operation works
        const result = Parser.evaluate('x * 2', {x: 5});
        if (result !== 10) {
            console.log('FAIL');
            return;
        }

        // Now test if constructor is accessible (vulnerability check)
        Parser.evaluate('constructor');
        console.log('VULNERABLE');
    } catch (e) {
        if (e.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
})();
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor should be blocked even in normal contexts. Got: {stdout}"

    def test_variable_containing_constructor(self):
        """Verify that exact constructor access is blocked even when similar variables exist."""
        code = """
(function() {
    try {
        // Test that similar variable names work
        const result = Parser.evaluate('myconstructor * 2', {myconstructor: 5});
        if (result !== 10) {
            console.log('FAIL');
            return;
        }

        // Now test if exact constructor is still accessible (vulnerability check)
        Parser.evaluate('constructor');
        console.log('VULNERABLE');
    } catch (e) {
        if (e.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
})();
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor should be blocked even when similar variables exist. Got: {stdout}"

    def test_variable_containing_proto(self):
        """Verify that exact __proto__ access is blocked even when similar variables exist."""
        code = """
(function() {
    try {
        // Test that normal variables work
        const result = Parser.evaluate('x + y', {x: 3, y: 7});
        if (result !== 10) {
            console.log('FAIL');
            return;
        }

        // Now test if __proto__ is still accessible (vulnerability check)
        Parser.evaluate('__proto__');
        console.log('VULNERABLE');
    } catch (e) {
        if (e.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
})();
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"__proto__ should be blocked. Got: {stdout}"

    def test_expression_after_blocked_attempt(self):
        """Verify that constructor access is blocked consistently."""
        code = """
(function() {
    try {
        // Test that basic expressions work
        const result = Parser.evaluate('2 + 3');
        if (result !== 5) {
            console.log('FAIL');
            return;
        }

        // Now test if constructor is still accessible (vulnerability check)
        Parser.evaluate('constructor');
        console.log('VULNERABLE');
    } catch (e) {
        if (e.message.includes('prototype access detected')) {
            console.log('SECURE');
        } else {
            console.log('SECURE');
        }
    }
})();
"""
        stdout, stderr, _ = run_node_isolated(code)
        assert stdout == "SECURE", f"Constructor should be consistently blocked. Got: {stdout}"
