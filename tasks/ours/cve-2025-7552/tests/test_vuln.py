"""
Vulnerability tests for Northstar authentication bypass (CVE-2025-7552).

These tests verify the URL encoding bypass vulnerability:
- FAIL on VULNERABLE version (bypass works, authentication is bypassed)
- PASS on FIXED version (bypass is blocked, authentication is enforced)

The vulnerability exists because the AuthorizationInterceptor uses getRequestURI()
which returns URL-encoded paths. By encoding characters in the path, attackers can
bypass the path prefix check and access protected endpoints without authentication.

IMPORTANT: We use http.client instead of requests library because requests normalizes
URLs and decodes percent-encoded characters before sending, which would prevent
testing the actual vulnerability.
"""

import pytest
import http.client

HOST = "localhost"
PORT = 80
TIMEOUT = 10


def make_raw_request(path, method="GET"):
    """
    Make an HTTP request with raw path (no URL normalization).
    This preserves percent-encoded characters in the path.
    """
    conn = http.client.HTTPConnection(HOST, PORT, timeout=TIMEOUT)
    try:
        conn.request(method, path)
        response = conn.getresponse()
        status = response.status
        body = response.read().decode('utf-8', errors='ignore')
        return status, body
    finally:
        conn.close()


class TestAuthBypassBlocked:
    """
    Test that URL encoding bypass attempts are properly blocked.
    These tests should PASS when the vulnerability is FIXED.
    On VULNERABLE version, these tests should FAIL because bypass works.
    """

    def test_encoded_n_lowercase_hex(self):
        """
        Test bypass with 'n' encoded as %6E (lowercase hex).
        /%6Eorthstar/log should be blocked (returns 401) on fixed version.
        On vulnerable version, bypass works and returns non-401 (FAIL).
        """
        # First verify normal endpoint requires auth
        normal_status, _ = make_raw_request("/northstar/log")
        assert normal_status == 401, \
            f"Normal endpoint should require auth, got {normal_status}"

        # Test bypass attempt - should be blocked (401) on fixed version
        # On vulnerable version, this will NOT be 401, causing test to FAIL
        bypass_status, body = make_raw_request("/%6Eorthstar/log")
        assert bypass_status == 401, \
            f"Bypass attempt with %6E should be blocked, got {bypass_status}. Body: {body[:200]}"

    def test_encoded_n_lowercase_variant(self):
        """
        Test bypass with 'n' encoded as %6e (lowercase variant).
        /%6eorthstar/log should be blocked (returns 401).
        """
        bypass_status, body = make_raw_request("/%6eorthstar/log")
        assert bypass_status == 401, \
            f"Bypass attempt with %6e should be blocked, got {bypass_status}. Body: {body[:200]}"

    def test_encoded_o_in_northstar(self):
        """
        Test bypass with 'o' encoded as %6F.
        /n%6Frthstar/log should be blocked (returns 401).
        """
        bypass_status, body = make_raw_request("/n%6Frthstar/log")
        assert bypass_status == 401, \
            f"Bypass attempt with %6F should be blocked, got {bypass_status}. Body: {body[:200]}"

    def test_multiple_encoded_chars(self):
        """
        Test bypass with multiple encoded characters.
        /%6E%6Frthstar/log should be blocked (returns 401).
        """
        bypass_status, body = make_raw_request("/%6E%6Frthstar/log")
        assert bypass_status == 401, \
            f"Bypass attempt with multiple encoded chars should be blocked, got {bypass_status}. Body: {body[:200]}"


class TestMultipleEndpointsProtected:
    """Test that bypass is blocked across different protected endpoints."""

    @pytest.mark.parametrize("endpoint,encoded_path", [
        ("/log", "/%6Eorthstar/log"),
        ("/gateway", "/%6Eorthstar/gateway"),
        ("/module", "/%6Eorthstar/module"),
    ])
    def test_bypass_blocked_on_various_endpoints(self, endpoint, encoded_path):
        """
        Verify bypass is blocked on multiple protected endpoints.
        On vulnerable version, bypass works (non-401), causing FAIL.
        """
        # Normal request should require auth
        normal_status, _ = make_raw_request(f"/northstar{endpoint}")
        assert normal_status == 401, \
            f"Normal endpoint /northstar{endpoint} should require auth"

        # Bypass attempt should also require auth (be blocked) on fixed version
        bypass_status, body = make_raw_request(encoded_path)
        assert bypass_status == 401, \
            f"Bypass on {encoded_path} should be blocked, got {bypass_status}. Body: {body[:200]}"


class TestEncodingVariations:
    """Test various encoding variations are all blocked."""

    @pytest.mark.parametrize("encoded_path,description", [
        ("/%6Eorthstar/log", "lowercase hex %6E for 'n'"),
        ("/%6eorthstar/log", "lowercase hex %6e for 'n'"),
        ("/n%6Frthstar/log", "encoded 'o' as %6F"),
        ("/no%72thstar/log", "encoded 'r' as %72"),
        ("/nor%74hstar/log", "encoded 't' as %74"),
        ("/nort%68star/log", "encoded 'h' as %68"),
        ("/north%73tar/log", "encoded 's' as %73"),
        ("/norths%74ar/log", "encoded 't' as %74"),
        ("/northst%61r/log", "encoded 'a' as %61"),
        ("/northsta%72/log", "encoded 'r' as %72"),
    ])
    def test_single_char_encoding_blocked(self, encoded_path, description):
        """
        Test that single character encoding bypass attempts are blocked.
        On vulnerable version, these bypasses work, causing FAIL.
        """
        bypass_status, body = make_raw_request(encoded_path)
        assert bypass_status == 401, \
            f"Bypass with {description} ({encoded_path}) should be blocked, got {bypass_status}. Body: {body[:200]}"
