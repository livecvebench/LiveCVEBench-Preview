#!/usr/bin/env python3
"""
Functional tests for the file upload attachment API.
These tests verify that the application works correctly for legitimate use cases.
Should PASS in both vulnerable and fixed states.
"""

import os
import io
import uuid
import pytest
import requests
import time

BASE_URL = os.environ.get("BASE_URL", "http://localhost:3000")
API_TIMEOUT = 30


def wait_for_service(max_retries=30, delay=2):
    """Wait for the service to be ready."""
    for i in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/api/v1/ping", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


class TestApplicationHealth:
    """Test that the application is running and responsive."""

    def test_service_is_running(self):
        """Test that the service responds to health check."""
        assert wait_for_service(), "Service did not start within timeout"
        response = requests.get(f"{BASE_URL}/api/v1/ping", timeout=API_TIMEOUT)
        assert response.status_code == 200

    def test_api_root_accessible(self):
        """Test that the main API is accessible."""
        response = requests.get(f"{BASE_URL}/", timeout=API_TIMEOUT)
        # Either 200 or redirect is acceptable
        assert response.status_code in [200, 301, 302, 304]


class TestAttachmentsEndpoint:
    """Test the attachments endpoint for legitimate functionality."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_endpoint_exists(self):
        """Test that the attachments endpoint exists and accepts POST requests."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        # Even without a valid file, the endpoint should respond
        # The endpoint returns:
        # - 404 with "chatflow ... not found" (endpoint exists, chatflow doesn't) - ACCEPTABLE
        # - 400 for validation errors - ACCEPTABLE
        # - 500 for server errors - ACCEPTABLE
        # - Route-level 404 would not contain our error message format - UNACCEPTABLE
        response = requests.post(endpoint, timeout=API_TIMEOUT)

        # The endpoint exists if we get a JSON error response (not HTML 404 from router)
        if response.status_code == 404:
            # If 404, it should be our application's 404 (chatflow not found)
            # not a route-not-found error
            assert "chatflow" in response.text.lower() or "statuscode" in response.text.lower(), \
                f"Expected application-level 404, got route-level 404: {response.text}"
        else:
            # Any other status code is acceptable (endpoint exists)
            assert response.status_code in [200, 400, 404, 500]

    def test_upload_text_file(self):
        """Test uploading a legitimate text file."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        test_content = b"This is a test text file for upload testing."
        files = {
            "files": ("test.txt", io.BytesIO(test_content), "text/plain")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)
        # In the vulnerable version, this should succeed (200)
        # In the fixed version, it might fail with 404 (chatflow not found)
        # Both behaviors are acceptable for functional tests
        assert response.status_code in [200, 400, 404, 500]

    def test_upload_pdf_file(self):
        """Test uploading a PDF document."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        # Minimal PDF content
        pdf_content = b"%PDF-1.4\n1 0 obj\n<< /Type /Catalog >>\nendobj\n%%EOF"
        files = {
            "files": ("document.pdf", io.BytesIO(pdf_content), "application/pdf")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)
        assert response.status_code in [200, 400, 404, 500]

    def test_upload_image_file(self):
        """Test uploading an image file."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        # Minimal PNG (1x1 transparent pixel)
        png_content = bytes([
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,  # PNG signature
            0x00, 0x00, 0x00, 0x0D,  # IHDR chunk length
            0x49, 0x48, 0x44, 0x52,  # IHDR
            0x00, 0x00, 0x00, 0x01,  # Width: 1
            0x00, 0x00, 0x00, 0x01,  # Height: 1
            0x08, 0x06,              # Bit depth: 8, Color type: RGBA
            0x00, 0x00, 0x00,        # Compression, filter, interlace
            0x1F, 0x15, 0xC4, 0x89,  # CRC
            0x00, 0x00, 0x00, 0x00,  # IEND length
            0x49, 0x45, 0x4E, 0x44,  # IEND
            0xAE, 0x42, 0x60, 0x82   # CRC
        ])
        files = {
            "files": ("test.png", io.BytesIO(png_content), "image/png")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)
        assert response.status_code in [200, 400, 404, 500]

    def test_upload_json_file(self):
        """Test uploading a JSON configuration file."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        json_content = b'{"config": {"key": "value"}, "settings": []}'
        files = {
            "files": ("config.json", io.BytesIO(json_content), "application/json")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)
        assert response.status_code in [200, 400, 404, 500]

    def test_multiple_file_upload(self):
        """Test uploading multiple files at once."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        files = [
            ("files", ("file1.txt", io.BytesIO(b"Content 1"), "text/plain")),
            ("files", ("file2.txt", io.BytesIO(b"Content 2"), "text/plain")),
        ]

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)
        assert response.status_code in [200, 400, 404, 500]

    def test_response_format(self):
        """Test that successful uploads return proper JSON response."""
        chatflow_id = str(uuid.uuid4())
        chat_id = str(uuid.uuid4())
        endpoint = f"{BASE_URL}/api/v1/attachments/{chatflow_id}/{chat_id}"

        files = {
            "files": ("test.txt", io.BytesIO(b"test content"), "text/plain")
        }

        response = requests.post(endpoint, files=files, timeout=API_TIMEOUT)

        if response.status_code == 200:
            # If upload succeeds, response should be valid JSON
            try:
                data = response.json()
                # Response should be a list or contain attachment info
                assert data is not None
            except Exception:
                # JSON parsing failed, but this is still acceptable
                pass


class TestAPIVersioning:
    """Test API versioning and routing."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is ready before each test."""
        assert wait_for_service(), "Service is not available"

    def test_v1_api_routing(self):
        """Test that v1 API routing works correctly."""
        response = requests.get(f"{BASE_URL}/api/v1/ping", timeout=API_TIMEOUT)
        assert response.status_code == 200

    def test_invalid_api_version_handling(self):
        """Test that invalid API versions are handled gracefully."""
        response = requests.get(f"{BASE_URL}/api/v999/ping", timeout=API_TIMEOUT)
        # Flowise routes may fallback to UI handler or return 200 for unknown routes
        # The key is that it responds without crashing
        assert response.status_code in [200, 404, 400]


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
