#!/bin/bash
# Solution script for fixing the getScale function vulnerability
# This script modifies the scales.js and scale-gradient.js files to reject function arguments

set -e
cd /app

SCALES_FILE="packages/vega-functions/src/scales.js"
SCALE_GRADIENT_FILE="packages/vega-functions/src/functions/scale-gradient.js"

echo "=== Applying fix to getScale function ==="

# Fix 1: Patch scales.js
# The fix removes the isFunction check and import, making getScale only accept strings

cat > "$SCALES_FILE" << 'EOF'
import {ScalePrefix} from './constants';
import {scaleVisitor} from './visitors';
import {Literal} from 'vega-expression';
import {isString, stringValue} from 'vega-util';
import {isRegisteredScale} from 'vega-scale';

/**
 * Name must be a string. Return undefined if the scale is not registered.
 */
export function getScale(name, ctx) {

  if (isString(name)) {
    const maybeScale = ctx.scales[name];
    return (maybeScale && isRegisteredScale(maybeScale.value)) ? maybeScale.value : undefined;
  }

  return undefined;
}

export function internalScaleFunctions(codegen, fnctx, visitors) {
  // add helper method to the 'this' expression function context
  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0;

  // register AST visitors for internal scale functions
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;

  // resolve scale reference directly to the signal hash argument
  const ref = arg => '_[' + (
    arg.type === Literal
    ? stringValue(ScalePrefix + arg.value)
    : stringValue(ScalePrefix) + '+' + codegen(arg)
  ) + ']';

  // define and return internal scale function code generators
  // these internal functions are called by mark encoders
  return {
    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,
    _range: args => `${ref(args[0])}.range()`,
    _scale: args => `${ref(args[0])}(${codegen(args[1])})`
  };
}
EOF

echo "Fixed: $SCALES_FILE"

# Fix 2: Patch scale-gradient.js
# Move function handling to scale-gradient.js for internal testing only

cat > "$SCALE_GRADIENT_FILE" << 'EOF'
import {getScale} from '../scales';
import {scale as get, scaleFraction} from 'vega-scale';
import {Gradient} from 'vega-scenegraph';
import {identity, peek} from 'vega-util';

/**
 * Passing a function is only used for for testing.
 * Outside of tests, the first argument should be a string.
 */
export default function(scaleOrFunction, p0, p1, count, group) {

  let scale = typeof scaleOrFunction === 'string' ? getScale(scaleOrFunction, (group || this).context) : scaleOrFunction;

  const gradient = Gradient(p0, p1);

  let stops = scale.domain(),
      min = stops[0],
      max = peek(stops),
      fraction = identity;

  if (!(max - min)) {
    // expand scale if domain has zero span, fix #1479
    scale = (scale.interpolator
      ? get('sequential')().interpolator(scale.interpolator())
      : get('linear')().interpolate(scale.interpolate()).range(scale.range())
    ).domain([min=0, max=1]);
  } else {
    fraction = scaleFraction(scale, min, max);
  }

  if (scale.ticks) {
    stops = scale.ticks(+count || 15);
    if (min !== stops[0]) stops.unshift(min);
    if (max !== peek(stops)) stops.push(max);
  }

  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));

  return gradient;
}
EOF

echo "Fixed: $SCALE_GRADIENT_FILE"

# Rebuild the package to apply changes
echo "=== Rebuilding vega-functions package ==="
cd /app

# Use yarn to rebuild the specific package
yarn workspace vega-functions build

echo "=== Fix applied successfully ==="
