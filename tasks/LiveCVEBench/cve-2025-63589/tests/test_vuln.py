"""
Vulnerability tests for CMSimple_XH reflected XSS vulnerability.

These tests verify that the XSS vulnerability EXISTS in the vulnerable version:
- FAIL in vulnerable state (XSS payload reflected unencoded - this is what we want)
- PASS in fixed state (XSS payload properly HTML-encoded)

The vulnerability exists because user-controlled URL path segments are
reflected into HTML attributes without proper encoding.

IMPORTANT: These tests send raw (non-URL-encoded) payloads because the
vulnerability requires raw angle brackets and quotes in the URL path.
When URL-encoded, PHP keeps them encoded and the XSS doesn't trigger.
"""

import pytest
import requests
import time
import re
import socket

# Application runs on port 8080 in Docker
BASE_URL = "http://localhost:8080"

# Timeout for requests
REQUEST_TIMEOUT = 10


def wait_for_server(max_retries=30, delay=1):
    """Wait for the server to become available."""
    for i in range(max_retries):
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code in [200, 302, 403]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


def send_raw_request(path):
    """
    Send an HTTP request with a raw (non-URL-encoded) path.

    The requests library auto-encodes URLs, so we need to use raw sockets
    to send the exact path we want (with unencoded < > " characters).

    NOTE: Path must not contain spaces or end with //, as they will cause issues.
    """
    try:
        host = "localhost"
        port = 8080

        # Build raw HTTP request
        request = f"GET {path} HTTP/1.1\r\n"
        request += f"Host: {host}:{port}\r\n"
        request += "Connection: close\r\n"
        request += "\r\n"

        # Create socket and send
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(REQUEST_TIMEOUT)
        sock.connect((host, port))
        sock.sendall(request.encode('utf-8'))

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
        sock.close()

        # Decode and return body (after headers)
        response_text = response.decode('utf-8', errors='replace')
        if '\r\n\r\n' in response_text:
            return response_text.split('\r\n\r\n', 1)[1]
        return response_text
    except Exception as e:
        pytest.fail(f"Failed to send raw request: {e}")


class TestBasicXSSPayloads:
    """Test basic XSS injection vectors through URL path."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_script_tag_injection_in_path(self):
        """
        Test that <script> tags in URL path are properly encoded.

        Vulnerable: <script>alert(1)</script> appears raw in HTML
        Fixed: &lt;script&gt;alert(1)&lt;/script&gt; appears encoded
        """
        payload = '"><script>alert("XSS1")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The raw script tag should NOT appear in the response
        assert '<script>alert("XSS1")</script>' not in response_text, \
            "VULNERABILITY: Unencoded <script> tag found in response - XSS is exploitable!"

    def test_event_handler_injection_onerror(self):
        """
        Test that onerror event handlers in URL path are encoded.

        The actual vulnerability requires the <img> tag to be rendered.
        If < and > are HTML-encoded, the XSS cannot execute even if
        the onerror text appears in the response (inside an encoded href).
        """
        payload = "\"><img/src=x/onerror=alert('XSS2')>"
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The raw <img> tag should NOT appear - this is what enables XSS
        # If <img is encoded to &lt;img, the XSS cannot execute
        assert "<img/src=x/onerror=" not in response_text and "<img src=x onerror=" not in response_text, \
            "VULNERABILITY: Unencoded <img> tag found - XSS is exploitable!"

    def test_event_handler_injection_onload(self):
        """
        Test that onload event handlers in URL path are encoded.
        """
        payload = "\"><svg/onload=alert('XSS3')>"
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The raw SVG onload should NOT appear
        assert '<svg/onload=' not in response_text and '<svg onload=' not in response_text, \
            "VULNERABILITY: Unencoded SVG onload found - XSS is exploitable!"

    def test_attribute_breakout_double_quote(self):
        """
        Test that double quotes in URL path are encoded to prevent
        attribute breakout via onclick handler.

        The actual vulnerability requires:
        1. Double quotes to break out of the href attribute
        2. An HTML tag like <b> to be rendered

        If " is encoded to &quot; and < is encoded to &lt;, the XSS cannot execute.
        """
        # Use a simpler payload that doesn't cause HTTP issues
        payload = '"><b/onclick=alert(1)>CLICK</b>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The injected HTML tag should NOT appear unencoded
        # Check for the actual XSS vector - unencoded HTML tags
        assert '<b/onclick=' not in response_text and '<b onclick=' not in response_text, \
            "VULNERABILITY: Unencoded <b> tag found - XSS is exploitable!"


class TestSearchFormXSS:
    """Test XSS specifically in the search form action attribute."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_searchform_action_escapes_script(self):
        """
        Verify search form action attribute properly encodes injected scripts.
        """
        payload = '"><script>alert("SEARCHBOX")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The unencoded script tag should NOT appear in the response
        assert '<script>alert("SEARCHBOX")</script>' not in response_text, \
            "VULNERABILITY: Unencoded script tag in response"

    def test_searchform_action_escapes_quotes(self):
        """
        Verify double quotes in path cause attribute breakout (vulnerability).
        """
        payload = 'test"><injected'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # If quote breaks out, "><injected will appear in the response
        assert '"><injected' not in response_text, \
            "VULNERABILITY: Quote breakout in form action"


class TestNavigationLinksXSS:
    """Test XSS in navigation and menu links."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_sitemap_link_escapes_xss(self):
        """
        Verify sitemap link properly encodes XSS payload.
        """
        payload = '"><script>alert("SITEMAP")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check whole response for unencoded payload
        assert '<script>alert("SITEMAP")</script>' not in response_text, \
            "VULNERABILITY: Unencoded script tag in response"

    def test_mailform_link_escapes_xss(self):
        """
        Verify mailform link properly encodes XSS payload.
        """
        payload = '"><script>alert("MAILFORM")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check whole response for unencoded payload
        assert '<script>alert("MAILFORM")</script>' not in response_text, \
            "VULNERABILITY: Unencoded script tag in response"

    def test_login_link_escapes_xss(self):
        """
        Verify login link properly encodes XSS payload.
        """
        payload = '"><script>alert("LOGIN")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check whole response for unencoded payload
        assert '<script>alert("LOGIN")</script>' not in response_text, \
            "VULNERABILITY: Unencoded script tag in response"


class TestEncodingBypassAttempts:
    """Test various encoding bypass techniques."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_mixed_case_script_tag(self):
        """
        Test mixed case <ScRiPt> tags are also handled.
        """
        payload = '"><ScRiPt>alert("MIXED")</ScRiPt>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check for any case variation of script tag
        assert not re.search(r'<script[^>]*>alert\("MIXED"\)</script>', response_text, re.IGNORECASE), \
            "VULNERABILITY: Mixed-case script tag found unencoded"

    def test_simple_script_injection(self):
        """
        Test simple script tag injection.
        """
        payload = '"><script>alert("SIMPLE")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        assert '<script>alert("SIMPLE")</script>' not in response_text, \
            "VULNERABILITY: Script tag injection"

    def test_javascript_protocol_injection(self):
        """
        Test javascript: protocol handler injection.
        """
        # Inject a script tag with javascript protocol reference
        payload = '"><script>location=\'javascript:alert(1)\'</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check that the script tag doesn't appear unencoded
        assert '<script>location=' not in response_text, \
            "VULNERABILITY: javascript: protocol injection successful"

    def test_data_uri_injection(self):
        """
        Test data: URI injection attempt via script tag.
        """
        payload = '"><script>alert("DATA")</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The raw payload should be encoded
        assert '<script>alert("DATA")</script>' not in response_text, \
            "VULNERABILITY: data: URI injection successful"


class TestMultipleReflectionPoints:
    """Test that all reflection points are properly protected."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_count_unencoded_script_reflections(self):
        """
        Count how many times the payload appears unencoded.

        Should be 0 after fix.
        """
        payload = '<script>UNIQUE_MARKER_12345</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Count unencoded appearances
        unencoded_count = response_text.count('<script>UNIQUE_MARKER_12345</script>')

        assert unencoded_count == 0, \
            f"VULNERABILITY: Found {unencoded_count} unencoded script tag reflections"

    def test_all_angle_brackets_encoded(self):
        """
        Verify all injected angle brackets are encoded.
        """
        marker = "ANGLE_TEST_98765"
        payload = f'<{marker}>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The raw < and > around our marker should not appear
        assert f'<{marker}>' not in response_text, \
            f"VULNERABILITY: Unencoded angle brackets found around marker"

    def test_form_action_attribute_injection(self):
        """
        Verify form action attribute cannot have injected content.

        The actual vulnerability requires the <form> tag to be rendered.
        If < and > are HTML-encoded to &lt; and &gt;, the injected form
        cannot be rendered even if 'action=EVILFORM' appears in an encoded href.
        """
        # Test with a marker that should appear in form action if vulnerable
        payload = '"><form/action=EVILFORM><input/name=x>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # Check that the injected <form> tag doesn't appear as HTML
        # The text 'action=EVILFORM' might appear in encoded hrefs, but that's safe
        assert '<form/action=EVILFORM>' not in response_text and '<form action=EVILFORM>' not in response_text, \
            "VULNERABILITY: Form injection attack successful"


class TestDOMBasedIndicators:
    """Test for indicators that would allow DOM-based attacks."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is available before tests."""
        assert wait_for_server(), "Server did not start in time"

    def test_no_script_content_from_path(self):
        """
        Verify injected script content doesn't appear in the page.
        """
        marker = "INLINE_JS_54321"
        payload = f'<script>{marker}</script>'
        path = f'/index.php/{payload}'

        response_text = send_raw_request(path)

        # The marker inside script tags should not appear
        assert f'<script>{marker}</script>' not in response_text, \
            f"VULNERABILITY: Injected script content found in response"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
