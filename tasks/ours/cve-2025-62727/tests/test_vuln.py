#!/usr/bin/env python3
"""
Vulnerability tests for Range header DoS via quadratic complexity parsing.

These tests verify the vulnerability status:
- FAIL when vulnerable (processing takes excessive time)
- PASS when fixed (processing completes quickly)

The vulnerability is in the _parse_range_header method's regex-based parsing
which has O(n^2) complexity with certain input patterns.
"""
import time
import pytest
from starlette.responses import FileResponse


class TestRangeHeaderDoSVulnerability:
    """
    Test for quadratic complexity in Range header parsing.

    The vulnerable code uses a regex pattern (\d*)-(\d*) with findall(),
    which has catastrophic backtracking on inputs like "0000...0000a-".
    """

    def build_malicious_payload(self, length: int) -> str:
        """
        Build a Range header payload that triggers quadratic complexity.

        The pattern "bytes=" + ("0" * length) + "a-" causes the regex
        to backtrack extensively trying to match digit sequences.
        """
        return "bytes=" + ("0" * length) + "a-"

    def measure_parse_time(self, range_header: str, file_size: int = 1_000_000) -> float:
        """Measure time to parse a Range header."""
        start = time.perf_counter()
        try:
            FileResponse._parse_range_header(range_header, file_size)
        except Exception:
            pass  # We're measuring time, not correctness
        return time.perf_counter() - start

    def test_quadratic_complexity_with_large_payload(self):
        """
        Test that a 20,000 character malicious payload is processed quickly.

        Vulnerable: Takes ~0.8-1.0 seconds (quadratic)
        Fixed: Takes < 0.01 seconds (linear)
        """
        payload = self.build_malicious_payload(20000)
        elapsed = self.measure_parse_time(payload)

        print(f"Processing time for 20,000 char payload: {elapsed:.4f}s")

        # Threshold: 0.1 seconds should be plenty for linear-time parsing
        # Vulnerable code typically takes 0.8+ seconds
        assert elapsed < 0.1, (
            f"VULNERABLE: Range header parsing took {elapsed:.4f}s for 20k chars. "
            f"Expected < 0.1s for fixed linear-time implementation."
        )
        print("PASSED: Large payload processed in linear time")

    def test_quadratic_complexity_with_medium_payload(self):
        """
        Test that a 10,000 character malicious payload is processed quickly.

        Vulnerable: Takes ~0.2 seconds (quadratic)
        Fixed: Takes < 0.01 seconds (linear)
        """
        payload = self.build_malicious_payload(10000)
        elapsed = self.measure_parse_time(payload)

        print(f"Processing time for 10,000 char payload: {elapsed:.4f}s")

        assert elapsed < 0.05, (
            f"VULNERABLE: Range header parsing took {elapsed:.4f}s for 10k chars. "
            f"Expected < 0.05s for fixed implementation."
        )
        print("PASSED: Medium payload processed quickly")

    def test_time_scaling_is_linear_not_quadratic(self):
        """
        Test that processing time scales linearly with input size, not quadratically.

        For vulnerable O(n^2) code:
        - Doubling input size should ~4x the processing time

        For fixed O(n) code:
        - Doubling input size should ~2x the processing time
        """
        time_5k = self.measure_parse_time(self.build_malicious_payload(5000))
        time_10k = self.measure_parse_time(self.build_malicious_payload(10000))
        time_20k = self.measure_parse_time(self.build_malicious_payload(20000))

        print(f"Time for 5k: {time_5k:.4f}s")
        print(f"Time for 10k: {time_10k:.4f}s")
        print(f"Time for 20k: {time_20k:.4f}s")

        # In quadratic code: 10k/5k ratio is ~4, 20k/10k ratio is ~4
        # In linear code: ratios should be ~2
        if time_5k > 0.001:  # Avoid division by tiny numbers
            ratio_10k_5k = time_10k / time_5k
            ratio_20k_10k = time_20k / time_10k
            print(f"Ratio 10k/5k: {ratio_10k_5k:.2f}")
            print(f"Ratio 20k/10k: {ratio_20k_10k:.2f}")

            # Quadratic scaling would show ratios close to 4
            # Linear scaling should show ratios close to 2 or less
            assert ratio_20k_10k < 3.0, (
                f"VULNERABLE: Time scaling ratio {ratio_20k_10k:.2f} indicates quadratic complexity"
            )

        # Absolute time check as backup
        assert time_20k < 0.1, f"VULNERABLE: 20k chars took {time_20k:.4f}s"
        print("PASSED: Time scaling is linear, not quadratic")

    def test_various_malicious_patterns(self):
        """Test multiple payload patterns that could trigger quadratic behavior."""
        file_size = 1_000_000

        # Pattern 1: zeros followed by non-digit
        payload1 = "bytes=" + ("0" * 15000) + "a-"

        # Pattern 2: mixed digits with non-digit interruption
        payload2 = "bytes=" + "123" * 5000 + "x-"

        # Pattern 3: all digits but no valid range format
        payload3 = "bytes=" + "9" * 15000 + "-"

        for i, payload in enumerate([payload1, payload2, payload3], 1):
            elapsed = self.measure_parse_time(payload)
            print(f"Pattern {i}: {elapsed:.4f}s for {len(payload)} chars")
            assert elapsed < 0.1, (
                f"VULNERABLE: Pattern {i} took {elapsed:.4f}s, expected < 0.1s"
            )

        print("PASSED: All malicious patterns processed quickly")

    def test_repeated_malicious_requests_dont_degrade(self):
        """Test that repeated requests don't accumulate or degrade."""
        payload = self.build_malicious_payload(10000)

        times = []
        for i in range(5):
            elapsed = self.measure_parse_time(payload)
            times.append(elapsed)

        avg_time = sum(times) / len(times)
        max_time = max(times)

        print(f"Average time over 5 requests: {avg_time:.4f}s")
        print(f"Max time: {max_time:.4f}s")

        assert avg_time < 0.05, f"VULNERABLE: Average time {avg_time:.4f}s too high"
        assert max_time < 0.1, f"VULNERABLE: Max time {max_time:.4f}s too high"
        print("PASSED: Repeated requests don't degrade")

    def test_edge_case_very_long_zero_sequence(self):
        """Test extremely long sequence of zeros (40k chars)."""
        payload = self.build_malicious_payload(40000)
        elapsed = self.measure_parse_time(payload)

        print(f"Processing time for 40,000 char payload: {elapsed:.4f}s")

        # Vulnerable code takes 3+ seconds for 40k chars
        # Fixed code should still be < 0.1s
        assert elapsed < 0.2, (
            f"VULNERABLE: 40k char payload took {elapsed:.4f}s. "
            f"Expected < 0.2s for linear time implementation."
        )
        print("PASSED: Very long payload processed quickly")



if __name__ == "__main__":
    pytest.main([__file__, "-v"])
