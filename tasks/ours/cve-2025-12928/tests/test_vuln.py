#!/usr/bin/env python3
"""
Vulnerability tests for Online Job Search Engine SQL Injection (CVE-2025-12928).

The vulnerability is in the registration functionality (functions.php):
  $userName = $data['txtusername'];
  mysql_query("select username from registration where username ='$userName'");

The txtusername field is directly concatenated into SQL without any sanitization.

Tests use boolean-based and UNION-based injection (no time-based SLEEP).
All tests should FAIL in vulnerable state, PASS in fixed state.
"""

import os
import requests
import pytest
import random
import string

BASE_URL = os.environ.get("APP_URL", "http://localhost")


def random_string(length=8):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))


def get_registration_payload(username):
    """Generate a registration payload with the given username."""
    return {
        "txtregID": random_string(6).upper(),
        "txtusername": username,
        "txtfullname": "Test User",
        "txtphone": "1234567890",
        "txtaddress": "123 Test Street",
        "state": "Lagos",
        "month": "01",
        "day": "15",
        "year": "1990",
        "cmdsex": "Male",
        "cmdqualification": "BSC",
        "cmdspecialization": "Computer Science"
    }


class TestSQLInjectionVulnerability:
    """
    Test for SQL injection vulnerability in registration form.

    The vulnerable query: SELECT username FROM registration WHERE username='$userName'

    If vulnerable:
    - OR 1=1 returns all rows -> numrows > 0 -> "ALREADY EXIST"
    - UNION SELECT returns injected row -> numrows > 0 -> "ALREADY EXIST"

    If fixed (escaped):
    - Input treated as literal string -> no rows found -> proceeds to INSERT
    """

    # ==================== BOOLEAN-BASED INJECTION ====================

    def test_no_or_true_injection(self):
        """
        OR '1'='1' should NOT make system think username exists.

        Vulnerable query: WHERE username='' OR '1'='1'#'
        This returns ALL rows, so numrows > 0 -> "ALREADY EXIST"
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' OR '1'='1'#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: OR '1'='1' returned all rows as 'existing user'"
        )

    def test_no_or_1_equals_1_injection(self):
        """
        OR 1=1 (without quotes) should NOT bypass check.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' OR 1=1#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: OR 1=1 bypassed username check"
        )

    def test_no_or_true_with_nonexistent_prefix(self):
        """
        nonexistent' OR '1'='1 should NOT find users.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = f"nonexistent_{random_string()}' OR '1'='1'#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: OR tautology with nonexistent prefix worked"
        )

    def test_no_or_not_null_injection(self):
        """
        OR username IS NOT NULL should NOT return all users.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' OR username IS NOT NULL#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: OR username IS NOT NULL returned rows"
        )

    # ==================== UNION-BASED INJECTION ====================

    def test_no_union_select_string_injection(self):
        """
        UNION SELECT 'value' should NOT inject fake existing user.

        Vulnerable query: WHERE username='' UNION SELECT 'fake'#'
        UNION adds a row to result, numrows > 0 -> "ALREADY EXIST"
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' UNION SELECT 'injected_user'#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: UNION SELECT injected fake 'existing' user"
        )

    def test_no_union_select_number_injection(self):
        """
        UNION SELECT 1 should NOT inject row.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' UNION SELECT 1#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: UNION SELECT 1 injected row"
        )

    def test_no_union_select_null_injection(self):
        """
        UNION SELECT NULL should NOT inject row.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' UNION SELECT NULL#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: UNION SELECT NULL injected row"
        )

    def test_no_union_all_select_injection(self):
        """
        UNION ALL SELECT should NOT inject row.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' UNION ALL SELECT 'test'#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: UNION ALL SELECT injected row"
        )

    # ==================== COMMENT INJECTION ====================

    def test_no_comment_truncation_with_or(self):
        """
        Comment # should NOT truncate query allowing OR to work.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "x' OR 'x'='x"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        # Query becomes: WHERE username='x' OR 'x'='x'
        # If vulnerable, 'x'='x' is true -> returns all rows
        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: OR with balanced quotes returned all rows"
        )

    def test_no_double_dash_comment_injection(self):
        """
        -- comment should NOT allow injection.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' OR 1=1-- "
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: -- comment allowed OR 1=1"
        )

    # ==================== SUBQUERY INJECTION ====================

    def test_no_subquery_injection(self):
        """
        Subquery should NOT be executed to check for users.
        """
        url = f"{BASE_URL}/registration.php"

        # Subquery returns existing username
        sqli_username = "' OR username=(SELECT username FROM registration LIMIT 1)#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: Subquery executed and found user"
        )

    def test_no_exists_subquery_injection(self):
        """
        EXISTS subquery should NOT return true.
        """
        url = f"{BASE_URL}/registration.php"

        sqli_username = "' OR EXISTS(SELECT 1 FROM registration)#"
        payload = get_registration_payload(sqli_username)

        response = requests.post(url, data=payload, timeout=10)

        assert "ALREADY EXIST" not in response.text.upper(), (
            "SQL injection: EXISTS subquery returned true"
        )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
