#!/bin/bash
# solution.sh - Apply fix for unsafe pickle deserialization in pdfminer.six CMapDB
set -e

echo "Locating pdfminer cmapdb.py..."

# Find the cmapdb.py file in the pdfminer installation
CMAPDB_FILE=$(python3 -c "import pdfminer.cmapdb; print(pdfminer.cmapdb.__file__)")

if [ ! -f "$CMAPDB_FILE" ]; then
    echo "ERROR: Cannot find cmapdb.py at $CMAPDB_FILE"
    exit 1
fi

echo "Found cmapdb.py at: $CMAPDB_FILE"

# Apply the fix using Python
python3 << 'PYEOF'
import sys

# Find cmapdb.py location
import pdfminer.cmapdb
cmapdb_path = pdfminer.cmapdb.__file__

print(f"Reading {cmapdb_path}...")

with open(cmapdb_path, 'r') as f:
    content = f.read()

# Check if already fixed
if 'RestrictedUnpickler' in content:
    print("File already appears to be fixed. Skipping.")
    sys.exit(0)

# Define the restricted unpickler class to add after imports
restricted_unpickler_class = '''

class RestrictedUnpickler(pickle.Unpickler):
    """Safe unpickler that only allows specific safe classes for CMap data."""

    SAFE_BUILTINS = frozenset([
        'dict', 'list', 'tuple', 'set', 'frozenset',
        'str', 'bytes', 'int', 'float', 'bool', 'type', 'None'
    ])

    def find_class(self, module, name):
        # Only allow builtins that are safe data types
        if module == 'builtins' and name in self.SAFE_BUILTINS:
            return getattr(__builtins__ if isinstance(__builtins__, dict) else __builtins__.__class__, name, None) or eval(name)
        # Block everything else - no exec, eval, os, subprocess, etc.
        raise pickle.UnpicklingError(f"Blocked unsafe class: {module}.{name}")


def safe_loads(data):
    """Safely load pickle data using RestrictedUnpickler."""
    import io
    return RestrictedUnpickler(io.BytesIO(data)).load()

'''

# Find where to insert the restricted unpickler (after the imports section)
# Look for the log = logging.getLogger line which is after all imports
insert_marker = 'log = logging.getLogger(__name__)'
if insert_marker not in content:
    print("ERROR: Could not find insertion point for RestrictedUnpickler")
    sys.exit(1)

# Insert the restricted unpickler class before the log line
content = content.replace(insert_marker, restricted_unpickler_class + insert_marker)

# Now replace pickle.loads with safe_loads in the _load_data method
# Original: return type(str(name), (), pickle.loads(gzfile.read()))
# New: return type(str(name), (), safe_loads(gzfile.read()))
content = content.replace('pickle.loads(gzfile.read())', 'safe_loads(gzfile.read())')

# Also add path traversal protection
old_code = '''        for directory in cmap_paths:
            path = os.path.join(directory, filename)
            if os.path.exists(path):
                gzfile = gzip.open(path)'''

new_code = '''        for directory in cmap_paths:
            path = os.path.join(directory, filename)
            # Resolve paths to prevent directory traversal
            resolved_path = os.path.realpath(path)
            resolved_directory = os.path.realpath(directory)
            # Check if resolved path is within the intended directory
            if not resolved_path.startswith(resolved_directory + os.sep):
                continue
            if os.path.exists(resolved_path):
                gzfile = gzip.open(resolved_path)'''

if old_code in content:
    content = content.replace(old_code, new_code)
else:
    print("Note: Path traversal fix may already be applied or code structure differs")

print("Writing fixed content...")
with open(cmapdb_path, 'w') as f:
    f.write(content)

print(f"Successfully fixed {cmapdb_path}")
PYEOF

echo ""
echo "Fix applied successfully."
echo ""

# Verify the fix was applied
echo "Verifying fix..."
if grep -q "RestrictedUnpickler" "$CMAPDB_FILE"; then
    echo "Verification: RestrictedUnpickler is present in the file."
else
    echo "WARNING: Could not verify RestrictedUnpickler was added."
    exit 1
fi

if grep -q "safe_loads" "$CMAPDB_FILE"; then
    echo "Verification: safe_loads is present in the file."
else
    echo "WARNING: Could not verify safe_loads was added."
    exit 1
fi

echo "Done."
