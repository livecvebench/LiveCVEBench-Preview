"""
Functional tests for fio job file parser.

These tests verify that fio correctly parses valid job files and handles
various job configurations. They should PASS in both vulnerable and fixed states.
"""

import subprocess
import tempfile
import os
import pytest


FIO_PATH = '/app/fio'


def run_fio_parse(job_content, timeout=30):
    """Helper function to run fio --parse-only on a job file."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
        f.write(job_content)
        job_file = f.name

    try:
        result = subprocess.run(
            ['./fio', '--parse-only', job_file],
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=FIO_PATH
        )
        return result
    finally:
        if os.path.exists(job_file):
            os.unlink(job_file)


class TestBasicJobParsing:
    """Test basic job file parsing functionality."""

    def test_parse_minimal_job_file(self):
        """Test that fio can parse a minimal valid job file."""
        job_content = """[job1]
rw=read
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"

    def test_parse_job_with_global_section(self):
        """Test job file with global section."""
        job_content = """[global]
runtime=10
size=1M

[job1]
rw=read
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"

    def test_parse_job_with_multiple_jobs(self):
        """Test job file with multiple job sections."""
        job_content = """[global]
runtime=10

[read_job]
rw=read
size=1M

[write_job]
rw=write
size=1M

[randread_job]
rw=randread
size=1M
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"


class TestJobOptions:
    """Test various job options are parsed correctly."""

    def test_io_patterns(self):
        """Test various I/O pattern options."""
        job_content = """[global]
size=1M

[seq_read]
rw=read

[seq_write]
rw=write

[rand_read]
rw=randread

[rand_write]
rw=randwrite

[mixed]
rw=randrw
rwmixread=70
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"

    def test_size_options(self):
        """Test various size specification formats."""
        job_content = """[job1]
rw=read
size=1M

[job2]
rw=read
size=1G

[job3]
rw=read
size=1024K
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"

    def test_block_size_options(self):
        """Test block size options."""
        job_content = """[global]
size=1M

[job1]
rw=read
bs=4k

[job2]
rw=read
bs=64k

[job3]
rw=read
blocksize=128k
"""
        result = run_fio_parse(job_content)
        assert result.returncode == 0, f"fio parse failed: {result.stderr}"


class TestValidIncludeDirective:
    """Test valid include directive handling."""

    def test_parse_with_valid_include(self):
        """Test that fio handles valid include directives."""
        # Create included file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write("size=1M\n")
            include_file = f.name

        job_content = f"""[global]
runtime=10

[job1]
rw=read
include {include_file}
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write(job_content)
            job_file = f.name

        try:
            result = subprocess.run(
                ['./fio', '--parse-only', job_file],
                capture_output=True,
                text=True,
                timeout=30,
                cwd=FIO_PATH
            )
            # Should succeed with valid include
            assert result.returncode == 0, f"fio parse with include failed: {result.stderr}"
        finally:
            if os.path.exists(job_file):
                os.unlink(job_file)
            if os.path.exists(include_file):
                os.unlink(include_file)

    def test_nested_include(self):
        """Test nested include directives."""
        # Create inner include file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write("bs=4k\n")
            inner_file = f.name

        # Create outer include file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write(f"size=1M\ninclude {inner_file}\n")
            outer_file = f.name

        job_content = f"""[global]
runtime=10

[job1]
rw=read
include {outer_file}
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.fio', delete=False) as f:
            f.write(job_content)
            job_file = f.name

        try:
            result = subprocess.run(
                ['./fio', '--parse-only', job_file],
                capture_output=True,
                text=True,
                timeout=30,
                cwd=FIO_PATH
            )
            assert result.returncode == 0, f"Nested include failed: {result.stderr}"
        finally:
            for path in [job_file, outer_file, inner_file]:
                if os.path.exists(path):
                    os.unlink(path)


class TestEdgeCases:
    """Test edge cases in job file parsing."""

    def test_empty_job_file(self):
        """Test empty job file handling."""
        job_content = ""
        result = run_fio_parse(job_content)
        # Empty file should be handled gracefully (may succeed or fail, but no crash)
        assert result.returncode >= 0 or result.returncode < 0, "fio crashed on empty file"

    def test_whitespace_only_job_file(self):
        """Test job file with only whitespace."""
        job_content = "   \n\n   \n"
        result = run_fio_parse(job_content)
        # Should handle gracefully
        assert result.returncode >= 0 or result.returncode < 0, "fio crashed on whitespace-only file"

    def test_comments_in_job_file(self):
        """Test job file with comments."""
        job_content = """# This is a comment
; This is also a comment
[global]
# Another comment
runtime=10

[job1]
rw=read
size=1M  # inline comment might not be supported
"""
        result = run_fio_parse(job_content)
        # Comments should be handled
        # Note: fio uses ';' and '#' for comments
        assert result.returncode == 0, f"Comment handling failed: {result.stderr}"


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
