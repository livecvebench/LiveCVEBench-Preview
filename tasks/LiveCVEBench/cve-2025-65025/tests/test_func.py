#!/usr/bin/env python3
"""
Functional tests for esm.sh tar extraction.
These tests verify that normal package extraction works correctly.
Should PASS in both vulnerable and fixed states.
"""

import os
import subprocess
import tempfile
import tarfile
import gzip
import io
import json
import shutil
import pytest


class TestNormalExtraction:
    """Test that legitimate package extraction works correctly."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup and teardown for each test."""
        self.test_dir = tempfile.mkdtemp(prefix="esm_func_test_")
        yield
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)

    def create_normal_tarball(self, files_dict, tarball_path):
        """Create a normal tarball with given files."""
        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            for name, content in files_dict.items():
                content_bytes = content.encode('utf-8')
                info = tarfile.TarInfo(name=name)
                info.size = len(content_bytes)
                tar.addfile(info, io.BytesIO(content_bytes))

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

    def test_simple_package_structure(self):
        """Test extraction of a simple package with standard structure."""
        tarball_path = os.path.join(self.test_dir, "simple.tgz")

        package_json = {
            "name": "simple-pkg",
            "version": "1.0.0",
            "main": "index.js"
        }

        files = {
            "package/package.json": json.dumps(package_json, indent=2),
            "package/index.js": "module.exports = { hello: 'world' };",
            "package/README.md": "# Simple Package"
        }

        self.create_normal_tarball(files, tarball_path)

        # Verify tarball was created
        assert os.path.exists(tarball_path)

        # Verify tarball contents
        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                names = tar.getnames()
                assert "package/package.json" in names
                assert "package/index.js" in names

    def test_nested_directory_structure(self):
        """Test extraction of packages with nested directories."""
        tarball_path = os.path.join(self.test_dir, "nested.tgz")

        files = {
            "package/package.json": '{"name": "nested-pkg", "version": "1.0.0"}',
            "package/src/index.js": "export default {};",
            "package/src/utils/helper.js": "export function helper() {}",
            "package/src/utils/deep/nested/file.js": "// deeply nested",
            "package/lib/compiled.js": "// compiled output"
        }

        self.create_normal_tarball(files, tarball_path)

        # Verify all nested paths are in the tarball
        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                names = tar.getnames()
                assert "package/src/utils/deep/nested/file.js" in names

    def test_various_file_types(self):
        """Test extraction handles various common file types."""
        tarball_path = os.path.join(self.test_dir, "various.tgz")

        files = {
            "package/package.json": '{"name": "multi-type"}',
            "package/index.js": "// JavaScript",
            "package/index.mjs": "// ES Module",
            "package/index.cjs": "// CommonJS",
            "package/types/index.d.ts": "// TypeScript definitions",
            "package/styles/main.css": "/* CSS styles */",
            "package/index.js.map": '{"version": 3}'
        }

        self.create_normal_tarball(files, tarball_path)

        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                names = tar.getnames()
                assert len(names) == len(files)

    def test_scoped_package_name(self):
        """Test extraction of scoped packages like @org/package."""
        tarball_path = os.path.join(self.test_dir, "scoped.tgz")

        package_json = {
            "name": "@myorg/mypackage",
            "version": "2.0.0",
            "main": "dist/index.js"
        }

        files = {
            "package/package.json": json.dumps(package_json),
            "package/dist/index.js": "module.exports = {};",
            "package/dist/utils.js": "// utils"
        }

        self.create_normal_tarball(files, tarball_path)

        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                names = tar.getnames()
                assert "package/dist/index.js" in names

    def test_empty_directories_handling(self):
        """Test that tarballs with directory entries are handled."""
        tarball_path = os.path.join(self.test_dir, "with_dirs.tgz")

        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            # Add a directory entry
            dir_info = tarfile.TarInfo(name='package/lib/')
            dir_info.type = tarfile.DIRTYPE
            tar.addfile(dir_info)

            # Add a file in that directory
            content = b'// lib file'
            file_info = tarfile.TarInfo(name='package/lib/index.js')
            file_info.size = len(content)
            tar.addfile(file_info, io.BytesIO(content))

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

        # Verify structure
        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                members = tar.getmembers()
                dir_members = [m for m in members if m.isdir()]
                file_members = [m for m in members if m.isfile()]
                assert len(dir_members) == 1
                assert len(file_members) == 1


class TestTarballIntegrity:
    """Test tarball handling and integrity checks."""

    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Setup and teardown."""
        self.test_dir = tempfile.mkdtemp(prefix="esm_integrity_test_")
        yield
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)

    def test_gzip_compression(self):
        """Test that gzipped tarballs are properly compressed."""
        tarball_path = os.path.join(self.test_dir, "compressed.tgz")

        # Create a tarball with some content
        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            content = b'x' * 10000  # Repetitive content compresses well
            info = tarfile.TarInfo(name='package/big.js')
            info.size = len(content)
            tar.addfile(info, io.BytesIO(content))

        tar_buffer.seek(0)
        raw_size = len(tar_buffer.read())

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

        compressed_size = os.path.getsize(tarball_path)

        # Compressed should be smaller than raw
        assert compressed_size < raw_size

    def test_large_file_handling(self):
        """Test handling of larger files in tarball."""
        tarball_path = os.path.join(self.test_dir, "large.tgz")

        # Create a moderate-size file (100KB)
        large_content = 'console.log("test");\n' * 5000

        tar_buffer = io.BytesIO()
        with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
            content_bytes = large_content.encode('utf-8')
            info = tarfile.TarInfo(name='package/large-bundle.js')
            info.size = len(content_bytes)
            tar.addfile(info, io.BytesIO(content_bytes))

        tar_buffer.seek(0)
        with gzip.open(tarball_path, 'wb') as gz:
            gz.write(tar_buffer.read())

        # Verify we can read it back
        with gzip.open(tarball_path, 'rb') as gz:
            with tarfile.open(fileobj=gz, mode='r') as tar:
                for member in tar.getmembers():
                    if member.name == 'package/large-bundle.js':
                        assert member.size == len(large_content.encode('utf-8'))


class TestPathNormalization:
    """Test that path handling works correctly for legitimate paths."""

    def test_relative_paths_within_package(self):
        """Test that internal relative paths like package/./file.js work."""
        # This tests legitimate use of . in paths
        test_dir = tempfile.mkdtemp(prefix="esm_path_test_")
        tarball_path = os.path.join(test_dir, "rel.tgz")

        try:
            tar_buffer = io.BytesIO()
            with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
                # A path with redundant ./
                content = b'// test'
                info = tarfile.TarInfo(name='package/./src/./index.js')
                info.size = len(content)
                tar.addfile(info, io.BytesIO(content))

            tar_buffer.seek(0)
            with gzip.open(tarball_path, 'wb') as gz:
                gz.write(tar_buffer.read())

            # Just verify it can be created and read
            with gzip.open(tarball_path, 'rb') as gz:
                with tarfile.open(fileobj=gz, mode='r') as tar:
                    names = tar.getnames()
                    assert len(names) == 1
        finally:
            shutil.rmtree(test_dir)

    def test_hidden_files_handling(self):
        """Test that hidden files (starting with .) are handled appropriately."""
        test_dir = tempfile.mkdtemp(prefix="esm_hidden_test_")
        tarball_path = os.path.join(test_dir, "hidden.tgz")

        try:
            files = {
                "package/package.json": '{"name": "test"}',
                "package/.gitignore": "node_modules/",
                "package/.npmrc": "registry=https://registry.npmjs.org/",
                "package/src/index.js": "// main"
            }

            tar_buffer = io.BytesIO()
            with tarfile.open(fileobj=tar_buffer, mode='w') as tar:
                for name, content in files.items():
                    content_bytes = content.encode('utf-8')
                    info = tarfile.TarInfo(name=name)
                    info.size = len(content_bytes)
                    tar.addfile(info, io.BytesIO(content_bytes))

            tar_buffer.seek(0)
            with gzip.open(tarball_path, 'wb') as gz:
                gz.write(tar_buffer.read())

            # Verify all files including hidden ones are present
            with gzip.open(tarball_path, 'rb') as gz:
                with tarfile.open(fileobj=gz, mode='r') as tar:
                    names = tar.getnames()
                    assert "package/.gitignore" in names
                    assert "package/.npmrc" in names
        finally:
            shutil.rmtree(test_dir)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
