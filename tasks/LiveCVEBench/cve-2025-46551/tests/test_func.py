#!/usr/bin/env python3
"""
Functional tests for JRuby SSL/TLS connections.

These tests verify that the application works correctly - basic functionality.
They should PASS in both vulnerable and fixed states.

test_func.py tests basic functionality:
- JRuby is installed and works
- jruby-openssl library loads correctly
- SSL connections to valid hosts work
- SSL context defaults are properly configured (except verify_hostname)
"""

import subprocess
import pytest


class TestJRubyInstallation:
    """Tests to verify JRuby and jruby-openssl are properly installed."""

    def test_jruby_installed(self):
        """Verify JRuby is installed and working."""
        result = subprocess.run(
            ['jruby', '--version'],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"JRuby not installed or not working: {result.stderr}"
        assert 'jruby' in result.stdout.lower(), f"Unexpected output: {result.stdout}"

    def test_jruby_openssl_installed(self):
        """Verify jruby-openssl gem is installed."""
        result = subprocess.run(
            ['jruby', '-e', "require 'openssl'; puts JOpenSSL::VERSION"],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"jruby-openssl not installed: {result.stderr}"
        version = result.stdout.strip()
        assert version, "Could not get JOpenSSL version"


class TestSSLFunctionality:
    """Tests to verify SSL/TLS connections work correctly."""

    def test_ssl_connection_to_valid_host(self):
        """Verify SSL connections to properly configured HTTPS servers work."""
        script = '''
require "net/http"
require "openssl"

uri = URI("https://www.google.com/")
https = Net::HTTP.new(uri.host, uri.port)
https.use_ssl = true
https.verify_mode = OpenSSL::SSL::VERIFY_PEER
https.open_timeout = 15
https.read_timeout = 15

begin
  response = https.start { https.get("/") }
  puts "Connection successful: #{response.code}"
  exit 0
rescue => e
  puts "Connection failed: #{e.message}"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=60
        )
        assert result.returncode == 0, f"SSL connection failed: {result.stderr}\n{result.stdout}"

    def test_ssl_connection_to_github(self):
        """Verify SSL connections to GitHub work."""
        script = '''
require "net/http"
require "openssl"

uri = URI("https://github.com/")
https = Net::HTTP.new(uri.host, uri.port)
https.use_ssl = true
https.verify_mode = OpenSSL::SSL::VERIFY_PEER
https.open_timeout = 15
https.read_timeout = 15

begin
  response = https.start { https.get("/") }
  puts "Connection successful: #{response.code}"
  exit 0
rescue => e
  puts "Connection failed: #{e.message}"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=60
        )
        assert result.returncode == 0, f"SSL connection to GitHub failed: {result.stderr}\n{result.stdout}"


class TestSSLContextDefaults:
    """Tests to verify SSL context default parameters are correct."""

    def test_verify_mode_is_peer(self):
        """Verify default verify_mode is VERIFY_PEER."""
        script = '''
require 'openssl'
mode = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:verify_mode]
if mode == OpenSSL::SSL::VERIFY_PEER
  puts "PASS: verify_mode is VERIFY_PEER"
  exit 0
else
  puts "FAIL: verify_mode is #{mode}"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"Verify mode incorrect: {result.stdout}\n{result.stderr}"

    def test_min_version_is_set(self):
        """Verify minimum TLS version is set."""
        script = '''
require 'openssl'
version = OpenSSL::SSL::SSLContext::DEFAULT_PARAMS[:min_version]
if version
  puts "PASS: min_version is set to #{version}"
  exit 0
else
  puts "FAIL: min_version not set"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"Min version not set: {result.stdout}\n{result.stderr}"

    def test_verify_certificate_identity_function_exists(self):
        """Verify the verify_certificate_identity function exists."""
        script = '''
require 'openssl'

# Test that verify_certificate_identity method exists
if OpenSSL::SSL.respond_to?(:verify_certificate_identity)
  puts "PASS: verify_certificate_identity method exists"
  exit 0
else
  puts "FAIL: verify_certificate_identity method not found"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"verify_certificate_identity not available: {result.stdout}\n{result.stderr}"

    def test_jruby_openssl_loaded(self):
        """Verify JRuby-OpenSSL library is properly loaded."""
        script = '''
require 'openssl'
version = OpenSSL::OPENSSL_VERSION
if version.include?('JRuby-OpenSSL') || version.include?('BouncyCastle')
  puts "PASS: JRuby-OpenSSL loaded: #{version}"
  exit 0
else
  puts "FAIL: Unexpected provider: #{version}"
  exit 1
end
'''
        result = subprocess.run(
            ['jruby', '-e', script],
            capture_output=True,
            text=True,
            timeout=30
        )
        assert result.returncode == 0, f"JRuby-OpenSSL not loaded: {result.stdout}\n{result.stderr}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
