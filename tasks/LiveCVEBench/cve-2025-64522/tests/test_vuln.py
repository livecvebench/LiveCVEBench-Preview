"""
Vulnerability tests for Soft Serve webhook URL validation.

These tests verify that the application properly validates webhook URLs
to prevent requests to internal/private network addresses.

- FAIL in vulnerable state (internal URLs are accepted)
- PASS in fixed state (internal URLs are rejected)
"""
import pytest
import subprocess
import time
import os
import socket


# SSH configuration for soft-serve
SSH_HOST = os.environ.get("SOFT_SERVE_HOST", "localhost")
SSH_PORT = os.environ.get("SOFT_SERVE_SSH_PORT", "23231")
SSH_KEY = os.environ.get("SOFT_SERVE_ADMIN_KEY", "/root/.ssh/id_ed25519")

# Test repository name
TEST_REPO = "vuln-test-repo"

# Error messages expected when URL is blocked
BLOCKED_URL_ERRORS = [
    "private",
    "internal",
    "invalid",
    "cannot resolve",
    "blocked",
    "not allowed",
    "forbidden",
    "rejected"
]


def run_ssh_command(command: str, timeout: int = 30) -> subprocess.CompletedProcess:
    """Run an SSH command against soft-serve.

    Note: In soft-serve v0.11.0, webhooks are managed via 'repo webhook' subcommand,
    not a top-level 'webhook' command.
    """
    ssh_cmd = [
        "ssh",
        "-p", SSH_PORT,
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        "-o", "IdentitiesOnly=yes",
        "-i", SSH_KEY,
        SSH_HOST,
        command
    ]
    return subprocess.run(ssh_cmd, capture_output=True, text=True, timeout=timeout)


def wait_for_soft_serve(max_wait: int = 60) -> bool:
    """Wait for soft-serve to be ready."""
    start = time.time()
    while time.time() - start < max_wait:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((SSH_HOST, int(SSH_PORT)))
            sock.close()
            if result == 0:
                time.sleep(2)
                return True
        except Exception:
            pass
        time.sleep(1)
    return False


def is_url_blocked(result: subprocess.CompletedProcess) -> bool:
    """Check if the command result indicates URL was blocked."""
    output = (result.stdout + result.stderr).lower()

    # If return code is non-zero and contains error keywords, URL was blocked
    if result.returncode != 0:
        for keyword in BLOCKED_URL_ERRORS:
            if keyword in output:
                return True

    # Also check if error message is present even with returncode 0
    for keyword in BLOCKED_URL_ERRORS:
        if keyword in output:
            return True

    return False


@pytest.fixture(scope="module", autouse=True)
def setup_environment():
    """Ensure soft-serve is running and set up test repository."""
    import re
    assert wait_for_soft_serve(), "Soft Serve is not running"

    # Create test repository
    run_ssh_command(f"repo create {TEST_REPO}")

    # Pre-cleanup - delete any webhooks that might exist from previous runs
    result = run_ssh_command(f"repo webhook list {TEST_REPO}")
    if result.returncode == 0 and result.stdout.strip():
        lines = result.stdout.strip().split("\n")
        for line in lines:
            match = re.search(r'│\s*(\d+)\s*│', line)
            if match:
                webhook_id = match.group(1)
                run_ssh_command(f"repo webhook delete {TEST_REPO} {webhook_id}")

    yield

    # Cleanup webhooks
    result = run_ssh_command(f"repo webhook list {TEST_REPO}")
    if result.returncode == 0 and result.stdout.strip():
        lines = result.stdout.strip().split("\n")
        for line in lines:
            # Parse ID from table format: │ID│URL│... (with possible whitespace)
            match = re.search(r'│\s*(\d+)\s*│', line)
            if match:
                webhook_id = match.group(1)
                run_ssh_command(f"repo webhook delete {TEST_REPO} {webhook_id}")


class TestLoopbackAddressBlocking:
    """Test that loopback addresses are blocked."""

    def test_localhost_url_blocked(self):
        """Webhook with localhost URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://localhost:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"localhost URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_127_0_0_1_url_blocked(self):
        """Webhook with 127.0.0.1 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://127.0.0.1:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"127.0.0.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_127_x_x_x_url_blocked(self):
        """Webhook with any 127.x.x.x URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://127.1.2.3:9000/hook --events push"
        )
        assert is_url_blocked(result), \
            f"127.1.2.3 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_localhost_localdomain_blocked(self):
        """Webhook with localhost.localdomain should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://localhost.localdomain/hook --events push"
        )
        assert is_url_blocked(result), \
            f"localhost.localdomain URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_subdomain_localhost_blocked(self):
        """Webhook with *.localhost should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://foo.localhost/hook --events push"
        )
        assert is_url_blocked(result), \
            f"foo.localhost URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


class TestPrivateIPRangeBlocking:
    """Test that private IP ranges are blocked."""

    def test_10_x_x_x_blocked(self):
        """Webhook with 10.0.0.0/8 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://10.0.0.1:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"10.0.0.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_10_255_x_x_blocked(self):
        """Webhook with 10.255.x.x URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://10.255.255.1/hook --events push"
        )
        assert is_url_blocked(result), \
            f"10.255.255.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_172_16_x_x_blocked(self):
        """Webhook with 172.16.0.0/12 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://172.16.0.1:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"172.16.0.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_172_31_x_x_blocked(self):
        """Webhook with 172.31.x.x URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://172.31.255.255/hook --events push"
        )
        assert is_url_blocked(result), \
            f"172.31.255.255 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_192_168_x_x_blocked(self):
        """Webhook with 192.168.0.0/16 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://192.168.1.1:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"192.168.1.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_192_168_0_1_blocked(self):
        """Webhook with 192.168.0.1 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://192.168.0.1/hook --events push"
        )
        assert is_url_blocked(result), \
            f"192.168.0.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


class TestLinkLocalBlocking:
    """Test that link-local addresses (169.254.x.x) are blocked."""

    def test_aws_metadata_endpoint_blocked(self):
        """Webhook with AWS metadata endpoint should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://169.254.169.254/latest/meta-data/ --events push"
        )
        assert is_url_blocked(result), \
            f"AWS metadata URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_link_local_address_blocked(self):
        """Webhook with link-local address should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://169.254.1.1/hook --events push"
        )
        assert is_url_blocked(result), \
            f"Link-local URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_azure_metadata_endpoint_blocked(self):
        """Webhook with Azure metadata endpoint should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://169.254.169.254/metadata/instance --events push"
        )
        assert is_url_blocked(result), \
            f"Azure metadata URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


class TestSpecialAddressBlocking:
    """Test that special/reserved addresses are blocked."""

    def test_0_0_0_0_blocked(self):
        """Webhook with 0.0.0.0 URL should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://0.0.0.0:8080/hook --events push"
        )
        assert is_url_blocked(result), \
            f"0.0.0.0 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_shared_address_space_blocked(self):
        """Webhook with 100.64.0.0/10 (shared address space) should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://100.64.0.1/hook --events push"
        )
        assert is_url_blocked(result), \
            f"100.64.0.1 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_shared_address_upper_bound_blocked(self):
        """Webhook with 100.127.x.x should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} http://100.127.255.255/hook --events push"
        )
        assert is_url_blocked(result), \
            f"100.127.255.255 URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


class TestWebhookUpdateBlocking:
    """Test that URL validation also applies to webhook updates."""

    def test_update_to_localhost_blocked(self):
        """Updating a webhook to use localhost should be rejected."""
        import re
        # First create with valid URL
        create_result = run_ssh_command(
            f"repo webhook create {TEST_REPO} https://example.com/hook-update1 --events push"
        )

        # Get webhook ID - parse the table output format
        list_result = run_ssh_command(f"repo webhook list {TEST_REPO}")
        webhook_id = None
        for line in list_result.stdout.strip().split("\n"):
            if "example.com/hook-update1" in line:
                # Parse ID from table format: │ID│URL│... (with possible whitespace)
                match = re.search(r'│\s*(\d+)\s*│', line)
                if match:
                    webhook_id = match.group(1)
                    break

        assert webhook_id is not None, f"Could not find webhook ID in output: {list_result.stdout}"

        # Try to update to localhost
        update_result = run_ssh_command(
            f"repo webhook update {TEST_REPO} {webhook_id} --url http://localhost:8080/hook"
        )
        assert is_url_blocked(update_result), \
            f"Update to localhost URL was accepted but should be blocked. stdout: {update_result.stdout}, stderr: {update_result.stderr}"

    def test_update_to_private_ip_blocked(self):
        """Updating a webhook to use private IP should be rejected."""
        import re
        # First create with valid URL
        create_result = run_ssh_command(
            f"repo webhook create {TEST_REPO} https://example.org/webhook-update2 --events push"
        )

        # Get webhook ID - parse the table output format
        list_result = run_ssh_command(f"repo webhook list {TEST_REPO}")
        webhook_id = None
        for line in list_result.stdout.strip().split("\n"):
            if "example.org/webhook-update2" in line:
                # Parse ID from table format: │ID│URL│... (with possible whitespace)
                match = re.search(r'│\s*(\d+)\s*│', line)
                if match:
                    webhook_id = match.group(1)
                    break

        assert webhook_id is not None, f"Could not find webhook ID in output: {list_result.stdout}"

        # Try to update to private IP
        update_result = run_ssh_command(
            f"repo webhook update {TEST_REPO} {webhook_id} --url http://192.168.1.100/hook"
        )
        assert is_url_blocked(update_result), \
            f"Update to private IP URL was accepted but should be blocked. stdout: {update_result.stdout}, stderr: {update_result.stderr}"


class TestInvalidSchemes:
    """Test that invalid URL schemes are rejected."""

    def test_file_scheme_blocked(self):
        """Webhook with file:// scheme should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} file:///etc/passwd --events push"
        )
        assert is_url_blocked(result) or result.returncode != 0, \
            f"file:// URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_ftp_scheme_blocked(self):
        """Webhook with ftp:// scheme should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} ftp://example.com/file --events push"
        )
        assert is_url_blocked(result) or result.returncode != 0, \
            f"ftp:// URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_gopher_scheme_blocked(self):
        """Webhook with gopher:// scheme should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} gopher://example.com/ --events push"
        )
        assert is_url_blocked(result) or result.returncode != 0, \
            f"gopher:// URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


class TestIPv6Blocking:
    """Test that IPv6 loopback and private addresses are blocked."""

    def test_ipv6_loopback_blocked(self):
        """Webhook with IPv6 loopback (::1) should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} 'http://[::1]:8080/hook' --events push"
        )
        assert is_url_blocked(result), \
            f"IPv6 loopback URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"

    def test_ipv6_mapped_localhost_blocked(self):
        """Webhook with IPv6-mapped localhost should be rejected."""
        result = run_ssh_command(
            f"repo webhook create {TEST_REPO} 'http://[::ffff:127.0.0.1]:8080/hook' --events push"
        )
        # This might not parse correctly, but should still fail
        assert is_url_blocked(result) or result.returncode != 0, \
            f"IPv6-mapped localhost URL was accepted but should be blocked. stdout: {result.stdout}, stderr: {result.stderr}"


