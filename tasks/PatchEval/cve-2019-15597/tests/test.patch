diff --git a/poc/node-df.test.js b/poc/node-df.test.js
new file mode 100644
index 0000000..70432e1
--- /dev/null
+++ b/poc/node-df.test.js
@@ -0,0 +1,52 @@
+const fs = require("fs");
+const PATH = "./node-df";
+
+describe("node-df command injection test", () => {
+  beforeEach(() => {
+    try {
+      if (fs.existsSync(PATH)) {
+        fs.unlinkSync(PATH);
+      }
+    } catch (e) {
+      // ignore cleanup errors
+    }
+  });
+
+  test("should not allow command injection via options.file", async () => {
+    expect.assertions(2);
+    const df = require("node-df");
+
+    // precondition: file does not exist
+    expect(fs.existsSync(PATH)).toBe(false);
+
+    const options = {
+      file: "/;touch node-df",
+      prefixMultiplier: "GB",
+      isDisplayPrefixMultiplier: true,
+      precision: 2,
+    };
+
+    // adapt callback API to promise so we can await completion
+    await new Promise((resolve) => {
+      df(options, () => {
+        resolve();
+      });
+    });
+
+    const existsAfter = fs.existsSync(PATH);
+
+    // Before fix (vulnerable): expect(existsAfter).toBe(true);
+    // After fix (secure): expect(existsAfter).toBe(false);
+    expect(existsAfter).toBe(false);
+
+    // cleanup if test environment created the file
+    try {
+      if (fs.existsSync(PATH)) {
+        fs.unlinkSync(PATH);
+      }
+    } catch (e) {
+      // ignore
+    }
+  });
+});
+
diff --git a/lib/__tests__/index.spec.js b/lib/__tests__/index.spec.js
new file mode 100644
index 0000000..89ec000
--- /dev/null
+++ b/lib/__tests__/index.spec.js
@@ -0,0 +1,39 @@
+// lib/__tests__/index-file.spec.js
+const df = require('../index');
+const child_process = require('child_process');
+const parse = require('../parse');
+
+jest.mock('child_process');
+jest.mock('../parse');
+
+describe('df module - file option test after 2019-15597 fix', () => {
+    beforeEach(() => {
+        parse.mockImplementation((stdout, options) => {
+            return [{ filesystem: 'mock', size: 100 }];
+        });
+        child_process.exec.mockImplementation((cmd, cb) => {
+            cb(null, 'mock stdout', '');
+        });
+    });
+
+    afterEach(() => {
+        jest.resetAllMocks();
+    });
+
+    it('should allow options.file in the normal flow', done => {
+        const options = { file: '/dev/sda1' };
+        df(options, (err, result) => {
+            if (err) {
+                // If the file option is rejected, the test should fail
+                done.fail('options.file was rejected: ' + err.message);
+            } else {
+                expect(result).toBeDefined();
+                expect(Array.isArray(result)).toBe(true);
+                expect(result.length).toBeGreaterThan(0);
+                done();
+            }
+        });
+    });
+});
+
+
