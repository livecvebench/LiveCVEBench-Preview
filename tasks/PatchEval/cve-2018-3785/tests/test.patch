diff --git a/poc/git-dummy-commit.test.js b/poc/git-dummy-commit.test.js
new file mode 100644
index 0000000..83c6b63
--- /dev/null
+++ b/poc/git-dummy-commit.test.js
@@ -0,0 +1,62 @@
+// tests/git-dummy-commit.command-injection.test.js
+const fs = require('fs');
+const pathStr = './git-dummy-commit';
+
+test('Command injection should NOT create files (fix should make this pass)', (done) => {
+  expect.assertions(2);
+
+  // cleanup before test
+  try {
+    if (fs.existsSync(pathStr)) fs.unlinkSync(pathStr);
+  } catch (e) {
+    // ignore cleanup errors
+  }
+
+  // 1) file must not exist before call
+  expect(fs.existsSync(pathStr)).toBe(false);
+
+  // require the module under test
+  const gitDummyCommit = require('git-dummy-commit');
+
+  // payload used in the original PoC
+  const payload = '";touch git-dummy-commit;"';
+
+  let finished = false;
+
+  // call the module; support sync, promise, or callback styles
+  try {
+    const result = gitDummyCommit(payload);
+
+    if (result && typeof result.then === 'function') {
+      result
+        .then(() => finalize())
+        .catch(() => finalize());
+      return;
+    }
+  } catch (e) {
+    // ignore synchronous errors and proceed to finalize
+  }
+
+  // fallback: wait briefly for any asynchronous side effects, then finalize
+  setTimeout(() => {
+    if (!finished) finalize();
+  }, 200);
+
+  function finalize() {
+    finished = true;
+    const existsAfter = fs.existsSync(pathStr);
+
+    // cleanup if created by vulnerable code
+    try {
+      if (existsAfter) fs.unlinkSync(pathStr);
+    } catch (e) {
+      // ignore cleanup errors
+    }
+
+    // 2) expectation: file should NOT be created (fix -> test passes)
+    expect(existsAfter).toBe(false);
+
+    done();
+  }
+});
+
