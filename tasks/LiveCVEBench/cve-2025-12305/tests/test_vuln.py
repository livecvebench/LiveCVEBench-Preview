"""
Vulnerability tests for shiyi-blog scheduled task arbitrary class instantiation.
These tests verify that the vulnerability is properly mitigated.

BEFORE FIX: These tests should FAIL (vulnerability is exploitable)
AFTER FIX: These tests should PASS (vulnerability is blocked)
"""
import pytest
import requests
import time
import subprocess
import os


BASE_URL = "http://localhost:8800/shiyi"

# Default admin credentials
ADMIN_USERNAME = "admin"
ADMIN_PASSWORD = "123456"

# Use an existing job ID from the database (must exist in b_job table)
# The exploit works by sending a request with an existing jobId but malicious invokeTarget
EXISTING_JOB_ID = 1
EXISTING_JOB_GROUP = "DEFAULT"

# Delay between requests to avoid rate limiting (code 8002)
REQUEST_DELAY = 3.0


@pytest.fixture(scope="module")
def auth_headers():
    """Get authentication headers for API requests"""
    login_url = f"{BASE_URL}/login"
    payload = {
        "username": ADMIN_USERNAME,
        "password": ADMIN_PASSWORD,
        "rememberMe": False
    }

    for attempt in range(5):
        try:
            response = requests.post(login_url, json=payload, timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get("code") == 200 or data.get("success"):
                    # Token is returned directly in data field as a string
                    token = data.get("data")
                    if token and isinstance(token, str):
                        return {"Authorization": token}
                    elif token and isinstance(token, dict):
                        return {"Authorization": token.get("token")}
        except requests.exceptions.RequestException:
            time.sleep(2)

    pytest.skip("Could not authenticate with admin credentials")


@pytest.fixture(autouse=True)
def rate_limit_delay():
    """Add delay before each test to avoid rate limiting"""
    time.sleep(REQUEST_DELAY)


class TestArbitraryClassInstantiation:
    """
    Test that arbitrary class instantiation is blocked.
    The vulnerability allows instantiating any class via Class.forName().
    """

    def test_snakeyaml_class_instantiation_blocked(self, auth_headers):
        """
        Test that org.yaml.snakeyaml.Yaml cannot be instantiated via invoke target.
        This is the primary attack vector for RCE via SnakeYAML deserialization.
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "org.yaml.snakeyaml.Yaml.load('test')"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        # After fix: Should return error indicating unauthorized class
        # The response should indicate the request was blocked
        response_text = response.text.lower()

        # Check for security exception indicators
        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        assert is_blocked, (
            f"Arbitrary class instantiation was not blocked. "
            f"Response: {response.text[:500]}"
        )

    def test_runtime_class_instantiation_blocked(self, auth_headers):
        """
        Test that java.lang.Runtime cannot be instantiated.
        This would allow direct command execution.
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "java.lang.Runtime.getRuntime()"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        assert is_blocked, (
            f"Runtime class instantiation was not blocked. "
            f"Response: {response.text[:500]}"
        )

    def test_processbuilder_class_instantiation_blocked(self, auth_headers):
        """
        Test that java.lang.ProcessBuilder cannot be instantiated.
        This would allow command execution.
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "java.lang.ProcessBuilder.command('id')"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        assert is_blocked, (
            f"ProcessBuilder class instantiation was not blocked. "
            f"Response: {response.text[:500]}"
        )


class TestSnakeYAMLGadgetChain:
    """
    Test that SnakeYAML-based gadget chains are blocked.
    These tests specifically target the CVE's exploitation method.
    """

    def test_scriptenginemanager_gadget_blocked(self, auth_headers):
        """
        Test that ScriptEngineManager gadget chain is blocked.
        This is the actual RCE payload format.
        """
        # This payload format is used to load malicious JARs
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager')"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        assert is_blocked, (
            f"SnakeYAML gadget chain was not blocked. "
            f"Response: {response.text[:500]}"
        )

    def test_urlclassloader_gadget_blocked(self, auth_headers):
        """
        Test that URLClassLoader gadget is blocked.
        This is used to load remote malicious classes.
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "org.yaml.snakeyaml.Yaml.load('!!java.net.URLClassLoader')"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        assert is_blocked, (
            f"URLClassLoader gadget was not blocked. "
            f"Response: {response.text[:500]}"
        )


class TestVariousClassInstantiationVectors:
    """
    Test various potentially dangerous classes that could be instantiated.
    Reduced test set to avoid rate limiting while still testing key attack vectors.
    """

    @pytest.mark.parametrize("dangerous_class", [
        # Core Java dangerous classes
        "java.io.FileOutputStream.write()",
        "java.io.FileInputStream.read()",
        # Reflection/classloading vectors
        "java.lang.ClassLoader.loadClass('test')",
    ])
    def test_dangerous_class_blocked(self, auth_headers, dangerous_class):
        """
        Test that various dangerous classes cannot be instantiated.
        AFTER FIX: Should return security-related error (test passes)
        BEFORE FIX: Will attempt class instantiation (test fails)
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": dangerous_class
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        # Check for explicit security blocking indicators
        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text or
            "denied" in response_text or
            "forbidden" in response_text or
            "whitelist" in response_text
        )

        # In fixed state, security-related blocking should occur
        # In vulnerable state, the class instantiation is attempted (no security block)
        assert is_blocked, (
            f"Class {dangerous_class} was not properly blocked. "
            f"Response: {response.text[:500]}"
        )


class TestBypassAttempts:
    """
    Test that various bypass attempts are also blocked.
    Limited to one test to avoid rate limiting accumulation.
    """

    def test_nested_class_instantiation_blocked(self, auth_headers):
        """
        Test that nested/inner class references are blocked.
        """
        malicious_payload = {
            "jobId": EXISTING_JOB_ID,
            "jobGroup": EXISTING_JOB_GROUP,
            "invokeTarget": "org.yaml.snakeyaml.Yaml$SafeConstructor.construct()"
        }

        response = requests.post(
            f"{BASE_URL}/system/job/run",
            headers=auth_headers,
            json=malicious_payload,
            timeout=15
        )

        response_text = response.text.lower()

        is_blocked = (
            "security" in response_text or
            "unauthorized" in response_text or
            "not allowed" in response_text
        )

        assert is_blocked, (
            f"Nested class instantiation was not blocked. "
            f"Response: {response.text[:500]}"
        )
