"""
Vulnerability tests for i-Educar enrollment listing page.
These tests verify that XSS payloads are properly sanitized.

Expected behavior:
- FAIL in vulnerable state (payloads appear unescaped in HTML)
- PASS in fixed state (payloads are sanitized/cast to integers)
"""

import pytest
import requests
import time
import re
import os
import urllib.parse

BASE_URL = os.environ.get("BASE_URL", "http://localhost")
LOGIN_URL = f"{BASE_URL}/login"
TARGET_URL = f"{BASE_URL}/intranet/educar_matricula_lst.php"

# Default credentials
USERNAME = os.environ.get("TEST_USERNAME", "admin")
PASSWORD = os.environ.get("TEST_PASSWORD", "123456789")


class TestSession:
    """Shared session for authenticated tests."""
    _session = None
    _cookies = None

    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            cls._cookies = cls._authenticate()
        return cls._session, cls._cookies

    @classmethod
    def _authenticate(cls):
        """Authenticate and return session cookies."""
        session = cls._session

        # Get login page to obtain CSRF token
        response = session.get(LOGIN_URL, timeout=30)

        csrf_token = None

        # Check for Laravel CSRF token in cookies
        if 'XSRF-TOKEN' in session.cookies:
            csrf_token = session.cookies['XSRF-TOKEN']

        # Check for token in HTML meta tag
        if csrf_token is None and 'csrf-token' in response.text:
            match = re.search(r'<meta name="csrf-token" content="([^"]+)"', response.text)
            if match:
                csrf_token = match.group(1)

        # Check for _token in form
        if csrf_token is None and '_token' in response.text:
            match = re.search(r'name="_token"[^>]*value="([^"]+)"', response.text)
            if match:
                csrf_token = match.group(1)

        # Attempt login
        login_data = {
            "login": USERNAME,
            "password": PASSWORD,
        }

        if csrf_token:
            login_data["_token"] = csrf_token

        headers = {}
        if csrf_token:
            headers["X-XSRF-TOKEN"] = csrf_token

        login_response = session.post(
            LOGIN_URL,
            data=login_data,
            headers=headers,
            allow_redirects=True,
            timeout=30
        )

        return session.cookies


@pytest.fixture(scope="module")
def auth_session():
    """Provide an authenticated session for tests."""
    return TestSession.get_session()


def wait_for_app(max_retries=30, delay=2):
    """Wait for the application to be ready."""
    for _ in range(max_retries):
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code in [200, 302, 301]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


def contains_unescaped_payload(response_text, payload):
    """
    Check if the payload appears unescaped in the response.
    The payload is vulnerable if it appears in HTML without proper encoding.
    """
    # Check for the exact payload in the response
    if payload in response_text:
        return True

    # Also check for URL-decoded version if payload was encoded
    decoded = urllib.parse.unquote(payload)
    if decoded != payload and decoded in response_text:
        return True

    return False


def has_dangerous_html(response_text):
    """Check for dangerous HTML patterns that indicate XSS."""
    dangerous_patterns = [
        r'<script[^>]*>',           # Script tags
        r'onerror\s*=',              # Event handlers
        r'onload\s*=',
        r'onmouseover\s*=',
        r'onclick\s*=',
        r'onfocus\s*=',
        r'javascript:',              # JavaScript protocol
        r'<svg[^>]*onload',          # SVG with onload
        r'<img[^>]*onerror',         # IMG with onerror
    ]

    for pattern in dangerous_patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            # Make sure it's in a value context (reflected from input)
            # not just in legitimate application code
            # Check if it's in a value attribute or similar
            return True

    return False


class TestXSSBasicPayloads:
    """Test basic XSS injection payloads."""

    def test_script_tag_injection(self, auth_session):
        """Test that basic script tag injection is blocked."""
        session, cookies = auth_session

        payload = '"><script>alert("XSS")</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        # Payload should NOT appear in response (either escaped or sanitized)
        assert payload not in response.text, \
            f"XSS payload found unescaped in response: {payload}"

        # Check that script tag is not present
        assert '<script>alert("XSS")</script>' not in response.text, \
            "Script tag injection was not blocked"

    def test_script_tag_with_single_quotes(self, auth_session):
        """Test script tag with single quotes."""
        session, cookies = auth_session

        payload = "'><script>alert('XSS')</script>"

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert "<script>alert('XSS')</script>" not in response.text, \
            "Script tag injection with single quotes was not blocked"

    def test_simple_script_tag(self, auth_session):
        """Test simple script tag without attribute breaking."""
        session, cookies = auth_session

        payload = '<script>alert(1)</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert payload not in response.text, \
            f"Simple script tag found in response: {payload}"


class TestXSSEventHandlers:
    """Test event handler based XSS payloads."""

    def test_img_onerror_injection(self, auth_session):
        """Test img tag with onerror event handler."""
        session, cookies = auth_session

        payload = '"><img src=x onerror=alert("XSS")>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        # Check that onerror is not reflected
        assert 'onerror=alert("XSS")' not in response.text, \
            "IMG onerror injection was not blocked"

        assert 'onerror=' not in response.text.lower() or \
               payload not in response.text, \
            "Event handler found in response"

    def test_svg_onload_injection(self, auth_session):
        """Test SVG tag with onload event handler."""
        session, cookies = auth_session

        payload = '"><svg onload=alert("XSS")>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'onload=alert("XSS")' not in response.text, \
            "SVG onload injection was not blocked"

    def test_body_onload_injection(self, auth_session):
        """Test body tag with onload event handler."""
        session, cookies = auth_session

        payload = '"><body onload=alert("XSS")>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'onload=alert("XSS")' not in response.text, \
            "Body onload injection was not blocked"

    def test_div_onmouseover_injection(self, auth_session):
        """Test onmouseover event handler."""
        session, cookies = auth_session

        payload = '" onmouseover="alert(\'XSS\')" x="'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'onmouseover="alert(\'XSS\')"' not in response.text, \
            "onmouseover injection was not blocked"


class TestXSSEncodingBypass:
    """Test encoded XSS payloads and bypass attempts."""

    def test_html_encoded_payload(self, auth_session):
        """Test that HTML special chars are properly escaped in output."""
        session, cookies = auth_session

        # Send a double-quote which should be escaped to &quot; in proper output
        payload = '"><script>alert("encoded")</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        # If vulnerable, the raw < and > will appear unescaped
        assert '<script>alert("encoded")</script>' not in response.text, \
            "HTML encoding bypass - payload not properly escaped"

    def test_mixed_case_script_tag(self, auth_session):
        """Test mixed case script tag to bypass filters."""
        session, cookies = auth_session

        payload = '"><ScRiPt>alert("XSS")</ScRiPt>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        # Case-insensitive check for script tag
        assert not re.search(r'<script>alert\("XSS"\)</script>', response.text, re.IGNORECASE), \
            "Mixed case script injection was not blocked"

    def test_null_byte_injection(self, auth_session):
        """Test null byte in payload."""
        session, cookies = auth_session

        payload = '"><scr\x00ipt>alert("XSS")</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'alert("XSS")' not in response.text, \
            "Null byte injection bypass was not blocked"


class TestXSSContextSpecific:
    """Test context-specific XSS payloads."""

    def test_javascript_url_scheme(self, auth_session):
        """Test javascript: URL scheme injection."""
        session, cookies = auth_session

        payload = 'javascript:alert("XSS")'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert payload not in response.text, \
            "javascript: URL scheme found in response"

    def test_data_url_scheme(self, auth_session):
        """Test data: URL scheme with script."""
        session, cookies = auth_session

        payload = 'data:text/html,<script>alert("XSS")</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert payload not in response.text, \
            "data: URL scheme with script found in response"

    def test_attribute_breaking_double_quote(self, auth_session):
        """Test breaking out of double-quoted attribute."""
        session, cookies = auth_session

        payload = '" onclick="alert(\'XSS\')" data-x="'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'onclick="alert(\'XSS\')"' not in response.text, \
            "Attribute breaking with onclick was not blocked"

    def test_attribute_breaking_single_quote(self, auth_session):
        """Test breaking out of single-quoted attribute."""
        session, cookies = auth_session

        payload = "' onclick='alert(\"XSS\")' data-x='"

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert "onclick='alert(\"XSS\")'" not in response.text, \
            "Single quote attribute breaking was not blocked"


class TestXSSInDifferentLocations:
    """Test XSS in different reflection points in the page."""

    def test_hidden_field_injection(self, auth_session):
        """Test XSS via hidden form field (campoOculto)."""
        session, cookies = auth_session

        # This targets the campoOculto() call
        payload = '"><script>alert(document.cookie)</script><input value="'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert '<script>alert(document.cookie)</script>' not in response.text, \
            "Hidden field XSS injection was not blocked"

    def test_url_parameter_injection(self, auth_session):
        """Test XSS via URL construction (array_botao_url)."""
        session, cookies = auth_session

        # This targets the URL construction in $this->array_botao_url
        payload = '1&"><script>alert(1)</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert '<script>alert(1)</script>' not in response.text, \
            "URL parameter XSS injection was not blocked"

    def test_javascript_context_injection(self, auth_session):
        """Test XSS via JavaScript context ($this->acao)."""
        session, cookies = auth_session

        # This targets: $this->acao = "go(\"educar_matricula_cad.php?ref_cod_aluno={$this->ref_cod_aluno}\")"
        payload = '1"); alert("XSS"); //'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        assert 'alert("XSS")' not in response.text, \
            "JavaScript context XSS was not blocked"


class TestIntegerSanitization:
    """Test that the fix properly sanitizes input as integers."""

    def test_payload_becomes_zero(self, auth_session):
        """Test that non-numeric payloads become 0 or are stripped."""
        session, cookies = auth_session

        payload = '"><script>alert(1)</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            allow_redirects=False,
            timeout=30
        )

        # After the fix, non-integer values should be cast to 0
        # which triggers a redirect since !$this->ref_cod_aluno
        # So we should either see a redirect or the payload should be gone
        if response.status_code == 200:
            assert '<script>' not in response.text, \
                "Script tag found in response - integer sanitization failed"

    def test_leading_number_strips_payload(self, auth_session):
        """Test that leading number with payload strips everything after."""
        session, cookies = auth_session

        # integer() should convert this to just 123
        payload = '123"><script>alert(1)</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            timeout=30
        )

        # The <script> portion should be stripped
        assert '<script>alert(1)</script>' not in response.text, \
            "Script tag after number was not stripped"

    def test_pure_text_becomes_zero(self, auth_session):
        """Test that pure text input becomes 0."""
        session, cookies = auth_session

        payload = 'abcdef<script>alert(1)</script>'

        response = session.get(
            TARGET_URL,
            params={"ref_cod_aluno": payload},
            allow_redirects=False,
            timeout=30
        )

        # Pure text should become 0 and redirect
        if response.status_code == 200:
            assert '<script>' not in response.text, \
                "Script tag found - text not properly sanitized"


class TestMassAssignmentPrevention:
    """Test that mass assignment vulnerability allows XSS via ref_cod_aluno."""

    def test_arbitrary_property_assignment_blocked(self, auth_session):
        """Test that XSS via ref_cod_aluno allows script in titulo context."""
        session, cookies = auth_session

        # The titulo property is set via mass assignment and reflected
        payload = '"><script>alert("titulo")</script>'

        response = session.get(
            TARGET_URL,
            params={
                "ref_cod_aluno": payload
            },
            timeout=30
        )

        # XSS payload in ref_cod_aluno should be blocked
        assert '<script>alert("titulo")</script>' not in response.text, \
            "XSS via ref_cod_aluno was not blocked"

    def test_only_whitelisted_params_accepted(self, auth_session):
        """Test that ref_cod_aluno XSS is properly sanitized."""
        session, cookies = auth_session

        # Test with a different XSS payload
        payload = '1"><img src=x onerror=alert("param")>'

        response = session.get(
            TARGET_URL,
            params={
                "ref_cod_aluno": payload
            },
            timeout=30
        )

        # The XSS payload should not be reflected
        assert 'onerror=alert("param")' not in response.text, \
            "XSS payload in ref_cod_aluno was not sanitized"
