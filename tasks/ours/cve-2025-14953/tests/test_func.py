"""
Functional tests for Open5GS UPF.
These tests verify the UPF works correctly and is accessible.
Should PASS in both vulnerable and fixed states.
"""
import socket
import subprocess
import time
import pytest


# Configuration
PFCP_HOST = "127.0.0.7"
PFCP_PORT = 8805
GTP_HOST = "127.0.0.7"
GTP_PORT = 2152
POC_PATH = "/poc/poc"


def is_upf_running() -> bool:
    """Check if UPF process is running."""
    try:
        result = subprocess.run(
            ["pgrep", "-f", "open5gs-upfd"],
            capture_output=True,
            timeout=5
        )
        return result.returncode == 0
    except Exception:
        return False


def get_upf_pid() -> int:
    """Get UPF process PID."""
    try:
        result = subprocess.run(
            ["pgrep", "-f", "open5gs-upfd"],
            capture_output=True,
            timeout=5,
            text=True
        )
        if result.returncode == 0:
            return int(result.stdout.strip().split('\n')[0])
    except Exception:
        pass
    return 0


def check_port_listening(host: str, port: int) -> bool:
    """Check if a UDP port is open by checking /proc/net/udp or ss."""
    try:
        result = subprocess.run(
            ["ss", "-ulnp"],
            capture_output=True,
            timeout=5,
            text=True
        )
        return f"{host}:{port}" in result.stdout or f":{port}" in result.stdout
    except Exception:
        return False


def wait_for_upf_ready(max_wait: int = 30) -> bool:
    """Wait for UPF to be ready (process running and ports listening)."""
    for _ in range(max_wait):
        if is_upf_running():
            if check_port_listening(PFCP_HOST, PFCP_PORT):
                return True
        time.sleep(1)
    return False


def run_poc_association_only() -> tuple:
    """Run PoC to establish PFCP association only (skip session/gtp)."""
    try:
        # Just test that we can reach the UPF - use nc to send a UDP packet
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(2)
        try:
            # Send a minimal packet to verify port is reachable
            sock.sendto(b"test", (PFCP_HOST, PFCP_PORT))
            return True, "UDP port reachable"
        except Exception as e:
            return False, str(e)
        finally:
            sock.close()
    except Exception as e:
        return False, str(e)


class TestUPFFunctional:
    """Functional tests for UPF."""

    def test_upf_process_running(self):
        """Test that UPF process is running."""
        assert wait_for_upf_ready(30), "UPF not ready within timeout"
        assert is_upf_running(), "UPF process is not running"

    def test_pfcp_port_listening(self):
        """Test that PFCP port (8805) is listening."""
        assert wait_for_upf_ready(30), "UPF not ready"
        assert check_port_listening(PFCP_HOST, PFCP_PORT), \
            f"PFCP port {PFCP_PORT} not listening on {PFCP_HOST}"

    def test_gtp_port_listening(self):
        """Test that GTP-U port (2152) is listening."""
        assert wait_for_upf_ready(30), "UPF not ready"
        assert check_port_listening(GTP_HOST, GTP_PORT), \
            f"GTP-U port {GTP_PORT} not listening on {GTP_HOST}"

    def test_pfcp_udp_reachable(self):
        """Test that PFCP endpoint is reachable via UDP."""
        assert wait_for_upf_ready(30), "UPF not ready"

        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(2)
        try:
            # Just verify we can send to the port
            sock.sendto(b"\x20\x01\x00\x04\x00\x00\x01\x00", (PFCP_HOST, PFCP_PORT))
            # Don't worry about response - we just verify no connection refused
        except ConnectionRefusedError:
            pytest.fail("PFCP port connection refused")
        except Exception as e:
            # Timeout is OK - it means port is open but no valid response
            pass
        finally:
            sock.close()

    def test_gtp_udp_reachable(self):
        """Test that GTP-U endpoint is reachable via UDP."""
        assert wait_for_upf_ready(30), "UPF not ready"

        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(1)
        try:
            # Just verify we can send to the port
            sock.sendto(b"\x30\xff\x00\x04\x00\x00\x00\x01test", (GTP_HOST, GTP_PORT))
        except ConnectionRefusedError:
            pytest.fail("GTP-U port connection refused")
        except Exception:
            pass
        finally:
            sock.close()

    def test_upf_survives_invalid_packet(self):
        """Test that UPF survives receiving an invalid packet."""
        assert wait_for_upf_ready(30), "UPF not ready"

        pid_before = get_upf_pid()

        # Send invalid packet
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            sock.sendto(b"invalid_data_that_is_not_pfcp", (PFCP_HOST, PFCP_PORT))
        finally:
            sock.close()

        time.sleep(1)

        # Verify UPF is still running (same PID)
        assert is_upf_running(), "UPF crashed after invalid packet"
        assert get_upf_pid() == pid_before, "UPF restarted after invalid packet"

    def test_poc_binary_exists(self):
        """Test that PoC binary is available."""
        import os
        assert os.path.exists(POC_PATH), f"PoC binary not found at {POC_PATH}"
        assert os.access(POC_PATH, os.X_OK), f"PoC binary not executable"
