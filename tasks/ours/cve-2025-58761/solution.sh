#!/bin/bash
set -e

echo "[*] Starting Final Patch (Indentation Fix)..."

# ------------------------------------------------------------------------------
# 1. 修复 helpers.py (保持不变，这部分是好的)
# ------------------------------------------------------------------------------
HELPERS="/app/plexpy/helpers.py"
if grep -q "def is_subdir" "$HELPERS"; then
    echo "[+] helpers.py already patched."
else
    cat >> "$HELPERS" <<EOF

# [Security Fix] Added for CVE-2025-58761
import os
def is_subdir(child, parent):
    child = os.path.abspath(child)
    parent = os.path.abspath(parent)
    return os.path.commonpath([parent]) == os.path.commonpath([parent, child])
EOF
    echo "[+] Patched helpers.py"
fi

# ------------------------------------------------------------------------------
# 2. 修复 webserve.py (关键修正：在锚点中包含缩进)
# ------------------------------------------------------------------------------
cat << 'EOF' > /app/patcher.py
import os

TARGET_FILE = '/app/plexpy/webserve.py'

# 1. 定义带有正确缩进的替换代码 (开头 4 空格)
SECURE_PROXY_FUNC = r'''    @addtoapi('pms_image_proxy')
    def real_pms_image_proxy(self, img=None, rating_key=None, width=750, height=1000,
                             opacity=100, background='000000', blur=0, img_format='png',
                             fallback=None, refresh=False, clip=False, **kwargs):
        """ Gets an image from the PMS and saves it to the image cache directory. """
        cherrypy.response.headers['Cache-Control'] = 'max-age=2592000'  # 30 days

        if isinstance(img, str) and img.startswith('interfaces/default/images'):
            resource_dir = os.path.join(plexpy.PROG_DIR, 'data/interfaces/default/images')
            img_path = os.path.join(plexpy.PROG_DIR, 'data', img)
            if not helpers.is_subdir(img_path, resource_dir):
                return

            ext = img.rsplit(".", 1)[-1]
            if ext == 'svg':
                content_type = 'image/svg+xml'
            else:
                content_type = 'image/{}'.format(ext)
            return serve_file(path=img_path, content_type=content_type)

        if not img and not rating_key:
            if fallback in common.DEFAULT_IMAGES:
                fbi = common.DEFAULT_IMAGES[fallback]
                fp = os.path.join(plexpy.PROG_DIR, 'data', fbi)
                return serve_file(path=fp, content_type='image/png')
            logger.warn('No image input received.')
            return

        return_hash = helpers.bool_true(kwargs.get('return_hash'))

        if rating_key and not img:
            if fallback and fallback.startswith('art'):
                img = '/library/metadata/{}/art'.format(rating_key)
            else:
                img = '/library/metadata/{}/thumb'.format(rating_key)

        if img and not img.startswith('http'):
            parts = 5
            if img.startswith('/playlists'):
                parts -= 1
            rating_key_idx = parts - 2
            parts += int('composite' in img)
            img_split = img.split('/')
            img = '/'.join(img_split[:parts])
            img_rating_key = img_split[rating_key_idx]
            if rating_key != img_rating_key:
                rating_key = img_rating_key

        img_hash = notification_handler.set_hash_image_info(
            img=img, rating_key=rating_key, width=width, height=height,
            opacity=opacity, background=background, blur=blur, fallback=fallback,
            add_to_db=return_hash)

        if return_hash:
            return {'img_hash': img_hash}

        fp = '{}.{}'.format(img_hash, img_format)
        c_dir = os.path.join(plexpy.CONFIG.CACHE_DIR, 'images')
        ffp = os.path.join(c_dir, fp)

        if not os.path.exists(c_dir):
            os.mkdir(c_dir)

        clip = helpers.bool_true(clip)

        try:
            if not plexpy.CONFIG.CACHE_IMAGES or refresh or 'indexes' in img:
                raise NotFound

            return serve_file(path=ffp, content_type='image/png')

        except NotFound:
            try:
                pms_connect = pmsconnect.PmsConnect()
                pms_connect.request_handler._silent = True
                result = pms_connect.get_image(img=img, width=width, height=height, opacity=opacity, background=background, blur=blur, img_format=img_format, clip=clip, refresh=refresh)

                if result and result[0]:
                    cherrypy.response.headers['Content-type'] = result[1]
                    if plexpy.CONFIG.CACHE_IMAGES and 'indexes' not in img:
                        with open(ffp, 'wb') as f:
                            f.write(result[0])
                    return result[0]
                else:
                    raise Exception('PMS image request failed')

            except Exception as e:
                logger.warn("Failed to get image %s, falling back to %s." % (img, fallback))
                cherrypy.response.headers['Cache-Control'] = "max-age=0,no-cache,no-store"
                if fallback in common.DEFAULT_IMAGES:
                    fbi = common.DEFAULT_IMAGES[fallback]
                    fp = os.path.join(plexpy.PROG_DIR, 'data', fbi)
                    return serve_file(path=fp, content_type='image/png')
                elif fallback:
                    return self.real_pms_image_proxy(
                        img=fallback, rating_key=None, width=width, height=height,
                        opacity=opacity, background=background, blur=blur, img_format=img_format,
                        fallback=None, refresh=refresh, clip=clip, **kwargs)'''

SECURE_IMAGE_FUNC = r'''    @cherrypy.expose
    def image(self, *args, **kwargs):
        if args:
            cherrypy.response.headers['Cache-Control'] = 'max-age=3600'

            if len(args) >= 2 and args[0] == 'images':
                resource_dir = os.path.join(plexpy.PROG_DIR, 'data/interfaces/default')
                img_path = os.path.join(resource_dir, *args)
                if not helpers.is_subdir(img_path, resource_dir):
                    return

                try:
                    return serve_file(path=img_path, content_type='image/png')
                except NotFound:
                    return

            img_hash = args[0].split('.')[0]

            if img_hash in common.DEFAULT_IMAGES:
                fbi = common.DEFAULT_IMAGES[img_hash]
                fp = os.path.join(plexpy.PROG_DIR, 'data', fbi)
                return serve_file(path=fp, content_type='image/png')

            img_info = notification_handler.get_hash_image_info(img_hash=img_hash)

            if img_info:
                kwargs.update(img_info)
                return self.real_pms_image_proxy(refresh=True, **kwargs)

        return'''

def apply_patch():
    print(f"[*] Reading {TARGET_FILE}...")
    with open(TARGET_FILE, 'r', encoding='utf-8') as f:
        content = f.read()

    # 【重要修改】Marker 现在包含前面的 4 个空格缩进
    # 这样 split 的时候就会把这 4 个空格“吃掉”，避免拼接时双重缩进
    
    # Marker 1: real_pms_image_proxy 开始
    marker_1 = "    @addtoapi('pms_image_proxy')"
    
    # Marker 2: image 函数开始 (作为 proxy 的结束)
    marker_2 = "    @cherrypy.expose\n    def image(self, *args, **kwargs):"
    
    # Marker 3: download_config 开始 (作为 image 的结束)
    marker_3 = "    @cherrypy.expose\n    @requireAuth(member_of(\"admin\"))\n    @addtoapi()\n    def download_config"

    if marker_1 not in content:
        print("[-] Error: marker_1 not found!")
        return

    # 1. 切割头部 (保留到 proxy 函数之前)
    part1, rest = content.split(marker_1, 1)
    
    # 2. 切割中间 (去掉旧的 proxy 函数，找到 image 函数的位置)
    if marker_2 not in rest:
        print("[-] Error: marker_2 not found!")
        return
    _, rest2 = rest.split(marker_2, 1)

    # 3. 切割尾部 (去掉旧的 image 函数，找到 download_config 的位置)
    if marker_3 not in rest2:
        print("[-] Error: marker_3 not found!")
        return
    _, part3 = rest2.split(marker_3, 1)

    # 4. 拼接
    # part1: 头部
    # SECURE_PROXY_FUNC: 新的 proxy (自带4空格缩进)
    # SECURE_IMAGE_FUNC: 新的 image (自带4空格缩进)
    # marker_3: 因为 split 把 marker_3 吃掉了，我们要把它补回来 (自带4空格缩进)
    # part3: 尾部
    
    new_content = part1 + SECURE_PROXY_FUNC + "\n\n" + SECURE_IMAGE_FUNC + "\n\n" + marker_3 + part3

    print(f"[*] Writing patched content to {TARGET_FILE}...")
    with open(TARGET_FILE, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("[+] Success: File patched with correct indentation.")

if __name__ == "__main__":
    apply_patch()
EOF

python3 /app/patcher.py
rm /app/patcher.py

echo "[*] Waiting for autoreload..."
sleep 5
echo "[*] Done."