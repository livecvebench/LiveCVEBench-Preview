"""
Vulnerability tests for the WebSocket server.
Tests that verify the integer underflow vulnerability is fixed.

These tests:
- FAIL when vulnerability exists (server crashes)
- PASS when vulnerability is fixed (server handles gracefully)
"""

import socket
import time
import base64
import struct
import subprocess
import pytest
import os
import signal


HOST = "localhost"
PORT = 8000


def websocket_handshake(sock):
    """
    Perform WebSocket handshake with the server.
    Returns True if handshake successful, False otherwise.
    """
    key = base64.b64encode(b"thisis16byteskey").decode()
    request = (
        f"GET /websocket HTTP/1.1\r\n"
        f"Host: {HOST}:{PORT}\r\n"
        f"Upgrade: websocket\r\n"
        f"Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {key}\r\n"
        f"Sec-WebSocket-Version: 13\r\n"
        f"\r\n"
    )
    sock.send(request.encode())
    response = sock.recv(1024)
    return b"101" in response and b"Switching Protocols" in response


def create_websocket_frame(payload, opcode, fin=True, mask=True):
    """
    Create a WebSocket frame.

    Args:
        payload: bytes - The payload data
        opcode: int - Frame opcode
        fin: bool - FIN bit
        mask: bool - Whether to mask the frame

    Returns:
        bytes - The complete WebSocket frame
    """
    frame = bytearray()

    # First byte: FIN + opcode
    first_byte = (0x80 if fin else 0x00) | opcode
    frame.append(first_byte)

    # Second byte: MASK + payload length
    payload_len = len(payload)
    mask_bit = 0x80 if mask else 0x00

    if payload_len < 126:
        frame.append(mask_bit | payload_len)
    elif payload_len < 65536:
        frame.append(mask_bit | 126)
        frame.extend(struct.pack(">H", payload_len))
    else:
        frame.append(mask_bit | 127)
        frame.extend(struct.pack(">Q", payload_len))

    # Add mask key and masked payload if masking
    if mask:
        mask_key = bytes([0x12, 0x34, 0x56, 0x78])
        frame.extend(mask_key)
        masked_payload = bytes(p ^ mask_key[i % 4] for i, p in enumerate(payload))
        frame.extend(masked_payload)
    else:
        frame.extend(payload)

    return bytes(frame)


def wait_for_server(host=HOST, port=PORT, timeout=10):
    """Wait for the server to be ready."""
    start = time.time()
    while time.time() - start < timeout:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            sock.connect((host, port))
            sock.close()
            return True
        except (socket.error, ConnectionRefusedError):
            time.sleep(0.5)
    return False


def is_server_running(host=HOST, port=PORT):
    """Check if server is currently running."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        sock.connect((host, port))
        sock.close()
        return True
    except (socket.error, ConnectionRefusedError):
        return False


def send_malicious_continue_frame(sock, payload=b""):
    """
    Send a CONTINUE frame (opcode 0x0) as the first frame.
    This triggers the vulnerability when ofs=0.

    CRITICAL: The vulnerability ONLY triggers with EMPTY payload.
    When payload has data, ofs becomes > 0 and the underflow doesn't occur.

    The frame has:
    - FIN=1 (final frame)
    - opcode=0 (CONTINUE)
    - EMPTY payload (to keep ofs=0)
    - This is sent without any preceding non-final frames
    """
    # opcode 0x0 = CONTINUE, FIN=1, MUST have empty payload to trigger vuln
    frame = create_websocket_frame(payload, opcode=0x0, fin=True, mask=True)
    sock.send(frame)


class TestContinueFrameVulnerability:
    """
    Test the integer underflow vulnerability caused by sending
    a CONTINUE frame as the first frame (without preceding fragments).
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before each test."""
        assert wait_for_server(), "Server is not running"

    def test_continue_frame_as_first_frame_empty_payload(self):
        """
        Send a CONTINUE frame with empty payload as the first frame.
        Vulnerable server: crashes due to integer underflow (ofs - 1 when ofs = 0)
        Fixed server: handles gracefully, connection remains usable
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send CONTINUE frame with FIN=1 and empty payload
            frame = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame)

            time.sleep(1)

            # Verify server is still running
            assert is_server_running(), "Server crashed after malicious frame"

            # Try to establish a new connection to confirm server is alive
            test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            test_sock.settimeout(3)
            try:
                test_sock.connect((HOST, PORT))
                assert websocket_handshake(test_sock), "Server not accepting new connections"
            finally:
                test_sock.close()
        finally:
            sock.close()

    def test_continue_frame_as_first_frame_with_payload(self):
        """
        Send a CONTINUE frame with EMPTY payload as the first frame.
        This triggers the integer underflow when ofs=0.

        NOTE: The vulnerability ONLY triggers with empty payload because:
        - When payload has data, ofs += len(data) making ofs > 0
        - The underflow ofs-1 only occurs when ofs=0
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send CONTINUE frame with EMPTY payload to trigger vuln
            send_malicious_continue_frame(sock, payload=b"")

            time.sleep(0.5)

            # Verify server is still running (should crash in vulnerable state)
            assert is_server_running(), "Server crashed after malicious CONTINUE frame"
        finally:
            sock.close()

    def test_continue_frame_large_payload(self):
        """
        Send a CONTINUE frame with EMPTY payload to trigger integer underflow.
        Testing with different connection establishment.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send CONTINUE frame with empty payload - vuln requires ofs=0
            frame = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame)

            time.sleep(0.5)

            assert is_server_running(), "Server crashed after CONTINUE frame"
        finally:
            sock.close()

    def test_multiple_malicious_continue_frames(self):
        """
        Send multiple malicious CONTINUE frames from different connections.
        Each frame has empty payload to trigger the integer underflow.
        """
        for i in range(3):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            try:
                sock.connect((HOST, PORT))
                if not websocket_handshake(sock):
                    pytest.fail(f"Handshake failed on iteration {i}, server may have crashed")

                # Send malicious frame with EMPTY payload
                send_malicious_continue_frame(sock, payload=b"")
                time.sleep(0.3)
            finally:
                sock.close()

        time.sleep(0.5)
        # Final check: server should still be running (but won't be if vulnerable)
        assert is_server_running(), "Server crashed after multiple CONTINUE frame attacks"

    def test_continue_frame_after_close(self):
        """
        Test sending empty CONTINUE frame after connection setup.
        Verifies vulnerability trigger on fresh connection.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send empty CONTINUE frame to trigger vuln
            frame = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame)

            time.sleep(0.5)

            # Server should still be running (but won't be if vulnerable)
            assert is_server_running(), "Server crashed on CONTINUE frame"
        finally:
            sock.close()

    def test_continue_frame_with_reserved_bits(self):
        """
        Test empty CONTINUE frame with reserved bits set.
        Empty payload triggers vuln (ofs=0), reserved bits are bonus edge case.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Manually craft frame with RSV bits set and EMPTY payload
            # FIN=1, RSV1=1, RSV2=0, RSV3=0, opcode=0 -> 0b11000000 = 0xC0
            frame = bytearray()
            frame.append(0xC0)  # FIN + RSV1 + opcode 0 (CONTINUE)
            frame.append(0x80)  # MASK + len=0 (empty payload)
            mask_key = bytes([0x12, 0x34, 0x56, 0x78])
            frame.extend(mask_key)
            # No payload bytes needed for empty payload

            sock.send(bytes(frame))
            time.sleep(0.5)

            assert is_server_running(), "Server crashed on frame with RSV bits"
        finally:
            sock.close()

    def test_server_stability_after_attack_sequence(self):
        """
        Test server stability after sending empty CONTINUE frame.
        Verifies the vulnerability by checking if server survives the attack.
        """
        # First, send attack with empty payload
        sock1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock1.settimeout(5)
        try:
            sock1.connect((HOST, PORT))
            assert websocket_handshake(sock1), "Initial handshake failed"
            # Empty payload triggers the vulnerability
            send_malicious_continue_frame(sock1, payload=b"")
            time.sleep(0.3)
        finally:
            sock1.close()

        time.sleep(0.5)

        # Check if server is still running
        assert is_server_running(), "Server crashed after attack"

    def test_rapid_continue_frames(self):
        """
        Rapidly send multiple empty CONTINUE frames on same connection.
        Tests for race conditions or buffer issues with the vulnerability.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Rapidly send multiple malicious frames with EMPTY payload
            for i in range(3):
                frame = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
                try:
                    sock.send(frame)
                except BrokenPipeError:
                    # Server may close connection, which is acceptable behavior
                    break
                time.sleep(0.1)

            time.sleep(0.5)
            assert is_server_running(), "Server crashed on rapid CONTINUE frames"
        finally:
            sock.close()

    def test_continue_frame_minimum_bytes(self):
        """
        Test with the absolute minimum malicious frame - just 6 bytes.
        FIN=1, opcode=0, mask=1, len=0, mask_key
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Minimal frame: FIN=1, opcode=0, MASK=1, len=0 + 4-byte mask
            frame = bytes([0x80, 0x80, 0x00, 0x00, 0x00, 0x00])
            sock.send(frame)

            time.sleep(1)
            assert is_server_running(), "Server crashed on minimal CONTINUE frame"
        finally:
            sock.close()

    def test_interleaved_normal_and_malicious(self):
        """
        Test sending empty CONTINUE frame after a normal message.
        The normal message doesn't affect ofs for subsequent CONTINUE frames.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # Send normal text - this completes and resets state
            frame1 = create_websocket_frame(b"normal1", opcode=0x1, fin=True, mask=True)
            sock.send(frame1)
            time.sleep(0.2)

            # Send malicious empty CONTINUE - ofs is 0 again, triggers vuln
            frame2 = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame2)
            time.sleep(0.5)

            # Check if connection/server still works
            assert is_server_running(), "Server crashed during interleaved test"
        finally:
            sock.close()


class TestFragmentedFrameEdgeCases:
    """
    Additional edge case tests related to fragmented frame handling.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is ready before each test."""
        assert wait_for_server(), "Server is not running"

    def test_non_final_continue_without_start(self):
        """
        Send a non-final CONTINUE frame with empty payload.
        Tests another edge case for the vulnerability.
        Note: FIN=0 won't trigger the vuln directly, but tests protocol handling.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # FIN=0 (not final), opcode=0 (CONTINUE), empty payload
            frame = create_websocket_frame(b"", opcode=0x0, fin=False, mask=True)
            sock.send(frame)
            time.sleep(0.3)

            # Now send FIN=1, opcode=0 with empty payload to trigger vuln
            frame2 = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame2)

            time.sleep(0.5)
            assert is_server_running(), "Server crashed on non-final CONTINUE frame"
        finally:
            sock.close()

    def test_final_continue_after_non_final_continue(self):
        """
        Send non-final CONTINUE, then final CONTINUE with empty payloads.
        Both frames have empty payload to keep ofs=0 and trigger the underflow.
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        try:
            sock.connect((HOST, PORT))
            assert websocket_handshake(sock), "WebSocket handshake failed"

            # First: non-final CONTINUE with empty payload
            frame1 = create_websocket_frame(b"", opcode=0x0, fin=False, mask=True)
            sock.send(frame1)
            time.sleep(0.1)

            # Second: final CONTINUE with empty payload - triggers vuln
            frame2 = create_websocket_frame(b"", opcode=0x0, fin=True, mask=True)
            sock.send(frame2)

            time.sleep(0.5)
            assert is_server_running(), "Server crashed on CONTINUE sequence"
        finally:
            sock.close()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
