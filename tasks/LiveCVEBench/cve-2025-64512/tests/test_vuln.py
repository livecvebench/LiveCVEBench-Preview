"""
Vulnerability tests for pdfminer.six CMapDB path traversal issue.

These tests verify that the path traversal vulnerability is properly fixed.
- FAIL in vulnerable state (vulnerability is exploitable)
- PASS in fixed state (vulnerability is mitigated)
"""
import gzip
import os
import pickle
import shutil
import tempfile
import pytest


class PayloadBasic:
    """Basic payload that writes a marker file."""
    def __reduce__(self):
        return (exec, ("import os; open('/tmp/vuln_marker_basic', 'w').write('TRIGGERED')",))


class PayloadWithUserInfo:
    """Payload that writes user info to marker file."""
    def __reduce__(self):
        code = """
import os
with open('/tmp/vuln_marker_userinfo', 'w') as f:
    f.write(f'uid={os.getuid()}')
"""
        return (exec, (code,))


class PayloadEnvRead:
    """Payload that reads environment variables."""
    def __reduce__(self):
        code = """
import os
with open('/tmp/vuln_marker_env', 'w') as f:
    f.write(os.environ.get('HOME', 'unknown'))
"""
        return (exec, (code,))


class PayloadSystemCommand:
    """Payload that executes system commands."""
    def __reduce__(self):
        return (exec, ("import subprocess; open('/tmp/vuln_marker_cmd', 'w').write(subprocess.getoutput('id'))",))


class PayloadFileSystem:
    """Payload that reads filesystem."""
    def __reduce__(self):
        code = """
import os
with open('/tmp/vuln_marker_fs', 'w') as f:
    f.write(','.join(os.listdir('/')))
"""
        return (exec, (code,))


def create_pickle_payload(output_path, payload_class):
    """Create a gzipped pickle file containing the malicious payload."""
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with gzip.open(output_path, 'wb') as f:
        f.write(pickle.dumps(payload_class()))


def cleanup_marker(marker_path):
    """Remove marker file if it exists."""
    if os.path.exists(marker_path):
        os.remove(marker_path)


def reload_cmapdb():
    """Clear CMapDB cache and reload module."""
    # Import fresh
    import importlib
    import pdfminer.cmapdb
    importlib.reload(pdfminer.cmapdb)
    from pdfminer.cmapdb import CMapDB
    # Clear caches
    CMapDB._cmap_cache.clear()
    if hasattr(CMapDB, '_umap_cache'):
        CMapDB._umap_cache.clear()
    return CMapDB


class TestVulnerabilityBasicPayload:
    """Test basic code execution via pickle deserialization."""

    def test_basic_code_execution_blocked(self):
        """
        Test that code execution via malicious pickle is blocked.

        In vulnerable state: Marker file is created (code executes) -> FAIL
        In fixed state: Marker file is NOT created -> PASS
        """
        marker = '/tmp/vuln_marker_basic'
        cleanup_marker(marker)

        with tempfile.TemporaryDirectory() as tmpdir:
            pickle_path = os.path.join(tmpdir, "Exploit1.pickle.gz")
            create_pickle_payload(pickle_path, PayloadBasic)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            try:
                CMapDB.get_cmap("Exploit1")
            except Exception:
                pass

            # Vulnerability is FIXED if marker file was NOT created
            assert not os.path.exists(marker), \
                "Vulnerability exists: arbitrary code was executed via pickle deserialization"

        cleanup_marker(marker)


class TestVulnerabilityUserInfo:
    """Test user information disclosure via pickle deserialization."""

    def test_user_info_disclosure_blocked(self):
        """
        Test that user info cannot be extracted via malicious pickle.
        """
        marker = '/tmp/vuln_marker_userinfo'
        cleanup_marker(marker)

        with tempfile.TemporaryDirectory() as tmpdir:
            pickle_path = os.path.join(tmpdir, "Exploit2.pickle.gz")
            create_pickle_payload(pickle_path, PayloadWithUserInfo)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            try:
                CMapDB.get_cmap("Exploit2")
            except Exception:
                pass

            assert not os.path.exists(marker), \
                "Vulnerability exists: user information was disclosed via pickle"

        cleanup_marker(marker)


class TestVulnerabilityEnvRead:
    """Test environment variable reading via pickle deserialization."""

    def test_env_read_blocked(self):
        """
        Test that environment variables cannot be read via malicious pickle.
        """
        marker = '/tmp/vuln_marker_env'
        cleanup_marker(marker)

        with tempfile.TemporaryDirectory() as tmpdir:
            pickle_path = os.path.join(tmpdir, "Exploit3.pickle.gz")
            create_pickle_payload(pickle_path, PayloadEnvRead)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            try:
                CMapDB.get_cmap("Exploit3")
            except Exception:
                pass

            assert not os.path.exists(marker), \
                "Vulnerability exists: environment variables were read via pickle"

        cleanup_marker(marker)


class TestVulnerabilitySystemCommand:
    """Test system command execution via pickle deserialization."""

    def test_system_command_blocked(self):
        """
        Test that system commands cannot be executed via malicious pickle.
        """
        marker = '/tmp/vuln_marker_cmd'
        cleanup_marker(marker)

        with tempfile.TemporaryDirectory() as tmpdir:
            pickle_path = os.path.join(tmpdir, "Exploit4.pickle.gz")
            create_pickle_payload(pickle_path, PayloadSystemCommand)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            try:
                CMapDB.get_cmap("Exploit4")
            except Exception:
                pass

            assert not os.path.exists(marker), \
                "Vulnerability exists: system commands were executed via pickle"

        cleanup_marker(marker)


class TestVulnerabilityFileSystem:
    """Test filesystem access via pickle deserialization."""

    def test_filesystem_access_blocked(self):
        """
        Test that filesystem cannot be accessed via malicious pickle.
        """
        marker = '/tmp/vuln_marker_fs'
        cleanup_marker(marker)

        with tempfile.TemporaryDirectory() as tmpdir:
            pickle_path = os.path.join(tmpdir, "Exploit5.pickle.gz")
            create_pickle_payload(pickle_path, PayloadFileSystem)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            try:
                CMapDB.get_cmap("Exploit5")
            except Exception:
                pass

            assert not os.path.exists(marker), \
                "Vulnerability exists: filesystem was accessed via pickle"

        cleanup_marker(marker)


class TestPathTraversal:
    """Test path traversal prevention."""

    def test_path_traversal_with_dotdot(self):
        """
        Test that path traversal via '../' is blocked.
        """
        marker = '/tmp/vuln_marker_traversal'
        cleanup_marker(marker)

        # Create a payload class for this specific test
        class PayloadTraversal:
            def __reduce__(self):
                return (exec, ("open('/tmp/vuln_marker_traversal', 'w').write('TRAVERSED')",))

        with tempfile.TemporaryDirectory() as tmpdir:
            # Create a subdirectory structure
            subdir = os.path.join(tmpdir, "subdir")
            os.makedirs(subdir, exist_ok=True)

            # Create pickle in parent directory, but CMAP_PATH points to subdir
            pickle_path = os.path.join(tmpdir, "Traversal.pickle.gz")
            create_pickle_payload(pickle_path, PayloadTraversal)

            os.environ["CMAP_PATH"] = subdir
            CMapDB = reload_cmapdb()

            # Try to load "../Traversal" which should resolve to parent directory
            try:
                CMapDB.get_cmap("../Traversal")
            except Exception:
                pass

            assert not os.path.exists(marker), \
                "Vulnerability exists: path traversal with '../' was not blocked"

        cleanup_marker(marker)

    def test_symlink_attack_blocked(self):
        """
        Test that symlink attacks are blocked.
        """
        marker = '/tmp/vuln_marker_symlink'
        cleanup_marker(marker)

        class PayloadSymlink:
            def __reduce__(self):
                return (exec, ("open('/tmp/vuln_marker_symlink', 'w').write('SYMLINKED')",))

        with tempfile.TemporaryDirectory() as tmpdir:
            # Create actual pickle in a separate location
            actual_dir = os.path.join(tmpdir, "actual")
            os.makedirs(actual_dir, exist_ok=True)
            actual_pickle = os.path.join(actual_dir, "Symlink.pickle.gz")
            create_pickle_payload(actual_pickle, PayloadSymlink)

            # Create CMAP directory with symlink
            cmap_dir = os.path.join(tmpdir, "cmap")
            os.makedirs(cmap_dir, exist_ok=True)
            symlink_path = os.path.join(cmap_dir, "Symlink.pickle.gz")

            try:
                os.symlink(actual_pickle, symlink_path)
            except OSError:
                pytest.skip("Cannot create symlinks on this system")

            os.environ["CMAP_PATH"] = cmap_dir
            CMapDB = reload_cmapdb()

            # The symlink points outside the cmap directory
            # Fixed version should block this
            try:
                CMapDB.get_cmap("Symlink")
            except Exception:
                pass

            # Note: The current fix may or may not block symlinks within the same
            # directory depending on implementation. This test checks if symlinks
            # pointing outside are blocked.
            if os.path.exists(marker):
                # If marker exists, check if symlink was followed
                cleanup_marker(marker)
                # The symlink target (actual_pickle) is NOT within cmap_dir
                # So after fix, it should be blocked
                pytest.fail("Vulnerability exists: symlink attack was not blocked")


class TestMultipleVectors:
    """Test multiple attack vectors in combination."""

    def test_multiple_payloads_all_blocked(self):
        """
        Test that multiple different payloads are all blocked.
        """
        markers = [
            '/tmp/vuln_multi_1',
            '/tmp/vuln_multi_2',
            '/tmp/vuln_multi_3',
        ]

        for m in markers:
            cleanup_marker(m)

        class Payload1:
            def __reduce__(self):
                return (exec, ("open('/tmp/vuln_multi_1', 'w').write('1')",))

        class Payload2:
            def __reduce__(self):
                return (exec, ("open('/tmp/vuln_multi_2', 'w').write('2')",))

        class Payload3:
            def __reduce__(self):
                return (exec, ("open('/tmp/vuln_multi_3', 'w').write('3')",))

        with tempfile.TemporaryDirectory() as tmpdir:
            create_pickle_payload(os.path.join(tmpdir, "Multi1.pickle.gz"), Payload1)
            create_pickle_payload(os.path.join(tmpdir, "Multi2.pickle.gz"), Payload2)
            create_pickle_payload(os.path.join(tmpdir, "Multi3.pickle.gz"), Payload3)

            os.environ["CMAP_PATH"] = tmpdir
            CMapDB = reload_cmapdb()

            for name in ["Multi1", "Multi2", "Multi3"]:
                try:
                    CMapDB.get_cmap(name)
                except Exception:
                    pass

            triggered = [m for m in markers if os.path.exists(m)]

            for m in markers:
                cleanup_marker(m)

            assert len(triggered) == 0, \
                f"Vulnerability exists: {len(triggered)} payloads executed"
