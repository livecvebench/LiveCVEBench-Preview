"""
Vulnerability tests for Aim query system sandbox escape.

These tests verify whether the sandbox escape vulnerability exists:
- FAIL in vulnerable state (vulnerability is exploitable - command executes)
- PASS in fixed state (vulnerability is mitigated - access blocked)

The tests send malicious queries that attempt to traverse object chains
to reach internal system modules and execute commands.
"""

import pytest
import requests
import time
import os
import subprocess
import urllib.parse

# Aim server URL
BASE_URL = "http://localhost:43800"

# File used as proof of command execution
EXPLOIT_MARKER_FILE = "/tmp/aim_exploit_test_marker"


def wait_for_server(url, timeout=60):
    """Wait for the Aim server to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{url}/api/runs/search/run/", timeout=5)
            if response.status_code in [200, 400]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


def cleanup_marker_file():
    """Remove the exploit marker file if it exists."""
    try:
        if os.path.exists(EXPLOIT_MARKER_FILE):
            os.remove(EXPLOIT_MARKER_FILE)
    except Exception:
        pass


@pytest.fixture(scope="module", autouse=True)
def ensure_server_ready():
    """Ensure the Aim server is running and ready before tests."""
    if not wait_for_server(BASE_URL):
        pytest.skip("Aim server is not available")


@pytest.fixture(autouse=True)
def cleanup():
    """Clean up before and after each test."""
    cleanup_marker_file()
    yield
    cleanup_marker_file()


class TestSandboxEscapeBlocked:
    """
    Tests that verify sandbox escape via object traversal is blocked.

    These tests should:
    - FAIL when vulnerability exists (exploit succeeds)
    - PASS when vulnerability is fixed (exploit is blocked)
    """

    def test_db_attribute_access_blocked(self):
        """
        Test that accessing the 'db' attribute is blocked.

        The db attribute provides access to the database session,
        which is the first step in the object traversal chain.
        """
        query = "run.db and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # After fix: Should return empty results (query fails because db is blocked)
        # Aim returns MessagePack format, not JSON. Check content length for empty response
        # Empty response or small progress response indicates db access was blocked
        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        # If db access was blocked, the query evaluates to False/error and returns no matches
        # An empty or near-empty response (just progress markers) indicates the fix works
        content = response.content
        # A very large response would indicate many runs were returned (db was accessible)
        # After fix, response should be small (just progress markers, no run data)
        assert len(content) < 200, \
            f"db attribute access should be blocked - response too large ({len(content)} bytes)"

    def test_session_attribute_access_blocked(self):
        """
        Test that accessing 'session' attribute is blocked.

        The session attribute is part of the SQLAlchemy traversal chain.
        """
        query = "run.db.runs().session and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # Should fail or return empty after fix
        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        # Small response indicates db access was blocked at the first step
        content = response.content
        assert len(content) < 200, \
            f"session attribute access should be blocked - response too large ({len(content)} bytes)"

    def test_bind_attribute_access_blocked(self):
        """
        Test that accessing 'bind' attribute is blocked.

        Part of the SQLAlchemy engine traversal chain.
        """
        query = "run.db.runs().session.bind and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        content = response.content
        assert len(content) < 200, \
            f"bind attribute access should be blocked - response too large ({len(content)} bytes)"

    def test_dialect_attribute_access_blocked(self):
        """
        Test that accessing 'dialect' attribute is blocked.
        """
        query = "run.db.runs().session.bind.dialect and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        content = response.content
        assert len(content) < 200, \
            f"dialect attribute access should be blocked - response too large ({len(content)} bytes)"

    def test_dbapi_attribute_access_blocked(self):
        """
        Test that accessing 'dbapi' attribute is blocked.

        The dbapi attribute provides access to the database driver module.
        """
        query = "run.db.runs().session.bind.dialect.dbapi and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        content = response.content
        assert len(content) < 200, \
            f"dbapi attribute access should be blocked - response too large ({len(content)} bytes)"

    def test_full_exploit_chain_os_system_blocked(self):
        """
        Test that the full exploit chain to os.system is blocked.

        This is the primary RCE exploit vector using object traversal
        to reach sys.modules['os'].system().
        """
        # Clean up marker file before test
        cleanup_marker_file()

        # The exploit chain that should be blocked
        # Uses touch to create a marker file as proof of execution
        exploit_cmd = f"touch {EXPLOIT_MARKER_FILE}"
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'{exploit_cmd}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # Give a moment for any file creation
        time.sleep(1)

        # The marker file should NOT exist if the vulnerability is fixed
        assert not os.path.exists(EXPLOIT_MARKER_FILE), \
            f"VULNERABILITY EXPLOITED: Command executed and created {EXPLOIT_MARKER_FILE}. " \
            "The sandbox escape vulnerability allows arbitrary command execution."

    def test_alternative_exploit_chain_whoami(self):
        """
        Test alternative exploit using whoami command.
        """
        cleanup_marker_file()

        # Alternative marker file
        marker = "/tmp/aim_exploit_whoami_marker"
        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'whoami > {marker}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        # Cleanup
        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED: whoami command executed. Sandbox escape is possible."

    def test_exploit_via_metric_endpoint(self):
        """
        Test that the metric search endpoint is also protected.

        The vulnerability exists in both /api/runs/search/run/ and
        /api/runs/search/metric/ endpoints.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_exploit_metric_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'touch {marker}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/metric/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED via metric endpoint: Command executed."

    def test_exploit_chain_with_subprocess(self):
        """
        Test exploit chain attempting to use subprocess module.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_exploit_subprocess_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        # Try accessing subprocess through sys.modules
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["subprocess"].call(["touch", "{marker}"]) or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED: subprocess.call executed through sandbox escape."

    def test_run_attribute_access_blocked(self):
        """
        Test that direct access to internal 'run' object is blocked.

        The run_view.run attribute gives access to the actual Run object.
        """
        query = "run.run and run.archived == False"

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        # After fix, accessing run.run should fail or return empty
        assert response.status_code == 200, f"Unexpected status: {response.status_code}"
        content = response.content
        assert len(content) < 200, \
            f"run.run attribute access should be blocked - response too large ({len(content)} bytes)"


class TestVariousExploitPayloads:
    """
    Test various payload variations that might bypass simple filters.
    """

    def test_encoded_attribute_names(self):
        """
        Test that direct db attribute access via bracket notation is blocked.
        Uses marker file to verify if command execution occurred.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_exploit_encoded_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        # Access db through the standard traversal path and try to execute a command
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'touch {marker}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED: db attribute traversal executed command."

    def test_alternative_traversal_path(self):
        """
        Test alternative object traversal paths via structured_db.
        Uses run.db.get_run() to access the run object and traverse to session.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_alt_traversal_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        # Use the correct traversal path through runs() method
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'touch {marker}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED via alternative traversal path."

    def test_file_read_exploit(self):
        """
        Test that file reading/writing through sandbox escape is blocked.
        Uses marker file approach to verify if file operations are possible.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_exploit_file_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        # Try to write a file through the sandbox escape using Python's open()
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["builtins"].open("{marker}", "w").write("pwned") or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED: File writing through sandbox escape succeeded."

    def test_environment_variable_access(self):
        """
        Test that environment variable access and command execution through sandbox escape is blocked.
        Uses marker file approach to verify if the exploit chain works.
        """
        cleanup_marker_file()
        marker = "/tmp/aim_exploit_env_marker"

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        # Try to access environment variables and execute a command
        query = f'run.db.runs().session.bind.dialect.dbapi.datetime.sys.modules["os"].system(\'echo $PATH > {marker}\') or run.archived == False'

        response = requests.get(
            f"{BASE_URL}/api/runs/search/run/",
            params={"q": query, "limit": 10},
            timeout=30
        )

        time.sleep(1)

        marker_exists = os.path.exists(marker)

        try:
            if os.path.exists(marker):
                os.remove(marker)
        except Exception:
            pass

        assert not marker_exists, \
            "VULNERABILITY EXPLOITED: Environment variable access and command execution succeeded."
