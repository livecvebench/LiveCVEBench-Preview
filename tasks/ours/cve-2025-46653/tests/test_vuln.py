"""
Vulnerability tests for predictable filename generation.
These tests verify whether the filename generation is predictable.

In VULNERABLE state: Tests should FAIL (vulnerability is exploitable - predictable filenames)
In FIXED state: Tests should PASS (vulnerability is mitigated - random filenames)
"""

import os
import time
import pytest
import requests
from collections import Counter

BASE_URL = os.environ.get("BASE_URL", "http://localhost:3000")


def wait_for_server(max_retries=30, delay=1):
    """Wait for the server to be ready."""
    for _ in range(max_retries):
        try:
            response = requests.get(f"{BASE_URL}/health", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(delay)
    return False


def upload_file(filename="test.txt", content=b"test content"):
    """Helper function to upload a file and return the generated filename."""
    files = {"file": (filename, content, "text/plain")}
    response = requests.post(f"{BASE_URL}/upload", files=files, timeout=10)
    if response.status_code == 200:
        data = response.json()
        return data["files"][0]["newFilename"]
    return None


def extract_prefix_and_suffix(filename, ext_len=4):
    """
    Extract prefix (first 23 chars) and suffix (last 2 chars before extension) from filename.
    For a 25-char filename like 'abc...xyz00.txt':
    - prefix: first 23 chars
    - suffix: chars 24-25 (hex counter)
    """
    # Remove extension
    if "." in filename:
        name_without_ext = filename.rsplit(".", 1)[0]
    else:
        name_without_ext = filename

    # With hexoid: 25-char total, 23-char prefix + 2-char hex suffix
    if len(name_without_ext) >= 25:
        prefix = name_without_ext[:23]
        suffix = name_without_ext[23:25]
        return prefix, suffix
    return name_without_ext, ""


class TestFilenamePredictability:
    """Test that filenames are not predictable."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure server is running before each test."""
        assert wait_for_server(), "Server did not become ready"

    def test_no_shared_prefix_pattern(self):
        """
        Test that consecutive uploads don't share the same prefix.

        VULNERABLE: hexoid reuses the same 23-char prefix for up to 256 files
        FIXED: cuid2 generates completely independent IDs
        """
        filenames = []
        for i in range(5):
            filename = upload_file(f"test{i}.txt", f"content {i}".encode())
            assert filename is not None, f"Upload {i} failed"
            filenames.append(filename)

        prefixes = [extract_prefix_and_suffix(f)[0] for f in filenames]

        # Count how many files share the same prefix
        prefix_counts = Counter(prefixes)
        most_common_count = prefix_counts.most_common(1)[0][1]

        # In a secure implementation, no prefix should repeat
        # (or at worst, random collision which is extremely unlikely)
        assert most_common_count < 3, \
            f"Filename prefix repeated {most_common_count} times. " \
            f"Prefixes: {prefixes}. This suggests predictable filename generation."

    def test_no_sequential_suffix_pattern(self):
        """
        Test that suffixes don't follow a sequential hex pattern.

        VULNERABLE: hexoid uses incrementing suffix (00, 01, 02, ...)
        FIXED: cuid2 generates random characters
        """
        filenames = []
        for i in range(5):
            filename = upload_file(f"seq{i}.txt", f"seq content {i}".encode())
            assert filename is not None, f"Upload {i} failed"
            filenames.append(filename)

        suffixes = []
        for f in filenames:
            _, suffix = extract_prefix_and_suffix(f)
            if suffix:
                suffixes.append(suffix)

        if len(suffixes) < 3:
            # Can't test with insufficient data
            return

        # Check for sequential hex pattern
        sequential_count = 0
        for i in range(len(suffixes) - 1):
            try:
                current_val = int(suffixes[i], 16)
                next_val = int(suffixes[i + 1], 16)
                if next_val == current_val + 1:
                    sequential_count += 1
            except ValueError:
                # Not hex values, which is fine for cuid2
                pass

        # If most suffixes are sequential, that's the vulnerability
        assert sequential_count < len(suffixes) - 2, \
            f"Suffixes follow sequential hex pattern: {suffixes}. " \
            f"Sequential pairs found: {sequential_count}/{len(suffixes)-1}"

    def test_filename_enumeration_attack(self):
        """
        Simulate an attacker trying to enumerate filenames.

        Attack: Upload one file, get its name, try to predict others.

        VULNERABLE: Can predict up to 255 filenames from one known filename
        FIXED: Cannot predict any filenames
        """
        # Upload first file (attacker's file)
        attacker_filename = upload_file("attacker.txt", b"attacker content")
        assert attacker_filename is not None

        prefix, suffix = extract_prefix_and_suffix(attacker_filename)

        # Upload more files (victim files)
        victim_filenames = []
        for i in range(5):
            fname = upload_file(f"victim{i}.txt", f"victim content {i}".encode())
            assert fname is not None
            victim_filenames.append(fname)

        # Try to predict victim filenames using attacker's prefix
        predicted_count = 0
        for victim_fname in victim_filenames:
            victim_prefix, victim_suffix = extract_prefix_and_suffix(victim_fname)

            # Check if the prefix matches (attacker can enumerate)
            if victim_prefix == prefix:
                # Attacker could have predicted this filename
                # by trying hex values 00-ff with the known prefix
                predicted_count += 1

        # In secure implementation, attacker should not be able to predict any filenames
        assert predicted_count < 2, \
            f"Attacker could predict {predicted_count}/5 victim filenames! " \
            f"Attacker prefix: {prefix}, Victim filenames: {victim_filenames}"

    def test_bulk_upload_prefix_diversity(self):
        """
        Test that bulk uploads produce diverse prefixes.

        VULNERABLE: All 10 files share same prefix (only suffix changes)
        FIXED: All 10 files have different prefixes
        """
        filenames = []
        for i in range(10):
            filename = upload_file(f"bulk{i}.txt", f"bulk {i}".encode())
            assert filename is not None
            filenames.append(filename)

        prefixes = [extract_prefix_and_suffix(f)[0] for f in filenames]
        unique_prefixes = set(prefixes)

        # With secure random generation, we expect high diversity
        # With hexoid vulnerability, we expect 1 unique prefix (all same)
        diversity_ratio = len(unique_prefixes) / len(prefixes)

        assert diversity_ratio > 0.5, \
            f"Low prefix diversity: {len(unique_prefixes)}/{len(prefixes)} unique. " \
            f"This indicates predictable filename generation."

    def test_cannot_predict_next_filename(self):
        """
        Test that knowing previous filenames doesn't help predict the next one.

        VULNERABLE: Given filename ending in '05', next will end in '06'
        FIXED: No predictable relationship
        """
        # Upload two files to establish a "pattern"
        fname1 = upload_file("pred1.txt", b"p1")
        fname2 = upload_file("pred2.txt", b"p2")

        prefix1, suffix1 = extract_prefix_and_suffix(fname1)
        prefix2, suffix2 = extract_prefix_and_suffix(fname2)

        # If vulnerable, we can predict fname3 will have:
        # - Same prefix as fname1 and fname2
        # - Suffix = suffix2 + 1 (in hex)

        fname3 = upload_file("pred3.txt", b"p3")
        prefix3, suffix3 = extract_prefix_and_suffix(fname3)

        # Build what we would predict in vulnerable state
        prediction_match = False
        if prefix1 == prefix2 == prefix3:
            try:
                s1 = int(suffix1, 16)
                s2 = int(suffix2, 16)
                s3 = int(suffix3, 16)
                # Check if sequential
                if s2 == s1 + 1 and s3 == s2 + 1:
                    prediction_match = True
            except ValueError:
                pass

        assert not prediction_match, \
            f"Filename pattern is predictable! " \
            f"Files: {fname1}, {fname2}, {fname3}"

    def test_randomness_across_batches(self):
        """
        Test that separate upload sessions produce independent filenames.

        VULNERABLE: Counter continues incrementing, patterns persist
        FIXED: Each request produces independent random ID
        """
        batch1 = []
        for i in range(3):
            fname = upload_file(f"b1_{i}.txt", f"batch1 {i}".encode())
            assert fname is not None
            batch1.append(fname)

        # Small delay to simulate separate session
        time.sleep(0.1)

        batch2 = []
        for i in range(3):
            fname = upload_file(f"b2_{i}.txt", f"batch2 {i}".encode())
            assert fname is not None
            batch2.append(fname)

        # Get prefixes from both batches
        prefixes1 = set(extract_prefix_and_suffix(f)[0] for f in batch1)
        prefixes2 = set(extract_prefix_and_suffix(f)[0] for f in batch2)

        # Check if batches share prefixes (they shouldn't in secure impl)
        shared_prefixes = prefixes1 & prefixes2

        # With hexoid, both batches use same prefix (within 256 file window)
        # With cuid2, batches should have different prefixes
        assert len(shared_prefixes) == 0 or len(prefixes1) > 1, \
            f"Batches share predictable prefix pattern. " \
            f"Batch1 prefixes: {prefixes1}, Batch2 prefixes: {prefixes2}"

    def test_suffix_is_not_hex_counter(self):
        """
        Directly test if suffix values are hex counters.

        VULNERABLE: Suffixes are 00, 01, 02, 03, 04 (hex counter)
        FIXED: Suffixes are random characters
        """
        filenames = []
        for i in range(5):
            fname = upload_file(f"hex{i}.txt", f"hex {i}".encode())
            assert fname is not None
            filenames.append(fname)

        suffixes = [extract_prefix_and_suffix(f)[1] for f in filenames]

        # Check if all suffixes are valid 2-char hex incrementing from a base
        try:
            hex_values = [int(s, 16) for s in suffixes if s]
            if len(hex_values) >= 3:
                # Check if they form an incrementing sequence
                is_sequential = all(
                    hex_values[i+1] == hex_values[i] + 1
                    for i in range(len(hex_values) - 1)
                )
                assert not is_sequential, \
                    f"Suffixes are sequential hex counter: {suffixes} -> {hex_values}"
        except ValueError:
            # Suffixes aren't hex, which means it's using cuid2 (good)
            pass
