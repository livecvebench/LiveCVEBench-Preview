"""
Vulnerability tests for i-Educar user type authorization (CVE-2025-11554).

The vulnerability is that ANY authenticated user can modify user types, regardless of
whether they have permission to do so. This is a Broken Function Level Authorization (BFLA).

In VULNERABLE state:
- An authenticated user (even with minimal permissions) CAN access /usuarios/tipos/* routes
- Tests that check "low priv user can't do X" will FAIL (because they CAN do X)

In FIXED state:
- Only users with can:view:554, can:modify:554, can:remove:554 permissions can access these routes
- Tests that check "low priv user can't do X" will PASS (because they're properly blocked)

Expected results:
- VULNERABLE: test_vuln.py tests FAIL (unauthorized access succeeds)
- FIXED: test_vuln.py tests PASS (unauthorized access is blocked)

IMPORTANT: Admin users (level=1) bypass all permission checks via Gate::before.
Therefore, we must test with a non-admin user (level != 1) to verify the fix works.

When a low-privilege user is blocked by the middleware, they get a 302 redirect
(back()->withErrors() returns a redirect). This is different from a direct 403.
"""
import os
import pytest
import requests
from requests.exceptions import RequestException
from bs4 import BeautifulSoup

BASE_URL = os.environ.get("APP_URL", "http://localhost")
ADMIN_USER = os.environ.get("ADMIN_USER", "admin")
ADMIN_PASSWORD = os.environ.get("ADMIN_PASSWORD", "123456789")

# Low privilege test user credentials (created by run-tests.sh)
LOW_PRIV_USER = "lowprivtest"
LOW_PRIV_PASSWORD = "testpassword123"


def wait_for_app(timeout=60):
    """Wait for the application to be ready."""
    import time
    start = time.time()
    while time.time() - start < timeout:
        try:
            resp = requests.get(f"{BASE_URL}/login", timeout=5)
            if resp.status_code == 200:
                return True
        except RequestException:
            pass
        time.sleep(2)
    return False


def get_csrf_token(session, url):
    """Get CSRF token from a page.

    i-Educar uses Vue.js with CSRF in meta tag, not hidden input.
    Check both meta tag and hidden input.
    """
    resp = session.get(url)
    soup = BeautifulSoup(resp.text, 'html.parser')

    # First try hidden input (used on login page)
    csrf_input = soup.find('input', {'name': '_token'})
    if csrf_input and csrf_input.get('value'):
        return csrf_input['value']

    # Then try meta tag (used on Vue.js pages)
    meta_csrf = soup.find('meta', {'name': 'csrf-token'})
    if meta_csrf and meta_csrf.get('content'):
        return meta_csrf['content']

    return None


def login(session, username, password):
    """Login and return success status."""
    resp = session.get(f"{BASE_URL}/login")
    csrf_token = get_csrf_token(session, f"{BASE_URL}/login")

    login_data = {
        'login': username,
        'password': password,
    }
    if csrf_token:
        login_data['_token'] = csrf_token

    resp = session.post(
        f"{BASE_URL}/login",
        data=login_data,
        allow_redirects=True
    )
    # Login succeeds if we're not still on /login page
    return '/login' not in resp.url


def is_user_type_form_accessible(session, url):
    """
    Check if the user type management form is actually accessible.

    Returns True if:
    - The user can load the page (status 200)
    - The page contains the actual user type form fields (not an error page)

    This is used to detect if the VULNERABILITY exists:
    - If accessible -> vulnerability exists (no authorization check)
    - If not accessible -> vulnerability fixed (middleware blocks access)
    """
    resp = session.get(url, allow_redirects=True)

    # If redirected to login page, access is denied
    if '/login' in resp.url:
        return False

    # If not 200, access is denied
    if resp.status_code != 200:
        return False

    # Parse the response to check for form elements
    soup = BeautifulSoup(resp.text, 'html.parser')

    # Look for user type form-specific elements
    # The form should have inputs for name, level, and processes
    has_name_field = soup.find('input', {'name': 'name'}) is not None
    has_level_field = soup.find('select', {'name': 'level'}) is not None or soup.find('input', {'name': 'level'}) is not None

    # Alternative: check for the form action URL
    form = soup.find('form')
    if form:
        action = form.get('action', '')
        if 'usuarios/tipos' in action:
            return True

    # Check for Vue.js component that manages permissions
    if 'v-for="menu in menus"' in resp.text or 'processes[item.process]' in resp.text:
        return True

    # Check for the title or heading specific to user type form
    if 'Novo Tipo de Usuário' in resp.text or 'Editar Tipo de Usuário' in resp.text:
        return True

    # If we have the name field and level field, it's the form
    if has_name_field and has_level_field:
        return True

    # Check if it's a redirect page with error (blocked access)
    # When middleware blocks, Laravel typically redirects back with errors
    # NOTE: We check for "Você não tem permissão" NOT just "permissão"
    # because "permissão" appears in the form as a button label
    if 'Você não tem permissão' in resp.text or 'acesso negado' in resp.text.lower():
        return False

    # If none of the above, we need to check more carefully
    # Look for the permission matrix elements that are unique to this form
    text = resp.text.lower()
    if 'tipo de usuário' in text and ('nome' in text or 'name' in text):
        return True

    return False


def is_access_denied(session, url, method='GET', data=None):
    """
    Check if access to a URL is denied for a low-privilege user.

    When the can:* middleware blocks access, it returns:
    - back()->withErrors() which causes a 302 redirect

    We detect blocked access by:
    1. Status code 403 (direct forbidden)
    2. Status code 302 redirect (middleware blocking)
    3. The form is NOT accessible (checked via is_user_type_form_accessible)

    IMPORTANT: We do NOT rely on just checking for "permissão" in the content
    because that word appears in the form itself as a button label ("sem permissão").

    IMPORTANT: For POST/PUT operations, we check if the redirect goes to the
    SUCCESS route (usertype.index) vs being blocked at the middleware level.
    The controller always redirects to usertype.index on success.
    When middleware blocks, it redirects back or to home.
    """
    if method == 'GET':
        # For GET requests, check if the form is actually accessible
        form_accessible = is_user_type_form_accessible(session, url)
        return not form_accessible

    # For POST/PUT/DELETE requests
    if method == 'POST':
        resp = session.post(url, data=data, allow_redirects=False)
    elif method == 'DELETE':
        resp = session.delete(url, allow_redirects=False)
    else:
        resp = session.request(method, url, data=data, allow_redirects=False)

    # Direct 403 Forbidden
    if resp.status_code == 403:
        return True

    # 302 redirect needs analysis
    if resp.status_code == 302:
        location = resp.headers.get('Location', '')

        # The controller's success redirect is to `/usuarios/tipos` (the index)
        # If we see this redirect, the operation SUCCEEDED (vulnerability exists)
        # The legacy index page may deny access separately, but the damage is done.

        # Check for success redirect pattern (ends with /usuarios/tipos, not /novo)
        if location.rstrip('/').endswith('/usuarios/tipos'):
            # This is the SUCCESS redirect from the controller
            # The operation was NOT blocked - vulnerability EXISTS
            return False

        # If redirect goes back to the form (/novo, /{id}) or home, it was blocked
        if '/usuarios/tipos/novo' in location or '/usuarios/tipos/' in location:
            # Redirect back to form - probably validation error or block
            # Need to follow and check
            follow_url = location if location.startswith('http') else f"{BASE_URL}{location}"
            follow_resp = session.get(follow_url, allow_redirects=True)
            # If there's a success message, it succeeded
            if 'sucesso' in follow_resp.text.lower():
                return False
            # If there's an error/denial message, it was blocked
            if 'Você não tem permissão' in follow_resp.text:
                return True
            # Assume blocked if unclear
            return True

        # Redirect to home or other pages means blocked by middleware
        return True

    # 405 Method Not Allowed is acceptable for blocked access
    if resp.status_code == 405:
        return True

    # 200 response for POST/PUT might mean validation error on the form
    # Check for specific error message
    if resp.status_code == 200:
        if 'Você não tem permissão' in resp.text:
            return True
        # 200 with the form displayed again usually means blocked or validation error
        if is_user_type_form_accessible(session, url):
            # Form is still accessible, might be validation error, not denial
            # For our test purposes, if form is accessible, the route wasn't blocked
            return False

    return False


class TestVulnerabilityExists:
    """
    Test that the vulnerability is FIXED by checking that low-privilege users
    are blocked from accessing user type management routes.

    IMPORTANT: Admin users (level=1) bypass all permission checks via Gate::before.
    We must test with a non-admin user to verify the middleware actually blocks access.

    In FIXED state, these tests should PASS because:
    - Low-privilege users get 302 redirect (denied access via middleware)
    - The middleware can:view:554, can:modify:554, can:remove:554 blocks non-admin users

    In VULNERABLE state, these tests would FAIL because:
    - Routes lack middleware entirely, so any authenticated user can access them
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test environment with low-privilege user."""
        assert wait_for_app(), "Application failed to start"
        self.session = requests.Session()
        # Login as low-privilege user (created by run-tests.sh)
        login_success = login(self.session, LOW_PRIV_USER, LOW_PRIV_PASSWORD)
        assert login_success, f"Low-privilege user login failed for {LOW_PRIV_USER}"

    def test_user_type_routes_lack_permission_middleware(self):
        """
        Test that low-privilege user cannot access the new user type form.

        In FIXED state: Should be blocked (302 redirect, or 403)
        In VULNERABLE state: Would return 200 (access granted)
        """
        denied = is_access_denied(self.session, f"{BASE_URL}/usuarios/tipos/novo")

        assert denied, \
            "Expected access denied for low-privilege user. " \
            "This indicates the vulnerability EXISTS - routes lack permission middleware."

    def test_update_user_type_lacks_permission_check(self):
        """
        Test that low-privilege user cannot update user types.
        """
        # First, check if the view route is blocked
        view_denied = is_access_denied(self.session, f"{BASE_URL}/usuarios/tipos/1")

        if view_denied:
            # View is blocked, which means update would also be blocked
            return  # Test passes - properly blocked at view level

        # Try the PUT operation
        csrf_token = get_csrf_token(self.session, f"{BASE_URL}/usuarios/tipos/1")
        update_data = {
            '_method': 'put',
            '_token': csrf_token or '',
            'name': 'UpdatedByVulnTest',
            'level': '1',
            'description': 'Testing vulnerability',
        }

        denied = is_access_denied(
            self.session,
            f"{BASE_URL}/usuarios/tipos/1",
            method='POST',
            data=update_data
        )

        assert denied, \
            "Expected access denied for PUT. " \
            "This indicates the vulnerability EXISTS - PUT lacks permission middleware."

    def test_create_user_type_lacks_permission_check(self):
        """
        Test that low-privilege user cannot create user types.
        """
        # First, check if the form route is blocked
        form_denied = is_access_denied(self.session, f"{BASE_URL}/usuarios/tipos/novo")

        if form_denied:
            # Form is blocked, which means create would also be blocked
            return  # Test passes - properly blocked at form level

        # Try the POST operation
        csrf_token = get_csrf_token(self.session, f"{BASE_URL}/usuarios/tipos/novo")
        create_data = {
            '_token': csrf_token or '',
            'name': 'VulnTestCreated',
            'level': '8',
            'description': 'Created via vulnerability test',
        }

        denied = is_access_denied(
            self.session,
            f"{BASE_URL}/usuarios/tipos",
            method='POST',
            data=create_data
        )

        assert denied, \
            "Expected access denied for POST. " \
            "This indicates the vulnerability EXISTS - POST lacks permission middleware."

    def test_view_user_type_details_lacks_permission_check(self):
        """
        Test that low-privilege user cannot view user type details.
        """
        denied = is_access_denied(self.session, f"{BASE_URL}/usuarios/tipos/1")

        assert denied, \
            "Expected access denied for GET show. " \
            "This indicates the vulnerability EXISTS - GET show lacks permission middleware."

    def test_delete_user_type_lacks_permission_check(self):
        """
        Test that low-privilege user cannot delete user types.
        """
        # First, check if the form route is blocked
        form_denied = is_access_denied(self.session, f"{BASE_URL}/usuarios/tipos/novo")

        if form_denied:
            # Form is blocked, which means delete would also be blocked
            return  # Test passes - properly blocked at form level

        # Try the DELETE operation
        csrf_token = get_csrf_token(self.session, f"{BASE_URL}/usuarios/tipos/novo")

        # Create a session with CSRF header
        headers = {}
        if csrf_token:
            headers['X-CSRF-TOKEN'] = csrf_token

        resp = self.session.delete(
            f"{BASE_URL}/usuarios/tipos/9999",
            headers=headers,
            allow_redirects=False
        )

        # Check for blocked access
        denied = (
            resp.status_code in [302, 403, 405] or
            (resp.status_code == 200 and 'permissão' in resp.text.lower())
        )

        assert denied, \
            f"Expected access denied for DELETE, got status {resp.status_code}. " \
            "This indicates the vulnerability EXISTS - DELETE lacks permission middleware."


class TestPrivilegeEscalationPossible:
    """
    Test that privilege escalation is blocked for low-privilege users.

    These tests verify that the fix prevents non-admin users from
    modifying user types and escalating privileges.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test environment with low-privilege user."""
        assert wait_for_app(), "Application failed to start"
        self.session = requests.Session()
        login_success = login(self.session, LOW_PRIV_USER, LOW_PRIV_PASSWORD)
        assert login_success, f"Low-privilege user login failed for {LOW_PRIV_USER}"

    def test_can_grant_all_permissions(self):
        """
        Test that low-privilege user cannot access user type modification.

        The vulnerability allows ANY authenticated user to modify user types,
        which enables privilege escalation by granting all permissions.

        In FIXED state: Should be blocked at the form level
        In VULNERABLE state: Form is accessible (privilege escalation possible)
        """
        # The vulnerability is at the ROUTE level - if the form is accessible,
        # the vulnerability exists. We don't need to test the actual escalation
        # data because that can fail for validation reasons unrelated to auth.

        form_accessible = is_user_type_form_accessible(
            self.session,
            f"{BASE_URL}/usuarios/tipos/1"
        )

        assert not form_accessible, \
            "Low-privilege user CAN access user type modification form! " \
            "Full privilege escalation possible - vulnerability EXISTS!"

    def test_can_change_institutional_level(self):
        """
        Test that low-privilege user cannot access user type modification.

        The vulnerability allows changing institutional level (nivel), which
        can grant higher access scope (e.g., from school-level to institution-wide).

        In FIXED state: Should be blocked at the form level
        In VULNERABLE state: Form is accessible (level escalation possible)
        """
        # Same as test_can_grant_all_permissions - check form access only
        form_accessible = is_user_type_form_accessible(
            self.session,
            f"{BASE_URL}/usuarios/tipos/1"
        )

        assert not form_accessible, \
            "Low-privilege user CAN access user type modification form! " \
            "Institutional level escalation possible - vulnerability EXISTS!"
