"""
Vulnerability tests for Simple SEO WordPress Plugin - Stored XSS (CVE-2025-10357).

These tests verify that the XSS vulnerability is properly mitigated.
- FAIL in vulnerable state (XSS payload appears unescaped on output)
- PASS in fixed state (XSS payload is properly escaped on output)

The vulnerability exists in app/Admin/Meta/Post.php where user-supplied
SEO metadata is output without proper escaping using esc_html().

NOTE: This test bypasses input sanitization by directly inserting payloads
into the database, to specifically test OUTPUT escaping which is the CVE issue.
"""

import pytest
import requests
import re
import time
import subprocess
from urllib.parse import urljoin

# WordPress configuration
BASE_URL = "http://localhost"
ADMIN_USER = "admin"
ADMIN_PASS = "admin"


class WordPressSession:
    """Helper class to manage WordPress authenticated sessions."""

    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def login(self, username, password):
        """Log in to WordPress admin."""
        login_url = urljoin(self.base_url, '/wp-login.php')
        self.session.get(login_url)

        login_data = {
            'log': username,
            'pwd': password,
            'wp-submit': 'Log In',
            'redirect_to': urljoin(self.base_url, '/wp-admin/'),
            'testcookie': '1'
        }

        response = self.session.post(login_url, data=login_data, allow_redirects=True)

        if 'wp-admin' in response.url or 'Dashboard' in response.text or 'dashboard' in response.text.lower():
            return True
        return False

    def get(self, path, **kwargs):
        """Make authenticated GET request."""
        url = urljoin(self.base_url, path)
        return self.session.get(url, **kwargs)

    def post(self, path, **kwargs):
        """Make authenticated POST request."""
        url = urljoin(self.base_url, path)
        return self.session.post(url, **kwargs)


def wait_for_wordpress(timeout=120):
    """Wait for WordPress to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{BASE_URL}/wp-login.php", timeout=5)
            if response.status_code == 200:
                return True
        except requests.RequestException:
            pass
        time.sleep(2)
    return False


def run_wp_cli(args):
    """Run WP-CLI command and return output."""
    result = subprocess.run(
        ['wp', '--allow-root'] + args,
        capture_output=True,
        text=True,
        cwd='/var/www/html'
    )
    return result.stdout.strip(), result.returncode


def create_test_post(title):
    """Create a test post and return its ID."""
    output, code = run_wp_cli([
        'post', 'create',
        f'--post_title={title}',
        '--post_status=draft',
        '--porcelain'
    ])
    if code == 0 and output.strip().isdigit():
        return output.strip()
    return None


def set_post_meta(post_id, meta_key, meta_value):
    """Set post meta directly via WP-CLI (bypasses sanitization)."""
    # Use wp eval to set the meta value directly, escaping single quotes
    escaped_value = meta_value.replace("'", "\\'")
    php_code = f"update_post_meta({post_id}, '{meta_key}', '{escaped_value}');"
    result = subprocess.run(
        ['wp', 'eval', php_code, '--allow-root'],
        capture_output=True,
        text=True,
        cwd='/var/www/html'
    )
    return result.returncode == 0


def get_post_meta(post_id, meta_key):
    """Get post meta value."""
    output, code = run_wp_cli(['post', 'meta', 'get', str(post_id), meta_key])
    return output if code == 0 else None


@pytest.fixture(scope="module")
def wp_ready():
    """Ensure WordPress is ready before running tests."""
    assert wait_for_wordpress(), "WordPress did not become ready in time"
    return True


@pytest.fixture(scope="module")
def admin_session(wp_ready):
    """Create an authenticated admin session."""
    session = WordPressSession(BASE_URL)
    assert session.login(ADMIN_USER, ADMIN_PASS), "Failed to login as admin"
    return session


@pytest.fixture(scope="module")
def test_post_id(wp_ready):
    """Create a single test post for XSS testing."""
    post_id = create_test_post("XSS Vulnerability Test Post")
    assert post_id, "Failed to create test post"
    return post_id


class TestXSSOutputEscaping:
    """
    Test XSS vulnerability in SEO field OUTPUT.

    These tests directly insert XSS payloads into the database (bypassing
    input sanitization) and check if they appear unescaped in the admin output.

    Expected behavior:
    - VULNERABLE version: Raw XSS payload appears in HTML (test FAILs)
    - FIXED version: XSS payload is HTML-escaped (test PASSes)
    """

    def test_script_tag_in_seo_title(self, admin_session, test_post_id):
        """Test that script tags are escaped in SEO title output."""
        payload = '<script>alert("XSS")</script>'

        # Directly insert payload into database
        assert set_post_meta(test_post_id, 'sseo_meta_title', payload), \
            "Failed to set post meta"

        # Verify payload was stored
        stored = get_post_meta(test_post_id, 'sseo_meta_title')
        assert payload in stored, "Payload was not stored correctly"

        # Check if payload appears unescaped in admin page
        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        # In vulnerable version: raw <script> appears
        # In fixed version: &lt;script&gt; appears
        assert payload not in content, \
            f"VULNERABLE: Raw script tag found in output - XSS possible in sseo_meta_title"

    def test_img_onerror_in_seo_title(self, admin_session, test_post_id):
        """Test that img onerror is escaped in SEO title output."""
        payload = '<img src=x onerror=alert(1)>'

        set_post_meta(test_post_id, 'sseo_meta_title', payload)
        stored = get_post_meta(test_post_id, 'sseo_meta_title')
        assert payload in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        assert payload not in content, \
            f"VULNERABLE: Raw img onerror found in output - XSS possible in sseo_meta_title"

    def test_svg_onload_in_seo_title(self, admin_session, test_post_id):
        """Test that svg onload is escaped in SEO title output."""
        payload = '<svg onload=alert(1)>'

        set_post_meta(test_post_id, 'sseo_meta_title', payload)
        stored = get_post_meta(test_post_id, 'sseo_meta_title')
        assert payload in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        assert payload not in content, \
            f"VULNERABLE: Raw svg onload found in output - XSS possible in sseo_meta_title"

    def test_script_tag_in_seo_description(self, admin_session, test_post_id):
        """Test that script tags are escaped in SEO description output."""
        payload = '<script>alert("desc")</script>'

        set_post_meta(test_post_id, 'sseo_meta_description', payload)
        stored = get_post_meta(test_post_id, 'sseo_meta_description')
        assert payload in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        assert payload not in content, \
            f"VULNERABLE: Raw script tag found in output - XSS possible in sseo_meta_description"

    def test_xss_in_facebook_title(self, admin_session, test_post_id):
        """Test that XSS is escaped in Facebook title output."""
        payload = '<script>alert("fb")</script>'

        set_post_meta(test_post_id, 'sseo_fb_title', payload)
        stored = get_post_meta(test_post_id, 'sseo_fb_title')
        assert payload in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        assert payload not in content, \
            f"VULNERABLE: Raw XSS found in output - XSS possible in sseo_fb_title"

    def test_xss_in_twitter_title(self, admin_session, test_post_id):
        """Test that XSS is escaped in Twitter title output."""
        payload = '<script>alert("tw")</script>'

        set_post_meta(test_post_id, 'sseo_tw_title', payload)
        stored = get_post_meta(test_post_id, 'sseo_tw_title')
        assert payload in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        assert payload not in content, \
            f"VULNERABLE: Raw XSS found in output - XSS possible in sseo_tw_title"

    def test_attribute_escape_in_seo_title(self, admin_session, test_post_id):
        """Test that attribute escape payload is escaped in output."""
        # This payload attempts to break out of an attribute
        payload = '"><img src=x onerror=alert(1)>'

        set_post_meta(test_post_id, 'sseo_meta_title', payload)
        stored = get_post_meta(test_post_id, 'sseo_meta_title')
        assert '>' in stored, "Payload was not stored correctly"

        response = admin_session.get(f'/wp-admin/post.php?post={test_post_id}&action=edit')
        content = response.text

        # Check if the dangerous part appears unescaped
        assert 'onerror=alert(1)>' not in content, \
            f"VULNERABLE: Attribute escape with onerror found unescaped in sseo_meta_title"

