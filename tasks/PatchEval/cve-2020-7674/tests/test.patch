diff --git a/poc/access-policy.test.js b/poc/access-policy.test.js
new file mode 100644
index 0000000..580f5fc
--- /dev/null
+++ b/poc/access-policy.test.js
@@ -0,0 +1,62 @@
+// tests/access-policy.codegen-exec.test.js
+const fs = require('fs');
+const path = './access-policy';
+
+test('Arbitrary code execution should NOT create files (fix should make this pass)', (done) => {
+  expect.assertions(2);
+
+  // cleanup before test
+  try {
+    if (fs.existsSync(path)) fs.unlinkSync(path);
+  } catch (e) {
+    // ignore
+  }
+
+  // 1) file must not exist before call
+  expect(fs.existsSync(path)).toBe(false);
+
+  // require the module under test
+  const a = require('access-policy');
+
+  // payload that would execute fs.writeFileSync if the encoder is vulnerable
+  const statements = {
+  cmd: "`; require('fs').writeFileSync('" + path + "', 'TEST_FROM_PAYLOAD'); //`"
+};
+	const data = {};
+
+  // call the risky function; support sync, callback and promise styles
+  try {
+    const result = a.encode(statements, data);
+
+    if (result && typeof result.then === 'function') {
+      // promise-style
+      result
+        .then(() => finalize())
+        .catch(() => finalize());
+      return;
+    }
+  } catch (e) {
+    // if it throws synchronously, continue to finalize check
+    console.error(e)
+  }
+
+  // give a short delay to allow any asynchronous side effects to run
+  setTimeout(finalize, 200);
+
+  function finalize() {
+    const existsAfter = fs.existsSync(path);
+
+    // cleanup if created by vulnerable code
+    try {
+      if (existsAfter) fs.unlinkSync(path);
+    } catch (e) {
+      // ignore cleanup errors
+    }
+
+    // 2) Expectation: file should NOT be created (fix -> test passes)
+    expect(existsAfter).toBe(false);
+
+    done();
+  }
+});
+
