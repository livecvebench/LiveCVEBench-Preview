"""
Vulnerability tests for file upload event loop blocking.

These tests verify that file upload rollover operations (memory to disk)
are properly handled without blocking the async event loop.

- FAIL in vulnerable state: rollover happens on the event loop thread (blocking)
- PASS in fixed state: rollover happens in a background thread (non-blocking)
"""

import threading
from io import BytesIO
from tempfile import SpooledTemporaryFile
from typing import ClassVar
from unittest import mock
import pytest

from starlette.applications import Starlette
from starlette.requests import Request
from starlette.responses import JSONResponse
from starlette.routing import Route
from starlette.testclient import TestClient
from starlette.formparsers import MultiPartParser


class ThreadTrackingSpooledTemporaryFile(SpooledTemporaryFile):
    """
    A SpooledTemporaryFile subclass that tracks which thread performs
    the rollover operation (transition from memory to disk).
    """
    rollover_threads: ClassVar[set[int | None]] = set()
    rollover_count: ClassVar[int] = 0

    def rollover(self) -> None:
        """Override rollover to record the thread that performs it."""
        ThreadTrackingSpooledTemporaryFile.rollover_threads.add(
            threading.current_thread().ident
        )
        ThreadTrackingSpooledTemporaryFile.rollover_count += 1
        super().rollover()


async def thread_monitor_handler(request: Request):
    """Handler that records the current thread (event loop thread)."""
    await request.form()
    await request.close()
    return JSONResponse({"thread_ident": threading.current_thread().ident})


app = Starlette(routes=[
    Route("/upload", thread_monitor_handler, methods=["POST"])
])


class TestRolloverThreadBehavior:
    """
    Tests that verify rollover operations happen in background threads,
    not on the event loop thread.
    """

    def test_rollover_not_on_event_loop_thread(self):
        """
        Core test: SpooledTemporaryFile rollover must NOT happen on the
        event loop thread.

        When a file upload exceeds the spool_max_size threshold (1MB),
        the SpooledTemporaryFile needs to "roll over" from memory to disk.
        This disk I/O operation should happen in a background thread to
        avoid blocking the async event loop.

        In the vulnerable state, this rollover happens synchronously on
        the event loop thread, blocking all async operations.
        """
        ThreadTrackingSpooledTemporaryFile.rollover_threads.clear()

        with mock.patch(
            "starlette.formparsers.SpooledTemporaryFile",
            ThreadTrackingSpooledTemporaryFile
        ):
            client = TestClient(app)

            # Create file larger than spool_max_size to trigger rollover
            large_file = BytesIO(b" " * (MultiPartParser.spool_max_size + 1))

            response = client.post("/upload", files=[("test_file", large_file)])
            assert response.status_code == 200

            # Get the event loop thread ID from the response
            app_thread_ident = response.json().get("thread_ident")
            assert app_thread_ident is not None, "Failed to get event loop thread ID"

            # Verify rollover happened
            assert len(ThreadTrackingSpooledTemporaryFile.rollover_threads) == 1, \
                "Expected exactly one rollover to occur"

            # CRITICAL: Rollover must NOT happen on the event loop thread
            assert app_thread_ident not in ThreadTrackingSpooledTemporaryFile.rollover_threads, \
                (f"Rollover happened on the event loop thread (ID: {app_thread_ident}). "
                 f"This blocks async operations and causes performance degradation!")

    def test_rollover_in_threadpool(self):
        """
        Verify that rollover happens in a different thread than the event loop.

        This test is similar to the above but with different file sizes to
        ensure consistent behavior across various rollover scenarios.
        """
        ThreadTrackingSpooledTemporaryFile.rollover_threads.clear()

        with mock.patch(
            "starlette.formparsers.SpooledTemporaryFile",
            ThreadTrackingSpooledTemporaryFile
        ):
            client = TestClient(app)

            # File that's 2MB - well over the threshold
            large_file = BytesIO(b"x" * (2 * MultiPartParser.spool_max_size))

            response = client.post("/upload", files=[("big_file", large_file)])
            assert response.status_code == 200

            app_thread_ident = response.json().get("thread_ident")
            assert app_thread_ident is not None

            # Rollover should have happened
            assert len(ThreadTrackingSpooledTemporaryFile.rollover_threads) >= 1

            # None of the rollovers should be on the event loop thread
            assert app_thread_ident not in ThreadTrackingSpooledTemporaryFile.rollover_threads, \
                "Rollover blocked the event loop thread"


class TestMultipleFileRollovers:
    """Tests for handling multiple files that trigger rollover."""

    def test_multiple_large_files_rollover(self):
        """
        Test that multiple large file uploads don't block the event loop.

        Each file that exceeds the threshold will trigger a rollover.
        All rollovers should happen in background threads.
        """
        ThreadTrackingSpooledTemporaryFile.rollover_threads.clear()
        ThreadTrackingSpooledTemporaryFile.rollover_count = 0

        with mock.patch(
            "starlette.formparsers.SpooledTemporaryFile",
            ThreadTrackingSpooledTemporaryFile
        ):
            client = TestClient(app)

            # Multiple files, each triggering rollover
            files = [
                ("file1", BytesIO(b"a" * (MultiPartParser.spool_max_size + 100))),
                ("file2", BytesIO(b"b" * (MultiPartParser.spool_max_size + 200))),
                ("file3", BytesIO(b"c" * (MultiPartParser.spool_max_size + 300))),
            ]

            response = client.post("/upload", files=files)
            assert response.status_code == 200

            app_thread_ident = response.json().get("thread_ident")

            # Should have 3 rollovers (one per file) - check count, not unique threads
            assert ThreadTrackingSpooledTemporaryFile.rollover_count >= 3, \
                f"Expected at least 3 rollovers, got {ThreadTrackingSpooledTemporaryFile.rollover_count}"

            # None should be on the event loop thread
            assert app_thread_ident not in ThreadTrackingSpooledTemporaryFile.rollover_threads, \
                "At least one rollover blocked the event loop thread"


class TestEdgeCaseRollovers:
    """Tests for edge cases around the rollover threshold."""

    def test_file_just_over_threshold(self):
        """
        Test file that's just 1 byte over the threshold.

        This is the edge case where the final write pushes the file
        over the limit and triggers rollover.
        """
        ThreadTrackingSpooledTemporaryFile.rollover_threads.clear()

        with mock.patch(
            "starlette.formparsers.SpooledTemporaryFile",
            ThreadTrackingSpooledTemporaryFile
        ):
            client = TestClient(app)

            # Exactly 1 byte over the threshold
            just_over = BytesIO(b"x" * (MultiPartParser.spool_max_size + 1))

            response = client.post("/upload", files=[("edge_case", just_over)])
            assert response.status_code == 200

            app_thread_ident = response.json().get("thread_ident")

            # Should have exactly one rollover
            assert len(ThreadTrackingSpooledTemporaryFile.rollover_threads) == 1

            # Must not be on event loop thread
            assert app_thread_ident not in ThreadTrackingSpooledTemporaryFile.rollover_threads, \
                "Edge case rollover blocked the event loop"

    def test_gradual_threshold_crossing(self):
        """
        Test that rollover triggered by cumulative writes is handled correctly.

        The multipart parser writes data in chunks, so the threshold may be
        crossed during any write operation.
        """
        ThreadTrackingSpooledTemporaryFile.rollover_threads.clear()

        with mock.patch(
            "starlette.formparsers.SpooledTemporaryFile",
            ThreadTrackingSpooledTemporaryFile
        ):
            client = TestClient(app)

            # File that will definitely cross the threshold mid-stream
            file_size = int(MultiPartParser.spool_max_size * 1.5)
            gradual_file = BytesIO(b"g" * file_size)

            response = client.post("/upload", files=[("gradual", gradual_file)])
            assert response.status_code == 200

            app_thread_ident = response.json().get("thread_ident")

            assert len(ThreadTrackingSpooledTemporaryFile.rollover_threads) >= 1
            assert app_thread_ident not in ThreadTrackingSpooledTemporaryFile.rollover_threads


