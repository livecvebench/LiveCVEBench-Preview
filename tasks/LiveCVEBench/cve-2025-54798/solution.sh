#!/bin/bash
set -e

cd /app

echo "Applying fix to tmp library path validation..."

# The vulnerable file location
TMP_FILE="/app/node_modules/tmp/lib/tmp.js"

# Check if file exists
if [ ! -f "$TMP_FILE" ]; then
    echo "Error: $TMP_FILE not found"
    exit 1
fi

# Apply the fix using Node.js to handle the multi-line replacement
node -e "
const fs = require('fs');
const filePath = '$TMP_FILE';

let content = fs.readFileSync(filePath, 'utf8');

// The _resolvePath function patterns to match (vulnerable and previously fixed)
const vulnerablePatterns = [
    // Pattern 1: Original vulnerable formatting
    \`function _resolvePath(name, tmpDir) {
  if (name.startsWith(tmpDir)) {
    return path.resolve(name);
  } else {
    return path.resolve(path.join(tmpDir, name));
  }
}\`,
    // Pattern 2: Compact formatting
    \`function _resolvePath(name, tmpDir) {
  if (name.startsWith(tmpDir)) {
    return path.resolve(name);
  }
  else {
    return path.resolve(path.join(tmpDir, name));
  }
}\`,
    // Pattern 3: Previously fixed version (with simple realpathSync)
    \`function _resolvePath(name, tmpDir) {
  let resolvedPath;
  if (name.startsWith(tmpDir)) {
    resolvedPath = path.resolve(name);
  } else {
    resolvedPath = path.resolve(path.join(tmpDir, name));
  }
  // Resolve symlinks to get the real filesystem path
  return fs.realpathSync(resolvedPath);
}\`
];

const fixedFunction = \`function _resolvePath(name, tmpDir) {
  let resolvedPath;
  if (name.startsWith(tmpDir)) {
    resolvedPath = path.resolve(name);
  } else {
    resolvedPath = path.resolve(path.join(tmpDir, name));
  }

  // Special handling for template paths with XXXXXX placeholders
  if (path.basename(resolvedPath).includes('XXXXXX')) {
    // For templates, validate the directory part only
    const dir = path.dirname(resolvedPath);
    const fileName = path.basename(resolvedPath);

    // If the directory is just tmpDir, return as-is
    if (dir === tmpDir) {
      return resolvedPath;
    }

    // Validate the directory part exists and resolve symlinks
    try {
      const realDir = fs.realpathSync(dir);
      return path.join(realDir, fileName);
    } catch (err) {
      if (err.code === 'ENOENT') {
        // Directory doesn't exist - this is fine for templates
        return resolvedPath;
      }
      throw err;
    }
  }

  // For non-template paths, resolve symlinks to get the actual filesystem path
  try {
    return fs.realpathSync(resolvedPath);
  } catch (err) {
    if (err.code === 'ENOENT') {
      // Path doesn't exist yet, return the resolved path
      return resolvedPath;
    }
    throw err;
  }
}\`;

let replaced = false;

for (const pattern of vulnerablePatterns) {
    if (content.includes(pattern)) {
        content = content.replace(pattern, fixedFunction);
        replaced = true;
        break;
    }
}

// If exact match not found, try regex-based replacement
if (!replaced) {
    const regex = /function _resolvePath\(name, tmpDir\) \{[\s\S]*?if \(name\.startsWith\(tmpDir\)\) \{[\s\S]*?return path\.resolve\(name\);[\s\S]*?\} else \{[\s\S]*?return path\.resolve\(path\.join\(tmpDir, name\)\);[\s\S]*?\}[\s\S]*?\}/;

    if (regex.test(content)) {
        content = content.replace(regex, fixedFunction);
        replaced = true;
    }
}

// Check if the current function is already the fixed version
if (!replaced) {
    if (content.includes('Special handling for template paths with XXXXXX placeholders')) {
        console.log('Fix appears to already be applied correctly');
        process.exit(0);
    }
    console.error('Could not find vulnerable _resolvePath function to replace');
    process.exit(1);
}

fs.writeFileSync(filePath, content);
console.log('Fix applied successfully to ' + filePath);
"

echo "Fix applied successfully"
