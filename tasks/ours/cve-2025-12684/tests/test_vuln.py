"""
Vulnerability tests for URL Shortify plugin reflected XSS in the id parameter.

These tests verify:
- FAIL in vulnerable state (XSS payload appears unescaped in HTML)
- PASS in fixed state (XSS payload is blocked/sanitized)

The vulnerability exists when the 'id' parameter is not properly sanitized
and appears in HTML form attributes, allowing HTML/JavaScript injection.
"""

import pytest
import requests
import time
import re
from urllib.parse import quote, urlencode

# WordPress configuration
WP_URL = "http://localhost"
WP_ADMIN_URL = f"{WP_URL}/wp-admin"
WP_USER = "admin"
WP_PASS = "admin"

# Session for authenticated requests
session = requests.Session()


def wait_for_wordpress(timeout=60):
    """Wait for WordPress to be ready."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{WP_URL}/wp-login.php", timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


def wordpress_login():
    """Log in to WordPress admin and return authenticated session."""
    login_url = f"{WP_URL}/wp-login.php"

    # Get the login page
    response = session.get(login_url)
    assert response.status_code == 200, f"Failed to load login page: {response.status_code}"

    # Submit login form
    login_data = {
        "log": WP_USER,
        "pwd": WP_PASS,
        "wp-submit": "Log In",
        "redirect_to": f"{WP_ADMIN_URL}/",
        "testcookie": "1"
    }

    response = session.post(login_url, data=login_data, allow_redirects=True)

    # Verify logged in
    admin_response = session.get(f"{WP_ADMIN_URL}/")
    assert "dashboard" in admin_response.text.lower() or "wp-admin" in admin_response.url, \
        "Failed to log in to WordPress admin"

    return session


@pytest.fixture(scope="module")
def wp_session():
    """Fixture to provide an authenticated WordPress session."""
    assert wait_for_wordpress(), "WordPress did not become available in time"
    return wordpress_login()


class TestReflectedXSSVulnerability:
    """Tests for reflected XSS vulnerability via the id parameter."""

    def test_basic_attribute_escape(self, wp_session):
        """
        Test basic attribute escape with double quote.
        The payload attempts to break out of the action attribute.

        Vulnerable: The quote appears unescaped allowing attribute breakout
        Fixed: The id is sanitized to 0, no payload in output
        """
        # Simple payload to break out of attribute
        payload = '" test="injected'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that the injected attribute does NOT appear in response
        assert 'test="injected' not in response.text, \
            "XSS payload (attribute injection) was reflected in the HTML output"

    def test_animation_based_xss(self, wp_session):
        """
        Test CSS animation-based XSS payload (no user interaction required).
        This is the actual attack vector used in the wild.

        Vulnerable: onanimationstart handler appears in HTML
        Fixed: id sanitized to 0, no payload
        """
        payload = '" style="animation-name:rotation" onanimationstart="alert(1)//'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that the XSS event handler does NOT appear
        assert 'onanimationstart=' not in response.text.lower(), \
            "XSS payload (onanimationstart) was reflected in the HTML output"
        assert 'animation-name:rotation' not in response.text.lower(), \
            "XSS payload (animation style) was reflected in the HTML output"

    def test_onerror_xss(self, wp_session):
        """
        Test onerror-based XSS payload.
        Note: WordPress HTML-encodes < and > so we use attribute-only injection.

        Vulnerable: The injected attribute breaks out of action="" and adds onerror
        Fixed: id sanitized, no payload
        """
        # Use attribute breakout without < > which WordPress encodes
        payload = '" onerror="alert(1)" x="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that onerror handler is NOT present in attribute context
        assert 'onerror="alert' not in response.text.lower(), \
            "XSS payload (onerror) was reflected in the HTML output"

    def test_script_tag_injection(self, wp_session):
        """
        Test onclick event handler injection (WordPress encodes < > so we use attribute injection).

        Vulnerable: onclick handler appears in HTML
        Fixed: id sanitized, no payload
        """
        # Use onclick which doesn't need < > tags
        payload = '" onclick="alert(1)" data-test="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that onclick handler is NOT present
        assert 'onclick="alert' not in response.text.lower(), \
            "XSS payload (onclick) was reflected in the HTML output"

    def test_onmouseover_xss(self, wp_session):
        """
        Test onmouseover-based XSS payload.

        Vulnerable: onmouseover handler appears in HTML
        Fixed: id sanitized, no payload
        """
        payload = '" onmouseover="alert(1)" data-x="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that onmouseover handler is NOT present as injected
        # Look for the pattern that indicates injection
        assert '" onmouseover="alert' not in response.text.lower(), \
            "XSS payload (onmouseover) was reflected in the HTML output"

    def test_onfocus_autofocus_xss(self, wp_session):
        """
        Test onfocus with autofocus for automatic triggering.

        Vulnerable: onfocus handler appears in HTML
        Fixed: id sanitized, no payload
        """
        payload = '" onfocus="alert(1)" autofocus="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that onfocus handler is NOT present
        assert '" onfocus="alert' not in response.text.lower(), \
            "XSS payload (onfocus) was reflected in the HTML output"

    def test_svg_onload_xss(self, wp_session):
        """
        Test onload event handler injection (WordPress encodes < > so we use attribute injection).

        Vulnerable: onload handler appears in HTML
        Fixed: id sanitized, no payload
        """
        # Use onload without SVG tags
        payload = '" onload="alert(1)" x="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that onload is NOT present in attribute context
        assert 'onload="alert' not in response.text.lower(), \
            "XSS payload (onload) was reflected in the HTML output"


class TestInputSanitization:
    """Tests to verify proper input sanitization of the id parameter."""

    def test_non_numeric_id_with_event_handler(self, wp_session):
        """
        Test that non-numeric id values with event handlers are sanitized.

        Vulnerable: Event handler appears in output
        Fixed: Non-numeric id is sanitized to 0
        """
        # Non-numeric ID with event handler
        payload = 'abc" ondblclick="alert(1)" x="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that event handler is NOT present
        assert 'ondblclick="alert' not in response.text.lower(), \
            "XSS payload with non-numeric id was reflected"

    def test_html_entities_with_handler(self, wp_session):
        """
        Test that HTML special characters with event handler are properly handled.

        Vulnerable: Event handler appears in output
        Fixed: Id is sanitized
        """
        # Payload with HTML entities and event handler
        payload = '" ondrag="alert(1)" title="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200

        # Check that event handler is NOT present
        assert 'ondrag="alert' not in response.text.lower(), \
            "XSS payload with HTML entities was reflected"

    def test_array_id_with_handler(self, wp_session):
        """
        Test that array-based id injection with event handler is handled.

        Vulnerable: Event handler might still be processed
        Fixed: Array input is sanitized to 0
        """
        # First test with array
        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id[]=test"
        )
        # Should not cause an error
        assert response.status_code == 200

        # Now test with event handler
        payload = '" ondrop="alert(1)" x="'
        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={quote(payload, safe='')}"
        )
        assert response.status_code == 200

        # Check that event handler is NOT present
        assert 'ondrop="alert' not in response.text.lower(), \
            "XSS payload with event handler was reflected"


class TestEdgeCases:
    """Edge case tests for the vulnerability."""

    def test_unicode_in_id(self, wp_session):
        """Test that unicode characters in event handler don't bypass sanitization."""
        # Use unicode encoding of quote and handler - still triggers XSS
        payload = '\u0022 onmouseenter=\u0022alert(1)\u0022 x=\u0022'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200
        # Unicode quotes become regular quotes in the output
        assert 'onmouseenter="alert' not in response.text.lower(), \
            "XSS payload with unicode encoding was reflected"

    def test_null_byte_injection(self, wp_session):
        """Test that null byte with event handler doesn't bypass sanitization."""
        # Null byte followed by event handler
        payload = 'test%00" onkeyup="alert(1)" x="'
        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={quote(payload, safe='%')}"
        )
        assert response.status_code == 200
        assert 'onkeyup="alert' not in response.text.lower(), \
            "XSS payload with null byte was reflected"

    def test_double_encoding(self, wp_session):
        """Test that double-encoded payloads don't bypass sanitization."""
        # Double encode the quote
        payload = '%22 onmouseover=alert(1) x=%22'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        assert response.status_code == 200
        assert 'onmouseover=alert' not in response.text.lower(), \
            "XSS payload with double encoding was reflected"

    def test_very_long_id(self, wp_session):
        """Test that very long id values with XSS don't cause issues."""
        # Long padding followed by event handler
        payload = 'A' * 100 + '" onchange="alert(1)" x="'
        encoded_payload = quote(payload, safe='')

        response = wp_session.get(
            f"{WP_ADMIN_URL}/admin.php?page=us_links&action=edit&id={encoded_payload}"
        )
        # Should handle gracefully and still reflect XSS in vulnerable version
        assert response.status_code in [200, 414]
        if response.status_code == 200:
            assert 'onchange="alert' not in response.text.lower(), \
                "XSS payload with long prefix was reflected"
