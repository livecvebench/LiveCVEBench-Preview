#!/bin/bash
set -e
cd /app

echo "=== Applying security fix for HTML escaping bypass ==="

# File paths
UTILS_FILE="packages/shared/src/utils.ts"
TRANSLATE_FILE="packages/core-base/src/translate.ts"

# Check if files exist
if [ ! -f "$UTILS_FILE" ]; then
    echo "Error: $UTILS_FILE not found"
    exit 1
fi

if [ ! -f "$TRANSLATE_FILE" ]; then
    echo "Error: $TRANSLATE_FILE not found"
    exit 1
fi

echo "Step 1: Checking if already patched..."
if grep -q "sanitizeTranslatedHtml" "$UTILS_FILE"; then
    echo "Already patched - sanitizeTranslatedHtml exists in utils.ts"
else
    echo "Step 2: Modifying $UTILS_FILE..."

    # Create Python script to do the replacement
    cat > /tmp/patch_utils.py << 'PYTHON_EOF'
import sys

with open(sys.argv[1], 'r') as f:
    content = f.read()

# Check if already patched
if 'sanitizeTranslatedHtml' in content:
    print("Already patched - sanitizeTranslatedHtml exists")
    sys.exit(0)

# Add import for warn after the initial comment block
if "import { warn } from './warn'" not in content:
    # Find the position after "/**" header comment ends at "*/"
    header_end = content.find('*/', content.find('/**'))
    if header_end != -1:
        insert_pos = header_end + 2
        # Find next newline
        nl_pos = content.find('\n', insert_pos)
        if nl_pos != -1:
            insert_pos = nl_pos + 1
        content = content[:insert_pos] + "\nimport { warn } from './warn'\n" + content[insert_pos:]

# Find and replace the escapeHtml function
old_func_start = content.find("export function escapeHtml(rawText: string): string {")
if old_func_start == -1:
    print("Error: Could not find escapeHtml function")
    sys.exit(1)

# Find end of function (look for closing brace followed by newline + newline or export/const)
# The function body contains multiple .replace calls
func_body_start = content.find('{', old_func_start)
brace_count = 0
func_end = func_body_start
for i in range(func_body_start, len(content)):
    if content[i] == '{':
        brace_count += 1
    elif content[i] == '}':
        brace_count -= 1
        if brace_count == 0:
            func_end = i + 1
            break

# New fixed functions
new_code = '''export function escapeHtml(rawText: string): string {
  return rawText
    .replace(/&/g, '&amp;') // escape `&` first to avoid double escaping
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/\\//g, '&#x2F;') // escape `/` to prevent closing tags or JavaScript URLs
    .replace(/=/g, '&#x3D;') // escape `=` to prevent attribute injection
}

function escapeAttributeValue(value: string): string {
  return value
    .replace(/&(?![a-zA-Z0-9#]{2,6};)/g, '&amp;') // escape unescaped `&`
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}

export function sanitizeTranslatedHtml(html: string): string {
  // Escape dangerous characters in attribute values
  // Process attributes with double quotes
  html = html.replace(
    /(\\w+)\\s*=\\s*"([^"]*)"/g,
    (_, attrName, attrValue) =>
      `${attrName}="${escapeAttributeValue(attrValue)}"`
  )

  // Process attributes with single quotes
  html = html.replace(
    /(\\w+)\\s*=\\s*'([^']*)'/g,
    (_, attrName, attrValue) =>
      `${attrName}='${escapeAttributeValue(attrValue)}'`
  )

  // Detect and neutralize event handler attributes
  const eventHandlerPattern = /\\s*on\\w+\\s*=\\s*["']?[^"'>]+["']?/gi
  if (eventHandlerPattern.test(html)) {
    if (__DEV__) {
      warn(
        'Potentially dangerous event handlers detected in translation. ' +
          'Consider removing onclick, onerror, etc. from your translation messages.'
      )
    }
    // Neutralize event handler attributes by escaping 'on'
    html = html.replace(/(\\s+)(on)(\\w+\\s*=)/gi, '$1&#111;n$3')
  }

  // Disable javascript: URLs in various contexts
  const javascriptUrlPattern = [
    // In href, src, action, formaction attributes
    /(\\s+(?:href|src|action|formaction)\\s*=\\s*["']?)\\s*javascript:/gi,
    // In style attributes within url()
    /(style\\s*=\\s*["'][^"']*url\\s*\\(\\s*)javascript:/gi
  ]

  javascriptUrlPattern.forEach(pattern => {
    html = html.replace(pattern, '$1javascript&#58;')
  })

  return html
}'''

content = content[:old_func_start] + new_code + content[func_end:]

with open(sys.argv[1], 'w') as f:
    f.write(content)

print("Successfully patched utils.ts")
PYTHON_EOF

    python3 /tmp/patch_utils.py "$UTILS_FILE"
fi

echo "Step 3: Checking translate.ts..."
if grep -q "sanitizeTranslatedHtml" "$TRANSLATE_FILE"; then
    echo "Already patched - sanitizeTranslatedHtml exists in translate.ts"
else
    echo "Step 4: Modifying $TRANSLATE_FILE..."

    # Create Python script to patch translate.ts
    cat > /tmp/patch_translate.py << 'PYTHON_EOF'
import sys

with open(sys.argv[1], 'r') as f:
    content = f.read()

# Check if already patched
if 'sanitizeTranslatedHtml' in content:
    print("Already patched - sanitizeTranslatedHtml exists in translate.ts")
    sys.exit(0)

# 1. Add sanitizeTranslatedHtml to imports from @intlify/shared
# Find the import from @intlify/shared that contains escapeHtml
import_start = content.find("import {")
while import_start != -1:
    import_end = content.find("} from '@intlify/shared'", import_start)
    if import_end != -1 and 'escapeHtml' in content[import_start:import_end]:
        # Found the right import, add sanitizeTranslatedHtml after escapeHtml
        escape_pos = content.find('escapeHtml', import_start)
        if escape_pos < import_end:
            # Insert after 'escapeHtml'
            insert_pos = escape_pos + len('escapeHtml')
            content = content[:insert_pos] + ',\n  sanitizeTranslatedHtml' + content[insert_pos:]
            break
    import_start = content.find("import {", import_start + 1)

# 2. Change "const ret" to "let ret" and add sanitization
old_pattern = "const ret = postTranslation"
new_pattern = "let ret = postTranslation"
content = content.replace(old_pattern, new_pattern, 1)

# 3. Add sanitization after the ret assignment
# Find where ret is assigned and add sanitization after
ret_assignment = content.find("let ret = postTranslation\n    ? postTranslation(messaged, key as string)\n    : messaged")
if ret_assignment == -1:
    ret_assignment = content.find("let ret = postTranslation")

if ret_assignment != -1:
    # Find the end of this statement (look for ": messaged" followed by newlines)
    end_marker = content.find(": messaged", ret_assignment)
    if end_marker != -1:
        end_pos = end_marker + len(": messaged")
        # Check if sanitization already added
        if "sanitizeTranslatedHtml(ret)" not in content[end_pos:end_pos+200]:
            sanitize_code = '''

  // apply HTML sanitization for security
  if (escapeParameter && isString(ret)) {
    ret = sanitizeTranslatedHtml(ret) as MessageFunctionReturn<Message>
  }'''
            content = content[:end_pos] + sanitize_code + content[end_pos:]

with open(sys.argv[1], 'w') as f:
    f.write(content)

print("Successfully patched translate.ts")
PYTHON_EOF

    python3 /tmp/patch_translate.py "$TRANSLATE_FILE"
fi

# Clean up temp files
rm -f /tmp/patch_utils.py /tmp/patch_translate.py

echo "Step 5: Rebuilding the packages..."
# Initialize git if needed (build script requires git)
if [ ! -d ".git" ]; then
    git init
    git config user.email "test@test.com"
    git config user.name "Test"
    git add -A
    git commit -m "initial" --quiet
fi

# Build the packages to apply TypeScript changes
pnpm run build --filter @intlify/shared --filter @intlify/core-base

echo "=== Fix applied successfully ==="
echo "Changes made:"
echo "1. Enhanced escapeHtml() to escape &, /, and = characters"
echo "2. Added escapeAttributeValue() helper function"
echo "3. Added sanitizeTranslatedHtml() function to neutralize event handlers and javascript: URLs"
echo "4. Modified translate() to apply sanitization when escapeParameter is enabled"
echo "5. Rebuilt packages to apply TypeScript changes"
