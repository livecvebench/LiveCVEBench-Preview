"""
Minimal FastAPI server for testing the export API path validation.

This server mocks the heavy Frigate dependencies but uses the actual
export.py source code, allowing us to test the real vulnerability
via HTTP requests.
"""

import sys
import os
import importlib.util
from unittest.mock import MagicMock, patch
from typing import Optional
from pydantic import BaseModel

# We need to set up mocks before importing the export module
# Create mock modules for Frigate dependencies

class MockField:
    """Mock field that can handle peewee-style comparisons."""
    def between(self, start, end):
        return MagicMock()
    def __gt__(self, other):
        return MagicMock()
    def __lt__(self, other):
        return MagicMock()
    def __eq__(self, other):
        return MagicMock()
    def __and__(self, other):
        return MagicMock()
    def __or__(self, other):
        return MagicMock()
    def desc(self):
        """Support for order_by(field.desc())"""
        return MagicMock()

class MockPreviewsModel:
    """Mock Previews model."""
    start_time = MockField()
    end_time = MockField()
    camera = MockField()

    @classmethod
    def select(cls):
        mock_query = MagicMock()
        mock_query.where.return_value = mock_query
        mock_query.count.return_value = 5  # Always return some previews
        return mock_query

class MockRecordingsModel:
    """Mock Recordings model."""
    start_time = MockField()
    end_time = MockField()
    camera = MockField()

    @classmethod
    def select(cls):
        mock_query = MagicMock()
        mock_query.where.return_value = mock_query
        mock_query.count.return_value = 5  # Always return some recordings
        return mock_query

class MockExportModel:
    """Mock Export model."""
    id = MockField()
    date = MockField()

    @classmethod
    def select(cls):
        mock_query = MagicMock()
        mock_query.order_by.return_value.dicts.return_value.iterator.return_value = iter([])
        return mock_query

# Create mock enum classes
class PlaybackFactorEnum:
    __members__ = {'realtime': 'realtime', 'timelapse_25x': 'timelapse_25x'}
    realtime = 'realtime'
    timelapse_25x = 'timelapse_25x'

    def __class_getitem__(cls, key):
        return key

class PlaybackSourceEnum:
    __members__ = {'recordings': 'recordings', 'preview': 'preview'}
    recordings = 'recordings'
    preview = 'preview'

    def __class_getitem__(cls, key):
        return key

# Mock RecordingExporter that does nothing
class MockRecordingExporter:
    def __init__(self, *args, **kwargs):
        pass
    def start(self):
        pass

# Create mock frigate modules
class MockModels:
    Export = MockExportModel
    Previews = MockPreviewsModel
    Recordings = MockRecordingsModel

class MockAuth:
    @staticmethod
    def require_role(roles):
        def dependency():
            pass
        return dependency

class MockTags:
    export = "export"

class MockDefs:
    class request:
        class export_recordings_body:
            class ExportRecordingsBody(BaseModel):
                playback: str = "realtime"
                source: str = "preview"
                name: str = "test_export"
                image_path: Optional[str] = None

        class export_rename_body:
            class ExportRenameBody(BaseModel):
                name: str

class MockConst:
    EXPORT_DIR = "/media/frigate/exports"
    CLIPS_DIR = "/media/frigate/clips"
    BASE_DIR = "/media/frigate"

class MockRecordExport:
    PlaybackFactorEnum = PlaybackFactorEnum
    PlaybackSourceEnum = PlaybackSourceEnum
    RecordingExporter = MockRecordingExporter

class MockBuiltin:
    @staticmethod
    def is_current_hour(timestamp):
        return False

# Register mock modules before import
sys.modules['frigate'] = MagicMock()
sys.modules['frigate.models'] = MockModels
sys.modules['frigate.api'] = MagicMock()
sys.modules['frigate.api.auth'] = MockAuth
sys.modules['frigate.api.defs'] = MockDefs
sys.modules['frigate.api.defs.request'] = MockDefs.request
sys.modules['frigate.api.defs.request.export_recordings_body'] = MockDefs.request.export_recordings_body
sys.modules['frigate.api.defs.request.export_rename_body'] = MockDefs.request.export_rename_body
sys.modules['frigate.api.defs.tags'] = MagicMock()
sys.modules['frigate.api.defs.tags'].Tags = MockTags
sys.modules['frigate.const'] = MockConst
sys.modules['frigate.record'] = MagicMock()
sys.modules['frigate.record.export'] = MockRecordExport
sys.modules['frigate.util'] = MagicMock()
sys.modules['frigate.util.builtin'] = MockBuiltin

# Patch playhouse
sys.modules['playhouse'] = MagicMock()
sys.modules['playhouse.shortcuts'] = MagicMock()
sys.modules['playhouse.shortcuts'].model_to_dict = lambda x: {}
sys.modules['peewee'] = MagicMock()
sys.modules['peewee'].DoesNotExist = Exception

# Now import FastAPI and create the app
from fastapi import FastAPI, Request

app = FastAPI()

# Create a mock camera configuration
class MockCameraConfig:
    def get(self, camera_name):
        if camera_name and camera_name != "nonexistent_camera" and camera_name != "":
            return {'name': camera_name}
        return None

class MockFrigateConfig:
    cameras = MockCameraConfig()

# Load the actual export.py from Frigate source
export_path = '/app/frigate/api/export.py'

if os.path.exists(export_path):
    spec = importlib.util.spec_from_file_location("export", export_path)
    export_module = importlib.util.module_from_spec(spec)

    # Need to set the module's globals before executing
    spec.loader.exec_module(export_module)

    # Include the router from export.py
    app.include_router(export_module.router, prefix="/api")
else:
    # Fallback: create a simple endpoint for testing
    from fastapi import APIRouter
    from fastapi.responses import JSONResponse
    from pydantic import BaseModel
    from typing import Optional

    router = APIRouter()

    class ExportBody(BaseModel):
        playback: str = "realtime"
        source: str = "preview"
        name: str = "test_export"
        image_path: Optional[str] = None

    @router.post("/export/{camera_name}/start/{start_time}/end/{end_time}")
    def export_recording(
        request: Request,
        camera_name: str,
        start_time: float,
        end_time: float,
        body: ExportBody,
    ):
        # This should never be reached if real export.py is loaded
        return JSONResponse({"success": False, "message": "Fallback endpoint"}, status_code=500)

    app.include_router(router, prefix="/api")

# Attach mock config to app
@app.on_event("startup")
async def startup():
    app.frigate_config = MockFrigateConfig()

# Also set it immediately for sync access
app.frigate_config = MockFrigateConfig()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)
