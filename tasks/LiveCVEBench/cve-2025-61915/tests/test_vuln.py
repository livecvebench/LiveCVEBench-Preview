#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-61915 - CUPS IPv6 address parsing buffer underflow.

These tests verify that the buffer underflow vulnerability EXISTS in the vulnerable version.

- FAIL in vulnerable state (cupsd crashes with malformed input - this is what we want!)
- PASS in fixed state (cupsd handles malformed input gracefully)

The vulnerability occurs in get_addr_and_mask() when parsing IPv6 addresses:
- When :: is followed by more than 6 colon-separated values, the calculation i = 6 - j
  produces a negative value
- After i++, this negative index is used for array access ip[i/2], causing buffer underwrite
- Due to integer division, i must be <= -2 at array access time, meaning j >= 9 (10+ segments)
- The crash happens when ip[negative_index] is written
"""

import os
import random
import signal
import subprocess
import tempfile
import time
import pytest
from typing import Tuple


def find_cupsd_binary() -> str:
    """Find the cupsd binary in the container."""
    possible_paths = [
        "/app/cups-2.4.14/scheduler/cupsd",
        "/app/cups/scheduler/cupsd",
        "/usr/sbin/cupsd",
    ]
    for path in possible_paths:
        if os.path.isfile(path) and os.access(path, os.X_OK):
            return path
    raise FileNotFoundError("cupsd binary not found in expected locations")


def get_random_port() -> int:
    """Get a random port number to avoid conflicts between tests."""
    return random.randint(10000, 60000)


def run_cupsd_with_config(config_content: str, timeout: float = 15.0) -> Tuple[int, str, str]:
    """
    Run cupsd with a given configuration and return results.

    Returns:
        Tuple of (exit_code, stdout, stderr)
    """
    cupsd_path = find_cupsd_binary()

    # Create temporary config file
    fd, config_path = tempfile.mkstemp(suffix=".conf", prefix="cupsd_test_")
    with os.fdopen(fd, "w") as f:
        f.write(config_content)

    try:
        # Set library path for CUPS libraries
        env = os.environ.copy()
        cups_lib_dir = os.path.dirname(os.path.dirname(cupsd_path)) + "/cups"
        env["LD_LIBRARY_PATH"] = f"{cups_lib_dir}:{env.get('LD_LIBRARY_PATH', '')}"

        process = subprocess.Popen(
            [cupsd_path, "-f", "-c", config_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env,
            preexec_fn=os.setsid
        )

        try:
            stdout, stderr = process.communicate(timeout=timeout)
            exit_code = process.returncode
        except subprocess.TimeoutExpired:
            # Process is still running - gracefully handled (no crash)
            os.killpg(os.getpgid(process.pid), signal.SIGTERM)
            time.sleep(0.1)
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGKILL)
            except ProcessLookupError:
                pass
            stdout, stderr = process.communicate()
            # Exit code 0 for timeout means it was running successfully (no crash)
            exit_code = 0

        return exit_code, stdout.decode('utf-8', errors='replace'), stderr.decode('utf-8', errors='replace')
    finally:
        try:
            os.unlink(config_path)
        except OSError:
            pass


def is_crash_exit_code(exit_code: int) -> bool:
    """Check if the exit code indicates a crash (segfault, etc.)."""
    # Python subprocess returns negative signal numbers for signal deaths
    # SIGSEGV (11): Python returns -11, shell returns 139 (128 + 11)
    # SIGABRT (6): Python returns -6, shell returns 134 (128 + 6)
    # SIGBUS (7): Python returns -7, shell returns 135 (128 + 7)

    # Handle Python's negative signal convention
    if exit_code < 0:
        signal_num = -exit_code
        # SIGSEGV=11, SIGABRT=6, SIGBUS=7, SIGFPE=8, SIGILL=4
        crash_signals = [4, 6, 7, 8, 11]
        return signal_num in crash_signals

    # Handle shell convention (128 + signal)
    crash_codes = [134, 135, 139]  # SIGABRT, SIGBUS, SIGSEGV
    return exit_code in crash_codes or (exit_code > 128 and exit_code < 192)


def create_malicious_config(address: str) -> str:
    """Create a CUPS configuration with a malicious IPv6 address using a random port."""
    port = get_random_port()
    return f"""
LogLevel debug
Listen localhost:{port}
<Location />
  Order allow,deny
  Allow from {address}
</Location>
"""


def test_cve_2025_61915_buffer_underflow():
    """
    Test CVE-2025-61915: CUPS IPv6 address parsing buffer underflow.

    This test uses a malicious IPv6 address with 20 segments after ::
    which reliably triggers the buffer underwrite vulnerability.

    The address [::1:2:3:4:5:6:7:8:9:a:b:c:d:e:f:10:11:12:13:14] causes:
    - j = 19 (19 colons counted after ::)
    - i = 6 - 19 = -13
    - After i++: i = -12
    - ip[i/2] = ip[-6] -> buffer underwrite -> SIGSEGV

    In vulnerable state (CUPS < 2.4.15): cupsd crashes with SIGSEGV
    In fixed state (CUPS >= 2.4.15): cupsd handles gracefully
    """
    address = "[::1:2:3:4:5:6:7:8:9:a:b:c:d:e:f:10:11:12:13:14]"
    config = create_malicious_config(address)
    exit_code, stdout, stderr = run_cupsd_with_config(config)

    assert not is_crash_exit_code(exit_code), \
        f"cupsd crashed with exit code {exit_code}. " \
        f"The IPv6 parsing should handle malformed addresses gracefully."
