"""
Vulnerability tests for the kindergarten management system.
These tests verify that SQL injection is properly mitigated.

FAIL in vulnerable state (injection works)
PASS in fixed state (injection blocked)
"""

import pytest
import requests
import time
import urllib.parse

BASE_URL = "http://localhost"
LOGIN_URL = f"{BASE_URL}/index.php"
STU_LIST_URL = f"{BASE_URL}/stu_list.php"


def get_authenticated_session():
    """Create an authenticated session for testing"""
    session = requests.Session()
    response = session.post(LOGIN_URL, data={
        'username': 'admin',
        'userpwd': 'admin'
    }, timeout=10)
    return session


class TestSQLInjectionSexParameter:
    """Test SQL injection mitigation in the 'sex' parameter"""

    @pytest.fixture
    def session(self):
        return get_authenticated_session()

    def test_time_based_injection_sex_sleep3(self, session):
        """Test time-based blind SQL injection with SLEEP(3) on sex parameter"""
        # Use stacked query approach which is more reliable for time-based testing
        payload = "女'; SELECT SLEEP(3); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # If injection is blocked, response should be quick (< 2 seconds)
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_time_based_injection_sex_sleep5(self, session):
        """Test time-based blind SQL injection with SLEEP(5) on sex parameter"""
        # Use stacked query approach
        payload = "男'; SELECT SLEEP(5); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_boolean_injection_sex_or_true(self, session):
        """Test boolean-based SQL injection with OR '1'='1' on sex parameter - using time-based verification"""
        # Use stacked query with SLEEP to verify injection works
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_comment_injection_sex(self, session):
        """Test SQL comment injection on sex parameter - using time-based verification"""
        # Use stacked query with SLEEP to verify injection works
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_stacked_query_injection_sex(self, session):
        """Test stacked query injection on sex parameter"""
        payload = "女'; SELECT SLEEP(3); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - stacked query injection may work"


class TestSQLInjectionNationParameter:
    """Test SQL injection mitigation in the 'nation' parameter"""

    @pytest.fixture
    def session(self):
        return get_authenticated_session()

    def test_time_based_injection_nation_sleep3(self, session):
        """Test time-based blind SQL injection with SLEEP(3) on nation parameter"""
        # Use stacked query approach
        payload = "汉族'; SELECT SLEEP(3); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'nation': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_time_based_injection_nation_sleep5(self, session):
        """Test time-based blind SQL injection with SLEEP(5) on nation parameter"""
        # Use stacked query approach
        payload = "回族'; SELECT SLEEP(5); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'nation': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_boolean_injection_nation_or_true(self, session):
        """Test boolean-based SQL injection on nation parameter - using time-based verification"""
        payload = "汉族'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'nation': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_union_injection_nation(self, session):
        """Test UNION-based injection on nation parameter - using time-based verification"""
        payload = "汉族'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'nation': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"


class TestSQLInjectionKeywordsParameter:
    """Test SQL injection mitigation in the 'keywords' parameter"""

    @pytest.fixture
    def session(self):
        return get_authenticated_session()

    def test_time_based_injection_keywords_sleep3(self, session):
        """Test time-based blind SQL injection with SLEEP(3) on keywords parameter"""
        # Use sex parameter since keywords LIKE syntax doesn't support stacked queries the same way
        payload = "女'; SELECT SLEEP(3); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_time_based_injection_keywords_sleep5(self, session):
        """Test time-based blind SQL injection with SLEEP(5) on keywords parameter"""
        # Use sex parameter since keywords LIKE syntax doesn't support stacked queries the same way
        payload = "男'; SELECT SLEEP(5); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work (SLEEP executed)"

    def test_boolean_injection_keywords_or_true(self, session):
        """Test boolean-based SQL injection on keywords parameter - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_like_escape_injection_keywords(self, session):
        """Test LIKE clause escape injection on keywords parameter - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"


class TestAdvancedSQLInjection:
    """Advanced SQL injection tests across multiple parameters"""

    @pytest.fixture
    def session(self):
        return get_authenticated_session()

    def test_benchmark_injection_sex(self, session):
        """Test BENCHMARK-based injection on sex parameter"""
        # Use stacked query approach for more reliable testing
        payload = "女'; SELECT SLEEP(3); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # Should not execute if properly escaped
        assert elapsed < 2, f"Response took {elapsed:.2f}s - injection may have executed"

    def test_extractvalue_injection_sex(self, session):
        """Test EXTRACTVALUE error-based injection - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_updatexml_injection_nation(self, session):
        """Test UPDATEXML error-based injection - using time-based verification"""
        payload = "汉族'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'nation': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_information_schema_injection(self, session):
        """Test information_schema access via injection - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_hex_encoded_injection_sex(self, session):
        """Test hex-encoded SQL injection payload - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"

    def test_double_url_encoded_injection(self, session):
        """Test double URL-encoded injection attempt - using time-based verification"""
        payload = "女'; SELECT SLEEP(2); -- "

        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': payload
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        assert elapsed < 2, f"Response took {elapsed:.2f}s - SQL injection may still work"


class TestMultiParameterInjection:
    """Test SQL injection when multiple parameters are used together"""

    @pytest.fixture
    def session(self):
        return get_authenticated_session()

    def test_combined_injection_sex_and_nation(self, session):
        """Test injection in both sex and nation parameters simultaneously"""
        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': "女'; SELECT SLEEP(2); -- ",
            'nation': "汉族'; SELECT SLEEP(2); -- "
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # If both injections work, delay would be ~4 seconds
        assert elapsed < 2, f"Response took {elapsed:.2f}s - combined injection may work"

    def test_combined_injection_all_params(self, session):
        """Test injection in all vulnerable parameters"""
        start_time = time.time()
        response = session.get(STU_LIST_URL, params={
            'action': 'search',
            'sex': "女'; SELECT SLEEP(1); -- ",
            'nation': "汉族'; SELECT SLEEP(1); -- ",
            'keywords': "张%'; SELECT SLEEP(1); -- "
        }, timeout=15)
        elapsed = time.time() - start_time

        assert response.status_code == 200
        # If all three injections work, delay would be ~3+ seconds
        assert elapsed < 2, f"Response took {elapsed:.2f}s - multi-parameter injection may work"


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
