"""
Functional tests for WeGIA password configuration page.
These tests verify that the application works correctly and should PASS
in both vulnerable and fixed states.
"""
import os
import pytest
import requests
import pymysql

# Configuration
BASE_URL = os.environ.get("APP_URL", "http://localhost:8080")
DB_HOST = os.environ.get("DB_HOST", "localhost")
DB_USER = os.environ.get("DB_USER", "wegiauser")
DB_PASSWORD = os.environ.get("DB_PASSWORD", "senha")
DB_NAME = os.environ.get("DB_NAME", "wegia")

TARGET_PAGE = f"{BASE_URL}/WeGIA/html/geral/configurar_senhas.php"


def get_db_connection():
    """Create a database connection."""
    return pymysql.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME,
        charset='utf8mb4',
        cursorclass=pymysql.cursors.DictCursor
    )


def get_authenticated_session():
    """Create an authenticated session for accessing protected pages."""
    session = requests.Session()

    # Attempt login - WeGIA uses html/login.php with cpf and pwd fields
    login_url = f"{BASE_URL}/WeGIA/html/login.php"
    login_data = {
        "cpf": "admin",
        "pwd": "wegia"
    }

    try:
        # Try to login
        response = session.post(login_url, data=login_data, allow_redirects=True, timeout=10)
    except requests.exceptions.RequestException:
        pass

    return session


class TestPageLoads:
    """Test that the password configuration page loads correctly."""

    def test_page_returns_http_200(self):
        """The page should return HTTP 200 when accessed with a valid session."""
        session = get_authenticated_session()

        try:
            response = session.get(TARGET_PAGE, timeout=10)
            # Page might redirect if not authenticated, but shouldn't return 500
            assert response.status_code in [200, 302, 403], \
                f"Unexpected status code: {response.status_code}"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")

    def test_page_contains_form_elements(self):
        """The page should contain the password change form elements."""
        session = get_authenticated_session()

        try:
            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                html = response.text
                # Check for form elements
                assert '<form' in html.lower(), "Page should contain a form"
                assert 'nova_senha' in html, "Page should have password input"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")

    def test_page_contains_employee_dropdown(self):
        """The page should contain the employee selection dropdown."""
        session = get_authenticated_session()

        try:
            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                html = response.text
                assert '<select' in html.lower(), "Page should contain a select dropdown"
                assert 'id_pessoa' in html, "Page should have employee dropdown"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")


class TestDatabaseConnectivity:
    """Test that the database is properly configured."""

    def test_database_connection(self):
        """Verify that we can connect to the database."""
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            conn.close()
            assert result is not None
        except Exception as e:
            pytest.skip(f"Database not available: {e}")

    def test_required_tables_exist(self):
        """Verify that the required tables exist in the database."""
        try:
            conn = get_db_connection()
            cursor = conn.cursor()

            required_tables = ['pessoa', 'funcionario', 'cargo']
            for table in required_tables:
                cursor.execute(f"SHOW TABLES LIKE '{table}'")
                result = cursor.fetchone()
                assert result is not None, f"Table '{table}' should exist"

            conn.close()
        except Exception as e:
            pytest.skip(f"Database not available: {e}")


class TestNormalEmployeeNames:
    """Test that normal employee names are displayed correctly."""

    def test_regular_names_display(self):
        """Regular employee names should display correctly in the dropdown."""
        session = get_authenticated_session()

        # Create a normal employee for testing
        normal_name = "Maria Silva Santos"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()

            # Insert test employee with normal name
            cursor.execute(
                "INSERT INTO pessoa (nome, cpf, senha) VALUES (%s, 'func_test_001', 'hash123')",
                (normal_name,)
            )
            pessoa_id = cursor.lastrowid

            # Ensure cargo exists
            cursor.execute("INSERT IGNORE INTO cargo (id_cargo, cargo) VALUES (50, 'Teste Cargo')")

            # Ensure situacao exists
            cursor.execute("INSERT IGNORE INTO situacao (id_situacao, situacoes) VALUES (1, 'Ativo')")

            # Insert funcionario record
            cursor.execute(
                "INSERT INTO funcionario (id_pessoa, id_cargo, id_situacao, data_admissao, ctps) "
                "VALUES (%s, 50, 1, CURDATE(), '12345')",
                (pessoa_id,)
            )
            conn.commit()

            # Fetch the page
            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                # Verify the normal name appears in the response
                assert normal_name in response.text or "Maria" in response.text, \
                    "Normal employee name should appear in the dropdown"

            # Cleanup
            cursor.execute("DELETE FROM funcionario WHERE id_pessoa = %s", (pessoa_id,))
            cursor.execute("DELETE FROM pessoa WHERE id_pessoa = %s", (pessoa_id,))
            conn.commit()
            conn.close()

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")

    def test_names_with_accents_display(self):
        """Employee names with accented characters should display correctly."""
        session = get_authenticated_session()

        # Name with Portuguese accented characters
        accented_name = "José Gonçalves Ação"

        try:
            conn = get_db_connection()
            cursor = conn.cursor()

            cursor.execute(
                "INSERT INTO pessoa (nome, cpf, senha) VALUES (%s, 'func_test_002', 'hash123')",
                (accented_name,)
            )
            pessoa_id = cursor.lastrowid

            cursor.execute("INSERT IGNORE INTO cargo (id_cargo, cargo) VALUES (51, 'Gerente')")
            cursor.execute("INSERT IGNORE INTO situacao (id_situacao, situacoes) VALUES (1, 'Ativo')")

            cursor.execute(
                "INSERT INTO funcionario (id_pessoa, id_cargo, id_situacao, data_admissao, ctps) "
                "VALUES (%s, 51, 1, CURDATE(), '12346')",
                (pessoa_id,)
            )
            conn.commit()

            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                # Check if accented characters are preserved in some form
                assert "Jos" in response.text or "Gon" in response.text, \
                    "Employee name should appear in the page"

            # Cleanup
            cursor.execute("DELETE FROM funcionario WHERE id_pessoa = %s", (pessoa_id,))
            cursor.execute("DELETE FROM pessoa WHERE id_pessoa = %s", (pessoa_id,))
            conn.commit()
            conn.close()

        except pymysql.Error as e:
            pytest.skip(f"Database error: {e}")
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")


class TestFormFunctionality:
    """Test the password change form functionality."""

    def test_form_has_correct_action(self):
        """The form should submit to the correct endpoint."""
        session = get_authenticated_session()

        try:
            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                html = response.text
                assert 'control.php' in html, "Form should submit to control.php"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")

    def test_form_has_required_hidden_fields(self):
        """The form should contain the required hidden fields."""
        session = get_authenticated_session()

        try:
            response = session.get(TARGET_PAGE, timeout=10)

            if response.status_code == 200:
                html = response.text
                assert 'nomeClasse' in html, "Form should have nomeClasse hidden field"
                assert 'metodo' in html, "Form should have metodo hidden field"
                assert 'alterarSenha' in html, "Form should reference alterarSenha method"
        except requests.exceptions.RequestException as e:
            pytest.skip(f"Could not connect to application: {e}")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
