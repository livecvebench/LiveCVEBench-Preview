"""
Vulnerability tests for the PAX header size override bug.

These tests verify that the PAX-specified size smuggling vulnerability EXISTS.
- FAIL in vulnerable state (parser uses ustar size=0, extracts smuggled entries)
- PASS in fixed state (parser uses PAX size, correctly skips content)

The vulnerability allows attackers to smuggle additional entries into a tar archive
by setting PAX size larger than ustar size, with crafted content containing fake headers.

IMPORTANT: ALL tests in this file should FAIL when the vulnerability exists.
"""
import subprocess
import tempfile
import os
import struct


def write_octal(value: int, field_size: int) -> bytes:
    """Write an octal value with proper padding for tar header fields."""
    octal_str = f'{value:o}'
    if len(octal_str) >= field_size:
        return b'7' * (field_size - 1) + b'\x00'
    padding = field_size - 1 - len(octal_str)
    return (b'0' * padding + octal_str.encode() + b'\x00')


def calculate_checksum(header: bytes) -> int:
    """Calculate tar header checksum.
    The checksum is computed as the sum of all bytes in the header,
    treating the 8-byte checksum field (bytes 148-155) as spaces.
    """
    total = 0
    for i in range(512):
        if 148 <= i < 156:
            total += 32  # ASCII space
        else:
            total += header[i] if i < len(header) else 0
    return total


def set_header_field(header: bytearray, offset: int, data: bytes):
    """Set a field in the header without changing header size."""
    for i, b in enumerate(data):
        if offset + i < 512:
            header[offset + i] = b


def create_tar_header(name: bytes, size: int, typeflag: str = '0') -> bytearray:
    """Create a tar header with proper checksum."""
    header = bytearray(512)

    # Name: bytes 0-99
    set_header_field(header, 0, name[:100])

    # Mode: bytes 100-107
    set_header_field(header, 100, b'0000644\x00')

    # UID: bytes 108-115
    set_header_field(header, 108, b'0000000\x00')

    # GID: bytes 116-123
    set_header_field(header, 116, b'0000000\x00')

    # Size: bytes 124-135
    set_header_field(header, 124, write_octal(size, 12))

    # Mtime: bytes 136-147
    set_header_field(header, 136, b'00000000000\x00')

    # Checksum placeholder: bytes 148-155 (spaces for calculation)
    set_header_field(header, 148, b'        ')

    # Type: byte 156
    header[156] = ord(typeflag)

    # Magic: bytes 257-262
    set_header_field(header, 257, b'ustar\x00')

    # Version: bytes 263-264
    set_header_field(header, 263, b'00')

    # Calculate and set checksum
    checksum = calculate_checksum(bytes(header))
    checksum_str = f'{checksum:06o}\x00 '.encode()
    set_header_field(header, 148, checksum_str)

    return header


def create_pax_smuggling_tar(output_path: str, pax_size: int = 1024,
                               inner_filename: str = "SMUGGLED_ENTRY"):
    """
    Create a tar file that exploits the PAX size desync vulnerability.

    Structure:
    1. normal.txt - A regular file
    2. PAX header for blob.bin declaring size=pax_size
    3. blob.bin with ustar size=0 (but content is pax_size bytes)
       Content contains a fake tar header that would be misread as an entry
    4. marker.txt - A marker file

    Vulnerable behavior: Parser sees 4 entries (including fake inner entry)
    Fixed behavior: Parser sees 3 entries (normal.txt, blob.bin, marker.txt)
    """
    with open(output_path, 'wb') as f:
        # === Entry 1: normal.txt ===
        normal_content = b"Hello\n"
        header = create_tar_header(b"normal.txt", len(normal_content), '0')
        f.write(bytes(header))
        f.write(normal_content)
        padding = (512 - (len(normal_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # === Entry 2: PAX header for blob.bin ===
        # PAX format: "length key=value\n"
        pax_size_str = str(pax_size)
        pax_record = f"size={pax_size_str}\n"
        # Calculate proper length including the length prefix itself
        base_len = 1 + len(pax_record)  # space + record
        for digits in range(2, 10):
            total_len = digits + base_len
            if total_len < 10**digits:
                break
        pax_data = f"{total_len} {pax_record}"
        pax_content = pax_data.encode('utf-8')

        pax_header = create_tar_header(b"PaxHeader/blob.bin", len(pax_content), 'x')
        f.write(bytes(pax_header))
        f.write(pax_content)
        padding = (512 - (len(pax_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # === Entry 3: blob.bin with ustar size=0 ===
        # This is the key: ustar says size=0, but PAX said size=pax_size
        # Content contains a fake tar header for smuggling

        # Create fake inner content (pax_size bytes total)
        fake_content = bytearray(pax_size)

        # Fake header at offset 0 (first 512 bytes)
        inner_header = create_tar_header(inner_filename.encode('utf-8'), 100, '0')
        for i, b in enumerate(inner_header):
            if i < pax_size:
                fake_content[i] = b

        # Fake content at offset 512 (100 bytes of 'B')
        if pax_size >= 612:
            for i in range(100):
                fake_content[512 + i] = ord('B')

        # Now write blob.bin header with size=0!
        blob_header = create_tar_header(b"blob.bin", 0, '0')  # SIZE = 0!
        f.write(bytes(blob_header))

        # Write the actual content (pax_size bytes)
        # Vulnerable parser will skip 0 bytes and read this as a header!
        f.write(bytes(fake_content))

        # === Entry 4: marker.txt ===
        marker_content = b"MARKER\n"
        marker_header = create_tar_header(b"marker.txt", len(marker_content), '0')
        f.write(bytes(marker_header))
        f.write(marker_content)
        padding = (512 - (len(marker_content) % 512)) % 512
        f.write(b'\x00' * padding)

        # End of archive (two zero blocks)
        f.write(b'\x00' * 1024)


def setup_test_binary():
    """
    Create a test binary that counts entries in a tar file using the vulnerable library.
    Returns the path to the compiled binary.
    """
    test_code = '''
use tokio_tar::Archive;
use tokio::fs::File;
use tokio_stream::StreamExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let tar_path = std::env::args().nth(1).expect("Usage: count_entries <tar_file>");
    let file = File::open(&tar_path).await?;
    let mut archive = Archive::new(file);
    let mut entries = archive.entries()?;

    let mut count = 0;
    let mut names = Vec::new();
    while let Some(entry) = entries.next().await {
        let entry = entry?;
        let path = entry.path()?.to_string_lossy().to_string();
        names.push(path.clone());
        eprintln!("ENTRY: {}", path);
        count += 1;
    }

    println!("ENTRY_COUNT={}", count);
    for name in &names {
        println!("ENTRY_NAME={}", name);
    }

    Ok(())
}
'''
    example_dir = "/app/examples"
    subprocess.run(["mkdir", "-p", example_dir], check=True)
    example_path = f"{example_dir}/count_entries.rs"
    with open(example_path, "w") as f:
        f.write(test_code)

    result = subprocess.run(
        ["cargo", "build", "--release", "--example", "count_entries"],
        cwd="/app",
        capture_output=True,
        text=True,
        timeout=300
    )

    if result.returncode != 0:
        raise RuntimeError(f"Failed to build test binary: {result.stderr}")

    return "/app/target/release/examples/count_entries"


class TestPAXSizeSmuggling:
    """
    Test suite for PAX header size override vulnerability.

    The vulnerability allows an attacker to "smuggle" extra entries into a tar
    archive by exploiting the discrepancy between PAX-declared size and ustar size.

    ALL tests should FAIL in vulnerable state (smuggled entry found).
    ALL tests should PASS in fixed state (no smuggled entry).
    """

    def test_pax_size_precedence_basic(self, tmp_path):
        """
        Test that PAX size takes precedence over ustar size.

        Creates a tar where:
        - PAX header declares size=1024
        - ustar header has size=0
        - Content contains a fake tar header

        PASS: Parser uses PAX size, skips 1024 bytes, finds 3 entries
        FAIL: Parser uses ustar size=0, reads fake header, finds 4 entries
        """
        tar_path = str(tmp_path / "pax_smuggle.tar")
        create_pax_smuggling_tar(tar_path, pax_size=1024, inner_filename="SMUGGLED")

        binary_path = setup_test_binary()

        result = subprocess.run(
            [binary_path, tar_path],
            capture_output=True,
            text=True,
            timeout=60
        )

        output = result.stdout + result.stderr
        print(f"Test output:\n{output}")

        # Parse the entry count
        count = None
        for line in output.split('\n'):
            if 'ENTRY_COUNT=' in line:
                count = int(line.split('=')[1])
                break

        if count is None:
            # If we can't parse output, check for error messages
            if "Error" in output:
                raise RuntimeError(f"Library error during parsing:\n{output}")
            raise RuntimeError(f"Could not find ENTRY_COUNT in output:\n{output}")

        # Check for smuggled entry
        has_smuggled = "SMUGGLED" in output

        # Test should FAIL if vulnerability exists (smuggled entry found)
        assert not has_smuggled, (
            f"VULNERABILITY EXISTS: Smuggled entry detected!\n"
            f"Found {count} entries (expected 3 without smuggling).\n"
            f"Entry names: {[l for l in output.split(chr(10)) if 'ENTRY' in l]}"
        )
        assert count == 3, (
            f"VULNERABILITY EXISTS: Wrong entry count!\n"
            f"Found {count} entries (expected 3). Smuggled entry was extracted.\n"
            f"Output: {output}"
        )

    def test_no_smuggled_entries(self, tmp_path):
        """
        Verify that no smuggled entries appear during extraction.

        Expected entries: normal.txt, blob.bin, marker.txt (3 total)
        Vulnerable: normal.txt, blob.bin, HIDDEN_FILE, marker.txt (4 total)
        """
        tar_path = str(tmp_path / "test_smuggle.tar")
        create_pax_smuggling_tar(tar_path, pax_size=1024, inner_filename="HIDDEN_FILE")

        binary_path = setup_test_binary()

        result = subprocess.run(
            [binary_path, tar_path],
            capture_output=True,
            text=True,
            timeout=60
        )

        output = result.stdout + result.stderr
        print(f"Test output:\n{output}")

        # Check for smuggled entry
        assert "HIDDEN_FILE" not in output, (
            f"VULNERABILITY EXISTS: HIDDEN_FILE smuggled entry detected!\n{output}"
        )

    def test_smuggled_entry_with_various_sizes(self, tmp_path):
        """
        Test multiple PAX size values to ensure vulnerability is consistently present.
        """
        test_sizes = [1024, 2048]  # Only test sizes that work properly
        binary_path = setup_test_binary()

        for pax_size in test_sizes:
            tar_path = str(tmp_path / f"smuggle_{pax_size}.tar")
            create_pax_smuggling_tar(
                tar_path,
                pax_size=pax_size,
                inner_filename=f"SMUGGLED_{pax_size}"
            )

            result = subprocess.run(
                [binary_path, tar_path],
                capture_output=True,
                text=True,
                timeout=60
            )

            output = result.stdout + result.stderr
            print(f"Size {pax_size} output:\n{output}")

            # Verify no smuggled entry with this size
            assert f"SMUGGLED_{pax_size}" not in output, (
                f"VULNERABILITY EXISTS: Smuggled entry with PAX size {pax_size} detected!\n{output}"
            )

    def test_large_pax_size_value(self, tmp_path):
        """
        Test with a larger PAX size to ensure proper handling.
        """
        tar_path = str(tmp_path / "large_pax.tar")
        create_pax_smuggling_tar(tar_path, pax_size=10240, inner_filename="BIG_SMUGGLE")

        binary_path = setup_test_binary()

        result = subprocess.run(
            [binary_path, tar_path],
            capture_output=True,
            text=True,
            timeout=60
        )

        output = result.stdout + result.stderr
        print(f"Large PAX test output:\n{output}")

        assert "BIG_SMUGGLE" not in output, (
            f"VULNERABILITY EXISTS: Large PAX smuggled entry detected!\n{output}"
        )
