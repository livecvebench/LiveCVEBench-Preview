"""
Functionality tests for dataCompare database connection configuration.
These tests verify the application works correctly for legitimate use cases.
Should PASS in both vulnerable and fixed states.
"""

import pytest
import requests
import time

BASE_URL = "http://localhost"
LOGIN_URL = f"{BASE_URL}/login"
TEST_CONN_URL = f"{BASE_URL}/system/dbconfig/testConnection"

# Default credentials
USERNAME = "admin"
PASSWORD = "admin123"


class TestSession:
    """Shared session for authenticated requests"""
    _session = None
    _cookies = None

    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            cls._cookies = cls._login()
        return cls._session, cls._cookies

    @classmethod
    def _login(cls):
        """Login and get session cookies"""
        session = cls._session

        # First get the login page to get any CSRF tokens
        login_page = session.get(f"{BASE_URL}/login", timeout=10)

        # Attempt login
        login_data = {
            "username": USERNAME,
            "password": PASSWORD,
            "rememberMe": "false"
        }

        # Try form-based login
        response = session.post(
            LOGIN_URL,
            data=login_data,
            allow_redirects=True,
            timeout=10
        )

        return session.cookies


@pytest.fixture(scope="module")
def auth_session():
    """Provide authenticated session for tests"""
    session, cookies = TestSession.get_session()
    return session


class TestDatabaseTypeValidation:
    """Test that database type validation works correctly"""

    def test_invalid_database_type_rejected(self, auth_session):
        """Test that an invalid database type is rejected"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_invalid_type",
                "type": "InvalidDatabaseType",
                "url": "jdbc:invalid://localhost:3306/test",
                "userName": "root",
                "pwd": "password"
            },
            timeout=10
        )

        assert response.status_code == 200
        result = response.json()
        # Should fail with unrecognized type error
        assert result.get("code") != 0 or "不识别的类型" in result.get("msg", "") or "error" in str(result).lower()

    def test_mysql_type_accepted(self, auth_session):
        """Test that MySQL type is recognized as valid"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_mysql_type",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/nonexistent_db",
                "userName": "root",
                "pwd": "wrongpassword"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # It should try to connect (may fail due to wrong credentials/host, but type is valid)
        # Should not say "unrecognized type"
        msg = result.get("msg", "")
        assert "不识别的类型" not in msg

    def test_hive_type_accepted(self, auth_session):
        """Test that Hive type is recognized as valid"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_hive_type",
                "type": "Hive",
                "url": "jdbc:hive2://localhost:10000/default",
                "userName": "hive",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # Type should be recognized (connection may fail, but type is valid)
        msg = result.get("msg", "")
        assert "不识别的类型" not in msg

    def test_doris_type_accepted(self, auth_session):
        """Test that Doris type is recognized as valid"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_doris_type",
                "type": "Doris",
                "url": "jdbc:mysql://localhost:9030/test",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # Type should be recognized
        msg = result.get("msg", "")
        assert "不识别的类型" not in msg


class TestBasicConnectionParameters:
    """Test basic connection parameter handling"""

    def test_clean_jdbc_url_format(self, auth_session):
        """Test that clean JDBC URLs are processed correctly"""
        # This tests the basic flow works - connection may fail but URL processing should work
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_clean_url",
                "type": "MySQL",
                "url": "jdbc:mysql://mysql:3306/dataCompare?useSSL=false&serverTimezone=UTC",
                "userName": "root",
                "pwd": "123456"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # Clean URL with safe parameters should be processed
        # May succeed or fail based on actual DB availability
        assert isinstance(result, dict)
        assert "msg" in result

    def test_url_with_standard_parameters(self, auth_session):
        """Test that standard JDBC parameters are allowed"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_standard_params",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test?useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai",
                "userName": "root",
                "pwd": "password"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # Standard parameters should be accepted
        msg = result.get("msg", "")
        # Should not reject these safe parameters
        assert "非法" not in msg.lower() or "illegal" not in msg.lower()


class TestAPIEndpointResponsiveness:
    """Test that the API endpoint is responsive and returns proper format"""

    def test_endpoint_returns_json(self, auth_session):
        """Test that the endpoint returns valid JSON"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_json",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test",
                "userName": "root",
                "pwd": "test"
            },
            timeout=30
        )

        assert response.status_code == 200
        # Should be valid JSON
        result = response.json()
        assert isinstance(result, dict)

    def test_endpoint_handles_missing_type(self, auth_session):
        """Test that missing type parameter is handled"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "test_no_type",
                "type": "",
                "url": "jdbc:mysql://localhost:3306/test",
                "userName": "root",
                "pwd": "test"
            },
            timeout=30
        )

        assert response.status_code == 200
        result = response.json()
        # Should return an error response
        assert result.get("code") != 0 or "error" in result.get("msg", "").lower() or "失败" in result.get("msg", "")


class TestConnectionEndpointAvailability:
    """Test that the connection test endpoint is available"""

    def test_endpoint_exists(self, auth_session):
        """Test that the testConnection endpoint exists and is accessible"""
        response = auth_session.post(
            TEST_CONN_URL,
            data={
                "connectName": "availability_test",
                "type": "MySQL",
                "url": "jdbc:mysql://localhost:3306/test",
                "userName": "test",
                "pwd": "test"
            },
            timeout=30
        )

        # Should not return 404
        assert response.status_code != 404
        # Should return 200 (even if connection fails, endpoint works)
        assert response.status_code == 200
