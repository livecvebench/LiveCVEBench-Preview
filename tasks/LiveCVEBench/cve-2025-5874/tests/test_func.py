"""
Functional tests for Redash Python query runner.

These tests verify that the Python query runner works correctly for legitimate
Python queries. They should PASS in both vulnerable and fixed states.

This version creates a minimal test harness that replicates the vulnerable
execution context without requiring the full Redash application stack.
"""
import sys
import json
import pytest

# Add the app directory to the path for imports
sys.path.insert(0, '/app')

from RestrictedPython import compile_restricted
from RestrictedPython.Guards import safe_builtins, guarded_iter_unpack_sequence, guarded_unpack_sequence


def custom_write(obj):
    """Custom hook for RestrictedPython writes."""
    return obj


def custom_get_item(obj, key):
    """Custom hook for item access."""
    return obj[key]


def custom_get_iter(obj):
    """Custom hook for iteration."""
    return iter(obj)


def custom_import(name, globals=None, locals=None, fromlist=(), level=0):
    """Restricted import - blocks all imports for security."""
    raise Exception(f"'{name}' is not configured as a supported import module")


class CustomPrint:
    """Custom print handler for RestrictedPython."""
    def __init__(self):
        self.lines = []

    def write(self, text):
        if text and text.strip():
            self.lines.append(text)

    def __call__(self, *args):
        return self

    def _call_print(self, *objects, **kwargs):
        print(*objects, file=self)


def run_restricted_query(query):
    """
    Execute a query in a RestrictedPython environment that replicates
    the vulnerable Redash Python query runner.

    Returns: (data, error) tuple
    """
    try:
        code = compile_restricted(query, "<string>", "exec")

        builtins = safe_builtins.copy()
        builtins["_write_"] = custom_write
        builtins["__import__"] = custom_import
        # This is the VULNERABLE configuration - using native getattr
        builtins["_getattr_"] = getattr
        builtins["getattr"] = getattr
        builtins["_setattr_"] = setattr
        builtins["setattr"] = setattr
        builtins["_getitem_"] = custom_get_item
        builtins["_getiter_"] = custom_get_iter
        builtins["_print_"] = CustomPrint()
        builtins["_unpack_sequence_"] = guarded_unpack_sequence
        builtins["_iter_unpack_sequence_"] = guarded_iter_unpack_sequence

        # Add safe builtins
        safe_builtin_names = (
            "sorted", "reversed", "map", "any", "all", "slice",
            "filter", "len", "next", "enumerate", "sum", "abs",
            "min", "max", "round", "divmod", "str", "int", "float",
            "complex", "tuple", "set", "list", "dict", "bool",
        )
        for name in safe_builtin_names:
            builtins[name] = __builtins__[name] if isinstance(__builtins__, dict) else getattr(__builtins__, name)

        script_locals = {"result": {"rows": [], "columns": [], "log": []}}

        exec(code, {"__builtins__": builtins}, script_locals)

        result = script_locals.get("result", {"rows": [], "columns": []})
        return json.dumps(result), None

    except SyntaxError as e:
        return None, f"Syntax error in query: {e}"
    except Exception as e:
        return None, str(e)


class TestBasicFunctionality:
    """Tests for basic Python query execution functionality."""

    def test_simple_arithmetic(self):
        """Test basic arithmetic operations in Python queries."""
        query = """
a = 10
b = 20
total = a + b
result = {"rows": [{"value": total}], "columns": [{"name": "value", "type": "integer"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["value"] == 30

    def test_list_operations(self):
        """Test list operations in Python queries."""
        query = """
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)
length = len(numbers)
result = {"rows": [{"sum": total, "count": length}], "columns": [{"name": "sum"}, {"name": "count"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["sum"] == 15
        assert result["rows"][0]["count"] == 5

    def test_dictionary_operations(self):
        """Test dictionary operations in Python queries."""
        query = """
data = {"a": 1, "b": 2, "c": 3}
keys_list = list(data.keys())
values_sum = sum(data.values())
result = {"rows": [{"keys_count": len(keys_list), "values_sum": values_sum}], "columns": [{"name": "keys_count"}, {"name": "values_sum"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["keys_count"] == 3
        assert result["rows"][0]["values_sum"] == 6

    def test_string_operations(self):
        """Test string operations in Python queries."""
        query = """
text = "hello world"
upper_text = text.upper()
length = len(text)
result = {"rows": [{"upper": upper_text, "length": length}], "columns": [{"name": "upper"}, {"name": "length"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["upper"] == "HELLO WORLD"
        assert result["rows"][0]["length"] == 11


class TestBuiltinFunctions:
    """Tests for safe builtin functions."""

    def test_map_filter_functions(self):
        """Test map and filter builtin functions."""
        query = """
numbers = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, numbers))
doubled = list(map(lambda x: x * 2, evens))
result = {"rows": [{"doubled_evens": doubled}], "columns": [{"name": "doubled_evens"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["doubled_evens"] == [4, 8, 12]

    def test_sorted_function(self):
        """Test sorted builtin function."""
        query = """
numbers = [5, 2, 8, 1, 9, 3]
sorted_asc = sorted(numbers)
sorted_desc = sorted(numbers, reverse=True)
result = {"rows": [{"asc": sorted_asc, "desc": sorted_desc}], "columns": [{"name": "asc"}, {"name": "desc"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["asc"] == [1, 2, 3, 5, 8, 9]
        assert result["rows"][0]["desc"] == [9, 8, 5, 3, 2, 1]

    def test_range_enumerate(self):
        """Test range and enumerate functions."""
        query = """
range_list = list(range(5))
items = ['a', 'b', 'c']
enumerated = list(enumerate(items))
result = {"rows": [{"range": range_list, "enumerated": enumerated}], "columns": [{"name": "range"}, {"name": "enumerated"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["range"] == [0, 1, 2, 3, 4]
        assert result["rows"][0]["enumerated"] == [[0, 'a'], [1, 'b'], [2, 'c']]


class TestLegitimateAttributeAccess:
    """Tests for legitimate attribute access that should work."""

    def test_public_method_access(self):
        """Test accessing public methods on objects."""
        query = """
my_list = [1, 2, 3]
my_list.append(4)
length = len(my_list)
result = {"rows": [{"length": length, "list": my_list}], "columns": [{"name": "length"}, {"name": "list"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["length"] == 4
        assert result["rows"][0]["list"] == [1, 2, 3, 4]

    def test_string_method_access(self):
        """Test accessing string methods via attribute access."""
        query = """
text = "hello"
upper_method = getattr(text, "upper")
upper_result = upper_method()
result = {"rows": [{"upper": upper_result}], "columns": [{"name": "upper"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"][0]["upper"] == "HELLO"

    def test_dict_method_access(self):
        """Test accessing dictionary methods."""
        query = """
data = {"a": 1, "b": 2}
keys_method = getattr(data, "keys")
keys_list = list(keys_method())
result = {"rows": [{"keys": keys_list}], "columns": [{"name": "keys"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert set(result["rows"][0]["keys"]) == {"a", "b"}


class TestResultFormat:
    """Tests for proper result format handling."""

    def test_empty_result(self):
        """Test returning empty result."""
        query = """
result = {"rows": [], "columns": [{"name": "empty"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert result["rows"] == []

    def test_multiple_rows(self):
        """Test returning multiple rows."""
        query = """
rows = []
for i in range(5):
    rows.append({"index": i, "square": i * i})
result = {"rows": rows, "columns": [{"name": "index"}, {"name": "square"}]}
"""
        data, error = run_restricted_query(query)

        assert error is None, f"Unexpected error: {error}"
        assert data is not None
        result = json.loads(data)
        assert len(result["rows"]) == 5
        assert result["rows"][0]["square"] == 0
        assert result["rows"][4]["square"] == 16


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
