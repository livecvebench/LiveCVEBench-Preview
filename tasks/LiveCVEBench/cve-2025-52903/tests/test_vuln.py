"""
Vulnerability tests for File Browser command execution bypass.
These tests verify whether the command allowlist bypass vulnerability exists.

In the VULNERABLE state: These tests should FAIL (vulnerability is exploitable)
In the FIXED state: These tests should PASS (vulnerability is mitigated)
"""
import pytest
import requests
import time
import json

# Try to import websocket-client
try:
    import websocket
    WEBSOCKET_AVAILABLE = True
except ImportError:
    WEBSOCKET_AVAILABLE = False

BASE_URL = "http://localhost:80"
WS_URL = "ws://localhost:80/api/command"
TEST_USER = "testuser"
TEST_PASS = "testpass"


def wait_for_service(url, timeout=60):
    """Wait for the service to become available."""
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(url, timeout=5)
            if response.status_code in [200, 401, 403]:
                return True
        except requests.exceptions.RequestException:
            pass
        time.sleep(2)
    return False


def get_auth_token():
    """Authenticate and get JWT token."""
    response = requests.post(
        f"{BASE_URL}/api/login",
        json={"username": TEST_USER, "password": TEST_PASS},
        timeout=10
    )
    if response.status_code != 200:
        raise Exception(f"Authentication failed: {response.status_code}")

    # File Browser v2.32.0 returns raw JWT token as text/plain, not JSON
    token = response.text.strip()
    if token and token.startswith("eyJ"):
        return token
    raise Exception("No token in response")


def execute_command_via_websocket(token, command, timeout=10):
    """Execute a command via WebSocket and return the output."""
    if not WEBSOCKET_AVAILABLE:
        pytest.skip("websocket-client not installed")

    ws = websocket.WebSocket()
    ws.settimeout(timeout)

    try:
        # Connect with auth cookie
        ws.connect(WS_URL, cookie=f"auth={token}")

        # Send command
        ws.send(command)

        # Collect all output
        output_parts = []
        try:
            while True:
                result = ws.recv()
                if result:
                    output_parts.append(result)
                else:
                    break
        except websocket.WebSocketTimeoutException:
            pass
        except websocket.WebSocketConnectionClosedException:
            pass

        return "".join(output_parts)
    finally:
        try:
            ws.close()
        except:
            pass


class TestCommandAllowlistBypass:
    """
    Test that the command allowlist bypass vulnerability is FIXED.

    The test user has "find" in their allowlist. In the vulnerable version,
    they can execute arbitrary commands via find's -exec flag.

    After fix: These exploitation attempts should be blocked.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is available before tests."""
        assert wait_for_service(BASE_URL), "Service not available"

    def test_basic_find_exec_injection_blocked(self):
        """
        Test that find -exec cannot be used to execute arbitrary commands.

        In vulnerable version: executes whoami and returns username
        In fixed version: command is rejected
        """
        token = get_auth_token()

        # Try to execute whoami via find -exec
        malicious_cmd = "find . -exec whoami \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # After fix, this should be rejected
        # The output should contain rejection message, NOT executed command output
        assert "Command not allowed" in output or output.strip() == "", \
            f"Command injection succeeded! Output: {output}"

    def test_find_exec_id_command_blocked(self):
        """
        Test that find -exec cannot execute the 'id' command.
        """
        token = get_auth_token()

        malicious_cmd = "find . -exec id \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # Should not contain uid= which would indicate 'id' command ran
        assert "uid=" not in output, \
            f"Command injection via 'id' succeeded! Output: {output}"
        assert "Command not allowed" in output or output.strip() == "", \
            f"Unexpected output: {output}"

    def test_find_exec_pwd_command_blocked(self):
        """
        Test that find -exec cannot execute the 'pwd' command.
        """
        token = get_auth_token()

        malicious_cmd = "find . -exec pwd \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # After fix, should be rejected
        assert "Command not allowed" in output or not output.startswith("/"), \
            f"Command injection via 'pwd' succeeded! Output: {output}"

    def test_find_exec_cat_etc_passwd_blocked(self):
        """
        Test that find -exec cannot read /etc/passwd directly.
        """
        token = get_auth_token()

        # Read /etc/passwd directly via find -exec cat
        malicious_cmd = "find /etc/passwd -exec cat {} \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd, timeout=15)

        # In vulnerable version, this will read /etc/passwd
        # Should not contain passwd file contents like "root:x:0" or "nobody"
        is_exploited = "root:x:" in output or "nobody:" in output or "/bin/sh" in output or "/bin/bash" in output
        assert not is_exploited, \
            f"File reading via find -exec succeeded! Output: {output[:200]}"

    def test_find_exec_shell_spawn_blocked(self):
        """
        Test that find -exec cannot spawn a shell.
        """
        token = get_auth_token()

        # Try to spawn shell and execute command
        malicious_cmd = "find . -exec /bin/sh -c 'echo SHELL_SPAWNED' \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # Should not contain our marker
        assert "SHELL_SPAWNED" not in output, \
            f"Shell spawning via find -exec succeeded! Output: {output}"

    def test_find_exec_multiple_commands_blocked(self):
        """
        Test that find -exec cannot chain multiple commands.
        """
        token = get_auth_token()

        malicious_cmd = "find . -exec /bin/sh -c 'whoami && id && pwd' \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # Should not contain any command output
        assert "uid=" not in output, f"Chained command injection succeeded! Output: {output}"

    def test_find_with_name_and_exec_blocked(self):
        """
        Test various find syntax variations are blocked.
        """
        token = get_auth_token()

        # Different syntax variation
        malicious_cmd = "find /tmp -maxdepth 1 -exec ls -la \\;"
        output = execute_command_via_websocket(token, malicious_cmd)

        # Should be rejected
        assert "Command not allowed" in output or "total" not in output, \
            f"Find with -exec variation succeeded! Output: {output}"


class TestMultipleBypassVectors:
    """
    Test additional find -exec bypass vectors that exploit the vulnerability.
    These tests use working attack vectors via find's -exec flag.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is available before tests."""
        assert wait_for_service(BASE_URL), "Service not available"

    def test_find_exec_env_command_blocked(self):
        """
        Test that find -exec cannot execute the 'env' command to reveal environment.
        """
        token = get_auth_token()

        # Use find -exec to run env command
        malicious_cmd = "find . -exec env \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will execute and show env vars
        # After fix, should be rejected
        assert "Command not allowed" in output or "PATH=" not in output, \
            f"Environment disclosure via find -exec succeeded! Output: {output[:200]}"

    def test_find_exec_hostname_blocked(self):
        """
        Test that find -exec cannot execute the 'hostname' command.
        """
        token = get_auth_token()

        # Use find -exec to run hostname
        malicious_cmd = "find . -exec hostname \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will execute and return hostname
        # After fix, should be rejected
        assert "Command not allowed" in output or output.strip() == "", \
            f"Hostname leak via find -exec may have succeeded! Output: {output}"

    def test_find_exec_uname_blocked(self):
        """
        Test that find -exec cannot execute 'uname -a' for system info.
        """
        token = get_auth_token()

        # Use find -exec to run uname
        malicious_cmd = "find . -exec uname -a \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will show system info
        # After fix, should be rejected
        assert "Command not allowed" in output or "Linux" not in output, \
            f"System info leak via find -exec succeeded! Output: {output}"

    def test_find_exec_date_blocked(self):
        """
        Test that find -exec cannot execute arbitrary commands like 'date'.
        """
        token = get_auth_token()

        # Use find -exec to run date
        malicious_cmd = "find . -exec date \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will execute and show date
        # After fix, should be rejected
        assert "Command not allowed" in output or output.strip() == "", \
            f"Date command via find -exec may have succeeded! Output: {output}"


class TestExactMatchEnforcement:
    """
    Test that find -exec cannot be used to execute additional dangerous commands.
    """

    @pytest.fixture(autouse=True)
    def setup(self):
        """Ensure service is available before tests."""
        assert wait_for_service(BASE_URL), "Service not available"

    def test_find_exec_printenv_blocked(self):
        """
        Test that find -exec cannot run printenv to reveal environment.
        """
        token = get_auth_token()

        # Use printenv via find -exec
        malicious_cmd = "find . -exec printenv PATH \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will show PATH env variable
        # After fix, should be rejected
        assert "Command not allowed" in output or "/usr" not in output, \
            f"Env variable disclosure via find -exec succeeded! Output: {output}"

    def test_find_exec_head_blocked(self):
        """
        Test that find -exec cannot read files via head command.
        """
        token = get_auth_token()

        malicious_cmd = "find /etc/hostname -exec head {} \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will reveal the hostname
        # After fix, should be rejected
        # Note: hostname files typically have content
        assert "Command not allowed" in output or output.strip() == "", \
            f"File reading via find -exec head succeeded! Output: {output}"

    def test_find_exec_echo_marker_blocked(self):
        """
        Test that find -exec cannot execute echo to prove arbitrary execution.
        """
        token = get_auth_token()

        # Use a unique marker to prove command execution
        malicious_cmd = "find . -exec echo VULN_MARKER_12345 \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, the marker will appear in output
        # After fix, command should be rejected
        assert "VULN_MARKER_12345" not in output, \
            f"Echo command via find -exec succeeded! Output: {output}"

    def test_find_exec_cat_hostname_blocked(self):
        """
        Test that find -exec cannot read /etc/hostname.
        """
        token = get_auth_token()

        malicious_cmd = "find /etc/hostname -exec cat {} \\; -quit"
        output = execute_command_via_websocket(token, malicious_cmd)

        # In vulnerable version, this will reveal the container hostname
        # After fix, should be rejected
        # Container hostnames are typically hex strings
        assert "Command not allowed" in output or output.strip() == "", \
            f"Hostname reading via find -exec succeeded! Output: {output}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-x"])
