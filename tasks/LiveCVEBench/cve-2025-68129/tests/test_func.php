<?php
/**
 * Functionality Tests - Verify normal token validation still works
 *
 * These tests ensure that after applying the fix, normal token validation
 * continues to work correctly for all token types.
 *
 * PASS in both vulnerable and fixed states
 */

declare(strict_types=1);

use Auth0\SDK\Configuration\SdkConfiguration;
use Auth0\SDK\Exception\InvalidTokenException;
use Auth0\SDK\Token;
use Auth0\SDK\Token\Generator;
use Auth0\Tests\Utilities\TokenGenerator;
use Symfony\Component\Cache\Adapter\ArrayAdapter;

uses()->group('functionality');

beforeEach(function() {
    $this->cache = new ArrayAdapter();

    $this->configuration = new SdkConfiguration([
        'strategy' => SdkConfiguration::STRATEGY_NONE,
        'tokenCache' => $this->cache,
        'domain' => 'domain.test',
        'clientId' => '__test_client_id__',
        'tokenAlgorithm' => 'HS256',
        'clientSecret' => '__test_client_secret__',
    ]);
});

/**
 * Test 1: Valid ID token validates correctly as ID token
 */
it('validates a valid HS256 ID token correctly', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    // Should pass verification and validation
    $result = $token->verify()->validate(
        tokenNonce: '__test_nonce__'
    );

    expect($result)->toBeInstanceOf(Token::class);
    expect($result->getSubject())->toEqual('__test_sub__');
    expect($result->getNonce())->toEqual('__test_nonce__');
});

/**
 * Test 2: Valid RS256 ID token validates correctly
 */
it('validates a valid RS256 ID token correctly', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_RS256
    );

    $this->configuration->setTokenAlgorithm('RS256');

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify(
        tokenCache: $idToken->cached,
        tokenJwksUri: $idToken->jwks
    )->validate(
        tokenNonce: '__test_nonce__'
    );

    expect($result)->toBeInstanceOf(Token::class);
    expect($result->getSubject())->toEqual('__test_sub__');
});

/**
 * Test 3: Valid access token validates correctly (with proper API audience)
 */
it('validates a valid access token with API audience', function(): void {
    $this->configuration->setAudience(['https://api.example.com']);

    // Create access token WITHOUT nonce and WITH API audience
    $accessToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ACCESS,
        TokenGenerator::ALG_HS256,
        [
            'aud' => 'https://api.example.com',
            'nonce' => null,  // Access tokens don't have nonce
        ]
    );

    $token = new Token($this->configuration, $accessToken->token, Token::TYPE_ACCESS_TOKEN);

    $result = $token->verify()->validate();

    expect($result)->toBeInstanceOf(Token::class);
});

/**
 * Test 4: Access token without API audience uses clientId as fallback
 */
it('validates access token with clientId audience when no API audience configured', function(): void {
    // No API audience configured - clientId should be used as fallback
    $accessToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ACCESS,
        TokenGenerator::ALG_HS256,
        [
            'aud' => '__test_client_id__',
            'nonce' => null,  // Remove nonce
        ]
    );

    $token = new Token($this->configuration, $accessToken->token, Token::TYPE_ACCESS_TOKEN);

    $result = $token->verify()->validate();

    expect($result)->toBeInstanceOf(Token::class);
});

/**
 * Test 5: Valid logout token validates correctly
 */
it('validates a valid logout token correctly', function(): void {
    $logoutToken = TokenGenerator::create(
        TokenGenerator::TOKEN_LOGOUT,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $logoutToken->token, Token::TYPE_LOGOUT_TOKEN);

    $result = $token->verify()->validate();

    expect($result)->toBeInstanceOf(Token::class);
    expect($result->getSubject())->toEqual('__test_sub__');
});

/**
 * Test 6: Expired tokens are rejected
 */
it('rejects expired ID token', function(): void {
    $expiredToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        ['exp' => time() - 1000]  // Expired 1000 seconds ago
    );

    $token = new Token($this->configuration, $expiredToken->token, Token::TYPE_ID_TOKEN);

    $token->verify()->validate(
        tokenNonce: '__test_nonce__'
    );
})->throws(InvalidTokenException::class);

/**
 * Test 7: Wrong issuer is rejected
 */
it('rejects token with wrong issuer', function(): void {
    $badToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        ['iss' => 'https://wrong-issuer.test/']
    );

    $token = new Token($this->configuration, $badToken->token, Token::TYPE_ID_TOKEN);

    $token->verify()->validate(
        tokenNonce: '__test_nonce__'
    );
})->throws(InvalidTokenException::class);

/**
 * Test 8: Token parsing works correctly
 */
it('parses token claims correctly', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        [
            'sub' => 'user123',
            'aud' => '__test_client_id__',
            'nonce' => 'my-nonce',
        ]
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    expect($token->getSubject())->toEqual('user123');
    expect($token->getAudience())->toContain('__test_client_id__');
    expect($token->getNonce())->toEqual('my-nonce');
});

/**
 * Test 9: Token JSON export works
 */
it('exports token to JSON correctly', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $json = $token->toJson();
    expect($json)->toBeString();

    $decoded = json_decode($json, true);
    expect($decoded)->toBeArray();
    expect($decoded)->toHaveKey('sub');
});

/**
 * Test 10: Token array export works
 */
it('exports token to array correctly', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $array = $token->toArray();
    expect($array)->toBeArray();
    expect($array)->toHaveKey('sub');
});

/**
 * Test 11: ID token validation with organization claim
 */
it('validates ID token with organization claim', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        ['org_id' => 'org_123']
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify()->validate(
        tokenNonce: '__test_nonce__',
        tokenOrganization: ['org_123']
    );

    expect($result)->toBeInstanceOf(Token::class);
    expect($result->getOrganization())->toEqual('org_123');
});

/**
 * Test 12: Logout token with nonce is rejected
 */
it('rejects logout token with nonce claim', function(): void {
    $badLogoutToken = TokenGenerator::create(
        TokenGenerator::TOKEN_LOGOUT,
        TokenGenerator::ALG_HS256,
        ['nonce' => '__test_nonce__']
    );

    $token = new Token($this->configuration, $badLogoutToken->token, Token::TYPE_LOGOUT_TOKEN);

    $token->verify()->validate();
})->throws(InvalidTokenException::class, InvalidTokenException::MSG_LOGOUT_TOKEN_NONCE_PRESENT);

/**
 * Test 13: verify() returns fluent interface
 */
it('returns fluent interface from verify()', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify();

    expect($result)->toEqual($token);
});

/**
 * Test 14: validate() returns fluent interface
 */
it('returns fluent interface from validate()', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify()->validate(
        tokenNonce: '__test_nonce__'
    );

    expect($result)->toEqual($token);
});

/**
 * Test 15: Token with multiple audiences validates correctly
 */
it('validates ID token with multiple audiences', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        [
            'aud' => ['__test_client_id__', 'https://other-api.example.com'],
            'azp' => '__test_client_id__',
        ]
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify()->validate(
        tokenNonce: '__test_nonce__'
    );

    expect($result)->toBeInstanceOf(Token::class);
});

/**
 * Test 16: Token with max age validates correctly
 */
it('validates token with max age constraint', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        ['auth_time' => time() - 50]  // Authenticated 50 seconds ago
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $result = $token->verify()->validate(
        tokenNonce: '__test_nonce__',
        tokenMaxAge: 100  // Max age of 100 seconds
    );

    expect($result)->toBeInstanceOf(Token::class);
});

/**
 * Test 17: Token exceeding max age is rejected
 */
it('rejects token exceeding max age', function(): void {
    $idToken = TokenGenerator::create(
        TokenGenerator::TOKEN_ID,
        TokenGenerator::ALG_HS256,
        ['auth_time' => time() - 200]  // Authenticated 200 seconds ago
    );

    $token = new Token($this->configuration, $idToken->token, Token::TYPE_ID_TOKEN);

    $token->verify()->validate(
        tokenNonce: '__test_nonce__',
        tokenMaxAge: 100  // Max age of 100 seconds - should fail
    );
})->throws(InvalidTokenException::class);
