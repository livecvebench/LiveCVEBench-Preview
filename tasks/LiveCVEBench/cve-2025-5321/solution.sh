#!/bin/bash
set -e

# Solution script for Aim query sandbox escape vulnerability
# This fix adds attribute blocking in the safer_getattr function
# to prevent traversal to dangerous internal objects.

cd /app

# Find where Aim is installed dynamically
AIM_PATH=$(python3 -c "import aim; import os; print(os.path.dirname(aim.__file__))")
QUERY_FILE="$AIM_PATH/storage/query.py"

echo "Found Aim at: $AIM_PATH"
echo "Applying fix to $QUERY_FILE..."

# The fix adds a check for dangerous attributes in the safer_getattr function
# These attributes allow traversal to internal objects that can escape the sandbox:
# - db: database access
# - session: SQLAlchemy session
# - bind: SQLAlchemy engine binding
# - dialect: database dialect
# - dbapi: database driver module

# Create a backup first
cp "$QUERY_FILE" "${QUERY_FILE}.backup" 2>/dev/null || true

# Use Python to apply the fix more reliably
python3 << PYTHON_FIX
import re
import os

# Get the file path from environment
aim_path = "$AIM_PATH"
query_file = f"{aim_path}/storage/query.py"

# Read the original file
with open(query_file, 'r') as f:
    content = f.read()

# Check if fix is already applied
if 'dangerous_attrs' in content:
    print("Fix already applied, skipping.")
else:
    # Find the safer_getattr function and add the dangerous attribute check
    # The fix adds a check after the underscore check and before getting the attribute

    old_code = '''    if name[0] == '_':
        raise AttributeError('"{name}" is an invalid attribute name because it starts with "_"'.format(name=name))
    val = getattr(object, name, default)'''

    new_code = '''    if name[0] == '_':
        raise AttributeError('"{name}" is an invalid attribute name because it starts with "_"'.format(name=name))
    # Block dangerous attributes that could lead to sandbox escape
    dangerous_attrs = {'db', 'session', 'bind', 'dialect', 'dbapi', 'run', 'repo', 'modules'}
    if name in dangerous_attrs:
        raise AttributeError('"{name}" is a restricted attribute for security reasons'.format(name=name))
    val = getattr(object, name, default)'''

    if old_code in content:
        content = content.replace(old_code, new_code)
        with open(query_file, 'w') as f:
            f.write(content)
        print("Fix applied successfully to safer_getattr function.")
    else:
        print("Warning: Could not find exact code pattern. Attempting alternative fix...")

        # Alternative: Insert after the underscore check using regex
        pattern = r"(if name\[0\] == '_':.*?format\(name=name\)\))"

        def add_fix(match):
            original = match.group(0)
            fix_code = '''
    # Block dangerous attributes that could lead to sandbox escape
    dangerous_attrs = {'db', 'session', 'bind', 'dialect', 'dbapi', 'run', 'repo', 'modules'}
    if name in dangerous_attrs:
        raise AttributeError('"{name}" is a restricted attribute for security reasons'.format(name=name))'''
            return original + fix_code

        content = re.sub(pattern, add_fix, content, flags=re.DOTALL)

        with open(query_file, 'w') as f:
            f.write(content)
        print("Alternative fix applied.")

PYTHON_FIX

# Verify the fix was applied
if grep -q "dangerous_attrs" "$QUERY_FILE"; then
    echo "Verification: Fix is present in query.py"
else
    echo "Error: Fix verification failed!"
    exit 1
fi

# Clear Python bytecode cache
find "$AIM_PATH" -type f -name "*.pyc" -delete 2>/dev/null || true
find "$AIM_PATH" -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true

# Restart the Aim server to pick up the changes
# The server runs as a Python process - we need to restart it
echo "Restarting Aim server to apply changes..."

# Find and kill the existing aim server process
pkill -f "aim up" || true
pkill -f "uvicorn.*aim" || true
pkill -f "python.*aim" || true

# Give processes time to terminate
sleep 3

echo "Fix applied successfully. Server will be restarted by entrypoint."
