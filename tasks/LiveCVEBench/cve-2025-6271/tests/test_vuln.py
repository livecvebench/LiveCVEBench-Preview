"""
Vulnerability tests for wav2swf tool.

These tests verify that the vulnerability is properly mitigated.
- FAIL in vulnerable state (malformed WAV causes crash)
- PASS in fixed state (malformed WAV is rejected gracefully)
"""

import subprocess
import os
import struct
import tempfile
import signal
import pytest


WAV2SWF_PATH = "/app/swftools/src/wav2swf"
MALICIOUS_WAV_PATH = "/tests/malicious.wav"


def is_crash_exit(returncode):
    """
    Check if the return code indicates a crash (segfault, abort, etc.)
    rather than a clean error exit.

    Crashes typically have negative return codes (signal-based) or
    specific codes like 134 (SIGABRT), 139 (SIGSEGV).
    """
    # Negative return code = killed by signal
    if returncode < 0:
        return True

    # Common crash codes
    crash_codes = [
        134,  # SIGABRT (128 + 6)
        139,  # SIGSEGV (128 + 11)
        136,  # SIGFPE (128 + 8)
        137,  # SIGKILL (128 + 9)
        138,  # SIGBUS (128 + 10)
    ]
    return returncode in crash_codes


def create_malformed_wav_misaligned(filepath):
    """
    Create a malformed WAV file with mismatched block alignment.
    This triggers the buffer calculation bug.
    """
    # WAV header with misaligned block size
    # align field set to 0x0800 (2048) but actual format doesn't match
    data = (
        b'RIFF' +                 # RIFF header
        b'0000' +                 # Chunk size (malformed ASCII)
        b'WAVE' +                 # WAVE format
        b'fmt ' +                 # Format chunk
        b'0000' +                 # Format chunk size (malformed)
        b'00' +                   # Audio format (malformed)
        b'0\x00' +                # Channels (malformed)
        b'0000' +                 # Sample rate (malformed)
        b'0000' +                 # Byte rate (malformed)
        b'0\x00' +                # Block align (malformed)
        b'\x08\x00'               # Bits per sample = 2048 (huge!)
    )
    with open(filepath, 'wb') as f:
        f.write(data)


def create_malformed_wav_align_zero(filepath):
    """
    Create a malformed WAV file with align=0 to trigger divide-by-zero.
    """
    # Proper RIFF header structure but with align=0
    fmt_chunk_size = 16
    audio_format = 1  # PCM
    channels = 1
    sample_rate = 44100
    bits_per_sample = 16
    block_align = 0  # This causes divide-by-zero!
    byte_rate = sample_rate * channels * bits_per_sample // 8

    # fmt chunk
    fmt_data = struct.pack('<HHIIHH',
                           audio_format,
                           channels,
                           sample_rate,
                           byte_rate,
                           block_align,
                           bits_per_sample)

    # Minimal data chunk
    data_content = b'\x00' * 100
    data_chunk_size = len(data_content)

    # Total file size (excluding first 8 bytes)
    file_size = 4 + (8 + fmt_chunk_size) + (8 + data_chunk_size)

    wav_data = (
        b'RIFF' +
        struct.pack('<I', file_size) +
        b'WAVE' +
        b'fmt ' +
        struct.pack('<I', fmt_chunk_size) +
        fmt_data +
        b'data' +
        struct.pack('<I', data_chunk_size) +
        data_content
    )

    with open(filepath, 'wb') as f:
        f.write(wav_data)


def create_malformed_wav_large_bps(filepath):
    """
    Create a malformed WAV file with unsupported bits_per_sample (e.g., 24).
    Tests the error handling path.
    """
    fmt_chunk_size = 16
    audio_format = 1  # PCM
    channels = 1
    sample_rate = 44100
    bits_per_sample = 24  # Unsupported!
    block_align = channels * bits_per_sample // 8
    byte_rate = sample_rate * block_align

    fmt_data = struct.pack('<HHIIHH',
                           audio_format,
                           channels,
                           sample_rate,
                           byte_rate,
                           block_align,
                           bits_per_sample)

    # Data chunk
    data_content = b'\x00' * (block_align * 100)
    data_chunk_size = len(data_content)

    file_size = 4 + (8 + fmt_chunk_size) + (8 + data_chunk_size)

    wav_data = (
        b'RIFF' +
        struct.pack('<I', file_size) +
        b'WAVE' +
        b'fmt ' +
        struct.pack('<I', fmt_chunk_size) +
        fmt_data +
        b'data' +
        struct.pack('<I', data_chunk_size) +
        data_content
    )

    with open(filepath, 'wb') as f:
        f.write(wav_data)


def create_malformed_wav_huge_align(filepath):
    """
    Create a WAV file with hugely mismatched align value.
    """
    fmt_chunk_size = 16
    audio_format = 1  # PCM
    channels = 2
    sample_rate = 44100
    bits_per_sample = 16
    # Correct would be: channels * bits_per_sample / 8 = 4
    # But we set it to something huge
    block_align = 4096  # Way too large!
    byte_rate = sample_rate * channels * bits_per_sample // 8

    fmt_data = struct.pack('<HHIIHH',
                           audio_format,
                           channels,
                           sample_rate,
                           byte_rate,
                           block_align,
                           bits_per_sample)

    # Small data chunk
    data_content = b'\x00' * 100
    data_chunk_size = len(data_content)

    file_size = 4 + (8 + fmt_chunk_size) + (8 + data_chunk_size)

    wav_data = (
        b'RIFF' +
        struct.pack('<I', file_size) +
        b'WAVE' +
        b'fmt ' +
        struct.pack('<I', fmt_chunk_size) +
        fmt_data +
        b'data' +
        struct.pack('<I', data_chunk_size) +
        data_content
    )

    with open(filepath, 'wb') as f:
        f.write(wav_data)


def create_malformed_wav_small_align(filepath):
    """
    Create a WAV file where align is smaller than expected.
    This causes samplelen to be larger than actual data.
    """
    fmt_chunk_size = 16
    audio_format = 1  # PCM
    channels = 2
    sample_rate = 44100
    bits_per_sample = 16
    # Correct would be: channels * bits_per_sample / 8 = 4
    # But we set it to smaller value
    block_align = 1  # Too small!
    byte_rate = sample_rate * channels * bits_per_sample // 8

    fmt_data = struct.pack('<HHIIHH',
                           audio_format,
                           channels,
                           sample_rate,
                           byte_rate,
                           block_align,
                           bits_per_sample)

    # Small data chunk
    data_content = b'\x00' * 100
    data_chunk_size = len(data_content)

    file_size = 4 + (8 + fmt_chunk_size) + (8 + data_chunk_size)

    wav_data = (
        b'RIFF' +
        struct.pack('<I', file_size) +
        b'WAVE' +
        b'fmt ' +
        struct.pack('<I', fmt_chunk_size) +
        fmt_data +
        b'data' +
        struct.pack('<I', data_chunk_size) +
        data_content
    )

    with open(filepath, 'wb') as f:
        f.write(wav_data)


class TestMalformedWavHandling:
    """
    Test that malformed WAV files are handled gracefully.

    In the vulnerable version, these tests will FAIL because the tool crashes.
    In the fixed version, these tests should PASS because the tool returns
    an error message and exits cleanly.
    """

    def test_original_poc_malicious_wav(self, tmp_path):
        """
        Test the original PoC malicious WAV file.

        The malicious.wav file has corrupted header values that cause
        buffer miscalculation in wav_convert2mono().
        """
        swf_file = str(tmp_path / "output.swf")

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, MALICIOUS_WAV_PATH],
            capture_output=True,
            text=True,
            timeout=30
        )

        # After fix: should fail cleanly (non-zero exit, no crash)
        assert result.returncode != 0, "Should reject malicious WAV file"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash! Got exit code {result.returncode} (likely a crash)"

        # Should print some error message
        combined_output = result.stdout + result.stderr
        assert len(combined_output.strip()) > 0, \
            "Should print error message when rejecting malformed file"

    def test_malformed_wav_misaligned_block(self, tmp_path):
        """
        Test WAV file with mismatched block alignment values.

        When align != (channels * bits_per_sample / 8), the tool should
        reject the file as non-PCM format.
        """
        wav_file = str(tmp_path / "misaligned.wav")
        swf_file = str(tmp_path / "misaligned.swf")

        create_malformed_wav_misaligned(wav_file)

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, wav_file],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode != 0, "Should reject misaligned WAV file"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash! Got exit code {result.returncode}"

    def test_malformed_wav_align_zero(self, tmp_path):
        """
        Test WAV file with align=0 (would cause divide-by-zero).

        The tool should detect illegal align value and reject the file.
        """
        wav_file = str(tmp_path / "align_zero.wav")
        swf_file = str(tmp_path / "align_zero.swf")

        create_malformed_wav_align_zero(wav_file)

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, wav_file],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode != 0, "Should reject WAV file with align=0"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash with divide-by-zero! Got exit code {result.returncode}"

    def test_malformed_wav_huge_align(self, tmp_path):
        """
        Test WAV file with hugely inflated align value.

        A large align value causes samplelen calculation to be tiny,
        resulting in undersized buffer allocation.
        """
        wav_file = str(tmp_path / "huge_align.wav")
        swf_file = str(tmp_path / "huge_align.swf")

        create_malformed_wav_huge_align(wav_file)

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, wav_file],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode != 0, "Should reject WAV file with invalid align"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash! Got exit code {result.returncode}"

    def test_malformed_wav_small_align(self, tmp_path):
        """
        Test WAV file with align smaller than expected.

        When align is too small, samplelen becomes larger than actual data,
        causing out-of-bounds read.
        """
        wav_file = str(tmp_path / "small_align.wav")
        swf_file = str(tmp_path / "small_align.swf")

        create_malformed_wav_small_align(wav_file)

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, wav_file],
            capture_output=True,
            text=True,
            timeout=30
        )

        assert result.returncode != 0, "Should reject WAV file with invalid align"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash! Got exit code {result.returncode}"


class TestErrorMessageQuality:
    """
    Verify that error messages are informative.

    After the fix, the tool should provide meaningful error messages
    that help users understand why their file was rejected.
    """

    def test_error_message_for_poc_file(self, tmp_path):
        """
        Check that the PoC file produces a useful error message.
        """
        swf_file = str(tmp_path / "output.swf")

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, MALICIOUS_WAV_PATH],
            capture_output=True,
            text=True,
            timeout=30
        )

        combined_output = (result.stdout + result.stderr).lower()

        # After fix, should mention the issue (non-PCM, invalid align, error, etc.)
        has_useful_message = any(keyword in combined_output for keyword in [
            "error",
            "unsupported",
            "invalid",
            "illegal",
            "non-pcm",
            "align",
            "fatal",
            "failed"
        ])

        assert has_useful_message, \
            f"Should print informative error message, got: {result.stderr}"

    def test_no_output_file_on_error(self, tmp_path):
        """
        Verify that no output file is created when input is rejected.
        """
        swf_file = str(tmp_path / "should_not_exist.swf")

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, MALICIOUS_WAV_PATH],
            capture_output=True,
            text=True,
            timeout=30
        )

        # No output should be created on error
        assert not os.path.exists(swf_file), \
            "Should not create output file when input is invalid"


class TestUnsupportedBitsPerSample:
    """
    Test handling of unsupported bits-per-sample values.
    """

    def test_24bit_wav_rejection(self, tmp_path):
        """
        Test that 24-bit WAV files are rejected gracefully.

        The wav_convert2mono function only supports 8, 16, and 32 bit.
        24-bit should trigger the error handling path.
        """
        wav_file = str(tmp_path / "24bit.wav")
        swf_file = str(tmp_path / "24bit.swf")

        create_malformed_wav_large_bps(wav_file)

        result = subprocess.run(
            [WAV2SWF_PATH, "-o", swf_file, wav_file],
            capture_output=True,
            text=True,
            timeout=30
        )

        # After fix: should fail cleanly (non-zero exit, no crash)
        # Before fix: crashes or incorrectly succeeds
        assert result.returncode != 0, "Should reject unsupported 24-bit WAV file"
        assert not is_crash_exit(result.returncode), \
            f"Should not crash on unsupported bps! Got exit code {result.returncode}"


class TestMultipleVulnerabilityVariants:
    """
    Test various payload variations to ensure comprehensive fix.
    """

    def test_rapid_fire_malformed_files(self, tmp_path):
        """
        Process multiple malformed files in succession.
        Ensures the fix is robust across different inputs.
        """
        creators = [
            ("misaligned", create_malformed_wav_misaligned),
            ("align_zero", create_malformed_wav_align_zero),
            ("huge_align", create_malformed_wav_huge_align),
            ("small_align", create_malformed_wav_small_align),
        ]

        for name, creator_func in creators:
            wav_file = str(tmp_path / f"{name}.wav")
            swf_file = str(tmp_path / f"{name}.swf")

            creator_func(wav_file)

            result = subprocess.run(
                [WAV2SWF_PATH, "-o", swf_file, wav_file],
                capture_output=True,
                text=True,
                timeout=30
            )

            # All should fail cleanly without crashing
            assert not is_crash_exit(result.returncode), \
                f"Should not crash on {name}.wav! Got exit code {result.returncode}"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-rA"])
