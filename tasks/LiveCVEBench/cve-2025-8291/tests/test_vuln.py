#!/usr/bin/env python3
"""
Vulnerability tests for CVE-2025-8291: ZIP64 EOCD offset validation.

These tests verify that malformed ZIP64 archives with inconsistent
offset/size values are properly rejected.

- FAIL in vulnerable state (vulnerability is exploitable - malformed files accepted)
- PASS in fixed state (vulnerability is mitigated - malformed files rejected)
"""

import io
import struct
import zipfile
import zlib

import pytest


def make_malformed_zip64(offset_mismatch=0, size_mismatch=0):
    """
    Creates a ZIP64 file with intentionally mismatched offset/size values.

    In vulnerable versions, these files are accepted because the locator
    offset is not validated - the module just assumes the ZIP64 EOCD record
    is at a fixed position relative to the locator.

    In fixed versions, these files raise BadZipFile due to consistency checks.

    Args:
        offset_mismatch: Value to add to the correct offset (creates invalid offset)
        size_mismatch: Value to add to the correct size (creates invalid size)
    """
    filename = b'test.txt'
    content = b'test1234'
    crc32_val = zlib.crc32(content) & 0xffffffff

    # Local file header
    local_header = (
        b'PK\x03\x04'  # Signature
        + b'\x2d\x00'  # Version needed (4.5 for zip64)
        + b'\x00\x00'  # Flags
        + b'\x00\x00'  # Compression (stored)
        + b'\x00\x00'  # Mod time
        + b'\x00\x00'  # Mod date
        + struct.pack('<I', crc32_val)  # CRC32 (computed)
        + b'\xff\xff\xff\xff'  # Compressed size (zip64 marker)
        + b'\xff\xff\xff\xff'  # Uncompressed size (zip64 marker)
        + struct.pack('<H', len(filename))  # Filename length
        + struct.pack('<H', 20)  # Extra field length (zip64 extra)
        + filename
    )

    # ZIP64 Extra field in local header
    local_zip64_extra = (
        b'\x01\x00'  # Tag (zip64)
        + struct.pack('<H', 16)  # Size
        + struct.pack('<Q', len(content))  # Uncompressed size
        + struct.pack('<Q', len(content))  # Compressed size
    )

    # Central directory header
    central_header = (
        b'PK\x01\x02'  # Signature
        + b'\x2d\x00'  # Version made by
        + b'\x2d\x00'  # Version needed
        + b'\x00\x00'  # Flags
        + b'\x00\x00'  # Compression
        + b'\x00\x00'  # Mod time
        + b'\x00\x00'  # Mod date
        + struct.pack('<I', crc32_val)  # CRC32 (computed)
        + b'\xff\xff\xff\xff'  # Compressed size (zip64 marker)
        + b'\xff\xff\xff\xff'  # Uncompressed size (zip64 marker)
        + struct.pack('<H', len(filename))  # Filename length
        + struct.pack('<H', 28)  # Extra field length
        + b'\x00\x00'  # Comment length
        + b'\xff\xff'  # Disk number (zip64 marker)
        + b'\x00\x00'  # Internal attrs
        + b'\x00\x00\x00\x00'  # External attrs
        + b'\xff\xff\xff\xff'  # Offset (zip64 marker)
        + filename
    )

    # ZIP64 extra field in central directory
    central_zip64_extra = (
        b'\x01\x00'  # Tag (zip64)
        + struct.pack('<H', 24)  # Size
        + struct.pack('<Q', len(content))  # Uncompressed size
        + struct.pack('<Q', len(content))  # Compressed size
        + struct.pack('<Q', 0)  # Header offset
    )

    # Calculate positions
    local_header_size = len(local_header) + len(local_zip64_extra) + len(content)
    central_dir_offset = local_header_size
    central_dir_size = len(central_header) + len(central_zip64_extra)
    zip64_eocd_offset = central_dir_offset + central_dir_size

    # ZIP64 End of Central Directory
    zip64_eocd_size = 44  # Standard size without extensible data
    zip64_eocd = (
        b'PK\x06\x06'  # Signature
        + struct.pack('<Q', zip64_eocd_size + size_mismatch)  # Size of record
        + b'\x2d\x00'  # Version made by
        + b'\x2d\x00'  # Version needed
        + b'\x00\x00\x00\x00'  # This disk
        + b'\x00\x00\x00\x00'  # Disk with central dir
        + struct.pack('<Q', 1)  # Entries on this disk
        + struct.pack('<Q', 1)  # Total entries
        + struct.pack('<Q', central_dir_size)  # Central dir size
        + struct.pack('<Q', central_dir_offset)  # Central dir offset
    )

    # ZIP64 End of Central Directory Locator
    # The offset here should point to zip64_eocd_offset, but we can manipulate it
    zip64_locator = (
        b'PK\x06\x07'  # Signature
        + b'\x00\x00\x00\x00'  # Disk number
        + struct.pack('<Q', zip64_eocd_offset + offset_mismatch)  # EOCD offset (potentially wrong)
        + b'\x01\x00\x00\x00'  # Total disks
    )

    # End of Central Directory
    eocd = (
        b'PK\x05\x06'  # Signature
        + b'\x00\x00'  # This disk
        + b'\x00\x00'  # Disk with central dir
        + b'\x01\x00'  # Entries on this disk
        + b'\x01\x00'  # Total entries
        + b'\xff\xff\xff\xff'  # Central dir size (zip64)
        + b'\xff\xff\xff\xff'  # Central dir offset (zip64)
        + b'\x00\x00'  # Comment length
    )

    # Assemble the ZIP file
    return (
        local_header
        + local_zip64_extra
        + content
        + central_header
        + central_zip64_extra
        + zip64_eocd
        + zip64_locator
        + eocd
    )


class TestMalformedOffsetRejection:
    """Tests for rejecting ZIP64 archives with incorrect offset in locator."""

    def test_offset_mismatch_positive_100(self):
        """ZIP64 with offset pointing 100 bytes past actual location should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=100)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_offset_mismatch_positive_1(self):
        """ZIP64 with offset pointing 1 byte past actual location should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=1)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_offset_mismatch_positive_1000(self):
        """ZIP64 with large offset mismatch should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=1000)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_offset_mismatch_positive_50(self):
        """ZIP64 with offset pointing 50 bytes past actual location should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=50)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))


class TestMalformedSizeRejection:
    """Tests for rejecting ZIP64 archives with incorrect size field."""

    def test_size_mismatch_positive_50(self):
        """ZIP64 with size field 50 bytes larger than actual should raise BadZipFile."""
        malformed = make_malformed_zip64(size_mismatch=50)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_size_mismatch_positive_1(self):
        """ZIP64 with size field 1 byte larger than actual should raise BadZipFile."""
        malformed = make_malformed_zip64(size_mismatch=1)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_size_mismatch_positive_100(self):
        """ZIP64 with size field 100 bytes larger than actual should raise BadZipFile."""
        malformed = make_malformed_zip64(size_mismatch=100)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))


class TestCombinedMismatch:
    """Tests for rejecting ZIP64 archives with both offset and size mismatches."""

    def test_both_offset_and_size_mismatch(self):
        """ZIP64 with both offset and size mismatch should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=100, size_mismatch=50)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))

    def test_small_combined_mismatch(self):
        """ZIP64 with small combined mismatch should raise BadZipFile."""
        malformed = make_malformed_zip64(offset_mismatch=10, size_mismatch=5)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))


class TestIsZipfileBehavior:
    """Tests for is_zipfile() behavior on malformed archives."""

    def test_is_zipfile_offset_mismatch_100(self):
        """is_zipfile should return False for ZIP64 with wrong offset (+100)."""
        malformed = make_malformed_zip64(offset_mismatch=100)
        assert zipfile.is_zipfile(io.BytesIO(malformed)) is False

    def test_is_zipfile_offset_mismatch_50(self):
        """is_zipfile should return False for ZIP64 with wrong offset (+50)."""
        malformed = make_malformed_zip64(offset_mismatch=50)
        assert zipfile.is_zipfile(io.BytesIO(malformed)) is False

    def test_is_zipfile_size_mismatch_50(self):
        """is_zipfile should return False for ZIP64 with wrong size (+50)."""
        malformed = make_malformed_zip64(size_mismatch=50)
        assert zipfile.is_zipfile(io.BytesIO(malformed)) is False

    def test_is_zipfile_combined_mismatch(self):
        """is_zipfile should return False for ZIP64 with both offset and size wrong."""
        malformed = make_malformed_zip64(offset_mismatch=100, size_mismatch=50)
        assert zipfile.is_zipfile(io.BytesIO(malformed)) is False


class TestCorruptedSignature:
    """Tests for handling corrupted ZIP64 EOCD signature."""

    def test_corrupted_zip64_eocd_signature(self):
        """ZIP64 with corrupted EOCD signature should raise BadZipFile."""
        # Create valid ZIP64 then corrupt the signature
        zipdata = make_malformed_zip64(offset_mismatch=0, size_mismatch=0)
        # Replace PK\x06\x06 with nulls
        zipdata = zipdata.replace(b'PK\x06\x06', b'\x00\x00\x00\x00')
        with pytest.raises(zipfile.BadZipFile, match='record not found'):
            zipfile.ZipFile(io.BytesIO(zipdata))

    def test_is_zipfile_corrupted_signature(self):
        """is_zipfile should return False for ZIP64 with corrupted signature."""
        zipdata = make_malformed_zip64(offset_mismatch=0, size_mismatch=0)
        zipdata = zipdata.replace(b'PK\x06\x06', b'\x00\x00\x00\x00')
        assert zipfile.is_zipfile(io.BytesIO(zipdata)) is False


class TestEdgeCases:
    """Edge case tests for offset/size validation."""

    def test_zero_offset_when_nonzero_expected(self):
        """Test offset pointing to file start when EOCD is elsewhere."""
        # Create a ZIP64 where offset points to 0 (file start)
        # but actual EOCD is at a different position
        filename = b'test.txt'
        content = b'test1234'
        crc32_val = zlib.crc32(content) & 0xffffffff

        local_header = (
            b'PK\x03\x04' + b'\x2d\x00' + b'\x00\x00' + b'\x00\x00'
            + b'\x00\x00' + b'\x00\x00' + struct.pack('<I', crc32_val)
            + b'\xff\xff\xff\xff' + b'\xff\xff\xff\xff'
            + struct.pack('<H', len(filename)) + struct.pack('<H', 20) + filename
        )
        local_zip64_extra = (
            b'\x01\x00' + struct.pack('<H', 16)
            + struct.pack('<Q', len(content)) + struct.pack('<Q', len(content))
        )
        central_header = (
            b'PK\x01\x02' + b'\x2d\x00' + b'\x2d\x00' + b'\x00\x00'
            + b'\x00\x00' + b'\x00\x00' + b'\x00\x00' + struct.pack('<I', crc32_val)
            + b'\xff\xff\xff\xff' + b'\xff\xff\xff\xff'
            + struct.pack('<H', len(filename)) + struct.pack('<H', 28)
            + b'\x00\x00' + b'\xff\xff' + b'\x00\x00' + b'\x00\x00\x00\x00'
            + b'\xff\xff\xff\xff' + filename
        )
        central_zip64_extra = (
            b'\x01\x00' + struct.pack('<H', 24)
            + struct.pack('<Q', len(content)) + struct.pack('<Q', len(content))
            + struct.pack('<Q', 0)
        )

        local_header_size = len(local_header) + len(local_zip64_extra) + len(content)
        central_dir_size = len(central_header) + len(central_zip64_extra)

        zip64_eocd = (
            b'PK\x06\x06' + struct.pack('<Q', 44)
            + b'\x2d\x00' + b'\x2d\x00' + b'\x00\x00\x00\x00' + b'\x00\x00\x00\x00'
            + struct.pack('<Q', 1) + struct.pack('<Q', 1)
            + struct.pack('<Q', central_dir_size) + struct.pack('<Q', local_header_size)
        )

        # Point offset to 0 instead of correct location
        zip64_locator = (
            b'PK\x06\x07' + b'\x00\x00\x00\x00'
            + struct.pack('<Q', 0)  # Wrong - points to file start
            + b'\x01\x00\x00\x00'
        )

        eocd = (
            b'PK\x05\x06' + b'\x00\x00' + b'\x00\x00' + b'\x01\x00' + b'\x01\x00'
            + b'\xff\xff\xff\xff' + b'\xff\xff\xff\xff' + b'\x00\x00'
        )

        zipdata = (
            local_header + local_zip64_extra + content
            + central_header + central_zip64_extra
            + zip64_eocd + zip64_locator + eocd
        )

        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(zipdata))

    def test_offset_past_file_end(self):
        """Test offset pointing past the end of the file."""
        malformed = make_malformed_zip64(offset_mismatch=10000)
        with pytest.raises(zipfile.BadZipFile):
            zipfile.ZipFile(io.BytesIO(malformed))
