"""
Vulnerability tests for Linkr manifest tampering vulnerability.

These tests verify whether manifest integrity verification is implemented:
- FAIL in vulnerable state (tampered manifests are processed without detection)
- PASS in fixed state (tampered manifests are detected and extraction is aborted)
"""

import pytest
import os
import sys
import json
import hashlib
import threading
import time
from http.server import HTTPServer, BaseHTTPRequestHandler
from pathlib import Path
from io import BytesIO

# Add the app directory to sys.path for imports
sys.path.insert(0, '/app')

from linkr_extractor import linkr_extractor
import inspect


def call_extractor(manifest_path, output_dir, checksum_override=False, integrity_check=True):
    """
    Helper to call linkr_extractor with appropriate parameters.
    The vulnerable version doesn't have integrity_check parameter,
    while the fixed version does.
    For vulnerability tests, integrity_check defaults to True to enable the fix.
    """
    sig = inspect.signature(linkr_extractor)
    if 'integrity_check' in sig.parameters:
        return linkr_extractor(str(manifest_path), str(output_dir),
                              checksum_override=checksum_override,
                              integrity_check=integrity_check)
    else:
        # Vulnerable version - no integrity_check parameter
        return linkr_extractor(str(manifest_path), str(output_dir),
                              checksum_override=checksum_override)


class ReuseAddrHTTPServer(HTTPServer):
    """HTTP server that allows address reuse."""
    allow_reuse_address = True


class ManifestServer(BaseHTTPRequestHandler):
    """HTTP server that serves both files and original manifest for integrity checking."""

    # Class-level storage for serving different content
    files_to_serve = {}
    manifest_content = None

    def log_message(self, format, *args):
        """Suppress logging."""
        pass

    def do_GET(self):
        path = self.path.lstrip('/')

        # Check if this is a manifest verification request
        if path.endswith('.linkr') and self.manifest_content:
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.send_header('Content-Length', len(self.manifest_content))
            self.end_headers()
            self.wfile.write(self.manifest_content)
            return

        # Check if we have this file
        if path in self.files_to_serve:
            content = self.files_to_serve[path]
            self.send_response(200)
            self.send_header('Content-Type', 'application/octet-stream')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
        else:
            self.send_response(404)
            self.end_headers()


def start_manifest_server(files_dict, manifest_bytes, port=8770):
    """Start a server that serves files and original manifest."""
    ManifestServer.files_to_serve = files_dict
    ManifestServer.manifest_content = manifest_bytes
    server = ReuseAddrHTTPServer(('127.0.0.1', port), ManifestServer)
    thread = threading.Thread(target=server.serve_forever)
    thread.daemon = True
    thread.start()
    time.sleep(0.3)
    return server


class TestManifestTamperingDetection:
    """
    Test that manifest tampering is detected (or not, in vulnerable version).

    The vulnerability: In vulnerable versions, the extractor reads manifest files
    and downloads all listed files without verifying the manifest's integrity.
    An attacker can add malicious file entries or modify URLs.

    The fix: The extractor should verify the manifest against a trusted source
    (LINKR_ADDRESS field) before processing.
    """

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        """Set up test environment."""
        self.tmp_path = tmp_path
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()

        self.server = None
        self.server_port = 8770

        yield

        if self.server:
            self.server.shutdown()
            self.server.server_close()
            time.sleep(0.1)

    def test_tampered_manifest_with_injected_file(self):
        """
        Test that a manifest with injected file entries is detected as tampered.

        Attack scenario:
        1. Original manifest has one legitimate file
        2. Attacker adds a malicious file entry to the manifest
        3. Fixed version should detect the tampering and abort
        4. Vulnerable version will download the injected file
        """
        # Legitimate file content
        legit_content = b"This is the legitimate file"
        legit_checksum = hashlib.sha256(legit_content).hexdigest()

        # Injected "malicious" file content
        injected_content = b"INJECTED_MALICIOUS_CONTENT_12345"
        injected_checksum = hashlib.sha256(injected_content).hexdigest()

        # Original manifest (what the server has)
        original_manifest = {
            "PACKAGE": "legit_package",
            "TOTAL_SIZE": len(legit_content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/legit_package.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/legit.txt"],
                "DESTINATION": "legit.txt",
                "SIZE": len(legit_content),
                "CHECKSUM": legit_checksum
            }]
        }
        original_manifest_bytes = json.dumps(original_manifest, indent=4).encode()

        # Tampered manifest (with injected file)
        tampered_manifest = {
            "PACKAGE": "legit_package",
            "TOTAL_SIZE": len(legit_content) + len(injected_content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/legit_package.linkr"],
            "FILES": [
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/legit.txt"],
                    "DESTINATION": "legit.txt",
                    "SIZE": len(legit_content),
                    "CHECKSUM": legit_checksum
                },
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/injected.txt"],
                    "DESTINATION": "injected/malicious.txt",
                    "SIZE": len(injected_content),
                    "CHECKSUM": injected_checksum
                }
            ]
        }

        # Files the server can serve
        files_dict = {
            "legit.txt": legit_content,
            "injected.txt": injected_content
        }

        # Start server with original manifest for verification
        self.server = start_manifest_server(files_dict, original_manifest_bytes, self.server_port)

        # Write tampered manifest locally
        tampered_manifest_path = self.manifest_dir / "tampered.linkr"
        with open(tampered_manifest_path, 'w') as f:
            json.dump(tampered_manifest, f, indent=4)

        # Run extraction
        result = call_extractor(tampered_manifest_path, self.output_dir)

        # Check for injected file
        injected_file = self.output_dir / "injected" / "malicious.txt"

        # In fixed version: extraction should abort due to checksum mismatch (return 200)
        # OR injected file should NOT exist
        # In vulnerable version: injected file WILL exist

        if injected_file.exists():
            # Vulnerable - the injected file was downloaded without detection
            pytest.fail(
                "VULNERABILITY DETECTED: Tampered manifest was processed without detection. "
                "An injected file was downloaded. Manifest integrity verification is missing."
            )

        # If we reach here, either:
        # 1. Extraction was aborted (return code 200)
        # 2. The file wasn't downloaded for some other reason
        # Both indicate the fix is working
        assert True, "Manifest tampering was detected or prevented"

    def test_manifest_url_modification(self):
        """
        Test detection when manifest URLs are modified to point elsewhere.

        Attack scenario: Attacker changes URLs in manifest to point to
        malicious server while keeping the same file checksums.
        """
        # Original content
        original_content = b"Original legitimate content"
        original_checksum = hashlib.sha256(original_content).hexdigest()

        # "Malicious" replacement content (same checksum would require collision)
        # For this test, we use different content to simulate the attack
        malicious_content = b"REPLACED_WITH_MALICIOUS_DATA"
        malicious_checksum = hashlib.sha256(malicious_content).hexdigest()

        # Original manifest on server
        original_manifest = {
            "PACKAGE": "url_test_package",
            "TOTAL_SIZE": len(original_content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/url_test_package.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/original.txt"],
                "DESTINATION": "data.txt",
                "SIZE": len(original_content),
                "CHECKSUM": original_checksum
            }]
        }
        original_manifest_bytes = json.dumps(original_manifest, indent=4).encode()

        # Tampered manifest - URL changed to serve different content
        tampered_manifest = {
            "PACKAGE": "url_test_package",
            "TOTAL_SIZE": len(malicious_content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/url_test_package.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/malicious.txt"],
                "DESTINATION": "data.txt",
                "SIZE": len(malicious_content),
                "CHECKSUM": malicious_checksum  # Modified checksum for modified content
            }]
        }

        files_dict = {
            "original.txt": original_content,
            "malicious.txt": malicious_content
        }

        self.server = start_manifest_server(files_dict, original_manifest_bytes, self.server_port)

        tampered_manifest_path = self.manifest_dir / "url_tampered.linkr"
        with open(tampered_manifest_path, 'w') as f:
            json.dump(tampered_manifest, f, indent=4)

        result = call_extractor(tampered_manifest_path, self.output_dir)

        # Check what content was downloaded
        data_file = self.output_dir / "data.txt"

        if data_file.exists() and data_file.read_bytes() == malicious_content:
            pytest.fail(
                "VULNERABILITY DETECTED: Manifest with modified URLs was processed. "
                "Malicious content was downloaded instead of original. "
                "Manifest integrity verification is missing."
            )

        assert True, "URL modification in manifest was detected or prevented"

    def test_multiple_injected_files(self):
        """Test detection with multiple injected file entries."""
        legit_content = b"Legitimate package file"
        legit_checksum = hashlib.sha256(legit_content).hexdigest()

        # Multiple injected files
        injected1 = b"Injected file 1 - payload A"
        injected2 = b"Injected file 2 - payload B"
        injected3 = b"Injected file 3 - payload C"

        original_manifest = {
            "PACKAGE": "multi_inject_test",
            "TOTAL_SIZE": len(legit_content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/multi_inject_test.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/legit.txt"],
                "DESTINATION": "legit.txt",
                "SIZE": len(legit_content),
                "CHECKSUM": legit_checksum
            }]
        }
        original_manifest_bytes = json.dumps(original_manifest, indent=4).encode()

        # Tampered with 3 extra files
        tampered_manifest = {
            "PACKAGE": "multi_inject_test",
            "TOTAL_SIZE": 10000,
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/multi_inject_test.linkr"],
            "FILES": [
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/legit.txt"],
                    "DESTINATION": "legit.txt",
                    "SIZE": len(legit_content),
                    "CHECKSUM": legit_checksum
                },
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/inject1.txt"],
                    "DESTINATION": "payload/inject1.txt",
                    "SIZE": len(injected1),
                    "CHECKSUM": hashlib.sha256(injected1).hexdigest()
                },
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/inject2.txt"],
                    "DESTINATION": "payload/inject2.txt",
                    "SIZE": len(injected2),
                    "CHECKSUM": hashlib.sha256(injected2).hexdigest()
                },
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/inject3.txt"],
                    "DESTINATION": "scripts/inject3.sh",
                    "SIZE": len(injected3),
                    "CHECKSUM": hashlib.sha256(injected3).hexdigest()
                }
            ]
        }

        files_dict = {
            "legit.txt": legit_content,
            "inject1.txt": injected1,
            "inject2.txt": injected2,
            "inject3.txt": injected3
        }

        self.server = start_manifest_server(files_dict, original_manifest_bytes, self.server_port)

        tampered_path = self.manifest_dir / "multi_inject.linkr"
        with open(tampered_path, 'w') as f:
            json.dump(tampered_manifest, f, indent=4)

        result = call_extractor(tampered_path, self.output_dir)

        # Check for any injected files
        inject1_path = self.output_dir / "payload" / "inject1.txt"
        inject2_path = self.output_dir / "payload" / "inject2.txt"
        inject3_path = self.output_dir / "scripts" / "inject3.sh"

        injected_found = []
        if inject1_path.exists():
            injected_found.append("payload/inject1.txt")
        if inject2_path.exists():
            injected_found.append("payload/inject2.txt")
        if inject3_path.exists():
            injected_found.append("scripts/inject3.sh")

        if injected_found:
            pytest.fail(
                f"VULNERABILITY DETECTED: Multiple injected files downloaded: {injected_found}. "
                "Manifest integrity verification is missing."
            )

        assert True, "Multiple file injection was detected or prevented"

    def test_destination_path_manipulation(self):
        """Test detection when destination paths are manipulated."""
        content = b"File content for path test"
        checksum = hashlib.sha256(content).hexdigest()

        original_manifest = {
            "PACKAGE": "path_test",
            "TOTAL_SIZE": len(content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/path_test.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/file.txt"],
                "DESTINATION": "safe/location/file.txt",
                "SIZE": len(content),
                "CHECKSUM": checksum
            }]
        }
        original_manifest_bytes = json.dumps(original_manifest, indent=4).encode()

        # Tampered - destination changed to different location
        tampered_manifest = {
            "PACKAGE": "path_test",
            "TOTAL_SIZE": len(content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/path_test.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/file.txt"],
                "DESTINATION": "different/unexpected/location/file.txt",
                "SIZE": len(content),
                "CHECKSUM": checksum
            }]
        }

        files_dict = {"file.txt": content}

        self.server = start_manifest_server(files_dict, original_manifest_bytes, self.server_port)

        tampered_path = self.manifest_dir / "path_tampered.linkr"
        with open(tampered_path, 'w') as f:
            json.dump(tampered_manifest, f, indent=4)

        result = call_extractor(tampered_path, self.output_dir)

        unexpected_file = self.output_dir / "different" / "unexpected" / "location" / "file.txt"
        expected_file = self.output_dir / "safe" / "location" / "file.txt"

        if unexpected_file.exists() and not expected_file.exists():
            pytest.fail(
                "VULNERABILITY DETECTED: Manifest with modified destination path was processed. "
                "File was written to attacker-controlled location. "
                "Manifest integrity verification is missing."
            )

        assert True, "Destination path manipulation was detected or prevented"


class TestChecksumMismatchAbort:
    """
    Test that extraction properly aborts when manifest checksum doesn't match.
    """

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        self.tmp_path = tmp_path
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()
        self.server = None
        self.server_port = 8771

        yield

        if self.server:
            self.server.shutdown()
            self.server.server_close()
            time.sleep(0.1)

    def test_extraction_aborts_on_tamper_detection(self):
        """
        Verify that when tampering is detected, extraction is aborted
        before any files are downloaded.
        """
        content = b"Should not be downloaded"
        checksum = hashlib.sha256(content).hexdigest()

        original_manifest = {
            "PACKAGE": "abort_test",
            "TOTAL_SIZE": len(content),
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/abort_test.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/file.txt"],
                "DESTINATION": "file.txt",
                "SIZE": len(content),
                "CHECKSUM": checksum
            }]
        }
        original_manifest_bytes = json.dumps(original_manifest, indent=4).encode()

        # Tampered manifest - completely different
        tampered_manifest = {
            "PACKAGE": "completely_different_package",
            "TOTAL_SIZE": 99999,
            "LINKR_ADDRESS": [f"http://127.0.0.1:{self.server_port}/abort_test.linkr"],
            "FILES": [{
                "URLS": [f"http://127.0.0.1:{self.server_port}/file.txt"],
                "DESTINATION": "tampered_output.txt",
                "SIZE": len(content),
                "CHECKSUM": checksum
            }]
        }

        files_dict = {"file.txt": content}

        self.server = start_manifest_server(files_dict, original_manifest_bytes, self.server_port)

        tampered_path = self.manifest_dir / "abort_test.linkr"
        with open(tampered_path, 'w') as f:
            json.dump(tampered_manifest, f, indent=4)

        result = call_extractor(tampered_path, self.output_dir)

        # In fixed version, should return 200 (checksum mismatch)
        # and NO files should be downloaded
        output_file = self.output_dir / "tampered_output.txt"

        if output_file.exists():
            pytest.fail(
                "VULNERABILITY DETECTED: Files were downloaded despite manifest tampering. "
                "Extraction should abort before downloading any files when tampering is detected."
            )

        # Also verify expected return code for fixed version
        # (vulnerable version doesn't return specific codes)
        assert True, "Extraction properly aborted on tamper detection"


class TestNoLinkrAddressField:
    """
    Test behavior when LINKR_ADDRESS field is missing or empty.
    In vulnerable versions, missing LINKR_ADDRESS means no verification happens.
    """

    @pytest.fixture(autouse=True)
    def setup_and_teardown(self, tmp_path):
        self.tmp_path = tmp_path
        self.output_dir = tmp_path / "output"
        self.output_dir.mkdir()
        self.manifest_dir = tmp_path / "manifests"
        self.manifest_dir.mkdir()
        self.server = None
        self.server_port = 8772

        yield

        if self.server:
            self.server.shutdown()
            self.server.server_close()
            time.sleep(0.1)

    def test_manifest_without_linkr_address_allows_tampering(self):
        """
        Test that manifests without LINKR_ADDRESS field are vulnerable to tampering.

        In the vulnerable version, a manifest without LINKR_ADDRESS will be processed
        without any integrity check, allowing an attacker to inject malicious files.

        The test creates a manifest without LINKR_ADDRESS that contains an injected file.
        - FAIL in vulnerable version (the injected file will be downloaded - vulnerability exists)
        - PASS in fixed version (extraction should abort or require LINKR_ADDRESS)
        """
        # Legitimate file content
        legit_content = b"Legitimate file content"
        legit_checksum = hashlib.sha256(legit_content).hexdigest()

        # Injected malicious file content
        injected_content = b"INJECTED_VIA_NO_LINKR_ADDRESS_ATTACK"
        injected_checksum = hashlib.sha256(injected_content).hexdigest()

        # Manifest WITHOUT LINKR_ADDRESS - this is the attack vector
        # Since there's no LINKR_ADDRESS, there's no way to verify integrity
        manifest_no_address = {
            "PACKAGE": "no_address_pkg",
            "TOTAL_SIZE": len(legit_content) + len(injected_content),
            "FILES": [
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/legit.txt"],
                    "DESTINATION": "legit.txt",
                    "SIZE": len(legit_content),
                    "CHECKSUM": legit_checksum
                },
                {
                    "URLS": [f"http://127.0.0.1:{self.server_port}/injected.txt"],
                    "DESTINATION": "malicious/injected.txt",
                    "SIZE": len(injected_content),
                    "CHECKSUM": injected_checksum
                }
            ]
        }

        files_dict = {
            "legit.txt": legit_content,
            "injected.txt": injected_content
        }

        self.server = start_manifest_server(files_dict, None, self.server_port)

        manifest_path = self.manifest_dir / "no_address.linkr"
        with open(manifest_path, 'w') as f:
            json.dump(manifest_no_address, f, indent=4)

        result = call_extractor(manifest_path, self.output_dir)

        # Check if the injected file was downloaded
        injected_file = self.output_dir / "malicious" / "injected.txt"

        if injected_file.exists():
            pytest.fail(
                "VULNERABILITY DETECTED: A manifest without LINKR_ADDRESS was processed "
                "and allowed injection of arbitrary files. "
                "The extractor does not verify manifest integrity when LINKR_ADDRESS is missing."
            )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
