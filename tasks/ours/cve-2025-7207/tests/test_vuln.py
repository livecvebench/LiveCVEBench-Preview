"""
Vulnerability tests for mruby heap buffer overflow CVE-2025-7207.

These tests verify that the vulnerability EXISTS in the vulnerable version.
- FAIL in vulnerable state (crash/memory corruption occurs) <- This is what we want!
- PASS in fixed state (error handled gracefully, no crash)

The vulnerability is specifically triggered by the `retry` keyword in module/class
scope without local variables. The nregs/nlocals invariant violation causes
heap-buffer-overflow in stack_clear when the VM executes the compiled code.
"""
import subprocess
import pytest
import os
import tempfile
import signal

MRUBY_BIN = "/app/build/host/bin/mruby"


def run_mruby_file(filepath, timeout=30):
    """Run mruby with the given file and return result."""
    try:
        result = subprocess.run(
            [MRUBY_BIN, filepath],
            capture_output=True,
            timeout=timeout,
            text=True
        )
        return result
    except subprocess.TimeoutExpired:
        return None


def run_mruby(code, timeout=30):
    """Run mruby with the given Ruby code via temp file."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.rb', delete=False) as f:
        f.write(code)
        f.flush()
        temp_file = f.name

    try:
        result = subprocess.run(
            [MRUBY_BIN, temp_file],
            capture_output=True,
            timeout=timeout,
            text=True
        )
        return result
    except subprocess.TimeoutExpired:
        return None
    finally:
        os.unlink(temp_file)


def run_mruby_stdin(code, timeout=30):
    """Run mruby with code via -e option."""
    try:
        result = subprocess.run(
            [MRUBY_BIN, "-e", code],
            capture_output=True,
            timeout=timeout,
            text=True
        )
        return result
    except subprocess.TimeoutExpired:
        return None


def is_crash_signal(returncode):
    """Check if return code indicates a crash (segfault, abort, etc.)."""
    if returncode is None:
        return True
    # Negative return codes indicate signal termination on Unix
    # SIGSEGV = 11, SIGABRT = 6, SIGBUS = 7
    crash_signals = [
        -signal.SIGSEGV,   # -11
        -signal.SIGABRT,   # -6
        -signal.SIGBUS,    # -10 on macOS, -7 on Linux
    ]
    # Also check for raw signal numbers (some systems return positive)
    # 128 + signal_number is the convention when process dies from signal
    return returncode in crash_signals or returncode in [139, 134, 135, 138]


def has_memory_error(stderr):
    """Check if stderr contains memory error indicators."""
    if stderr is None:
        return False
    memory_errors = [
        "heap-buffer-overflow",
        "stack-buffer-overflow",
        "use-after-free",
        "AddressSanitizer",
        "ASAN",
        "Segmentation fault",
        "SEGV",
        "memory access",
        "double free",
        "corrupted",
        "invalid pointer",
        "free():",
    ]
    return any(err.lower() in stderr.lower() for err in memory_errors)


class TestPrimaryVulnerability:
    """Test the primary vulnerability trigger: module/class with retry (no local vars).

    These patterns specifically trigger the nregs/nlocals invariant violation
    that causes heap-buffer-overflow in stack_clear.
    """

    def test_module_retry_no_crash(self):
        """
        The original PoC: 'module K retry end' should NOT crash.

        In vulnerable state: causes heap-buffer-overflow crash (FAIL)
        In fixed state: returns error but no crash (PASS)
        """
        code = "module K retry\nend"
        result = run_mruby(code)

        # If we got no result, that's a timeout/crash
        assert result is not None, "mruby timed out or crashed"

        # Check for crash signal
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"

        # Check for memory errors in output
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_module_retry_inline(self):
        """Test the inline form of the PoC."""
        result = run_mruby_stdin("module K retry; end")

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_class_with_retry(self):
        """Class definition with invalid retry - also triggers the vulnerability."""
        code = "class Foo retry; end"
        result = run_mruby_stdin(code)

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"


class TestNestedScopes:
    """Test nested scope structures with retry that trigger the vulnerability."""

    def test_nested_module_retry(self):
        """Nested module with retry - inner scope triggers crash."""
        code = '''
module Outer
  module Inner
    retry
  end
end
'''
        result = run_mruby(code)

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_deeply_nested_scopes_with_retry(self):
        """Deeply nested scope structures with retry."""
        code = '''
module A
  module B
    class C
      module D
        retry
      end
    end
  end
end
'''
        result = run_mruby(code)

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_class_inside_module_retry(self):
        """Class inside module with retry."""
        code = '''
module Outer
  class Inner
    retry
  end
end
'''
        result = run_mruby(code)

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"


class TestModuleNameVariants:
    """Test various module/class names with retry."""

    def test_short_module_name(self):
        """Single character module name with retry."""
        result = run_mruby_stdin("module K; retry; end")

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_long_module_name(self):
        """Long module name with retry."""
        result = run_mruby_stdin("module VeryLongModuleName; retry; end")

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"

    def test_class_short_name(self):
        """Single character class name with retry."""
        result = run_mruby_stdin("class X; retry; end")

        assert result is not None, "mruby timed out or crashed"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode}"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected: {result.stderr}"


class TestPoC:
    """Direct PoC file test."""

    def test_poc_file_no_crash(self):
        """Test the PoC file directly."""
        poc_path = "/tests/poc.rb"

        # First try to copy PoC from task-deps
        if not os.path.exists(poc_path):
            # Write PoC inline
            with open(poc_path, 'w') as f:
                f.write("module K retry\nend\n")

        result = run_mruby_file(poc_path)

        assert result is not None, "mruby timed out or crashed on PoC"
        assert not is_crash_signal(result.returncode), \
            f"mruby crashed with signal {result.returncode} on PoC"
        assert not has_memory_error(result.stderr), \
            f"Memory error detected on PoC: {result.stderr}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
