#!/bin/bash
# Solution script to fix the authentication bypass vulnerability in social-auth-app-django
# This fixes the issue where create_user returns an existing user instead of failing
# when IntegrityError occurs (e.g., duplicate email).

set -e

cd /app

STORAGE_FILE="social_django/storage.py"

echo "Applying fix to $STORAGE_FILE..."

# Create a Python script to apply the fix
python3 << 'PYTHON_FIX'
import re

storage_file = "social_django/storage.py"

with open(storage_file, 'r') as f:
    content = f.read()

# Check if fix is already applied
if 'AuthAlreadyAssociated' in content:
    print("Fix appears to already be applied (AuthAlreadyAssociated found)")
else:
    # Step 1: Add the import for AuthAlreadyAssociated after IntegrityError import
    content = content.replace(
        'from django.db.utils import IntegrityError',
        'from django.db.utils import IntegrityError\nfrom social_core.exceptions import AuthAlreadyAssociated'
    )
    print("Added AuthAlreadyAssociated import")

# Step 2: Replace the vulnerable try-except block in create_user method
# The vulnerable code catches IntegrityError and returns existing user
# The fixed code raises AuthAlreadyAssociated instead

# Pattern to match the vulnerable code block
# This is the vulnerable pattern:
#         try:
#             if hasattr(transaction, "atomic"):
#                 ...
#                 with transaction.atomic(using=using):
#                     user = manager.create_user(*args, **kwargs)
#             else:
#                 user = manager.create_user(*args, **kwargs)
#         except IntegrityError as exc:
#             ...
#             try:
#                 user = manager.get(*args, **kwargs)
#             except cls.user_model().DoesNotExist:
#                 raise exc from None
#         return user

vulnerable_pattern = r'''        try:
            if hasattr\(transaction, "atomic"\):
                # In Django versions that have an "atomic" transaction decorator / context
                # manager, there's a transaction wrapped around this call\.
                # If the create fails below due to an IntegrityError, ensure that the transaction
                # stays undamaged by wrapping the create in an atomic\.
                using = router\.db_for_write\(cls\.user_model\(\)\)
                with transaction\.atomic\(using=using\):
                    user = manager\.create_user\(\*args, \*\*kwargs\)
            else:
                user = manager\.create_user\(\*args, \*\*kwargs\)
        except IntegrityError as exc:
            # .*?
            if kwargs\.get\("email", True\) is None:
                kwargs\["email"\] = ""
            try:
                user = manager\.get\(\*args, \*\*kwargs\)
            except cls\.user_model\(\)\.DoesNotExist:
                raise exc from None
        return user'''

fixed_code = '''        # If the create fails below due to an IntegrityError, ensure that the transaction
        # stays undamaged by wrapping the create in an atomic.
        using = router.db_for_write(cls.user_model())
        try:
            with transaction.atomic(using=using):
                return manager.create_user(*args, **kwargs)
        except IntegrityError as exc:
            raise AuthAlreadyAssociated(None) from exc'''

# Try to replace with the exact pattern
if re.search(vulnerable_pattern, content, re.DOTALL):
    content = re.sub(vulnerable_pattern, fixed_code, content, flags=re.DOTALL)
    print("Replaced vulnerable code block using exact pattern")
else:
    # Try a more flexible pattern if exact match fails
    flexible_pattern = r'''        try:
            if hasattr\(transaction, "atomic"\):.*?user = manager\.create_user\(\*args, \*\*kwargs\)
            else:
                user = manager\.create_user\(\*args, \*\*kwargs\)
        except IntegrityError as exc:.*?raise exc from None
        return user'''

    if re.search(flexible_pattern, content, re.DOTALL):
        content = re.sub(flexible_pattern, fixed_code, content, flags=re.DOTALL)
        print("Replaced vulnerable code block using flexible pattern")
    else:
        # Last resort: find the specific lines and replace them
        print("Patterns did not match, attempting line-by-line fix...")

        lines = content.split('\n')
        new_lines = []
        in_vulnerable_block = False
        skip_until_return = False

        for i, line in enumerate(lines):
            # Detect start of vulnerable block
            if 'if hasattr(transaction, "atomic"):' in line and 'try:' in lines[i-1] if i > 0 else False:
                in_vulnerable_block = True
                skip_until_return = True
                # Insert the fixed code
                new_lines.pop()  # Remove the 'try:' line we just added
                new_lines.append('        # If the create fails below due to an IntegrityError, ensure that the transaction')
                new_lines.append('        # stays undamaged by wrapping the create in an atomic.')
                new_lines.append('        using = router.db_for_write(cls.user_model())')
                new_lines.append('        try:')
                new_lines.append('            with transaction.atomic(using=using):')
                new_lines.append('                return manager.create_user(*args, **kwargs)')
                new_lines.append('        except IntegrityError as exc:')
                new_lines.append('            raise AuthAlreadyAssociated(None) from exc')
                continue

            if skip_until_return:
                if line.strip() == 'return user':
                    skip_until_return = False
                    in_vulnerable_block = False
                continue

            new_lines.append(line)

        if in_vulnerable_block:
            print("Warning: Could not find end of vulnerable block")
        else:
            content = '\n'.join(new_lines)
            print("Applied line-by-line fix")

with open(storage_file, 'w') as f:
    f.write(content)

print("Fix applied to", storage_file)

# Verify the fix
with open(storage_file, 'r') as f:
    final_content = f.read()

if 'AuthAlreadyAssociated' in final_content and 'raise AuthAlreadyAssociated(None) from exc' in final_content:
    print("Verification: Fix successfully applied!")
else:
    print("Warning: Fix may not have been applied correctly")
    print("Checking for AuthAlreadyAssociated:", 'AuthAlreadyAssociated' in final_content)
PYTHON_FIX

echo ""
echo "Fix applied successfully!"
echo ""

# Note: If there's a running Django application, it may need to be restarted
# to pick up the code changes. For typical Django deployments, this happens
# automatically via the entrypoint when the container is restarted.
