"""
Functionality tests for ZIP extraction in ProcessWire.
These tests verify that normal ZIP operations work correctly.
Tests should PASS in both vulnerable and fixed states.
"""

import subprocess
import os
import tempfile
import zipfile
import pytest


# Path to the PHP test helper script
PHP_TEST_SCRIPT = "/tests/test_helper.php"
APP_DIR = "/var/www/html"


def create_test_zip(num_files: int, file_size: int, dest_path: str) -> str:
    """Create a test ZIP file with specified number and size of files."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        for i in range(num_files):
            content = f"Test content for file {i}\n" * (file_size // 30 + 1)
            content = content[:file_size]
            zf.writestr(f"file_{i:04d}.txt", content)
    return dest_path


def run_unzip_test(zip_path: str, expect_success: bool = True, timeout: int = 120) -> dict:
    """
    Run the PHP unzip test and return the result.
    Returns dict with 'success', 'output', 'error' keys.
    """
    result = subprocess.run(
        ["php", PHP_TEST_SCRIPT, "unzip", zip_path],
        capture_output=True,
        text=True,
        timeout=timeout,
        cwd=APP_DIR
    )

    return {
        "success": result.returncode == 0,
        "output": result.stdout,
        "error": result.stderr,
        "returncode": result.returncode
    }


class TestNormalZipExtraction:
    """Test that normal ZIP files can be extracted properly."""

    def test_small_zip_extraction(self, tmp_path):
        """Test extracting a small ZIP with few files works correctly."""
        zip_path = str(tmp_path / "small_test.zip")
        create_test_zip(num_files=5, file_size=100, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], f"Small ZIP extraction failed: {result['error']}"
        assert "extracted" in result["output"].lower() or "files" in result["output"].lower()

    def test_medium_zip_extraction(self, tmp_path):
        """Test extracting a medium-sized ZIP works correctly."""
        zip_path = str(tmp_path / "medium_test.zip")
        create_test_zip(num_files=50, file_size=1000, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], f"Medium ZIP extraction failed: {result['error']}"

    def test_zip_with_subdirectories(self, tmp_path):
        """Test extracting a ZIP with subdirectory structure."""
        zip_path = str(tmp_path / "dir_test.zip")

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("root.txt", "Root file content")
            zf.writestr("subdir1/file1.txt", "File in subdir1")
            zf.writestr("subdir1/subdir2/file2.txt", "File in nested subdir")
            zf.writestr("subdir1/subdir2/subdir3/file3.txt", "Deeper nested file")

        result = run_unzip_test(zip_path)

        assert result["success"], f"ZIP with subdirectories failed: {result['error']}"

    def test_zip_with_various_extensions(self, tmp_path):
        """Test extracting a ZIP with various file extensions."""
        zip_path = str(tmp_path / "extensions_test.zip")

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("document.txt", "Text content")
            zf.writestr("data.json", '{"key": "value"}')
            zf.writestr("config.xml", "<config><setting>value</setting></config>")
            zf.writestr("style.css", "body { color: black; }")

        result = run_unzip_test(zip_path)

        assert result["success"], f"ZIP with various extensions failed: {result['error']}"


class TestPathTraversalProtection:
    """Test that path traversal attacks are blocked (existing security feature)."""

    def test_path_traversal_blocked(self, tmp_path):
        """Verify that path traversal attempts are blocked."""
        zip_path = str(tmp_path / "traversal_test.zip")

        # Create a ZIP with path traversal attempt
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("normal.txt", "Normal file")
            # The vulnerable code should skip files with '..' in name
            zf.writestr("../../../etc/malicious.txt", "Should not be extracted")

        result = run_unzip_test(zip_path)

        # The extraction should succeed (for normal files) but skip traversal files
        # This is existing behavior that should work in both vulnerable and fixed versions
        assert result["success"], f"Path traversal test failed unexpectedly: {result['error']}"


class TestEmptyAndMinimalZips:
    """Test edge cases with empty or minimal ZIP files."""

    def test_single_file_zip(self, tmp_path):
        """Test extracting a ZIP with single file."""
        zip_path = str(tmp_path / "single_file.zip")

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("only_file.txt", "Single file content")

        result = run_unzip_test(zip_path)

        assert result["success"], f"Single file ZIP failed: {result['error']}"

    def test_reasonable_file_count(self, tmp_path):
        """Test ZIP with reasonable file count (under any limits)."""
        zip_path = str(tmp_path / "reasonable_count.zip")
        # 100 files should be well under any reasonable limit
        create_test_zip(num_files=100, file_size=50, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], f"Reasonable file count ZIP failed: {result['error']}"


class TestFilePermissions:
    """Test that file permissions are set correctly after extraction."""

    def test_file_extraction_completes(self, tmp_path):
        """Test that extraction completes and files are accessible."""
        zip_path = str(tmp_path / "permissions_test.zip")

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("readable.txt", "This should be readable")
            zf.writestr("subdir/nested.txt", "Nested file")

        result = run_unzip_test(zip_path)

        assert result["success"], f"Permissions test ZIP failed: {result['error']}"


def create_many_files_zip(num_files: int, file_size: int, dest_path: str) -> str:
    """Create a ZIP file with many files to test file count limits."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        for i in range(num_files):
            content = "A" * file_size
            zf.writestr(f"file_{i:06d}.txt", content)
    return dest_path


def create_large_uncompressed_zip(total_mb: int, dest_path: str) -> str:
    """Create a ZIP file that expands to a large size when uncompressed."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        file_size = 1024 * 1024
        num_files = total_mb
        for i in range(num_files):
            content = ("AAAAAAAAAA" * 102400) + f"_{i:06d}"
            content = content[:file_size]
            zf.writestr(f"large_{i:04d}.txt", content)
    return dest_path


def create_deep_nested_zip(depth: int, dest_path: str) -> str:
    """Create a ZIP with deeply nested directory structure."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        path = ""
        for i in range(depth):
            path += f"dir_{i}/"
            zf.writestr(path + "file.txt", f"Content at depth {i}")
    return dest_path


def create_high_compression_ratio_zip(dest_path: str) -> str:
    """Create a ZIP with extremely high compression ratio."""
    with zipfile.ZipFile(dest_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=9) as zf:
        content = "\x00" * (10 * 1024 * 1024)
        zf.writestr("zeros.bin", content)
    return dest_path


class TestValidZipsAccepted:
    """Test that valid ZIPs under limits are still accepted."""

    def test_just_under_limit_accepted(self, tmp_path):
        """ZIP with files just under the limit should be accepted."""
        zip_path = str(tmp_path / "under_limit.zip")
        create_many_files_zip(num_files=500, file_size=100, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], (
            f"ZIP with 500 files should be accepted. Error: {result['error']}"
        )

    def test_zip_under_size_limit_accepted(self, tmp_path):
        """ZIP under the size limit should be accepted."""
        zip_path = str(tmp_path / "small_uncompressed.zip")
        create_large_uncompressed_zip(total_mb=50, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], (
            f"ZIP expanding to 50MB should be accepted. Error: {result['error']}"
        )

    def test_moderate_depth_accepted(self, tmp_path):
        """ZIP with moderate directory depth should be accepted."""
        zip_path = str(tmp_path / "moderate_nested.zip")
        create_deep_nested_zip(depth=5, dest_path=zip_path)

        result = run_unzip_test(zip_path)

        assert result["success"], (
            f"ZIP with 5 levels of nesting should be accepted. Error: {result['error']}"
        )

    def test_high_compression_ratio_handling(self, tmp_path):
        """Test that files with high compression ratios are handled correctly."""
        zip_path = str(tmp_path / "high_ratio.zip")
        create_high_compression_ratio_zip(dest_path=zip_path)

        result = run_unzip_test(zip_path)

        # High compression ratio files should still be extracted in vulnerable state
        # The 10MB of zeros file should be extractable
        assert result["success"], (
            f"ZIP with high compression ratio should be accepted. Error: {result['error']}"
        )
