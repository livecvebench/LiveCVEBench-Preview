#!/usr/bin/env python3
"""
Vulnerability tests for RemoteClinic staff profile file upload.

These tests verify that the file upload vulnerability is properly mitigated:
- Before fix: Non-image files can be uploaded and saved unchanged
- After fix: Non-image files are rejected or properly validated

Tests FAIL when vulnerable, PASS when fixed.
"""

import pytest
import requests
import os
import hashlib
from datetime import datetime
import time

# Base URL for the application
BASE_URL = os.environ.get("APP_URL", "http://localhost")

# Default credentials from the database
ADMIN_USER = "admin@domain.ext"
ADMIN_PASSWORD = "remoteclinic"

# Test staff IDs for different upload tests
# Using different staff IDs to avoid file collision issues
STAFF_IDS = {
    'php_basic': '10',
    'php_short_tag': '11',
    'php_phar': '12',
    'php_encoded': '15',
    'html_script': '17',
    'svg_script': '19',
    'polyglot': '21',
    'shell_script': '23',
}


def get_extra_key():
    """
    Generate the extra_key required for login.
    The key is MD5 hash of a formatted date string.
    """
    now = datetime.now()
    ampm = now.strftime("%p")
    day_name = now.strftime("%a")
    month = now.strftime("%b")
    day = now.day
    year = now.strftime("%Y")

    if day in [1, 21, 31]:
        suffix = "st"
    elif day in [2, 22]:
        suffix = "nd"
    elif day in [3, 23]:
        suffix = "rd"
    else:
        suffix = "th"

    date_str = f"{ampm}  {day_name}, {month} {day}{suffix}, {year}"
    return hashlib.md5(date_str.encode()).hexdigest()


def get_authenticated_session():
    """Get an authenticated session with admin credentials."""
    session = requests.Session()
    login_url = f"{BASE_URL}/login/process.php"
    extra_key = get_extra_key()

    data = {
        'user_id': ADMIN_USER,
        'password': ADMIN_PASSWORD,
        'extra_key': extra_key
    }

    session.post(login_url, data=data, allow_redirects=True)
    return session


def upload_malicious_file(session, staff_id, file_content, filename, content_type):
    """
    Attempt to upload a file with the given content to the staff edit endpoint.
    Returns the response object.
    """
    url = f"{BASE_URL}/staff/edit.php?id={staff_id}"

    files = {'image': (filename, file_content, content_type)}
    data = {
        'id': staff_id,
        'title': 'Mr.',
        'first_name': 'Test',
        'last_name': 'Exploit',
        'passkey': '',
        'contact': '1234567890',
        'mobile': '1234567890',
        'skype': 'test',
        'address': 'Test Address',
        'access_level': '4',
        'status': 'active',
        'branch': '1',
        'submit': 'Update'
    }

    return session.post(url, files=files, data=data, timeout=30)


def check_file_content(staff_id):
    """
    Read the uploaded file from the filesystem and return its content.
    This verifies what was actually saved.
    """
    file_path = f"/var/www/html/media/staff/{staff_id}.png"
    try:
        with open(file_path, 'rb') as f:
            return f.read()
    except FileNotFoundError:
        return None


def is_valid_image_content(content):
    """
    Check if the content appears to be a valid image based on magic bytes.
    Returns True if content starts with known image signatures.
    """
    if content is None or len(content) < 8:
        return False

    # PNG signature
    if content[:8] == b'\x89PNG\r\n\x1a\n':
        return True

    # JPEG signature
    if content[:2] == b'\xff\xd8':
        return True

    # GIF signatures
    if content[:6] in [b'GIF87a', b'GIF89a']:
        return True

    return False


class TestPHPPayloadUpload:
    """Test various PHP payload upload attempts."""

    def test_basic_php_upload_blocked(self):
        """
        Test that basic PHP code upload is blocked.

        Vulnerability: Without validation, PHP code is saved directly to the file
        even though it gets a .png extension.

        After fix: Upload should be rejected or file should not contain PHP code.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_basic']

        # Basic PHP webshell payload
        php_payload = b'<?php system($_GET["cmd"]); ?>'

        response = upload_malicious_file(
            session, staff_id, php_payload,
            'shell.php', 'application/x-php'
        )

        assert response.status_code == 200

        # Check what was actually saved
        saved_content = check_file_content(staff_id)

        # Test PASSES if either:
        # 1. File was not created (upload rejected)
        # 2. File does not contain the PHP payload (content was sanitized)
        if saved_content is None:
            # File wasn't created - upload was rejected
            pass
        else:
            # File was created - verify it doesn't contain PHP code
            assert php_payload not in saved_content, \
                "PHP code was saved unchanged - vulnerability exists!"
            assert b'<?php' not in saved_content, \
                "PHP opening tag found in saved file - vulnerability exists!"

    def test_short_tag_php_upload_blocked(self):
        """
        Test that PHP short tag syntax is also blocked.

        Attackers may try short tags like <? or <?= instead of <?php.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_short_tag']

        # PHP short tag payload
        php_payload = b'<? echo shell_exec($_GET["c"]); ?>'

        response = upload_malicious_file(
            session, staff_id, php_payload,
            'test.php', 'text/plain'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'<?' not in saved_content or is_valid_image_content(saved_content), \
                "PHP short tag code was saved - vulnerability exists!"

    def test_phar_prefix_php_blocked(self):
        """
        Test that PHAR-prefixed PHP payloads are blocked.

        PHAR files can be used for deserialization attacks.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_phar']

        # PHAR-style payload
        phar_payload = b'__HALT_COMPILER();<?php system("id"); ?>'

        response = upload_malicious_file(
            session, staff_id, phar_payload,
            'payload.phar', 'application/octet-stream'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'__HALT_COMPILER' not in saved_content, \
                "PHAR payload was saved - vulnerability exists!"
            assert b'<?php' not in saved_content, \
                "PHP code in PHAR was saved - vulnerability exists!"

    def test_encoded_php_upload_blocked(self):
        """
        Test that base64-encoded PHP wrapped in eval is blocked.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_encoded']

        # Base64 encoded PHP
        php_payload = b'<?php eval(base64_decode("c3lzdGVtKCRfR0VUWydjJ10pOw==")); ?>'

        response = upload_malicious_file(
            session, staff_id, php_payload,
            'encoded.php', 'application/x-php'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'<?php' not in saved_content and b'eval' not in saved_content, \
                "Encoded PHP payload was saved - vulnerability exists!"


class TestHTMLScriptUpload:
    """Test HTML/JavaScript payload upload attempts."""

    def test_html_script_upload_blocked(self):
        """
        Test that HTML with script tags is blocked.

        Could be used for stored XSS if the file is served with wrong content-type.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['html_script']

        html_payload = b'<html><body><script>alert(document.cookie)</script></body></html>'

        response = upload_malicious_file(
            session, staff_id, html_payload,
            'xss.html', 'text/html'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'<script>' not in saved_content or is_valid_image_content(saved_content), \
                "HTML script payload was saved - vulnerability exists!"

    def test_svg_script_upload_blocked(self):
        """
        Test that SVG with embedded JavaScript is blocked.

        SVG files can contain <script> tags that execute in browser context.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['svg_script']

        svg_payload = b'''<?xml version="1.0"?>
<svg xmlns="http://www.w3.org/2000/svg">
  <script>alert('XSS')</script>
</svg>'''

        response = upload_malicious_file(
            session, staff_id, svg_payload,
            'malicious.svg', 'image/svg+xml'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            # SVG with scripts should be rejected
            has_script = b'<script>' in saved_content
            assert not has_script or is_valid_image_content(saved_content), \
                "SVG with script was saved - vulnerability exists!"


class TestPolyglotUpload:
    """Test polyglot file upload attempts."""

    def test_gif_php_polyglot_blocked(self):
        """
        Test that GIF/PHP polyglot files are blocked.

        A polyglot starts with valid GIF header but contains PHP code.
        This might bypass simple magic byte checks.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['polyglot']

        # GIF header followed by PHP code
        polyglot_payload = b'GIF89a<?php system($_GET["cmd"]); ?>'

        response = upload_malicious_file(
            session, staff_id, polyglot_payload,
            'image.gif', 'image/gif'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            # Should either reject the file entirely or not contain PHP
            assert b'<?php' not in saved_content, \
                "GIF/PHP polyglot with PHP code was saved - vulnerability exists!"


class TestShellScriptUpload:
    """Test shell script upload attempts."""

    def test_bash_script_upload_blocked(self):
        """
        Test that bash scripts cannot be uploaded.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['shell_script']

        bash_payload = b'#!/bin/bash\nwhoami\nid\ncat /etc/passwd'

        response = upload_malicious_file(
            session, staff_id, bash_payload,
            'script.sh', 'application/x-sh'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'#!/bin/bash' not in saved_content or is_valid_image_content(saved_content), \
                "Bash script was saved - vulnerability exists!"


class TestMimeTypeBypass:
    """Test MIME type bypass attempts."""

    def test_php_with_image_mimetype_blocked(self):
        """
        Test that PHP code with image MIME type is still blocked.

        Attackers often try to bypass checks by sending PHP with image/png MIME type.
        A proper fix should check actual file content, not just declared MIME type.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_basic']  # Reuse staff ID since we're testing same concept

        # PHP code with falsely declared image MIME type
        php_payload = b'<?php phpinfo(); ?>'

        # Send with image MIME type to try bypassing
        url = f"{BASE_URL}/staff/edit.php?id={staff_id}"
        files = {'image': ('innocent.png', php_payload, 'image/png')}
        data = {
            'id': staff_id,
            'title': 'Mr.',
            'first_name': 'Test',
            'last_name': 'Bypass',
            'passkey': '',
            'contact': '1234567890',
            'mobile': '1234567890',
            'skype': 'test',
            'address': 'Test Address',
            'access_level': '4',
            'status': 'active',
            'branch': '1',
            'submit': 'Update'
        }

        session.post(url, files=files, data=data, timeout=30)

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            assert b'<?php' not in saved_content, \
                "PHP with fake image MIME type was saved - vulnerability exists!"


class TestContentValidation:
    """Test that content validation is properly implemented."""

    def test_only_real_images_accepted(self):
        """
        Verify that after fix, only files with valid image content are accepted.
        """
        session = get_authenticated_session()
        staff_id = STAFF_IDS['php_basic']

        # Plain text that is clearly not an image
        text_payload = b'This is just plain text, not an image.'

        response = upload_malicious_file(
            session, staff_id, text_payload,
            'text.txt', 'text/plain'
        )

        saved_content = check_file_content(staff_id)

        if saved_content is not None:
            # If file was saved, it should either:
            # 1. Be empty / different from input (content was rejected/sanitized)
            # 2. Be a valid image (if somehow the system created a placeholder)
            assert text_payload not in saved_content or is_valid_image_content(saved_content), \
                "Plain text was saved as image - vulnerability exists!"
