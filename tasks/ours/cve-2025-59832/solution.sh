#!/bin/bash
set -e

echo "Applying fix to /app/horilla/models.py..."

python3 << 'PYTHON_SCRIPT'
import re
import os

models_file = '/app/horilla/models.py'

# Read current content
with open(models_file, 'r') as f:
    content = f.read()

# Step 1: Ensure ValidationError import exists
if 'from django.core.exceptions import ValidationError' not in content:
    # Find where to add the import (after other django imports or at the top)
    if 'from django.db import models' in content:
        content = content.replace(
            'from django.db import models',
            'from django.core.exceptions import ValidationError\nfrom django.db import models'
        )
    elif 'from django.' in content:
        # Add after first django import
        match = re.search(r'(from django\.[^\n]+\n)', content)
        if match:
            content = content.replace(
                match.group(1),
                match.group(1) + 'from django.core.exceptions import ValidationError\n'
            )
    else:
        # Add at the top after any initial imports
        content = 'from django.core.exceptions import ValidationError\n' + content

# Step 1b: Ensure 're' module is imported (needed for has_xss function)
# Use regex to check for standalone 'import re' statement (not as substring of other imports)
if not re.search(r'^import re\s*$', content, re.MULTILINE):
    # Add 'import re' right after the first import block
    # Find the first 'from' or 'import' line and add before it
    import_match = re.search(r'^(from |import )', content, re.MULTILINE)
    if import_match:
        content = content[:import_match.start()] + 'import re\n' + content[import_match.start():]
    else:
        content = 'import re\n' + content
    print("Added 'import re'")

# Step 2: Add the has_xss function if it doesn't exist
# This function is needed for XSS pattern detection
if 'def has_xss(' not in content:
    # Add the has_xss function before the HorillaModel class definition
    has_xss_function = '''

def has_xss(value):
    """Basic check for common XSS patterns."""
    if not isinstance(value, str):
        return False
    xss_pattern = re.compile(
        r"<\\s*script.*?>.*?<\\s*/\\s*script\\s*>|"
        r"javascript\\s*:|"
        r"on\\w+\\s*=",
        re.IGNORECASE | re.DOTALL
    )
    return bool(xss_pattern.search(value))


'''
    # Insert before HorillaModel class
    horillamodel_pos = content.find('class HorillaModel(')
    if horillamodel_pos > 0:
        content = content[:horillamodel_pos] + has_xss_function + content[horillamodel_pos:]
        print("Added has_xss function")
    else:
        print("WARNING: Could not find HorillaModel class to insert has_xss function")

# Step 3: Add clean_fields method to HorillaModel if not present
# This is the critical fix that validates all text fields before saving
if 'def clean_fields(self, exclude=None):' not in content:
    # Find the HorillaModel class and its Meta class
    horillamodel_match = re.search(
        r'(class HorillaModel\([^)]+\):.*?class Meta:.*?abstract\s*=\s*True[^\n]*\n)',
        content,
        re.DOTALL
    )

    if horillamodel_match:
        insert_point = horillamodel_match.end()

        clean_fields_method = '''
    def clean_fields(self, exclude=None):
        """Validates text fields against XSS patterns only."""
        errors = {}
        total_exclude = set(exclude or []).union(getattr(self, "xss_exempt_fields", []))

        for field in self._meta.get_fields():
            if isinstance(field, (models.CharField, models.TextField)) and field.name not in total_exclude:
                value = getattr(self, field.name, None)
                if value and has_xss(value):
                    errors[field.name] = ValidationError("Potential XSS content detected.")

        if errors:
            raise ValidationError(errors)
        # Note: We intentionally do NOT call super().clean_fields() here
        # to avoid validating required fields like company_id that may be
        # intentionally blank during internal operations.

'''
        content = content[:insert_point] + clean_fields_method + content[insert_point:]
        print("Added clean_fields method")
    else:
        print("WARNING: Could not find HorillaModel Meta class")

# Step 4: Ensure save() calls clean_fields() for XSS validation only
# We call clean_fields directly instead of full_clean to avoid validating required fields
# which may be intentionally blank during normal operations
save_match = re.search(r'(def save\(self, \*args, \*\*kwargs\):)', content)
if save_match:
    # Check if clean_fields or full_clean is already called after save definition
    save_start = save_match.start()
    # Get the next ~500 chars to check the save method body
    save_section = content[save_start:save_start+500]

    if 'clean_fields()' not in save_section and 'self.clean_fields()' not in save_section and 'full_clean()' not in save_section:
        # Add clean_fields call at the beginning of save method
        # We pass exclude=None to check all text fields for XSS
        content = content.replace(
            'def save(self, *args, **kwargs):',
            'def save(self, *args, **kwargs):\n        self.clean_fields()'
        )
        print("Added clean_fields() call to save method")

# Write the modified content
with open(models_file, 'w') as f:
    f.write(content)

print("Fix applied successfully to horilla/models.py")
PYTHON_SCRIPT

# Restart the application if it's running
# The entrypoint will restart it automatically
if pgrep -f "python.*manage.py.*runserver" > /dev/null 2>&1; then
    echo "Restarting Django development server..."
    pkill -f "python.*manage.py.*runserver" || true
    sleep 3
fi

if pgrep -f "gunicorn" > /dev/null 2>&1; then
    echo "Restarting Gunicorn..."
    pkill -f "gunicorn" || true
    sleep 3
fi

echo "Fix complete!"
