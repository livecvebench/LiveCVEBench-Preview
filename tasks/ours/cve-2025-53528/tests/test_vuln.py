"""
Vulnerability tests for CVE-2025-53528: Cadwyn XSS vulnerability.

These tests check whether the vulnerability EXISTS in the current version.

In vulnerable state (cadwyn < 5.4.3):
- Malicious payloads appear UNENCODED in the response
- Tests should FAIL (because we assert the payload is NOT in the response)

In fixed state (cadwyn >= 5.4.3):
- Malicious payloads are URL-encoded
- Tests should PASS (payload is properly sanitized)

Expected behavior for CVE reproduction:
- test_func.py: ALL PASS (functionality works)
- test_vuln.py: ALL FAIL (vulnerability exists, payloads not sanitized)
"""

import pytest
from fastapi.testclient import TestClient
from cadwyn import Cadwyn, HeadVersion, Version, VersionBundle


@pytest.fixture
def client():
    """Create a test client with a minimal Cadwyn application."""
    app = Cadwyn(
        versions=VersionBundle(HeadVersion(), Version("2000-01-01")),
        title="Test API"
    )

    @app.get("/")
    async def root():
        return {"message": "Hello World"}

    return TestClient(app)


class TestXSSVulnerabilityInDocs:
    """Test XSS vulnerability in /docs endpoint."""

    def test_single_quote_xss_payload_sanitized(self, client):
        """
        Test that XSS payload with single quotes is properly sanitized.

        VULNERABLE: The raw payload '+alert(document.domain)+' appears in HTML
        FIXED: The payload is URL-encoded as %27%2Balert...

        Note: When using TestClient with f-string URLs, '+' is interpreted as space
        in URL query params. So we check for the "received" version of the payload.
        """
        payload = "'+alert(document.domain)+'"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # The + character in URLs is interpreted as space, so the server receives
        # the payload with spaces instead of +. Check for both the original and
        # the URL-decoded version (with + as space).
        received_payload = payload.replace('+', ' ')

        # In a FIXED version, the raw payload should NOT appear (it would be URL-encoded)
        # In a VULNERABLE version, this assertion FAILS (which is what we want)
        assert received_payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{received_payload}' found in response"

    def test_script_tag_injection_sanitized(self, client):
        """
        Test that script tag injection is properly sanitized.

        VULNERABLE: <script>alert(1)</script> appears unencoded
        FIXED: Encoded as %3Cscript%3Ealert...
        """
        payload = "<script>alert(1)</script>"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"

    def test_javascript_protocol_injection_sanitized(self, client):
        """
        Test that javascript: protocol is properly sanitized.

        VULNERABLE: javascript:alert(1) appears unencoded
        FIXED: The colon is encoded as %3A
        """
        payload = "javascript:alert(1)"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"

    def test_event_handler_injection_sanitized(self, client):
        """
        Test that HTML event handler injection is properly sanitized.

        VULNERABLE: ' onload='alert(1) appears unencoded
        FIXED: Single quotes encoded as %27
        """
        payload = "' onload='alert(1)"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"

    def test_parentheses_injection_sanitized(self, client):
        """
        Test that parentheses in version are properly sanitized.

        VULNERABLE: test()value appears unencoded
        FIXED: Parentheses encoded as %28 and %29
        """
        payload = "test()value"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"


class TestXSSVulnerabilityInRedoc:
    """Test XSS vulnerability in /redoc endpoint."""

    def test_single_quote_xss_in_redoc_sanitized(self, client):
        """
        Test that XSS payload is properly sanitized in ReDoc.

        VULNERABLE: The raw payload appears in HTML
        FIXED: The payload is URL-encoded

        Note: When using TestClient with f-string URLs, '+' is interpreted as space
        in URL query params. So we check for the "received" version of the payload.
        """
        payload = "'+alert(document.domain)+'"
        response = client.get(f"/redoc?version={payload}")
        assert response.status_code == 200

        # The + character in URLs is interpreted as space, so the server receives
        # the payload with spaces instead of +.
        received_payload = payload.replace('+', ' ')

        # In a FIXED version, the raw payload should NOT appear
        assert received_payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{received_payload}' found in response"

    def test_script_tag_in_redoc_sanitized(self, client):
        """
        Test that script tag injection is properly sanitized in ReDoc.

        VULNERABLE: <script>alert(1)</script> appears unencoded
        FIXED: Encoded properly
        """
        payload = "<script>alert(1)</script>"
        response = client.get(f"/redoc?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"

    def test_double_quote_injection_in_redoc_sanitized(self, client):
        """
        Test that double quote injection is properly sanitized in ReDoc.

        VULNERABLE: "><img src=x onerror=alert(1)> appears unencoded
        FIXED: Double quote encoded as %22
        """
        payload = '"><img src=x onerror=alert(1)>'
        response = client.get(f"/redoc?version={payload}")
        assert response.status_code == 200

        # Check that raw payload is not in the response
        assert payload not in response.text, \
            f"XSS vulnerability exists: raw payload '{payload}' found in response"


class TestSpecialCharacterSanitization:
    """Test that individual dangerous characters are properly sanitized."""

    @pytest.mark.parametrize("char,description", [
        ("'", "single quote"),
        ('"', "double quote"),
        ("<", "less than"),
        (">", "greater than"),
        ("(", "open parenthesis"),
        (")", "close parenthesis"),
    ])
    def test_special_char_sanitized_in_docs(self, client, char, description):
        """
        Test that special characters are properly sanitized in /docs.

        VULNERABLE: The raw character appears in the output
        FIXED: The character is URL-encoded
        """
        payload = f"test{char}value"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # The raw payload with the special character should not appear
        assert payload not in response.text, \
            f"XSS vulnerability exists: {description} not sanitized in docs"

    @pytest.mark.parametrize("char,description", [
        ("'", "single quote"),
        ('"', "double quote"),
        ("<", "less than"),
        (">", "greater than"),
    ])
    def test_special_char_sanitized_in_redoc(self, client, char, description):
        """
        Test that special characters are properly sanitized in /redoc.

        VULNERABLE: The raw character appears in the output
        FIXED: The character is URL-encoded
        """
        payload = f"test{char}value"
        response = client.get(f"/redoc?version={payload}")
        assert response.status_code == 200

        # The raw payload with the special character should not appear
        assert payload not in response.text, \
            f"XSS vulnerability exists: {description} not sanitized in redoc"


class TestComplexXSSPayloads:
    """Test complex attack payloads are properly neutralized."""

    def test_dom_based_xss_payload_sanitized(self, client):
        """
        Test that DOM-based XSS payload is properly sanitized.

        VULNERABLE: The raw eval(atob(...)) payload appears
        FIXED: Single quotes and special chars are encoded
        """
        payload = "'-eval(atob('YWxlcnQoMSk='))-'"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Raw payload should NOT appear
        assert payload not in response.text, \
            f"XSS vulnerability exists: DOM-based XSS payload not sanitized"

    def test_svg_based_xss_payload_sanitized(self, client):
        """
        Test that SVG-based XSS payload is properly sanitized.

        VULNERABLE: <svg/onload=alert('XSS')> appears unencoded
        FIXED: < and > are encoded
        """
        payload = "<svg/onload=alert('XSS')>"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Raw payload should NOT appear
        assert payload not in response.text, \
            f"XSS vulnerability exists: SVG-based XSS payload not sanitized"

    def test_unicode_escape_payload_sanitized(self, client):
        """
        Test that unicode escape sequences are properly handled.

        VULNERABLE: The raw payload appears
        FIXED: Backslashes are encoded
        """
        payload = "\\u003cscript\\u003e"
        response = client.get(f"/docs?version={payload}")
        assert response.status_code == 200

        # Raw payload should NOT appear
        assert payload not in response.text, \
            f"XSS vulnerability exists: unicode escape payload not sanitized"
