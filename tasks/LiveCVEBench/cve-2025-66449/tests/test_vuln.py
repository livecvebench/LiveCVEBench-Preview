"""
Vulnerability tests for ConvertX file upload path traversal.
These tests verify that path traversal attacks are prevented.

- FAIL when vulnerable (path traversal works, files written outside upload dir)
- PASS when fixed (path traversal blocked, files stay in upload dir)
"""
import os
import time
import requests

BASE_URL = "http://localhost:3000"


class ConvertXClient:
    """Helper class to interact with ConvertX API."""

    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.session = requests.Session()
        self.user_id = None
        self.job_id = None

    def register(self, email, password):
        """Register a new user."""
        response = self.session.post(
            f"{self.base_url}/register",
            data={"email": email, "password": password},
            allow_redirects=False
        )
        return response

    def login(self, email, password):
        """Login and get session cookies."""
        response = self.session.post(
            f"{self.base_url}/login",
            data={"email": email, "password": password},
            allow_redirects=False
        )
        return response

    def create_job(self):
        """Create a new conversion job."""
        response = self.session.get(f"{self.base_url}/")
        response = self.session.post(
            f"{self.base_url}/",
            data={"converter": "imagemagick", "outputFormat": "png"},
            allow_redirects=False
        )
        if "jobId" in self.session.cookies:
            self.job_id = self.session.cookies.get("jobId")
        return response

    def upload_file(self, filename, content):
        """Upload a file with the given filename and content."""
        files = {"file": (filename, content, "application/octet-stream")}
        response = self.session.post(
            f"{self.base_url}/upload",
            files=files,
            allow_redirects=False
        )
        return response


def get_authenticated_client():
    """Create and authenticate a ConvertX client."""
    client = ConvertXClient()
    email = f"vuln_test_{int(time.time() * 1000)}@example.com"
    password = "TestPassword123!"
    client.register(email, password)
    client.login(email, password)
    client.create_job()
    return client


def check_file_exists(filepath):
    """Check if a file exists (locally, tests run inside container)."""
    return os.path.isfile(filepath)


def remove_file(filepath):
    """Remove a file if it exists (locally, tests run inside container)."""
    if os.path.exists(filepath):
        try:
            os.remove(filepath)
        except OSError:
            pass


class TestPathTraversalVulnerability:
    """
    Test that path traversal vulnerability exists in ConvertX.

    These tests FAIL when the vulnerability exists (proving the exploit works).
    These tests PASS when the vulnerability is fixed (exploit blocked).

    Upload path: /app/data/uploads/<user>/<job>/
    To reach /tmp, we need 5 levels of ../
    """

    def setup_method(self):
        """Clean up any test files before each test."""
        self.test_files = [
            "/tmp/path_traversal_test",
            "/tmp/deep_traversal_test",
            "/tmp/multi_level_test",
            "/tmp/multi1",
            "/tmp/multi2",
            "/tmp/multi3",
            "/etc/passwd_test",
            "/app/data/node_modules/pwned",
        ]
        for f in self.test_files:
            remove_file(f)

    def teardown_method(self):
        """Clean up test files after each test."""
        for f in self.test_files:
            remove_file(f)

    def test_basic_path_traversal_blocked(self):
        """
        Test that basic ../ path traversal is blocked.

        Attempts to write file to /tmp/ using path traversal.
        FAILS if vulnerable (file written to /tmp)
        PASSES if fixed (file stays in upload dir)
        """
        client = get_authenticated_client()

        unique_content = f"PATH_TRAVERSAL_TEST_{time.time()}"
        # 5 levels of ../ to escape from /app/data/uploads/<user>/<job>/ to /tmp/
        malicious_filename = "../../../../../tmp/path_traversal_test"

        response = client.upload_file(malicious_filename, unique_content.encode())
        time.sleep(0.5)

        # Check if file was written to /tmp/ (VULNERABLE)
        file_exists = check_file_exists("/tmp/path_traversal_test")

        assert not file_exists, \
            "VULNERABILITY: Path traversal successful! File written to /tmp/path_traversal_test"

    def test_deep_path_traversal_blocked(self):
        """
        Test that deep path traversal with many ../ is blocked.

        FAILS if vulnerable (file written to /tmp)
        PASSES if fixed (file stays in upload dir)
        """
        client = get_authenticated_client()

        unique_content = f"DEEP_TRAVERSAL_{time.time()}"
        # 20 levels of ../ - will definitely reach /tmp
        malicious_filename = "../" * 20 + "tmp/deep_traversal_test"

        response = client.upload_file(malicious_filename, unique_content.encode())
        time.sleep(0.5)

        file_exists = check_file_exists("/tmp/deep_traversal_test")

        assert not file_exists, \
            "VULNERABILITY: Deep path traversal successful! File written to /tmp/deep_traversal_test"

    def test_mixed_traversal_blocked(self):
        """
        Test that mixed path traversal patterns are blocked.

        FAILS if vulnerable (file written to /tmp)
        PASSES if fixed (file stays in upload dir)
        """
        client = get_authenticated_client()

        test_cases = [
            "./../../../../../tmp/multi_level_test",
            "foo/../../../../../../tmp/multi_level_test",
        ]

        for malicious_name in test_cases:
            unique_content = f"MIXED_TEST_{time.time()}"
            response = client.upload_file(malicious_name, unique_content.encode())
            time.sleep(0.3)

            file_leaked = check_file_exists("/tmp/multi_level_test")
            assert not file_leaked, \
                f"VULNERABILITY: Mixed traversal '{malicious_name}' - file written to /tmp/multi_level_test"

            remove_file("/tmp/multi_level_test")

    def test_multiple_files_traversal_blocked(self):
        """
        Test that multiple files with traversal names are all blocked.

        FAILS if vulnerable (files written to /tmp)
        PASSES if fixed (files stay in upload dir)
        """
        client = get_authenticated_client()

        # Use 5 levels of ../ to escape to /tmp
        files = [
            ("file", ("../../../../../tmp/multi1", b"content1", "application/octet-stream")),
            ("file", ("../../../../../tmp/multi2", b"content2", "application/octet-stream")),
            ("file", ("../../../../../tmp/multi3", b"content3", "application/octet-stream")),
        ]

        response = client.session.post(
            f"{BASE_URL}/upload",
            files=files,
            allow_redirects=False
        )
        time.sleep(0.5)

        for path in ["/tmp/multi1", "/tmp/multi2", "/tmp/multi3"]:
            file_exists = check_file_exists(path)
            assert not file_exists, \
                f"VULNERABILITY: Multi-file traversal - file written to {path}"

    def test_etc_directory_protected(self):
        """
        Test that /etc cannot be written to via path traversal.

        FAILS if vulnerable (file written to /etc)
        PASSES if fixed (file stays in upload dir)
        """
        client = get_authenticated_client()

        # 5 levels to reach /etc
        malicious_filename = "../../../../../etc/passwd_test"
        response = client.upload_file(malicious_filename, b"pwned")
        time.sleep(0.5)

        file_exists = check_file_exists("/etc/passwd_test")
        assert not file_exists, \
            "VULNERABILITY: Wrote file to /etc/ directory!"

    def test_data_directory_escape_blocked(self):
        """
        Test that files can't escape the app data directory.

        With 3 levels of ../ from uploads/<user>/<job>, we escape to /app/data/
        FAILS if vulnerable (file written to /app/data/node_modules)
        PASSES if fixed (file stays in upload dir)
        """
        client = get_authenticated_client()

        # 3 levels up from uploads/<user>/<job> escapes to /app/data/
        malicious_filename = "../../../node_modules/pwned"
        response = client.upload_file(malicious_filename, b"pwned")
        time.sleep(0.5)

        # Check if file ended up in /app/data/node_modules/
        file_exists = check_file_exists("/app/data/node_modules/pwned")
        assert not file_exists, \
            "VULNERABILITY: Wrote file outside upload directory to data/node_modules!"
