diff --git a/router/failde-events-manager_test.go b/router/failde-events-manager_test.go
new file mode 100644
index 0000000..32c32ee
--- /dev/null
+++ b/router/failde-events-manager_test.go
@@ -0,0 +1,55 @@
+package router
+
+import (
+	"regexp"
+	"testing"
+
+	"github.com/DATA-DOG/go-sqlmock"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestDropFailedRecordIDs(t *testing.T) {
+	// Backup original value, restore after test
+	oldFlag := failedKeysEnabled
+	failedKeysEnabled = true
+	defer func() { failedKeysEnabled = oldFlag }()
+
+	tests := []struct {
+		name    string
+		inputID string
+		wantSQL string
+	}{
+		{
+			name:    "normal taskRunID",
+			inputID: "task123",
+			// getSqlSafeTablename will produce "failed_keys_task123"
+			wantSQL: `DROP TABLE IF EXISTS "failed_keys_task123"`,
+		},
+		{
+			name:    "taskRunID with quotes",
+			inputID: `abc"xyz`,
+			// Due to escaping, the final table name becomes "failed_keys_abc""xyz"
+			wantSQL: `DROP TABLE IF EXISTS "failed_keys_abc""xyz"`,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// Use sqlmock to create a mock DB
+			db, mock, err := sqlmock.New()
+			assert.NoError(t, err)
+			defer db.Close()
+
+			fem := &FailedEventsManagerT{dbHandle: db}
+
+			// Expect the SQL statement to be executed
+			mock.ExpectExec(regexp.QuoteMeta(tt.wantSQL)).WillReturnResult(sqlmock.NewResult(0, 0))
+
+			// Call the target function (indirectly uses getSqlSafeTablename)
+			fem.DropFailedRecordIDs(tt.inputID)
+
+			// Verify all expected operations were executed
+			assert.NoError(t, mock.ExpectationsWereMet())
+		})
+	}
+}
