"""
Vulnerability tests for PoDoFo Use-After-Free vulnerability.

These tests verify whether the use-after-free vulnerability has been fixed
by checking that the fix pattern exists in the source code.

The vulnerability occurs in PdfTokenizer::DetermineDataType when parsing
invalid numeric literals like "1.2.3.4.5" - the variant destructor is called
but the variant is not re-initialized before returning.

The fix adds a 'Recovery:' label that ensures proper initialization.

Test behavior:
- FAIL in vulnerable state: fix pattern not present (vulnerability exists)
- PASS in fixed state: fix pattern present (vulnerability fixed)

Note: Dynamic testing (executing podofoencrypt with malformed PDF) is unreliable
for this vulnerability because:
1. Use-After-Free doesn't always trigger ASAN errors
2. The memory corruption may not cause observable crashes
3. ASAN detection depends on memory layout which varies

Therefore, we verify the fix by checking the source code structure.
This is an acceptable approach for memory safety vulnerabilities where
the fix pattern is well-defined.
"""

import os
import pytest


# Path to source file containing the vulnerability
TOKENIZER_SOURCE = "/app/src/podofo/main/PdfTokenizer.cpp"


class TestUseAfterFreeVulnerability:
    """
    Test for the use-after-free vulnerability fix.
    
    These tests FAIL in vulnerable state (fix not present) and
    PASS in fixed state (fix present).
    """

    def test_recovery_label_exists(self):
        """
        Verify the Recovery label exists in the source code.

        The fix adds a 'Recovery:' label before the null initialization
        to ensure the variant is properly initialized on all error paths.

        - FAIL: Recovery label not found (vulnerable - UAF can occur)
        - PASS: Recovery label found (fixed)
        """
        assert os.path.exists(TOKENIZER_SOURCE), f"Source not found: {TOKENIZER_SOURCE}"

        with open(TOKENIZER_SOURCE, 'r') as f:
            content = f.read()

        has_recovery = 'Recovery:' in content

        assert has_recovery, (
            "VULNERABLE: Recovery label not found in PdfTokenizer.cpp. "
            "The use-after-free vulnerability is present. "
            "When TryParse fails for invalid numbers, the code returns without "
            "initializing the variant, causing use-after-free. "
            "Fix requires adding 'Recovery:' label for proper variant initialization."
        )

    def test_goto_recovery_for_invalid_real(self):
        """
        Verify 'goto Recovery' is used after invalid real parsing failure.

        The vulnerable code returns directly after TryParse fails for real numbers,
        leaving the variant in an invalid state. The fix uses 'goto Recovery'.

        - FAIL: goto Recovery not found after invalid real warning (vulnerable)
        - PASS: goto Recovery found (fixed)
        """
        assert os.path.exists(TOKENIZER_SOURCE), f"Source not found: {TOKENIZER_SOURCE}"

        with open(TOKENIZER_SOURCE, 'r') as f:
            content = f.read()

        lines = content.split('\n')
        found_goto = False

        for i, line in enumerate(lines):
            if 'Invalid real while parsing content' in line:
                # Check next few lines for goto Recovery
                for j in range(i + 1, min(i + 5, len(lines))):
                    if 'goto Recovery' in lines[j]:
                        found_goto = True
                        break
                break

        assert found_goto, (
            "VULNERABLE: 'goto Recovery' not found after invalid real parsing. "
            "The vulnerable code uses 'return PdfLiteralDataType::Unknown' which "
            "leaves the variant uninitialized, causing use-after-free when the "
            "variant destructor runs."
        )

    def test_goto_recovery_for_invalid_number(self):
        """
        Verify 'goto Recovery' is used after invalid number parsing failure.

        The vulnerable code returns directly after TryParse fails for numbers,
        leaving the variant in an invalid state. The fix uses 'goto Recovery'.

        - FAIL: goto Recovery not found after invalid number warning (vulnerable)
        - PASS: goto Recovery found (fixed)
        """
        assert os.path.exists(TOKENIZER_SOURCE), f"Source not found: {TOKENIZER_SOURCE}"

        with open(TOKENIZER_SOURCE, 'r') as f:
            content = f.read()

        lines = content.split('\n')
        found_goto = False

        for i, line in enumerate(lines):
            if 'Invalid number while parsing content' in line:
                # Check next few lines for goto Recovery
                for j in range(i + 1, min(i + 5, len(lines))):
                    if 'goto Recovery' in lines[j]:
                        found_goto = True
                        break
                break

        assert found_goto, (
            "VULNERABLE: 'goto Recovery' not found after invalid number parsing. "
            "The vulnerable code uses 'return PdfLiteralDataType::Unknown' which "
            "leaves the variant uninitialized, causing use-after-free."
        )

    def test_proper_variant_initialization_on_recovery(self):
        """
        Verify the Recovery path properly initializes the variant to null.

        The fix pattern should be:
            Recovery:
                new(&variant.m_Null)PdfVariant::NullMember();
                return PdfLiteralDataType::Unknown;

        - FAIL: Proper recovery pattern not found (vulnerable or incomplete fix)
        - PASS: Recovery with null initialization found (fixed)
        """
        assert os.path.exists(TOKENIZER_SOURCE), f"Source not found: {TOKENIZER_SOURCE}"

        with open(TOKENIZER_SOURCE, 'r') as f:
            content = f.read()

        lines = content.split('\n')
        proper_recovery = False

        for i, line in enumerate(lines):
            if 'Recovery:' in line:
                # Check next few lines for null initialization
                for j in range(i + 1, min(i + 5, len(lines))):
                    if 'new(&variant.m_Null)' in lines[j] and 'NullMember' in lines[j]:
                        proper_recovery = True
                        break
                break

        assert proper_recovery, (
            "VULNERABLE: Recovery label exists but doesn't properly initialize variant. "
            "The fix must initialize variant to null before returning: "
            "new(&variant.m_Null)PdfVariant::NullMember();"
        )
