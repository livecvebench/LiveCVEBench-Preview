"""
Functional tests for pdfme expression evaluator.
These tests verify that the expression evaluator works correctly for legitimate use cases.
They should PASS in both vulnerable and fixed states.
"""
import subprocess
import json
import pytest


def run_expression(expression: str, variables: dict = None) -> str:
    """
    Run an expression through the pdfme expression evaluator.
    Returns the result of the expression evaluation.
    """
    variables = variables or {}

    # Create a test script that uses the built library
    test_script = f'''
const {{ replacePlaceholders }} = require('/app/packages/common/dist/cjs/src/index.js');

const content = {json.dumps(expression)};
const variables = {json.dumps(variables)};
const schemas = [];

try {{
    const result = replacePlaceholders({{ content, variables, schemas }});
    console.log(JSON.stringify({{ success: true, result }}));
}} catch (error) {{
    console.log(JSON.stringify({{ success: false, error: error.message }}));
}}
'''

    result = subprocess.run(
        ['node', '-e', test_script],
        capture_output=True,
        text=True,
        timeout=10
    )

    if result.returncode != 0:
        return f"ERROR: {result.stderr}"

    try:
        output = json.loads(result.stdout.strip())
        if output.get('success'):
            return output['result']
        return f"ERROR: {output.get('error', 'Unknown error')}"
    except json.JSONDecodeError:
        return result.stdout.strip()


class TestBasicExpressions:
    """Test basic expression evaluation functionality."""

    def test_no_placeholders(self):
        """Content without placeholders should be returned as-is."""
        content = "Hello, world!"
        result = run_expression(content)
        assert result == content

    def test_simple_variable(self):
        """Simple variable substitution should work."""
        content = "Hello, {name}!"
        result = run_expression(content, {"name": "Alice"})
        assert result == "Hello, Alice!"

    def test_arithmetic_expression(self):
        """Arithmetic expressions should be evaluated."""
        content = "The sum is {1 + 2}."
        result = run_expression(content)
        assert result == "The sum is 3."

    def test_complex_arithmetic(self):
        """Complex arithmetic expressions should be evaluated."""
        content = "Result: {(10 + 5) * 2 - 3}"
        result = run_expression(content)
        assert result == "Result: 27"

    def test_division(self):
        """Division should work correctly."""
        content = "Result: {10 / 2}"
        result = run_expression(content)
        assert result == "Result: 5"

    def test_modulo(self):
        """Modulo operation should work."""
        content = "Result: {10 % 3}"
        result = run_expression(content)
        assert result == "Result: 1"

    def test_power(self):
        """Exponentiation should work."""
        content = "Result: {2 ** 3}"
        result = run_expression(content)
        assert result == "Result: 8"


class TestMathOperations:
    """Test Math object operations."""

    def test_math_max(self):
        """Math.max should work correctly."""
        content = "Max: {Math.max(1, 5, 3)}"
        result = run_expression(content)
        assert result == "Max: 5"

    def test_math_min(self):
        """Math.min should work correctly."""
        content = "Min: {Math.min(1, 5, 3)}"
        result = run_expression(content)
        assert result == "Min: 1"

    def test_math_floor(self):
        """Math.floor should work correctly."""
        content = "Floor: {Math.floor(4.7)}"
        result = run_expression(content)
        assert result == "Floor: 4"

    def test_math_ceil(self):
        """Math.ceil should work correctly."""
        content = "Ceil: {Math.ceil(4.2)}"
        result = run_expression(content)
        assert result == "Ceil: 5"

    def test_math_round(self):
        """Math.round should work correctly."""
        content = "Round: {Math.round(4.5)}"
        result = run_expression(content)
        assert result == "Round: 5"

    def test_math_abs(self):
        """Math.abs should work correctly."""
        content = "Abs: {Math.abs(-5)}"
        result = run_expression(content)
        assert result == "Abs: 5"

    def test_math_sqrt(self):
        """Math.sqrt should work correctly."""
        content = "Sqrt: {Math.sqrt(16)}"
        result = run_expression(content)
        assert result == "Sqrt: 4"


class TestStringOperations:
    """Test String operations."""

    def test_string_length(self):
        """String length should be accessible."""
        content = "Length: {\"hello\".length}"
        result = run_expression(content)
        assert result == "Length: 5"

    def test_string_toUpperCase(self):
        """String toUpperCase should work."""
        content = "Upper: {\"hello\".toUpperCase()}"
        result = run_expression(content)
        assert result == "Upper: HELLO"

    def test_string_toLowerCase(self):
        """String toLowerCase should work."""
        content = "Lower: {\"HELLO\".toLowerCase()}"
        result = run_expression(content)
        assert result == "Lower: hello"

    def test_string_substring(self):
        """String substring should work."""
        content = "Sub: {\"hello\".substring(0, 3)}"
        result = run_expression(content)
        assert result == "Sub: hel"

    def test_string_concat(self):
        """String concatenation should work."""
        content = "Concat: {\"hello\" + \" \" + \"world\"}"
        result = run_expression(content)
        assert result == "Concat: hello world"


class TestComparisonOperators:
    """Test comparison operators."""

    def test_equality(self):
        """Equality operator should work."""
        content = "Equal: {1 == 1}"
        result = run_expression(content)
        assert result == "Equal: true"

    def test_strict_equality(self):
        """Strict equality operator should work."""
        content = "StrictEqual: {1 === 1}"
        result = run_expression(content)
        assert result == "StrictEqual: true"

    def test_inequality(self):
        """Inequality operator should work."""
        content = "NotEqual: {1 != 2}"
        result = run_expression(content)
        assert result == "NotEqual: true"

    def test_less_than(self):
        """Less than operator should work."""
        content = "LessThan: {1 < 2}"
        result = run_expression(content)
        assert result == "LessThan: true"

    def test_greater_than(self):
        """Greater than operator should work."""
        content = "GreaterThan: {2 > 1}"
        result = run_expression(content)
        assert result == "GreaterThan: true"

    def test_less_than_or_equal(self):
        """Less than or equal operator should work."""
        content = "LessOrEqual: {2 <= 2}"
        result = run_expression(content)
        assert result == "LessOrEqual: true"

    def test_greater_than_or_equal(self):
        """Greater than or equal operator should work."""
        content = "GreaterOrEqual: {2 >= 2}"
        result = run_expression(content)
        assert result == "GreaterOrEqual: true"


class TestLogicalOperators:
    """Test logical operators."""

    def test_logical_and(self):
        """Logical AND should work."""
        content = "And: {true && true}"
        result = run_expression(content)
        assert result == "And: true"

    def test_logical_or(self):
        """Logical OR should work."""
        content = "Or: {false || true}"
        result = run_expression(content)
        assert result == "Or: true"

    def test_logical_not(self):
        """Logical NOT should work."""
        content = "Not: {!false}"
        result = run_expression(content)
        assert result == "Not: true"


class TestConditionalExpressions:
    """Test ternary conditional expressions."""

    def test_ternary_true(self):
        """Ternary with true condition should return first value."""
        content = "Result: {true ? \"yes\" : \"no\"}"
        result = run_expression(content)
        assert result == "Result: yes"

    def test_ternary_false(self):
        """Ternary with false condition should return second value."""
        content = "Result: {false ? \"yes\" : \"no\"}"
        result = run_expression(content)
        assert result == "Result: no"

    def test_ternary_with_expression(self):
        """Ternary with expression condition should work."""
        content = "Result: {1 > 0 ? \"positive\" : \"negative\"}"
        result = run_expression(content)
        assert result == "Result: positive"


class TestObjectAccess:
    """Test object property access."""

    def test_simple_object_access(self):
        """Simple object property access should work."""
        content = "Value: {data.value}"
        result = run_expression(content, {"data": {"value": 42}})
        assert result == "Value: 42"

    def test_nested_object_access(self):
        """Nested object property access should work."""
        content = "Deep: {data.level1.level2}"
        result = run_expression(content, {"data": {"level1": {"level2": "deep"}}})
        assert result == "Deep: deep"

    def test_array_access(self):
        """Array element access should work."""
        content = "Element: {arr[0]}"
        result = run_expression(content, {"arr": ["first", "second"]})
        assert result == "Element: first"

    def test_array_length(self):
        """Array length should be accessible."""
        content = "Length: {arr.length}"
        result = run_expression(content, {"arr": [1, 2, 3, 4, 5]})
        assert result == "Length: 5"


class TestObjectReference:
    """Test that Object global is accessible (vulnerable version exposes it)."""

    def test_object_global_accessible(self):
        """Object global should be accessible in vulnerable version."""
        content = "{ typeof Object }"
        result = run_expression(content)
        # In vulnerable version 5.4.0, Object is exposed but due to type checking
        # bug when calling Object methods, typeof still works
        assert "function" in result or result == content  # Either works or returns unchanged

    def test_object_keys_reference(self):
        """Object.keys function reference should be accessible."""
        content = "{ Object.keys }"
        result = run_expression(content)
        # The function reference is accessible even if calling it fails
        assert "function" in result.lower() or "keys" in result


class TestDateAndTime:
    """Test date and time placeholders."""

    def test_date_placeholder_exists(self):
        """Date placeholder should be replaced with a date string."""
        content = "Date: {date}"
        result = run_expression(content)
        # Date format is YYYY/MM/DD
        assert result.startswith("Date: ")
        assert "/" in result
        # Extract just the date part
        date_part = result.replace("Date: ", "")
        parts = date_part.split("/")
        assert len(parts) == 3
        assert len(parts[0]) == 4  # Year

    def test_dateTime_placeholder_exists(self):
        """DateTime placeholder should be replaced with a datetime string."""
        content = "DateTime: {dateTime}"
        result = run_expression(content)
        # DateTime format is YYYY/MM/DD HH:MM
        assert result.startswith("DateTime: ")
        assert "/" in result
        assert ":" in result


class TestJSONParsing:
    """Test JSON string parsing in variables."""

    def test_json_string_variable(self):
        """JSON string variables should be parsed."""
        content = "Value: {data.value}"
        result = run_expression(content, {"data": '{"value": 42}'})
        assert result == "Value: 42"

    def test_json_array_variable(self):
        """JSON array variables should be parsed."""
        content = "First: {arr[0]}"
        result = run_expression(content, {"arr": '[1, 2, 3]'})
        assert result == "First: 1"


class TestInvalidExpressions:
    """Test handling of invalid expressions."""

    def test_undefined_variable_unchanged(self):
        """Undefined variables should leave placeholder unchanged."""
        content = "Value: {undefinedVar}"
        result = run_expression(content)
        assert result == "Value: {undefinedVar}"

    def test_unclosed_brace(self):
        """Unclosed braces should leave content unchanged."""
        content = "Value: {name"
        result = run_expression(content)
        assert result == "Value: {name"

    def test_syntax_error_unchanged(self):
        """Syntax errors should leave placeholder unchanged."""
        content = "Value: {1 +}"
        result = run_expression(content)
        # Should return unchanged due to syntax error
        assert "{" in result


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
